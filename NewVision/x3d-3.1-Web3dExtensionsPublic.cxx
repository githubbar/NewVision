// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "x3d-3.1-Web3dExtensionsPublic.hxx"

// XvlShell_shellTypes
// 

XvlShell_shellTypes::
XvlShell_shellTypes (value v)
: ::xml_schema::string (_xsd_XvlShell_shellTypes_literals_[v])
{
}

XvlShell_shellTypes::
XvlShell_shellTypes (const char* v)
: ::xml_schema::string (v)
{
}

XvlShell_shellTypes::
XvlShell_shellTypes (const ::std::string& v)
: ::xml_schema::string (v)
{
}

XvlShell_shellTypes::
XvlShell_shellTypes (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

XvlShell_shellTypes::
XvlShell_shellTypes (const XvlShell_shellTypes& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

XvlShell_shellTypes& XvlShell_shellTypes::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_XvlShell_shellTypes_literals_[v]);

  return *this;
}


// XvlShell
// 

const XvlShell::IS_optional& XvlShell::
IS () const
{
  return this->IS_;
}

XvlShell::IS_optional& XvlShell::
IS ()
{
  return this->IS_;
}

void XvlShell::
IS (const IS_type& x)
{
  this->IS_.set (x);
}

void XvlShell::
IS (const IS_optional& x)
{
  this->IS_ = x;
}

void XvlShell::
IS (::std::auto_ptr< IS_type > x)
{
  this->IS_.set (x);
}

const XvlShell::MetadataDouble_optional& XvlShell::
MetadataDouble () const
{
  return this->MetadataDouble_;
}

XvlShell::MetadataDouble_optional& XvlShell::
MetadataDouble ()
{
  return this->MetadataDouble_;
}

void XvlShell::
MetadataDouble (const MetadataDouble_type& x)
{
  this->MetadataDouble_.set (x);
}

void XvlShell::
MetadataDouble (const MetadataDouble_optional& x)
{
  this->MetadataDouble_ = x;
}

void XvlShell::
MetadataDouble (::std::auto_ptr< MetadataDouble_type > x)
{
  this->MetadataDouble_.set (x);
}

const XvlShell::MetadataFloat_optional& XvlShell::
MetadataFloat () const
{
  return this->MetadataFloat_;
}

XvlShell::MetadataFloat_optional& XvlShell::
MetadataFloat ()
{
  return this->MetadataFloat_;
}

void XvlShell::
MetadataFloat (const MetadataFloat_type& x)
{
  this->MetadataFloat_.set (x);
}

void XvlShell::
MetadataFloat (const MetadataFloat_optional& x)
{
  this->MetadataFloat_ = x;
}

void XvlShell::
MetadataFloat (::std::auto_ptr< MetadataFloat_type > x)
{
  this->MetadataFloat_.set (x);
}

const XvlShell::MetadataInteger_optional& XvlShell::
MetadataInteger () const
{
  return this->MetadataInteger_;
}

XvlShell::MetadataInteger_optional& XvlShell::
MetadataInteger ()
{
  return this->MetadataInteger_;
}

void XvlShell::
MetadataInteger (const MetadataInteger_type& x)
{
  this->MetadataInteger_.set (x);
}

void XvlShell::
MetadataInteger (const MetadataInteger_optional& x)
{
  this->MetadataInteger_ = x;
}

void XvlShell::
MetadataInteger (::std::auto_ptr< MetadataInteger_type > x)
{
  this->MetadataInteger_.set (x);
}

const XvlShell::MetadataSet_optional& XvlShell::
MetadataSet () const
{
  return this->MetadataSet_;
}

XvlShell::MetadataSet_optional& XvlShell::
MetadataSet ()
{
  return this->MetadataSet_;
}

void XvlShell::
MetadataSet (const MetadataSet_type& x)
{
  this->MetadataSet_.set (x);
}

void XvlShell::
MetadataSet (const MetadataSet_optional& x)
{
  this->MetadataSet_ = x;
}

void XvlShell::
MetadataSet (::std::auto_ptr< MetadataSet_type > x)
{
  this->MetadataSet_.set (x);
}

const XvlShell::MetadataString_optional& XvlShell::
MetadataString () const
{
  return this->MetadataString_;
}

XvlShell::MetadataString_optional& XvlShell::
MetadataString ()
{
  return this->MetadataString_;
}

void XvlShell::
MetadataString (const MetadataString_type& x)
{
  this->MetadataString_.set (x);
}

void XvlShell::
MetadataString (const MetadataString_optional& x)
{
  this->MetadataString_ = x;
}

void XvlShell::
MetadataString (::std::auto_ptr< MetadataString_type > x)
{
  this->MetadataString_.set (x);
}

const XvlShell::DEF_optional& XvlShell::
DEF () const
{
  return this->DEF_;
}

XvlShell::DEF_optional& XvlShell::
DEF ()
{
  return this->DEF_;
}

void XvlShell::
DEF (const DEF_type& x)
{
  this->DEF_.set (x);
}

void XvlShell::
DEF (const DEF_optional& x)
{
  this->DEF_ = x;
}

void XvlShell::
DEF (::std::auto_ptr< DEF_type > x)
{
  this->DEF_.set (x);
}

const XvlShell::USE_optional& XvlShell::
USE () const
{
  return this->USE_;
}

XvlShell::USE_optional& XvlShell::
USE ()
{
  return this->USE_;
}

void XvlShell::
USE (const USE_type& x)
{
  this->USE_.set (x);
}

void XvlShell::
USE (const USE_optional& x)
{
  this->USE_ = x;
}

void XvlShell::
USE (::std::auto_ptr< USE_type > x)
{
  this->USE_.set (x);
}

const XvlShell::shellType_optional& XvlShell::
shellType () const
{
  return this->shellType_;
}

XvlShell::shellType_optional& XvlShell::
shellType ()
{
  return this->shellType_;
}

void XvlShell::
shellType (const shellType_type& x)
{
  this->shellType_.set (x);
}

void XvlShell::
shellType (const shellType_optional& x)
{
  this->shellType_ = x;
}

void XvlShell::
shellType (::std::auto_ptr< shellType_type > x)
{
  this->shellType_.set (x);
}

const XvlShell::numberOfDivisions_optional& XvlShell::
numberOfDivisions () const
{
  return this->numberOfDivisions_;
}

XvlShell::numberOfDivisions_optional& XvlShell::
numberOfDivisions ()
{
  return this->numberOfDivisions_;
}

void XvlShell::
numberOfDivisions (const numberOfDivisions_type& x)
{
  this->numberOfDivisions_.set (x);
}

void XvlShell::
numberOfDivisions (const numberOfDivisions_optional& x)
{
  this->numberOfDivisions_ = x;
}

void XvlShell::
numberOfDivisions (::std::auto_ptr< numberOfDivisions_type > x)
{
  this->numberOfDivisions_.set (x);
}

const XvlShell::vertexRound_optional& XvlShell::
vertexRound () const
{
  return this->vertexRound_;
}

XvlShell::vertexRound_optional& XvlShell::
vertexRound ()
{
  return this->vertexRound_;
}

void XvlShell::
vertexRound (const vertexRound_type& x)
{
  this->vertexRound_.set (x);
}

void XvlShell::
vertexRound (const vertexRound_optional& x)
{
  this->vertexRound_ = x;
}

void XvlShell::
vertexRound (::std::auto_ptr< vertexRound_type > x)
{
  this->vertexRound_.set (x);
}

const XvlShell::edgeBeginCoordIndex_optional& XvlShell::
edgeBeginCoordIndex () const
{
  return this->edgeBeginCoordIndex_;
}

XvlShell::edgeBeginCoordIndex_optional& XvlShell::
edgeBeginCoordIndex ()
{
  return this->edgeBeginCoordIndex_;
}

void XvlShell::
edgeBeginCoordIndex (const edgeBeginCoordIndex_type& x)
{
  this->edgeBeginCoordIndex_.set (x);
}

void XvlShell::
edgeBeginCoordIndex (const edgeBeginCoordIndex_optional& x)
{
  this->edgeBeginCoordIndex_ = x;
}

void XvlShell::
edgeBeginCoordIndex (::std::auto_ptr< edgeBeginCoordIndex_type > x)
{
  this->edgeBeginCoordIndex_.set (x);
}

const XvlShell::edgeEndCoordIndex_optional& XvlShell::
edgeEndCoordIndex () const
{
  return this->edgeEndCoordIndex_;
}

XvlShell::edgeEndCoordIndex_optional& XvlShell::
edgeEndCoordIndex ()
{
  return this->edgeEndCoordIndex_;
}

void XvlShell::
edgeEndCoordIndex (const edgeEndCoordIndex_type& x)
{
  this->edgeEndCoordIndex_.set (x);
}

void XvlShell::
edgeEndCoordIndex (const edgeEndCoordIndex_optional& x)
{
  this->edgeEndCoordIndex_ = x;
}

void XvlShell::
edgeEndCoordIndex (::std::auto_ptr< edgeEndCoordIndex_type > x)
{
  this->edgeEndCoordIndex_.set (x);
}

const XvlShell::edgeRound_optional& XvlShell::
edgeRound () const
{
  return this->edgeRound_;
}

XvlShell::edgeRound_optional& XvlShell::
edgeRound ()
{
  return this->edgeRound_;
}

void XvlShell::
edgeRound (const edgeRound_type& x)
{
  this->edgeRound_.set (x);
}

void XvlShell::
edgeRound (const edgeRound_optional& x)
{
  this->edgeRound_ = x;
}

void XvlShell::
edgeRound (::std::auto_ptr< edgeRound_type > x)
{
  this->edgeRound_.set (x);
}

const XvlShell::edgeBeginVector_optional& XvlShell::
edgeBeginVector () const
{
  return this->edgeBeginVector_;
}

XvlShell::edgeBeginVector_optional& XvlShell::
edgeBeginVector ()
{
  return this->edgeBeginVector_;
}

void XvlShell::
edgeBeginVector (const edgeBeginVector_type& x)
{
  this->edgeBeginVector_.set (x);
}

void XvlShell::
edgeBeginVector (const edgeBeginVector_optional& x)
{
  this->edgeBeginVector_ = x;
}

void XvlShell::
edgeBeginVector (::std::auto_ptr< edgeBeginVector_type > x)
{
  this->edgeBeginVector_.set (x);
}

const XvlShell::edgeEndVector_optional& XvlShell::
edgeEndVector () const
{
  return this->edgeEndVector_;
}

XvlShell::edgeEndVector_optional& XvlShell::
edgeEndVector ()
{
  return this->edgeEndVector_;
}

void XvlShell::
edgeEndVector (const edgeEndVector_type& x)
{
  this->edgeEndVector_.set (x);
}

void XvlShell::
edgeEndVector (const edgeEndVector_optional& x)
{
  this->edgeEndVector_ = x;
}

void XvlShell::
edgeEndVector (::std::auto_ptr< edgeEndVector_type > x)
{
  this->edgeEndVector_.set (x);
}

const XvlShell::faceCoordIndex_optional& XvlShell::
faceCoordIndex () const
{
  return this->faceCoordIndex_;
}

XvlShell::faceCoordIndex_optional& XvlShell::
faceCoordIndex ()
{
  return this->faceCoordIndex_;
}

void XvlShell::
faceCoordIndex (const faceCoordIndex_type& x)
{
  this->faceCoordIndex_.set (x);
}

void XvlShell::
faceCoordIndex (const faceCoordIndex_optional& x)
{
  this->faceCoordIndex_ = x;
}

void XvlShell::
faceCoordIndex (::std::auto_ptr< faceCoordIndex_type > x)
{
  this->faceCoordIndex_.set (x);
}

const XvlShell::faceTexCoordIndex_optional& XvlShell::
faceTexCoordIndex () const
{
  return this->faceTexCoordIndex_;
}

XvlShell::faceTexCoordIndex_optional& XvlShell::
faceTexCoordIndex ()
{
  return this->faceTexCoordIndex_;
}

void XvlShell::
faceTexCoordIndex (const faceTexCoordIndex_type& x)
{
  this->faceTexCoordIndex_.set (x);
}

void XvlShell::
faceTexCoordIndex (const faceTexCoordIndex_optional& x)
{
  this->faceTexCoordIndex_ = x;
}

void XvlShell::
faceTexCoordIndex (::std::auto_ptr< faceTexCoordIndex_type > x)
{
  this->faceTexCoordIndex_.set (x);
}

const XvlShell::faceEmpty_optional& XvlShell::
faceEmpty () const
{
  return this->faceEmpty_;
}

XvlShell::faceEmpty_optional& XvlShell::
faceEmpty ()
{
  return this->faceEmpty_;
}

void XvlShell::
faceEmpty (const faceEmpty_type& x)
{
  this->faceEmpty_.set (x);
}

void XvlShell::
faceEmpty (const faceEmpty_optional& x)
{
  this->faceEmpty_ = x;
}

void XvlShell::
faceEmpty (::std::auto_ptr< faceEmpty_type > x)
{
  this->faceEmpty_.set (x);
}

const XvlShell::faceHidden_optional& XvlShell::
faceHidden () const
{
  return this->faceHidden_;
}

XvlShell::faceHidden_optional& XvlShell::
faceHidden ()
{
  return this->faceHidden_;
}

void XvlShell::
faceHidden (const faceHidden_type& x)
{
  this->faceHidden_.set (x);
}

void XvlShell::
faceHidden (const faceHidden_optional& x)
{
  this->faceHidden_ = x;
}

void XvlShell::
faceHidden (::std::auto_ptr< faceHidden_type > x)
{
  this->faceHidden_.set (x);
}

const XvlShell::containerField_type& XvlShell::
containerField () const
{
  return this->containerField_.get ();
}

XvlShell::containerField_type& XvlShell::
containerField ()
{
  return this->containerField_.get ();
}

void XvlShell::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void XvlShell::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const XvlShell::containerField_type& XvlShell::
containerField_default_value ()
{
  return containerField_default_value_;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// XvlShell_shellTypes
//

XvlShell_shellTypes::
XvlShell_shellTypes (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_XvlShell_shellTypes_convert ();
}

XvlShell_shellTypes::
XvlShell_shellTypes (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_XvlShell_shellTypes_convert ();
}

XvlShell_shellTypes::
XvlShell_shellTypes (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_XvlShell_shellTypes_convert ();
}

XvlShell_shellTypes* XvlShell_shellTypes::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new XvlShell_shellTypes (*this, f, c);
}

XvlShell_shellTypes::value XvlShell_shellTypes::
_xsd_XvlShell_shellTypes_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_XvlShell_shellTypes_literals_);
  const value* i (::std::lower_bound (
                    _xsd_XvlShell_shellTypes_indexes_,
                    _xsd_XvlShell_shellTypes_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_XvlShell_shellTypes_indexes_ + 2 || _xsd_XvlShell_shellTypes_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const XvlShell_shellTypes::
_xsd_XvlShell_shellTypes_literals_[2] =
{
  "POLYGON_MESH",
  "LATTICE_MESH"
};

const XvlShell_shellTypes::value XvlShell_shellTypes::
_xsd_XvlShell_shellTypes_indexes_[2] =
{
  ::XvlShell_shellTypes::LATTICE_MESH,
  ::XvlShell_shellTypes::POLYGON_MESH
};

// XvlShell
//

const XvlShell::containerField_type XvlShell::containerField_default_value_ (
  ::std::string ("geometry"), 0, 0, 0);

XvlShell::
XvlShell ()
: ::xml_schema::type (),
  IS_ (::xml_schema::flags (), this),
  MetadataDouble_ (::xml_schema::flags (), this),
  MetadataFloat_ (::xml_schema::flags (), this),
  MetadataInteger_ (::xml_schema::flags (), this),
  MetadataSet_ (::xml_schema::flags (), this),
  MetadataString_ (::xml_schema::flags (), this),
  DEF_ (::xml_schema::flags (), this),
  USE_ (::xml_schema::flags (), this),
  shellType_ (::xml_schema::flags (), this),
  numberOfDivisions_ (::xml_schema::flags (), this),
  vertexRound_ (::xml_schema::flags (), this),
  edgeBeginCoordIndex_ (::xml_schema::flags (), this),
  edgeEndCoordIndex_ (::xml_schema::flags (), this),
  edgeRound_ (::xml_schema::flags (), this),
  edgeBeginVector_ (::xml_schema::flags (), this),
  edgeEndVector_ (::xml_schema::flags (), this),
  faceCoordIndex_ (::xml_schema::flags (), this),
  faceTexCoordIndex_ (::xml_schema::flags (), this),
  faceEmpty_ (::xml_schema::flags (), this),
  faceHidden_ (::xml_schema::flags (), this),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

XvlShell::
XvlShell (const XvlShell& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  IS_ (x.IS_, f, this),
  MetadataDouble_ (x.MetadataDouble_, f, this),
  MetadataFloat_ (x.MetadataFloat_, f, this),
  MetadataInteger_ (x.MetadataInteger_, f, this),
  MetadataSet_ (x.MetadataSet_, f, this),
  MetadataString_ (x.MetadataString_, f, this),
  DEF_ (x.DEF_, f, this),
  USE_ (x.USE_, f, this),
  shellType_ (x.shellType_, f, this),
  numberOfDivisions_ (x.numberOfDivisions_, f, this),
  vertexRound_ (x.vertexRound_, f, this),
  edgeBeginCoordIndex_ (x.edgeBeginCoordIndex_, f, this),
  edgeEndCoordIndex_ (x.edgeEndCoordIndex_, f, this),
  edgeRound_ (x.edgeRound_, f, this),
  edgeBeginVector_ (x.edgeBeginVector_, f, this),
  edgeEndVector_ (x.edgeEndVector_, f, this),
  faceCoordIndex_ (x.faceCoordIndex_, f, this),
  faceTexCoordIndex_ (x.faceTexCoordIndex_, f, this),
  faceEmpty_ (x.faceEmpty_, f, this),
  faceHidden_ (x.faceHidden_, f, this),
  containerField_ (x.containerField_, f, this)
{
}

XvlShell::
XvlShell (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  IS_ (f, this),
  MetadataDouble_ (f, this),
  MetadataFloat_ (f, this),
  MetadataInteger_ (f, this),
  MetadataSet_ (f, this),
  MetadataString_ (f, this),
  DEF_ (f, this),
  USE_ (f, this),
  shellType_ (f, this),
  numberOfDivisions_ (f, this),
  vertexRound_ (f, this),
  edgeBeginCoordIndex_ (f, this),
  edgeEndCoordIndex_ (f, this),
  edgeRound_ (f, this),
  edgeBeginVector_ (f, this),
  edgeEndVector_ (f, this),
  faceCoordIndex_ (f, this),
  faceTexCoordIndex_ (f, this),
  faceEmpty_ (f, this),
  faceHidden_ (f, this),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void XvlShell::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // IS
    //
    if (n.name () == "IS" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IS_type > r (
        IS_traits::create (i, f, this));

      if (!this->IS ())
      {
        this->IS (r);
        continue;
      }
    }

    // MetadataDouble
    //
    if (n.name () == "MetadataDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataDouble_type > r (
        MetadataDouble_traits::create (i, f, this));

      if (!this->MetadataDouble ())
      {
        this->MetadataDouble (r);
        continue;
      }
    }

    // MetadataFloat
    //
    if (n.name () == "MetadataFloat" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataFloat_type > r (
        MetadataFloat_traits::create (i, f, this));

      if (!this->MetadataFloat ())
      {
        this->MetadataFloat (r);
        continue;
      }
    }

    // MetadataInteger
    //
    if (n.name () == "MetadataInteger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataInteger_type > r (
        MetadataInteger_traits::create (i, f, this));

      if (!this->MetadataInteger ())
      {
        this->MetadataInteger (r);
        continue;
      }
    }

    // MetadataSet
    //
    if (n.name () == "MetadataSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataSet_type > r (
        MetadataSet_traits::create (i, f, this));

      if (!this->MetadataSet ())
      {
        this->MetadataSet (r);
        continue;
      }
    }

    // MetadataString
    //
    if (n.name () == "MetadataString" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataString_type > r (
        MetadataString_traits::create (i, f, this));

      if (!this->MetadataString ())
      {
        this->MetadataString (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "DEF" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DEF_type > r (
        DEF_traits::create (i, f, this));

      this->DEF (r);
      continue;
    }

    if (n.name () == "USE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< USE_type > r (
        USE_traits::create (i, f, this));

      this->USE (r);
      continue;
    }

    if (n.name () == "shellType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< shellType_type > r (
        shellType_traits::create (i, f, this));

      this->shellType (r);
      continue;
    }

    if (n.name () == "numberOfDivisions" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< numberOfDivisions_type > r (
        numberOfDivisions_traits::create (i, f, this));

      this->numberOfDivisions (r);
      continue;
    }

    if (n.name () == "vertexRound" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vertexRound_type > r (
        vertexRound_traits::create (i, f, this));

      this->vertexRound (r);
      continue;
    }

    if (n.name () == "edgeBeginCoordIndex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< edgeBeginCoordIndex_type > r (
        edgeBeginCoordIndex_traits::create (i, f, this));

      this->edgeBeginCoordIndex (r);
      continue;
    }

    if (n.name () == "edgeEndCoordIndex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< edgeEndCoordIndex_type > r (
        edgeEndCoordIndex_traits::create (i, f, this));

      this->edgeEndCoordIndex (r);
      continue;
    }

    if (n.name () == "edgeRound" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< edgeRound_type > r (
        edgeRound_traits::create (i, f, this));

      this->edgeRound (r);
      continue;
    }

    if (n.name () == "edgeBeginVector" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< edgeBeginVector_type > r (
        edgeBeginVector_traits::create (i, f, this));

      this->edgeBeginVector (r);
      continue;
    }

    if (n.name () == "edgeEndVector" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< edgeEndVector_type > r (
        edgeEndVector_traits::create (i, f, this));

      this->edgeEndVector (r);
      continue;
    }

    if (n.name () == "faceCoordIndex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< faceCoordIndex_type > r (
        faceCoordIndex_traits::create (i, f, this));

      this->faceCoordIndex (r);
      continue;
    }

    if (n.name () == "faceTexCoordIndex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< faceTexCoordIndex_type > r (
        faceTexCoordIndex_traits::create (i, f, this));

      this->faceTexCoordIndex (r);
      continue;
    }

    if (n.name () == "faceEmpty" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< faceEmpty_type > r (
        faceEmpty_traits::create (i, f, this));

      this->faceEmpty (r);
      continue;
    }

    if (n.name () == "faceHidden" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< faceHidden_type > r (
        faceHidden_traits::create (i, f, this));

      this->faceHidden (r);
      continue;
    }

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("geometry"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

XvlShell* XvlShell::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new XvlShell (*this, f, c);
}

XvlShell::
~XvlShell ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

