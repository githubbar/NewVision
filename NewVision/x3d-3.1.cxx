// Copyright (C) 2005-2008 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "x3d-3.1.hxx"

// SFVec3f
// 


// BoundingBoxSize
// 


// SFBool
// 


// MFBool
//

MFBool::
MFBool ()
{
}

MFBool::
MFBool (size_type n, const ::xml_schema::boolean& x)
: ::xsd::cxx::tree::list< ::xml_schema::boolean, char > (n, x)
{
}

MFBool::
MFBool (const MFBool& o,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::simple_type (o, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::boolean, char > (o, f, c)
{
}

// SFColor
// 


// MFColor
// 


// SFColorRGBA
// 


// MFColorRGBA
// 


// SFDouble
// 


// MFDouble
// 


// SFFloat
// 


// MFFloat
// 


// SFImage
// 


// MFImage
// 


// SFInt32
// 


// MFInt32
// 


// SFRotation
// 


// MFRotation
// 


// SFString
// 


// MFString
//

MFString::
MFString ()
{
}

MFString::
MFString (size_type n, const ::xml_schema::string& x)
: ::xsd::cxx::tree::list< ::xml_schema::string, char > (n, x)
{
}

MFString::
MFString (const MFString& o,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::simple_type (o, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (o, f, c)
{
}

// SFTime
// 


// MFTime
// 


// SFVec2f
// 


// MFVec2f
// 


// SFVec2d
// 


// MFVec2d
// 


// MFVec3f
// 


// SFVec3d
// 


// MFVec3d
// 


// SFVec4f
// 


// MFVec4f
// 


// SFVec4d
// 


// MFVec4d
// 


// SFMatrix3f
// 


// MFMatrix3f
// 


// SFMatrix3d
// 


// MFMatrix3d
// 


// SFMatrix4f
// 


// MFMatrix4f
// 


// SFMatrix4d
// 


// MFMatrix4d
// 


// accessTypeNames
// 

accessTypeNames::
accessTypeNames (value v)
: ::xml_schema::string (_xsd_accessTypeNames_literals_[v])
{
}

accessTypeNames::
accessTypeNames (const char* v)
: ::xml_schema::string (v)
{
}

accessTypeNames::
accessTypeNames (const ::std::string& v)
: ::xml_schema::string (v)
{
}

accessTypeNames::
accessTypeNames (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

accessTypeNames::
accessTypeNames (const accessTypeNames& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

accessTypeNames& accessTypeNames::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_accessTypeNames_literals_[v]);

  return *this;
}


// ArcClose2dTypeValues
// 

ArcClose2dTypeValues::
ArcClose2dTypeValues (value v)
: ::xml_schema::token (_xsd_ArcClose2dTypeValues_literals_[v])
{
}

ArcClose2dTypeValues::
ArcClose2dTypeValues (const char* v)
: ::xml_schema::token (v)
{
}

ArcClose2dTypeValues::
ArcClose2dTypeValues (const ::std::string& v)
: ::xml_schema::token (v)
{
}

ArcClose2dTypeValues::
ArcClose2dTypeValues (const ::xml_schema::token& v)
: ::xml_schema::token (v)
{
}

ArcClose2dTypeValues::
ArcClose2dTypeValues (const ArcClose2dTypeValues& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::token (v, f, c)
{
}

ArcClose2dTypeValues& ArcClose2dTypeValues::
operator= (value v)
{
  static_cast< ::xml_schema::token& > (*this) = 
  ::xml_schema::token (_xsd_ArcClose2dTypeValues_literals_[v]);

  return *this;
}


// componentNames
// 

componentNames::
componentNames (value v)
: ::xml_schema::string (_xsd_componentNames_literals_[v])
{
}

componentNames::
componentNames (const char* v)
: ::xml_schema::string (v)
{
}

componentNames::
componentNames (const ::std::string& v)
: ::xml_schema::string (v)
{
}

componentNames::
componentNames (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

componentNames::
componentNames (const componentNames& v,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

componentNames& componentNames::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_componentNames_literals_[v]);

  return *this;
}


// fieldTypeName
// 

fieldTypeName::
fieldTypeName (value v)
: ::xml_schema::string (_xsd_fieldTypeName_literals_[v])
{
}

fieldTypeName::
fieldTypeName (const char* v)
: ::xml_schema::string (v)
{
}

fieldTypeName::
fieldTypeName (const ::std::string& v)
: ::xml_schema::string (v)
{
}

fieldTypeName::
fieldTypeName (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

fieldTypeName::
fieldTypeName (const fieldTypeName& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

fieldTypeName& fieldTypeName::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_fieldTypeName_literals_[v]);

  return *this;
}


// fontStyleValues
// 

fontStyleValues::
fontStyleValues (value v)
: ::xml_schema::token (_xsd_fontStyleValues_literals_[v])
{
}

fontStyleValues::
fontStyleValues (const char* v)
: ::xml_schema::token (v)
{
}

fontStyleValues::
fontStyleValues (const ::std::string& v)
: ::xml_schema::token (v)
{
}

fontStyleValues::
fontStyleValues (const ::xml_schema::token& v)
: ::xml_schema::token (v)
{
}

fontStyleValues::
fontStyleValues (const fontStyleValues& v,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::token (v, f, c)
{
}

fontStyleValues& fontStyleValues::
operator= (value v)
{
  static_cast< ::xml_schema::token& > (*this) = 
  ::xml_schema::token (_xsd_fontStyleValues_literals_[v]);

  return *this;
}


// fogTypeValues
// 

fogTypeValues::
fogTypeValues (value v)
: ::xml_schema::token (_xsd_fogTypeValues_literals_[v])
{
}

fogTypeValues::
fogTypeValues (const char* v)
: ::xml_schema::token (v)
{
}

fogTypeValues::
fogTypeValues (const ::std::string& v)
: ::xml_schema::token (v)
{
}

fogTypeValues::
fogTypeValues (const ::xml_schema::token& v)
: ::xml_schema::token (v)
{
}

fogTypeValues::
fogTypeValues (const fogTypeValues& v,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::token (v, f, c)
{
}

fogTypeValues& fogTypeValues::
operator= (value v)
{
  static_cast< ::xml_schema::token& > (*this) = 
  ::xml_schema::token (_xsd_fogTypeValues_literals_[v]);

  return *this;
}


// shaderPartTypeValues
// 

shaderPartTypeValues::
shaderPartTypeValues (value v)
: ::xml_schema::token (_xsd_shaderPartTypeValues_literals_[v])
{
}

shaderPartTypeValues::
shaderPartTypeValues (const char* v)
: ::xml_schema::token (v)
{
}

shaderPartTypeValues::
shaderPartTypeValues (const ::std::string& v)
: ::xml_schema::token (v)
{
}

shaderPartTypeValues::
shaderPartTypeValues (const ::xml_schema::token& v)
: ::xml_schema::token (v)
{
}

shaderPartTypeValues::
shaderPartTypeValues (const shaderPartTypeValues& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::token (v, f, c)
{
}

shaderPartTypeValues& shaderPartTypeValues::
operator= (value v)
{
  static_cast< ::xml_schema::token& > (*this) = 
  ::xml_schema::token (_xsd_shaderPartTypeValues_literals_[v]);

  return *this;
}


// metaDirectionValues
// 

metaDirectionValues::
metaDirectionValues (value v)
: ::xml_schema::string (_xsd_metaDirectionValues_literals_[v])
{
}

metaDirectionValues::
metaDirectionValues (const char* v)
: ::xml_schema::string (v)
{
}

metaDirectionValues::
metaDirectionValues (const ::std::string& v)
: ::xml_schema::string (v)
{
}

metaDirectionValues::
metaDirectionValues (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

metaDirectionValues::
metaDirectionValues (const metaDirectionValues& v,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

metaDirectionValues& metaDirectionValues::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_metaDirectionValues_literals_[v]);

  return *this;
}


// networkModeValues
// 

networkModeValues::
networkModeValues (value v)
: ::xml_schema::token (_xsd_networkModeValues_literals_[v])
{
}

networkModeValues::
networkModeValues (const char* v)
: ::xml_schema::token (v)
{
}

networkModeValues::
networkModeValues (const ::std::string& v)
: ::xml_schema::token (v)
{
}

networkModeValues::
networkModeValues (const ::xml_schema::token& v)
: ::xml_schema::token (v)
{
}

networkModeValues::
networkModeValues (const networkModeValues& v,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::token (v, f, c)
{
}

networkModeValues& networkModeValues::
operator= (value v)
{
  static_cast< ::xml_schema::token& > (*this) = 
  ::xml_schema::token (_xsd_networkModeValues_literals_[v]);

  return *this;
}


// profileNames
// 

profileNames::
profileNames (value v)
: ::xml_schema::string (_xsd_profileNames_literals_[v])
{
}

profileNames::
profileNames (const char* v)
: ::xml_schema::string (v)
{
}

profileNames::
profileNames (const ::std::string& v)
: ::xml_schema::string (v)
{
}

profileNames::
profileNames (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

profileNames::
profileNames (const profileNames& v,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

profileNames& profileNames::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_profileNames_literals_[v]);

  return *this;
}


// x3dVersion
// 

x3dVersion::
x3dVersion (value v)
: ::xml_schema::string (_xsd_x3dVersion_literals_[v])
{
}

x3dVersion::
x3dVersion (const char* v)
: ::xml_schema::string (v)
{
}

x3dVersion::
x3dVersion (const ::std::string& v)
: ::xml_schema::string (v)
{
}

x3dVersion::
x3dVersion (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

x3dVersion::
x3dVersion (const x3dVersion& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

x3dVersion& x3dVersion::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_x3dVersion_literals_[v]);

  return *this;
}


// initializeOnlyAccessTypes
// 

initializeOnlyAccessTypes::
initializeOnlyAccessTypes (value v)
: ::xml_schema::string (_xsd_initializeOnlyAccessTypes_literals_[v])
{
}

initializeOnlyAccessTypes::
initializeOnlyAccessTypes (const char* v)
: ::xml_schema::string (v)
{
}

initializeOnlyAccessTypes::
initializeOnlyAccessTypes (const ::std::string& v)
: ::xml_schema::string (v)
{
}

initializeOnlyAccessTypes::
initializeOnlyAccessTypes (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

initializeOnlyAccessTypes::
initializeOnlyAccessTypes (const initializeOnlyAccessTypes& v,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

initializeOnlyAccessTypes& initializeOnlyAccessTypes::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_initializeOnlyAccessTypes_literals_[v]);

  return *this;
}


// inputOnlyAccessTypes
// 

inputOnlyAccessTypes::
inputOnlyAccessTypes (value v)
: ::xml_schema::string (_xsd_inputOnlyAccessTypes_literals_[v])
{
}

inputOnlyAccessTypes::
inputOnlyAccessTypes (const char* v)
: ::xml_schema::string (v)
{
}

inputOnlyAccessTypes::
inputOnlyAccessTypes (const ::std::string& v)
: ::xml_schema::string (v)
{
}

inputOnlyAccessTypes::
inputOnlyAccessTypes (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

inputOnlyAccessTypes::
inputOnlyAccessTypes (const inputOnlyAccessTypes& v,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

inputOnlyAccessTypes& inputOnlyAccessTypes::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_inputOnlyAccessTypes_literals_[v]);

  return *this;
}


// outputOnlyAccessTypes
// 

outputOnlyAccessTypes::
outputOnlyAccessTypes (value v)
: ::xml_schema::string (_xsd_outputOnlyAccessTypes_literals_[v])
{
}

outputOnlyAccessTypes::
outputOnlyAccessTypes (const char* v)
: ::xml_schema::string (v)
{
}

outputOnlyAccessTypes::
outputOnlyAccessTypes (const ::std::string& v)
: ::xml_schema::string (v)
{
}

outputOnlyAccessTypes::
outputOnlyAccessTypes (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

outputOnlyAccessTypes::
outputOnlyAccessTypes (const outputOnlyAccessTypes& v,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

outputOnlyAccessTypes& outputOnlyAccessTypes::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_outputOnlyAccessTypes_literals_[v]);

  return *this;
}


// inputOutputAccessTypes
// 

inputOutputAccessTypes::
inputOutputAccessTypes (value1 v)
: ::xml_schema::string (_xsd_inputOutputAccessTypes_literals_[v])
{
}

inputOutputAccessTypes::
inputOutputAccessTypes (const char* v)
: ::xml_schema::string (v)
{
}

inputOutputAccessTypes::
inputOutputAccessTypes (const ::std::string& v)
: ::xml_schema::string (v)
{
}

inputOutputAccessTypes::
inputOutputAccessTypes (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

inputOutputAccessTypes::
inputOutputAccessTypes (const inputOutputAccessTypes& v,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

inputOutputAccessTypes& inputOutputAccessTypes::
operator= (value1 v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_inputOutputAccessTypes_literals_[v]);

  return *this;
}


// X3DNode
// 

const X3DNode::IS_optional& X3DNode::
IS () const
{
  return this->IS_;
}

X3DNode::IS_optional& X3DNode::
IS ()
{
  return this->IS_;
}

void X3DNode::
IS (const IS_type& x)
{
  this->IS_.set (x);
}

void X3DNode::
IS (const IS_optional& x)
{
  this->IS_ = x;
}

void X3DNode::
IS (::std::auto_ptr< IS_type > x)
{
  this->IS_.set (x);
}

const X3DNode::MetadataDouble_optional& X3DNode::
MetadataDouble () const
{
  return this->MetadataDouble_;
}

X3DNode::MetadataDouble_optional& X3DNode::
MetadataDouble ()
{
  return this->MetadataDouble_;
}

void X3DNode::
MetadataDouble (const MetadataDouble_type& x)
{
  this->MetadataDouble_.set (x);
}

void X3DNode::
MetadataDouble (const MetadataDouble_optional& x)
{
  this->MetadataDouble_ = x;
}

void X3DNode::
MetadataDouble (::std::auto_ptr< MetadataDouble_type > x)
{
  this->MetadataDouble_.set (x);
}

const X3DNode::MetadataFloat_optional& X3DNode::
MetadataFloat () const
{
  return this->MetadataFloat_;
}

X3DNode::MetadataFloat_optional& X3DNode::
MetadataFloat ()
{
  return this->MetadataFloat_;
}

void X3DNode::
MetadataFloat (const MetadataFloat_type& x)
{
  this->MetadataFloat_.set (x);
}

void X3DNode::
MetadataFloat (const MetadataFloat_optional& x)
{
  this->MetadataFloat_ = x;
}

void X3DNode::
MetadataFloat (::std::auto_ptr< MetadataFloat_type > x)
{
  this->MetadataFloat_.set (x);
}

const X3DNode::MetadataInteger_optional& X3DNode::
MetadataInteger () const
{
  return this->MetadataInteger_;
}

X3DNode::MetadataInteger_optional& X3DNode::
MetadataInteger ()
{
  return this->MetadataInteger_;
}

void X3DNode::
MetadataInteger (const MetadataInteger_type& x)
{
  this->MetadataInteger_.set (x);
}

void X3DNode::
MetadataInteger (const MetadataInteger_optional& x)
{
  this->MetadataInteger_ = x;
}

void X3DNode::
MetadataInteger (::std::auto_ptr< MetadataInteger_type > x)
{
  this->MetadataInteger_.set (x);
}

const X3DNode::MetadataSet_optional& X3DNode::
MetadataSet () const
{
  return this->MetadataSet_;
}

X3DNode::MetadataSet_optional& X3DNode::
MetadataSet ()
{
  return this->MetadataSet_;
}

void X3DNode::
MetadataSet (const MetadataSet_type& x)
{
  this->MetadataSet_.set (x);
}

void X3DNode::
MetadataSet (const MetadataSet_optional& x)
{
  this->MetadataSet_ = x;
}

void X3DNode::
MetadataSet (::std::auto_ptr< MetadataSet_type > x)
{
  this->MetadataSet_.set (x);
}

const X3DNode::MetadataString_optional& X3DNode::
MetadataString () const
{
  return this->MetadataString_;
}

X3DNode::MetadataString_optional& X3DNode::
MetadataString ()
{
  return this->MetadataString_;
}

void X3DNode::
MetadataString (const MetadataString_type& x)
{
  this->MetadataString_.set (x);
}

void X3DNode::
MetadataString (const MetadataString_optional& x)
{
  this->MetadataString_ = x;
}

void X3DNode::
MetadataString (::std::auto_ptr< MetadataString_type > x)
{
  this->MetadataString_.set (x);
}

const X3DNode::DEF_optional& X3DNode::
DEF () const
{
  return this->DEF_;
}

X3DNode::DEF_optional& X3DNode::
DEF ()
{
  return this->DEF_;
}

void X3DNode::
DEF (const DEF_type& x)
{
  this->DEF_.set (x);
}

void X3DNode::
DEF (const DEF_optional& x)
{
  this->DEF_ = x;
}

void X3DNode::
DEF (::std::auto_ptr< DEF_type > x)
{
  this->DEF_.set (x);
}

const X3DNode::USE_optional& X3DNode::
USE () const
{
  return this->USE_;
}

X3DNode::USE_optional& X3DNode::
USE ()
{
  return this->USE_;
}

void X3DNode::
USE (const USE_type& x)
{
  this->USE_.set (x);
}

void X3DNode::
USE (const USE_optional& x)
{
  this->USE_ = x;
}

void X3DNode::
USE (::std::auto_ptr< USE_type > x)
{
  this->USE_.set (x);
}

const X3DNode::class_optional& X3DNode::
class_ () const
{
  return this->class__;
}

X3DNode::class_optional& X3DNode::
class_ ()
{
  return this->class__;
}

void X3DNode::
class_ (const class_type& x)
{
  this->class__.set (x);
}

void X3DNode::
class_ (const class_optional& x)
{
  this->class__ = x;
}

void X3DNode::
class_ (::std::auto_ptr< class_type > x)
{
  this->class__.set (x);
}


// X3DAppearanceNode
// 

const X3DAppearanceNode::FillProperties_sequence& X3DAppearanceNode::
FillProperties () const
{
  return this->FillProperties_;
}

X3DAppearanceNode::FillProperties_sequence& X3DAppearanceNode::
FillProperties ()
{
  return this->FillProperties_;
}

void X3DAppearanceNode::
FillProperties (const FillProperties_sequence& s)
{
  this->FillProperties_ = s;
}

const X3DAppearanceNode::LineProperties_sequence& X3DAppearanceNode::
LineProperties () const
{
  return this->LineProperties_;
}

X3DAppearanceNode::LineProperties_sequence& X3DAppearanceNode::
LineProperties ()
{
  return this->LineProperties_;
}

void X3DAppearanceNode::
LineProperties (const LineProperties_sequence& s)
{
  this->LineProperties_ = s;
}

const X3DAppearanceNode::Material_sequence& X3DAppearanceNode::
Material () const
{
  return this->Material_;
}

X3DAppearanceNode::Material_sequence& X3DAppearanceNode::
Material ()
{
  return this->Material_;
}

void X3DAppearanceNode::
Material (const Material_sequence& s)
{
  this->Material_ = s;
}

const X3DAppearanceNode::ComposedShader_sequence& X3DAppearanceNode::
ComposedShader () const
{
  return this->ComposedShader_;
}

X3DAppearanceNode::ComposedShader_sequence& X3DAppearanceNode::
ComposedShader ()
{
  return this->ComposedShader_;
}

void X3DAppearanceNode::
ComposedShader (const ComposedShader_sequence& s)
{
  this->ComposedShader_ = s;
}

const X3DAppearanceNode::PackagedShader_sequence& X3DAppearanceNode::
PackagedShader () const
{
  return this->PackagedShader_;
}

X3DAppearanceNode::PackagedShader_sequence& X3DAppearanceNode::
PackagedShader ()
{
  return this->PackagedShader_;
}

void X3DAppearanceNode::
PackagedShader (const PackagedShader_sequence& s)
{
  this->PackagedShader_ = s;
}

const X3DAppearanceNode::ProgramShader_sequence& X3DAppearanceNode::
ProgramShader () const
{
  return this->ProgramShader_;
}

X3DAppearanceNode::ProgramShader_sequence& X3DAppearanceNode::
ProgramShader ()
{
  return this->ProgramShader_;
}

void X3DAppearanceNode::
ProgramShader (const ProgramShader_sequence& s)
{
  this->ProgramShader_ = s;
}

const X3DAppearanceNode::ComposedCubeMapTexture_sequence& X3DAppearanceNode::
ComposedCubeMapTexture () const
{
  return this->ComposedCubeMapTexture_;
}

X3DAppearanceNode::ComposedCubeMapTexture_sequence& X3DAppearanceNode::
ComposedCubeMapTexture ()
{
  return this->ComposedCubeMapTexture_;
}

void X3DAppearanceNode::
ComposedCubeMapTexture (const ComposedCubeMapTexture_sequence& s)
{
  this->ComposedCubeMapTexture_ = s;
}

const X3DAppearanceNode::ImageTexture_sequence& X3DAppearanceNode::
ImageTexture () const
{
  return this->ImageTexture_;
}

X3DAppearanceNode::ImageTexture_sequence& X3DAppearanceNode::
ImageTexture ()
{
  return this->ImageTexture_;
}

void X3DAppearanceNode::
ImageTexture (const ImageTexture_sequence& s)
{
  this->ImageTexture_ = s;
}

const X3DAppearanceNode::MovieTexture_sequence& X3DAppearanceNode::
MovieTexture () const
{
  return this->MovieTexture_;
}

X3DAppearanceNode::MovieTexture_sequence& X3DAppearanceNode::
MovieTexture ()
{
  return this->MovieTexture_;
}

void X3DAppearanceNode::
MovieTexture (const MovieTexture_sequence& s)
{
  this->MovieTexture_ = s;
}

const X3DAppearanceNode::MultiTexture_sequence& X3DAppearanceNode::
MultiTexture () const
{
  return this->MultiTexture_;
}

X3DAppearanceNode::MultiTexture_sequence& X3DAppearanceNode::
MultiTexture ()
{
  return this->MultiTexture_;
}

void X3DAppearanceNode::
MultiTexture (const MultiTexture_sequence& s)
{
  this->MultiTexture_ = s;
}

const X3DAppearanceNode::PixelTexture_sequence& X3DAppearanceNode::
PixelTexture () const
{
  return this->PixelTexture_;
}

X3DAppearanceNode::PixelTexture_sequence& X3DAppearanceNode::
PixelTexture ()
{
  return this->PixelTexture_;
}

void X3DAppearanceNode::
PixelTexture (const PixelTexture_sequence& s)
{
  this->PixelTexture_ = s;
}

const X3DAppearanceNode::GeneratedCubeMapTexture_sequence& X3DAppearanceNode::
GeneratedCubeMapTexture () const
{
  return this->GeneratedCubeMapTexture_;
}

X3DAppearanceNode::GeneratedCubeMapTexture_sequence& X3DAppearanceNode::
GeneratedCubeMapTexture ()
{
  return this->GeneratedCubeMapTexture_;
}

void X3DAppearanceNode::
GeneratedCubeMapTexture (const GeneratedCubeMapTexture_sequence& s)
{
  this->GeneratedCubeMapTexture_ = s;
}

const X3DAppearanceNode::ImageCubeMapTexture_sequence& X3DAppearanceNode::
ImageCubeMapTexture () const
{
  return this->ImageCubeMapTexture_;
}

X3DAppearanceNode::ImageCubeMapTexture_sequence& X3DAppearanceNode::
ImageCubeMapTexture ()
{
  return this->ImageCubeMapTexture_;
}

void X3DAppearanceNode::
ImageCubeMapTexture (const ImageCubeMapTexture_sequence& s)
{
  this->ImageCubeMapTexture_ = s;
}

const X3DAppearanceNode::MultiTextureTransform_sequence& X3DAppearanceNode::
MultiTextureTransform () const
{
  return this->MultiTextureTransform_;
}

X3DAppearanceNode::MultiTextureTransform_sequence& X3DAppearanceNode::
MultiTextureTransform ()
{
  return this->MultiTextureTransform_;
}

void X3DAppearanceNode::
MultiTextureTransform (const MultiTextureTransform_sequence& s)
{
  this->MultiTextureTransform_ = s;
}

const X3DAppearanceNode::TextureTransform_sequence& X3DAppearanceNode::
TextureTransform () const
{
  return this->TextureTransform_;
}

X3DAppearanceNode::TextureTransform_sequence& X3DAppearanceNode::
TextureTransform ()
{
  return this->TextureTransform_;
}

void X3DAppearanceNode::
TextureTransform (const TextureTransform_sequence& s)
{
  this->TextureTransform_ = s;
}

const X3DAppearanceNode::ProtoInstance_sequence& X3DAppearanceNode::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

X3DAppearanceNode::ProtoInstance_sequence& X3DAppearanceNode::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void X3DAppearanceNode::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const X3DAppearanceNode::containerField_type& X3DAppearanceNode::
containerField () const
{
  return this->containerField_.get ();
}

X3DAppearanceNode::containerField_type& X3DAppearanceNode::
containerField ()
{
  return this->containerField_.get ();
}

void X3DAppearanceNode::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void X3DAppearanceNode::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const X3DAppearanceNode::containerField_type& X3DAppearanceNode::
containerField_default_value ()
{
  return containerField_default_value_;
}


// X3DAppearanceChildNode
// 


// X3DChildNode
// 

const X3DChildNode::containerField_type& X3DChildNode::
containerField () const
{
  return this->containerField_.get ();
}

X3DChildNode::containerField_type& X3DChildNode::
containerField ()
{
  return this->containerField_.get ();
}

void X3DChildNode::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void X3DChildNode::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const X3DChildNode::containerField_type& X3DChildNode::
containerField_default_value ()
{
  return containerField_default_value_;
}


// X3DBindableNode
// 


// X3DBackgroundNode
// 

const X3DBackgroundNode::groundAngle_optional& X3DBackgroundNode::
groundAngle () const
{
  return this->groundAngle_;
}

X3DBackgroundNode::groundAngle_optional& X3DBackgroundNode::
groundAngle ()
{
  return this->groundAngle_;
}

void X3DBackgroundNode::
groundAngle (const groundAngle_type& x)
{
  this->groundAngle_.set (x);
}

void X3DBackgroundNode::
groundAngle (const groundAngle_optional& x)
{
  this->groundAngle_ = x;
}

void X3DBackgroundNode::
groundAngle (::std::auto_ptr< groundAngle_type > x)
{
  this->groundAngle_.set (x);
}

const X3DBackgroundNode::groundColor_optional& X3DBackgroundNode::
groundColor () const
{
  return this->groundColor_;
}

X3DBackgroundNode::groundColor_optional& X3DBackgroundNode::
groundColor ()
{
  return this->groundColor_;
}

void X3DBackgroundNode::
groundColor (const groundColor_type& x)
{
  this->groundColor_.set (x);
}

void X3DBackgroundNode::
groundColor (const groundColor_optional& x)
{
  this->groundColor_ = x;
}

void X3DBackgroundNode::
groundColor (::std::auto_ptr< groundColor_type > x)
{
  this->groundColor_.set (x);
}

const X3DBackgroundNode::skyAngle_optional& X3DBackgroundNode::
skyAngle () const
{
  return this->skyAngle_;
}

X3DBackgroundNode::skyAngle_optional& X3DBackgroundNode::
skyAngle ()
{
  return this->skyAngle_;
}

void X3DBackgroundNode::
skyAngle (const skyAngle_type& x)
{
  this->skyAngle_.set (x);
}

void X3DBackgroundNode::
skyAngle (const skyAngle_optional& x)
{
  this->skyAngle_ = x;
}

void X3DBackgroundNode::
skyAngle (::std::auto_ptr< skyAngle_type > x)
{
  this->skyAngle_.set (x);
}

const X3DBackgroundNode::skyColor_type& X3DBackgroundNode::
skyColor () const
{
  return this->skyColor_.get ();
}

X3DBackgroundNode::skyColor_type& X3DBackgroundNode::
skyColor ()
{
  return this->skyColor_.get ();
}

void X3DBackgroundNode::
skyColor (const skyColor_type& x)
{
  this->skyColor_.set (x);
}

void X3DBackgroundNode::
skyColor (::std::auto_ptr< skyColor_type > x)
{
  this->skyColor_.set (x);
}

const X3DBackgroundNode::skyColor_type& X3DBackgroundNode::
skyColor_default_value ()
{
  return skyColor_default_value_;
}


// X3DBoundedObject
// 

const X3DBoundedObject::bboxCenter_type& X3DBoundedObject::
bboxCenter () const
{
  return this->bboxCenter_.get ();
}

X3DBoundedObject::bboxCenter_type& X3DBoundedObject::
bboxCenter ()
{
  return this->bboxCenter_.get ();
}

void X3DBoundedObject::
bboxCenter (const bboxCenter_type& x)
{
  this->bboxCenter_.set (x);
}

void X3DBoundedObject::
bboxCenter (::std::auto_ptr< bboxCenter_type > x)
{
  this->bboxCenter_.set (x);
}

const X3DBoundedObject::bboxCenter_type& X3DBoundedObject::
bboxCenter_default_value ()
{
  return bboxCenter_default_value_;
}

const X3DBoundedObject::bboxSize_type& X3DBoundedObject::
bboxSize () const
{
  return this->bboxSize_.get ();
}

X3DBoundedObject::bboxSize_type& X3DBoundedObject::
bboxSize ()
{
  return this->bboxSize_.get ();
}

void X3DBoundedObject::
bboxSize (const bboxSize_type& x)
{
  this->bboxSize_.set (x);
}

void X3DBoundedObject::
bboxSize (::std::auto_ptr< bboxSize_type > x)
{
  this->bboxSize_.set (x);
}

const X3DBoundedObject::bboxSize_type& X3DBoundedObject::
bboxSize_default_value ()
{
  return bboxSize_default_value_;
}


// X3DGeometricPropertyNode
// 


// X3DColorNode
// 

const X3DColorNode::containerField_type& X3DColorNode::
containerField () const
{
  return this->containerField_.get ();
}

X3DColorNode::containerField_type& X3DColorNode::
containerField ()
{
  return this->containerField_.get ();
}

void X3DColorNode::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void X3DColorNode::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const X3DColorNode::containerField_type& X3DColorNode::
containerField_default_value ()
{
  return containerField_default_value_;
}


// X3DGeometryNode
// 

const X3DGeometryNode::containerField_type& X3DGeometryNode::
containerField () const
{
  return this->containerField_.get ();
}

X3DGeometryNode::containerField_type& X3DGeometryNode::
containerField ()
{
  return this->containerField_.get ();
}

void X3DGeometryNode::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void X3DGeometryNode::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const X3DGeometryNode::containerField_type& X3DGeometryNode::
containerField_default_value ()
{
  return containerField_default_value_;
}


// X3DComposedGeometryNode
// 

const X3DComposedGeometryNode::FloatVertexAttribute_sequence& X3DComposedGeometryNode::
FloatVertexAttribute () const
{
  return this->FloatVertexAttribute_;
}

X3DComposedGeometryNode::FloatVertexAttribute_sequence& X3DComposedGeometryNode::
FloatVertexAttribute ()
{
  return this->FloatVertexAttribute_;
}

void X3DComposedGeometryNode::
FloatVertexAttribute (const FloatVertexAttribute_sequence& s)
{
  this->FloatVertexAttribute_ = s;
}

const X3DComposedGeometryNode::Matrix3VertexAttribute_sequence& X3DComposedGeometryNode::
Matrix3VertexAttribute () const
{
  return this->Matrix3VertexAttribute_;
}

X3DComposedGeometryNode::Matrix3VertexAttribute_sequence& X3DComposedGeometryNode::
Matrix3VertexAttribute ()
{
  return this->Matrix3VertexAttribute_;
}

void X3DComposedGeometryNode::
Matrix3VertexAttribute (const Matrix3VertexAttribute_sequence& s)
{
  this->Matrix3VertexAttribute_ = s;
}

const X3DComposedGeometryNode::Matrix4VertexAttribute_sequence& X3DComposedGeometryNode::
Matrix4VertexAttribute () const
{
  return this->Matrix4VertexAttribute_;
}

X3DComposedGeometryNode::Matrix4VertexAttribute_sequence& X3DComposedGeometryNode::
Matrix4VertexAttribute ()
{
  return this->Matrix4VertexAttribute_;
}

void X3DComposedGeometryNode::
Matrix4VertexAttribute (const Matrix4VertexAttribute_sequence& s)
{
  this->Matrix4VertexAttribute_ = s;
}

const X3DComposedGeometryNode::Color_sequence& X3DComposedGeometryNode::
Color () const
{
  return this->Color_;
}

X3DComposedGeometryNode::Color_sequence& X3DComposedGeometryNode::
Color ()
{
  return this->Color_;
}

void X3DComposedGeometryNode::
Color (const Color_sequence& s)
{
  this->Color_ = s;
}

const X3DComposedGeometryNode::ColorRGBA_sequence& X3DComposedGeometryNode::
ColorRGBA () const
{
  return this->ColorRGBA_;
}

X3DComposedGeometryNode::ColorRGBA_sequence& X3DComposedGeometryNode::
ColorRGBA ()
{
  return this->ColorRGBA_;
}

void X3DComposedGeometryNode::
ColorRGBA (const ColorRGBA_sequence& s)
{
  this->ColorRGBA_ = s;
}

const X3DComposedGeometryNode::Coordinate_sequence& X3DComposedGeometryNode::
Coordinate () const
{
  return this->Coordinate_;
}

X3DComposedGeometryNode::Coordinate_sequence& X3DComposedGeometryNode::
Coordinate ()
{
  return this->Coordinate_;
}

void X3DComposedGeometryNode::
Coordinate (const Coordinate_sequence& s)
{
  this->Coordinate_ = s;
}

const X3DComposedGeometryNode::CoordinateDouble_sequence& X3DComposedGeometryNode::
CoordinateDouble () const
{
  return this->CoordinateDouble_;
}

X3DComposedGeometryNode::CoordinateDouble_sequence& X3DComposedGeometryNode::
CoordinateDouble ()
{
  return this->CoordinateDouble_;
}

void X3DComposedGeometryNode::
CoordinateDouble (const CoordinateDouble_sequence& s)
{
  this->CoordinateDouble_ = s;
}

const X3DComposedGeometryNode::GeoCoordinate_sequence& X3DComposedGeometryNode::
GeoCoordinate () const
{
  return this->GeoCoordinate_;
}

X3DComposedGeometryNode::GeoCoordinate_sequence& X3DComposedGeometryNode::
GeoCoordinate ()
{
  return this->GeoCoordinate_;
}

void X3DComposedGeometryNode::
GeoCoordinate (const GeoCoordinate_sequence& s)
{
  this->GeoCoordinate_ = s;
}

const X3DComposedGeometryNode::FogCoordinate_sequence& X3DComposedGeometryNode::
FogCoordinate () const
{
  return this->FogCoordinate_;
}

X3DComposedGeometryNode::FogCoordinate_sequence& X3DComposedGeometryNode::
FogCoordinate ()
{
  return this->FogCoordinate_;
}

void X3DComposedGeometryNode::
FogCoordinate (const FogCoordinate_sequence& s)
{
  this->FogCoordinate_ = s;
}

const X3DComposedGeometryNode::Normal_sequence& X3DComposedGeometryNode::
Normal () const
{
  return this->Normal_;
}

X3DComposedGeometryNode::Normal_sequence& X3DComposedGeometryNode::
Normal ()
{
  return this->Normal_;
}

void X3DComposedGeometryNode::
Normal (const Normal_sequence& s)
{
  this->Normal_ = s;
}

const X3DComposedGeometryNode::TextureCoordinate_sequence& X3DComposedGeometryNode::
TextureCoordinate () const
{
  return this->TextureCoordinate_;
}

X3DComposedGeometryNode::TextureCoordinate_sequence& X3DComposedGeometryNode::
TextureCoordinate ()
{
  return this->TextureCoordinate_;
}

void X3DComposedGeometryNode::
TextureCoordinate (const TextureCoordinate_sequence& s)
{
  this->TextureCoordinate_ = s;
}

const X3DComposedGeometryNode::TextureCoordinate3D_sequence& X3DComposedGeometryNode::
TextureCoordinate3D () const
{
  return this->TextureCoordinate3D_;
}

X3DComposedGeometryNode::TextureCoordinate3D_sequence& X3DComposedGeometryNode::
TextureCoordinate3D ()
{
  return this->TextureCoordinate3D_;
}

void X3DComposedGeometryNode::
TextureCoordinate3D (const TextureCoordinate3D_sequence& s)
{
  this->TextureCoordinate3D_ = s;
}

const X3DComposedGeometryNode::TextureCoordinate4D_sequence& X3DComposedGeometryNode::
TextureCoordinate4D () const
{
  return this->TextureCoordinate4D_;
}

X3DComposedGeometryNode::TextureCoordinate4D_sequence& X3DComposedGeometryNode::
TextureCoordinate4D ()
{
  return this->TextureCoordinate4D_;
}

void X3DComposedGeometryNode::
TextureCoordinate4D (const TextureCoordinate4D_sequence& s)
{
  this->TextureCoordinate4D_ = s;
}

const X3DComposedGeometryNode::TextureCoordinateGenerator_sequence& X3DComposedGeometryNode::
TextureCoordinateGenerator () const
{
  return this->TextureCoordinateGenerator_;
}

X3DComposedGeometryNode::TextureCoordinateGenerator_sequence& X3DComposedGeometryNode::
TextureCoordinateGenerator ()
{
  return this->TextureCoordinateGenerator_;
}

void X3DComposedGeometryNode::
TextureCoordinateGenerator (const TextureCoordinateGenerator_sequence& s)
{
  this->TextureCoordinateGenerator_ = s;
}

const X3DComposedGeometryNode::MultiTextureCoordinate_sequence& X3DComposedGeometryNode::
MultiTextureCoordinate () const
{
  return this->MultiTextureCoordinate_;
}

X3DComposedGeometryNode::MultiTextureCoordinate_sequence& X3DComposedGeometryNode::
MultiTextureCoordinate ()
{
  return this->MultiTextureCoordinate_;
}

void X3DComposedGeometryNode::
MultiTextureCoordinate (const MultiTextureCoordinate_sequence& s)
{
  this->MultiTextureCoordinate_ = s;
}

const X3DComposedGeometryNode::NurbsTextureCoordinate_sequence& X3DComposedGeometryNode::
NurbsTextureCoordinate () const
{
  return this->NurbsTextureCoordinate_;
}

X3DComposedGeometryNode::NurbsTextureCoordinate_sequence& X3DComposedGeometryNode::
NurbsTextureCoordinate ()
{
  return this->NurbsTextureCoordinate_;
}

void X3DComposedGeometryNode::
NurbsTextureCoordinate (const NurbsTextureCoordinate_sequence& s)
{
  this->NurbsTextureCoordinate_ = s;
}

const X3DComposedGeometryNode::ProtoInstance_sequence& X3DComposedGeometryNode::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

X3DComposedGeometryNode::ProtoInstance_sequence& X3DComposedGeometryNode::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void X3DComposedGeometryNode::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const X3DComposedGeometryNode::ccw_type& X3DComposedGeometryNode::
ccw () const
{
  return this->ccw_.get ();
}

X3DComposedGeometryNode::ccw_type& X3DComposedGeometryNode::
ccw ()
{
  return this->ccw_.get ();
}

void X3DComposedGeometryNode::
ccw (const ccw_type& x)
{
  this->ccw_.set (x);
}

void X3DComposedGeometryNode::
ccw (::std::auto_ptr< ccw_type > x)
{
  this->ccw_.set (x);
}

const X3DComposedGeometryNode::ccw_type& X3DComposedGeometryNode::
ccw_default_value ()
{
  return ccw_default_value_;
}

const X3DComposedGeometryNode::colorPerVertex_type& X3DComposedGeometryNode::
colorPerVertex () const
{
  return this->colorPerVertex_.get ();
}

X3DComposedGeometryNode::colorPerVertex_type& X3DComposedGeometryNode::
colorPerVertex ()
{
  return this->colorPerVertex_.get ();
}

void X3DComposedGeometryNode::
colorPerVertex (const colorPerVertex_type& x)
{
  this->colorPerVertex_.set (x);
}

void X3DComposedGeometryNode::
colorPerVertex (::std::auto_ptr< colorPerVertex_type > x)
{
  this->colorPerVertex_.set (x);
}

const X3DComposedGeometryNode::colorPerVertex_type& X3DComposedGeometryNode::
colorPerVertex_default_value ()
{
  return colorPerVertex_default_value_;
}

const X3DComposedGeometryNode::normalPerVertex_type& X3DComposedGeometryNode::
normalPerVertex () const
{
  return this->normalPerVertex_.get ();
}

X3DComposedGeometryNode::normalPerVertex_type& X3DComposedGeometryNode::
normalPerVertex ()
{
  return this->normalPerVertex_.get ();
}

void X3DComposedGeometryNode::
normalPerVertex (const normalPerVertex_type& x)
{
  this->normalPerVertex_.set (x);
}

void X3DComposedGeometryNode::
normalPerVertex (::std::auto_ptr< normalPerVertex_type > x)
{
  this->normalPerVertex_.set (x);
}

const X3DComposedGeometryNode::normalPerVertex_type& X3DComposedGeometryNode::
normalPerVertex_default_value ()
{
  return normalPerVertex_default_value_;
}

const X3DComposedGeometryNode::solid_type& X3DComposedGeometryNode::
solid () const
{
  return this->solid_.get ();
}

X3DComposedGeometryNode::solid_type& X3DComposedGeometryNode::
solid ()
{
  return this->solid_.get ();
}

void X3DComposedGeometryNode::
solid (const solid_type& x)
{
  this->solid_.set (x);
}

void X3DComposedGeometryNode::
solid (::std::auto_ptr< solid_type > x)
{
  this->solid_.set (x);
}

const X3DComposedGeometryNode::solid_type& X3DComposedGeometryNode::
solid_default_value ()
{
  return solid_default_value_;
}


// X3DCoordinateNode
// 


// X3DSensorNode
// 

const X3DSensorNode::enabled_type& X3DSensorNode::
enabled () const
{
  return this->enabled_.get ();
}

X3DSensorNode::enabled_type& X3DSensorNode::
enabled ()
{
  return this->enabled_.get ();
}

void X3DSensorNode::
enabled (const enabled_type& x)
{
  this->enabled_.set (x);
}

void X3DSensorNode::
enabled (::std::auto_ptr< enabled_type > x)
{
  this->enabled_.set (x);
}

const X3DSensorNode::enabled_type& X3DSensorNode::
enabled_default_value ()
{
  return enabled_default_value_;
}


// X3DPointingDeviceSensorNode
// 

const X3DPointingDeviceSensorNode::description_optional& X3DPointingDeviceSensorNode::
description () const
{
  return this->description_;
}

X3DPointingDeviceSensorNode::description_optional& X3DPointingDeviceSensorNode::
description ()
{
  return this->description_;
}

void X3DPointingDeviceSensorNode::
description (const description_type& x)
{
  this->description_.set (x);
}

void X3DPointingDeviceSensorNode::
description (const description_optional& x)
{
  this->description_ = x;
}

void X3DPointingDeviceSensorNode::
description (::std::auto_ptr< description_type > x)
{
  this->description_.set (x);
}


// X3DDragSensorNode
// 

const X3DDragSensorNode::autoOffset_type& X3DDragSensorNode::
autoOffset () const
{
  return this->autoOffset_.get ();
}

X3DDragSensorNode::autoOffset_type& X3DDragSensorNode::
autoOffset ()
{
  return this->autoOffset_.get ();
}

void X3DDragSensorNode::
autoOffset (const autoOffset_type& x)
{
  this->autoOffset_.set (x);
}

void X3DDragSensorNode::
autoOffset (::std::auto_ptr< autoOffset_type > x)
{
  this->autoOffset_.set (x);
}

const X3DDragSensorNode::autoOffset_type& X3DDragSensorNode::
autoOffset_default_value ()
{
  return autoOffset_default_value_;
}


// X3DEnvironmentalSensorNode
// 

const X3DEnvironmentalSensorNode::center_type& X3DEnvironmentalSensorNode::
center () const
{
  return this->center_.get ();
}

X3DEnvironmentalSensorNode::center_type& X3DEnvironmentalSensorNode::
center ()
{
  return this->center_.get ();
}

void X3DEnvironmentalSensorNode::
center (const center_type& x)
{
  this->center_.set (x);
}

void X3DEnvironmentalSensorNode::
center (::std::auto_ptr< center_type > x)
{
  this->center_.set (x);
}

const X3DEnvironmentalSensorNode::center_type& X3DEnvironmentalSensorNode::
center_default_value ()
{
  return center_default_value_;
}

const X3DEnvironmentalSensorNode::size_type& X3DEnvironmentalSensorNode::
size () const
{
  return this->size_.get ();
}

X3DEnvironmentalSensorNode::size_type& X3DEnvironmentalSensorNode::
size ()
{
  return this->size_.get ();
}

void X3DEnvironmentalSensorNode::
size (const size_type& x)
{
  this->size_.set (x);
}

void X3DEnvironmentalSensorNode::
size (::std::auto_ptr< size_type > x)
{
  this->size_.set (x);
}

const X3DEnvironmentalSensorNode::size_type& X3DEnvironmentalSensorNode::
size_default_value ()
{
  return size_default_value_;
}


// X3DEnvironmentTextureNode
// 

const X3DEnvironmentTextureNode::containerField_type& X3DEnvironmentTextureNode::
containerField () const
{
  return this->containerField_.get ();
}

X3DEnvironmentTextureNode::containerField_type& X3DEnvironmentTextureNode::
containerField ()
{
  return this->containerField_.get ();
}

void X3DEnvironmentTextureNode::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void X3DEnvironmentTextureNode::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const X3DEnvironmentTextureNode::containerField_type& X3DEnvironmentTextureNode::
containerField_default_value ()
{
  return containerField_default_value_;
}


// X3DField
// 


// X3DFogObject
// 

const X3DFogObject::color_type& X3DFogObject::
color () const
{
  return this->color_.get ();
}

X3DFogObject::color_type& X3DFogObject::
color ()
{
  return this->color_.get ();
}

void X3DFogObject::
color (const color_type& x)
{
  this->color_.set (x);
}

void X3DFogObject::
color (::std::auto_ptr< color_type > x)
{
  this->color_.set (x);
}

const X3DFogObject::color_type& X3DFogObject::
color_default_value ()
{
  return color_default_value_;
}

const X3DFogObject::fogType_type& X3DFogObject::
fogType () const
{
  return this->fogType_.get ();
}

X3DFogObject::fogType_type& X3DFogObject::
fogType ()
{
  return this->fogType_.get ();
}

void X3DFogObject::
fogType (const fogType_type& x)
{
  this->fogType_.set (x);
}

void X3DFogObject::
fogType (::std::auto_ptr< fogType_type > x)
{
  this->fogType_.set (x);
}

const X3DFogObject::fogType_type& X3DFogObject::
fogType_default_value ()
{
  return fogType_default_value_;
}

const X3DFogObject::visibilityRange_type& X3DFogObject::
visibilityRange () const
{
  return this->visibilityRange_.get ();
}

X3DFogObject::visibilityRange_type& X3DFogObject::
visibilityRange ()
{
  return this->visibilityRange_.get ();
}

void X3DFogObject::
visibilityRange (const visibilityRange_type& x)
{
  this->visibilityRange_.set (x);
}

void X3DFogObject::
visibilityRange (::std::auto_ptr< visibilityRange_type > x)
{
  this->visibilityRange_.set (x);
}

const X3DFogObject::visibilityRange_type& X3DFogObject::
visibilityRange_default_value ()
{
  return visibilityRange_default_value_;
}

const X3DFogObject::containerField_type& X3DFogObject::
containerField () const
{
  return this->containerField_.get ();
}

X3DFogObject::containerField_type& X3DFogObject::
containerField ()
{
  return this->containerField_.get ();
}

void X3DFogObject::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void X3DFogObject::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const X3DFogObject::containerField_type& X3DFogObject::
containerField_default_value ()
{
  return containerField_default_value_;
}


// X3DFontStyleNode
// 

const X3DFontStyleNode::containerField_type& X3DFontStyleNode::
containerField () const
{
  return this->containerField_.get ();
}

X3DFontStyleNode::containerField_type& X3DFontStyleNode::
containerField ()
{
  return this->containerField_.get ();
}

void X3DFontStyleNode::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void X3DFontStyleNode::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const X3DFontStyleNode::containerField_type& X3DFontStyleNode::
containerField_default_value ()
{
  return containerField_default_value_;
}


// X3DGroupingNode
// 

const X3DGroupingNode::Appearance_sequence& X3DGroupingNode::
Appearance () const
{
  return this->Appearance_;
}

X3DGroupingNode::Appearance_sequence& X3DGroupingNode::
Appearance ()
{
  return this->Appearance_;
}

void X3DGroupingNode::
Appearance (const Appearance_sequence& s)
{
  this->Appearance_ = s;
}

const X3DGroupingNode::Background_sequence& X3DGroupingNode::
Background () const
{
  return this->Background_;
}

X3DGroupingNode::Background_sequence& X3DGroupingNode::
Background ()
{
  return this->Background_;
}

void X3DGroupingNode::
Background (const Background_sequence& s)
{
  this->Background_ = s;
}

const X3DGroupingNode::ColorInterpolator_sequence& X3DGroupingNode::
ColorInterpolator () const
{
  return this->ColorInterpolator_;
}

X3DGroupingNode::ColorInterpolator_sequence& X3DGroupingNode::
ColorInterpolator ()
{
  return this->ColorInterpolator_;
}

void X3DGroupingNode::
ColorInterpolator (const ColorInterpolator_sequence& s)
{
  this->ColorInterpolator_ = s;
}

const X3DGroupingNode::CoordinateInterpolator_sequence& X3DGroupingNode::
CoordinateInterpolator () const
{
  return this->CoordinateInterpolator_;
}

X3DGroupingNode::CoordinateInterpolator_sequence& X3DGroupingNode::
CoordinateInterpolator ()
{
  return this->CoordinateInterpolator_;
}

void X3DGroupingNode::
CoordinateInterpolator (const CoordinateInterpolator_sequence& s)
{
  this->CoordinateInterpolator_ = s;
}

const X3DGroupingNode::DirectionalLight_sequence& X3DGroupingNode::
DirectionalLight () const
{
  return this->DirectionalLight_;
}

X3DGroupingNode::DirectionalLight_sequence& X3DGroupingNode::
DirectionalLight ()
{
  return this->DirectionalLight_;
}

void X3DGroupingNode::
DirectionalLight (const DirectionalLight_sequence& s)
{
  this->DirectionalLight_ = s;
}

const X3DGroupingNode::Group_sequence& X3DGroupingNode::
Group () const
{
  return this->Group_;
}

X3DGroupingNode::Group_sequence& X3DGroupingNode::
Group ()
{
  return this->Group_;
}

void X3DGroupingNode::
Group (const Group_sequence& s)
{
  this->Group_ = s;
}

const X3DGroupingNode::NavigationInfo_sequence& X3DGroupingNode::
NavigationInfo () const
{
  return this->NavigationInfo_;
}

X3DGroupingNode::NavigationInfo_sequence& X3DGroupingNode::
NavigationInfo ()
{
  return this->NavigationInfo_;
}

void X3DGroupingNode::
NavigationInfo (const NavigationInfo_sequence& s)
{
  this->NavigationInfo_ = s;
}

const X3DGroupingNode::NormalInterpolator_sequence& X3DGroupingNode::
NormalInterpolator () const
{
  return this->NormalInterpolator_;
}

X3DGroupingNode::NormalInterpolator_sequence& X3DGroupingNode::
NormalInterpolator ()
{
  return this->NormalInterpolator_;
}

void X3DGroupingNode::
NormalInterpolator (const NormalInterpolator_sequence& s)
{
  this->NormalInterpolator_ = s;
}

const X3DGroupingNode::OrientationInterpolator_sequence& X3DGroupingNode::
OrientationInterpolator () const
{
  return this->OrientationInterpolator_;
}

X3DGroupingNode::OrientationInterpolator_sequence& X3DGroupingNode::
OrientationInterpolator ()
{
  return this->OrientationInterpolator_;
}

void X3DGroupingNode::
OrientationInterpolator (const OrientationInterpolator_sequence& s)
{
  this->OrientationInterpolator_ = s;
}

const X3DGroupingNode::PositionInterpolator_sequence& X3DGroupingNode::
PositionInterpolator () const
{
  return this->PositionInterpolator_;
}

X3DGroupingNode::PositionInterpolator_sequence& X3DGroupingNode::
PositionInterpolator ()
{
  return this->PositionInterpolator_;
}

void X3DGroupingNode::
PositionInterpolator (const PositionInterpolator_sequence& s)
{
  this->PositionInterpolator_ = s;
}

const X3DGroupingNode::ScalarInterpolator_sequence& X3DGroupingNode::
ScalarInterpolator () const
{
  return this->ScalarInterpolator_;
}

X3DGroupingNode::ScalarInterpolator_sequence& X3DGroupingNode::
ScalarInterpolator ()
{
  return this->ScalarInterpolator_;
}

void X3DGroupingNode::
ScalarInterpolator (const ScalarInterpolator_sequence& s)
{
  this->ScalarInterpolator_ = s;
}

const X3DGroupingNode::Shape_sequence& X3DGroupingNode::
Shape () const
{
  return this->Shape_;
}

X3DGroupingNode::Shape_sequence& X3DGroupingNode::
Shape ()
{
  return this->Shape_;
}

void X3DGroupingNode::
Shape (const Shape_sequence& s)
{
  this->Shape_ = s;
}

const X3DGroupingNode::TimeSensor_sequence& X3DGroupingNode::
TimeSensor () const
{
  return this->TimeSensor_;
}

X3DGroupingNode::TimeSensor_sequence& X3DGroupingNode::
TimeSensor ()
{
  return this->TimeSensor_;
}

void X3DGroupingNode::
TimeSensor (const TimeSensor_sequence& s)
{
  this->TimeSensor_ = s;
}

const X3DGroupingNode::Transform_sequence& X3DGroupingNode::
Transform () const
{
  return this->Transform_;
}

X3DGroupingNode::Transform_sequence& X3DGroupingNode::
Transform ()
{
  return this->Transform_;
}

void X3DGroupingNode::
Transform (const Transform_sequence& s)
{
  this->Transform_ = s;
}

const X3DGroupingNode::Viewpoint_sequence& X3DGroupingNode::
Viewpoint () const
{
  return this->Viewpoint_;
}

X3DGroupingNode::Viewpoint_sequence& X3DGroupingNode::
Viewpoint ()
{
  return this->Viewpoint_;
}

void X3DGroupingNode::
Viewpoint (const Viewpoint_sequence& s)
{
  this->Viewpoint_ = s;
}

const X3DGroupingNode::WorldInfo_sequence& X3DGroupingNode::
WorldInfo () const
{
  return this->WorldInfo_;
}

X3DGroupingNode::WorldInfo_sequence& X3DGroupingNode::
WorldInfo ()
{
  return this->WorldInfo_;
}

void X3DGroupingNode::
WorldInfo (const WorldInfo_sequence& s)
{
  this->WorldInfo_ = s;
}

const X3DGroupingNode::Anchor_sequence& X3DGroupingNode::
Anchor () const
{
  return this->Anchor_;
}

X3DGroupingNode::Anchor_sequence& X3DGroupingNode::
Anchor ()
{
  return this->Anchor_;
}

void X3DGroupingNode::
Anchor (const Anchor_sequence& s)
{
  this->Anchor_ = s;
}

const X3DGroupingNode::BooleanFilter_sequence& X3DGroupingNode::
BooleanFilter () const
{
  return this->BooleanFilter_;
}

X3DGroupingNode::BooleanFilter_sequence& X3DGroupingNode::
BooleanFilter ()
{
  return this->BooleanFilter_;
}

void X3DGroupingNode::
BooleanFilter (const BooleanFilter_sequence& s)
{
  this->BooleanFilter_ = s;
}

const X3DGroupingNode::BooleanSequencer_sequence& X3DGroupingNode::
BooleanSequencer () const
{
  return this->BooleanSequencer_;
}

X3DGroupingNode::BooleanSequencer_sequence& X3DGroupingNode::
BooleanSequencer ()
{
  return this->BooleanSequencer_;
}

void X3DGroupingNode::
BooleanSequencer (const BooleanSequencer_sequence& s)
{
  this->BooleanSequencer_ = s;
}

const X3DGroupingNode::BooleanToggle_sequence& X3DGroupingNode::
BooleanToggle () const
{
  return this->BooleanToggle_;
}

X3DGroupingNode::BooleanToggle_sequence& X3DGroupingNode::
BooleanToggle ()
{
  return this->BooleanToggle_;
}

void X3DGroupingNode::
BooleanToggle (const BooleanToggle_sequence& s)
{
  this->BooleanToggle_ = s;
}

const X3DGroupingNode::BooleanTrigger_sequence& X3DGroupingNode::
BooleanTrigger () const
{
  return this->BooleanTrigger_;
}

X3DGroupingNode::BooleanTrigger_sequence& X3DGroupingNode::
BooleanTrigger ()
{
  return this->BooleanTrigger_;
}

void X3DGroupingNode::
BooleanTrigger (const BooleanTrigger_sequence& s)
{
  this->BooleanTrigger_ = s;
}

const X3DGroupingNode::CylinderSensor_sequence& X3DGroupingNode::
CylinderSensor () const
{
  return this->CylinderSensor_;
}

X3DGroupingNode::CylinderSensor_sequence& X3DGroupingNode::
CylinderSensor ()
{
  return this->CylinderSensor_;
}

void X3DGroupingNode::
CylinderSensor (const CylinderSensor_sequence& s)
{
  this->CylinderSensor_ = s;
}

const X3DGroupingNode::Inline_sequence& X3DGroupingNode::
Inline () const
{
  return this->Inline_;
}

X3DGroupingNode::Inline_sequence& X3DGroupingNode::
Inline ()
{
  return this->Inline_;
}

void X3DGroupingNode::
Inline (const Inline_sequence& s)
{
  this->Inline_ = s;
}

const X3DGroupingNode::IntegerSequencer_sequence& X3DGroupingNode::
IntegerSequencer () const
{
  return this->IntegerSequencer_;
}

X3DGroupingNode::IntegerSequencer_sequence& X3DGroupingNode::
IntegerSequencer ()
{
  return this->IntegerSequencer_;
}

void X3DGroupingNode::
IntegerSequencer (const IntegerSequencer_sequence& s)
{
  this->IntegerSequencer_ = s;
}

const X3DGroupingNode::IntegerTrigger_sequence& X3DGroupingNode::
IntegerTrigger () const
{
  return this->IntegerTrigger_;
}

X3DGroupingNode::IntegerTrigger_sequence& X3DGroupingNode::
IntegerTrigger ()
{
  return this->IntegerTrigger_;
}

void X3DGroupingNode::
IntegerTrigger (const IntegerTrigger_sequence& s)
{
  this->IntegerTrigger_ = s;
}

const X3DGroupingNode::KeySensor_sequence& X3DGroupingNode::
KeySensor () const
{
  return this->KeySensor_;
}

X3DGroupingNode::KeySensor_sequence& X3DGroupingNode::
KeySensor ()
{
  return this->KeySensor_;
}

void X3DGroupingNode::
KeySensor (const KeySensor_sequence& s)
{
  this->KeySensor_ = s;
}

const X3DGroupingNode::PlaneSensor_sequence& X3DGroupingNode::
PlaneSensor () const
{
  return this->PlaneSensor_;
}

X3DGroupingNode::PlaneSensor_sequence& X3DGroupingNode::
PlaneSensor ()
{
  return this->PlaneSensor_;
}

void X3DGroupingNode::
PlaneSensor (const PlaneSensor_sequence& s)
{
  this->PlaneSensor_ = s;
}

const X3DGroupingNode::PointLight_sequence& X3DGroupingNode::
PointLight () const
{
  return this->PointLight_;
}

X3DGroupingNode::PointLight_sequence& X3DGroupingNode::
PointLight ()
{
  return this->PointLight_;
}

void X3DGroupingNode::
PointLight (const PointLight_sequence& s)
{
  this->PointLight_ = s;
}

const X3DGroupingNode::ProximitySensor_sequence& X3DGroupingNode::
ProximitySensor () const
{
  return this->ProximitySensor_;
}

X3DGroupingNode::ProximitySensor_sequence& X3DGroupingNode::
ProximitySensor ()
{
  return this->ProximitySensor_;
}

void X3DGroupingNode::
ProximitySensor (const ProximitySensor_sequence& s)
{
  this->ProximitySensor_ = s;
}

const X3DGroupingNode::SphereSensor_sequence& X3DGroupingNode::
SphereSensor () const
{
  return this->SphereSensor_;
}

X3DGroupingNode::SphereSensor_sequence& X3DGroupingNode::
SphereSensor ()
{
  return this->SphereSensor_;
}

void X3DGroupingNode::
SphereSensor (const SphereSensor_sequence& s)
{
  this->SphereSensor_ = s;
}

const X3DGroupingNode::SpotLight_sequence& X3DGroupingNode::
SpotLight () const
{
  return this->SpotLight_;
}

X3DGroupingNode::SpotLight_sequence& X3DGroupingNode::
SpotLight ()
{
  return this->SpotLight_;
}

void X3DGroupingNode::
SpotLight (const SpotLight_sequence& s)
{
  this->SpotLight_ = s;
}

const X3DGroupingNode::StringSensor_sequence& X3DGroupingNode::
StringSensor () const
{
  return this->StringSensor_;
}

X3DGroupingNode::StringSensor_sequence& X3DGroupingNode::
StringSensor ()
{
  return this->StringSensor_;
}

void X3DGroupingNode::
StringSensor (const StringSensor_sequence& s)
{
  this->StringSensor_ = s;
}

const X3DGroupingNode::Switch_sequence& X3DGroupingNode::
Switch () const
{
  return this->Switch_;
}

X3DGroupingNode::Switch_sequence& X3DGroupingNode::
Switch ()
{
  return this->Switch_;
}

void X3DGroupingNode::
Switch (const Switch_sequence& s)
{
  this->Switch_ = s;
}

const X3DGroupingNode::TimeTrigger_sequence& X3DGroupingNode::
TimeTrigger () const
{
  return this->TimeTrigger_;
}

X3DGroupingNode::TimeTrigger_sequence& X3DGroupingNode::
TimeTrigger ()
{
  return this->TimeTrigger_;
}

void X3DGroupingNode::
TimeTrigger (const TimeTrigger_sequence& s)
{
  this->TimeTrigger_ = s;
}

const X3DGroupingNode::TouchSensor_sequence& X3DGroupingNode::
TouchSensor () const
{
  return this->TouchSensor_;
}

X3DGroupingNode::TouchSensor_sequence& X3DGroupingNode::
TouchSensor ()
{
  return this->TouchSensor_;
}

void X3DGroupingNode::
TouchSensor (const TouchSensor_sequence& s)
{
  this->TouchSensor_ = s;
}

const X3DGroupingNode::AudioClip_sequence& X3DGroupingNode::
AudioClip () const
{
  return this->AudioClip_;
}

X3DGroupingNode::AudioClip_sequence& X3DGroupingNode::
AudioClip ()
{
  return this->AudioClip_;
}

void X3DGroupingNode::
AudioClip (const AudioClip_sequence& s)
{
  this->AudioClip_ = s;
}

const X3DGroupingNode::Billboard_sequence& X3DGroupingNode::
Billboard () const
{
  return this->Billboard_;
}

X3DGroupingNode::Billboard_sequence& X3DGroupingNode::
Billboard ()
{
  return this->Billboard_;
}

void X3DGroupingNode::
Billboard (const Billboard_sequence& s)
{
  this->Billboard_ = s;
}

const X3DGroupingNode::Collision_sequence& X3DGroupingNode::
Collision () const
{
  return this->Collision_;
}

X3DGroupingNode::Collision_sequence& X3DGroupingNode::
Collision ()
{
  return this->Collision_;
}

void X3DGroupingNode::
Collision (const Collision_sequence& s)
{
  this->Collision_ = s;
}

const X3DGroupingNode::Fog_sequence& X3DGroupingNode::
Fog () const
{
  return this->Fog_;
}

X3DGroupingNode::Fog_sequence& X3DGroupingNode::
Fog ()
{
  return this->Fog_;
}

void X3DGroupingNode::
Fog (const Fog_sequence& s)
{
  this->Fog_ = s;
}

const X3DGroupingNode::LoadSensor_sequence& X3DGroupingNode::
LoadSensor () const
{
  return this->LoadSensor_;
}

X3DGroupingNode::LoadSensor_sequence& X3DGroupingNode::
LoadSensor ()
{
  return this->LoadSensor_;
}

void X3DGroupingNode::
LoadSensor (const LoadSensor_sequence& s)
{
  this->LoadSensor_ = s;
}

const X3DGroupingNode::LocalFog_sequence& X3DGroupingNode::
LocalFog () const
{
  return this->LocalFog_;
}

X3DGroupingNode::LocalFog_sequence& X3DGroupingNode::
LocalFog ()
{
  return this->LocalFog_;
}

void X3DGroupingNode::
LocalFog (const LocalFog_sequence& s)
{
  this->LocalFog_ = s;
}

const X3DGroupingNode::LOD_sequence& X3DGroupingNode::
LOD () const
{
  return this->LOD_;
}

X3DGroupingNode::LOD_sequence& X3DGroupingNode::
LOD ()
{
  return this->LOD_;
}

void X3DGroupingNode::
LOD (const LOD_sequence& s)
{
  this->LOD_ = s;
}

const X3DGroupingNode::Script_sequence& X3DGroupingNode::
Script () const
{
  return this->Script_;
}

X3DGroupingNode::Script_sequence& X3DGroupingNode::
Script ()
{
  return this->Script_;
}

void X3DGroupingNode::
Script (const Script_sequence& s)
{
  this->Script_ = s;
}

const X3DGroupingNode::Sound_sequence& X3DGroupingNode::
Sound () const
{
  return this->Sound_;
}

X3DGroupingNode::Sound_sequence& X3DGroupingNode::
Sound ()
{
  return this->Sound_;
}

void X3DGroupingNode::
Sound (const Sound_sequence& s)
{
  this->Sound_ = s;
}

const X3DGroupingNode::VisibilitySensor_sequence& X3DGroupingNode::
VisibilitySensor () const
{
  return this->VisibilitySensor_;
}

X3DGroupingNode::VisibilitySensor_sequence& X3DGroupingNode::
VisibilitySensor ()
{
  return this->VisibilitySensor_;
}

void X3DGroupingNode::
VisibilitySensor (const VisibilitySensor_sequence& s)
{
  this->VisibilitySensor_ = s;
}

const X3DGroupingNode::CoordinateInterpolator2D_sequence& X3DGroupingNode::
CoordinateInterpolator2D () const
{
  return this->CoordinateInterpolator2D_;
}

X3DGroupingNode::CoordinateInterpolator2D_sequence& X3DGroupingNode::
CoordinateInterpolator2D ()
{
  return this->CoordinateInterpolator2D_;
}

void X3DGroupingNode::
CoordinateInterpolator2D (const CoordinateInterpolator2D_sequence& s)
{
  this->CoordinateInterpolator2D_ = s;
}

const X3DGroupingNode::PositionInterpolator2D_sequence& X3DGroupingNode::
PositionInterpolator2D () const
{
  return this->PositionInterpolator2D_;
}

X3DGroupingNode::PositionInterpolator2D_sequence& X3DGroupingNode::
PositionInterpolator2D ()
{
  return this->PositionInterpolator2D_;
}

void X3DGroupingNode::
PositionInterpolator2D (const PositionInterpolator2D_sequence& s)
{
  this->PositionInterpolator2D_ = s;
}

const X3DGroupingNode::StaticGroup_sequence& X3DGroupingNode::
StaticGroup () const
{
  return this->StaticGroup_;
}

X3DGroupingNode::StaticGroup_sequence& X3DGroupingNode::
StaticGroup ()
{
  return this->StaticGroup_;
}

void X3DGroupingNode::
StaticGroup (const StaticGroup_sequence& s)
{
  this->StaticGroup_ = s;
}

const X3DGroupingNode::CADAssembly_sequence& X3DGroupingNode::
CADAssembly () const
{
  return this->CADAssembly_;
}

X3DGroupingNode::CADAssembly_sequence& X3DGroupingNode::
CADAssembly ()
{
  return this->CADAssembly_;
}

void X3DGroupingNode::
CADAssembly (const CADAssembly_sequence& s)
{
  this->CADAssembly_ = s;
}

const X3DGroupingNode::CADLayer_sequence& X3DGroupingNode::
CADLayer () const
{
  return this->CADLayer_;
}

X3DGroupingNode::CADLayer_sequence& X3DGroupingNode::
CADLayer ()
{
  return this->CADLayer_;
}

void X3DGroupingNode::
CADLayer (const CADLayer_sequence& s)
{
  this->CADLayer_ = s;
}

const X3DGroupingNode::EspduTransform_sequence& X3DGroupingNode::
EspduTransform () const
{
  return this->EspduTransform_;
}

X3DGroupingNode::EspduTransform_sequence& X3DGroupingNode::
EspduTransform ()
{
  return this->EspduTransform_;
}

void X3DGroupingNode::
EspduTransform (const EspduTransform_sequence& s)
{
  this->EspduTransform_ = s;
}

const X3DGroupingNode::ReceiverPdu_sequence& X3DGroupingNode::
ReceiverPdu () const
{
  return this->ReceiverPdu_;
}

X3DGroupingNode::ReceiverPdu_sequence& X3DGroupingNode::
ReceiverPdu ()
{
  return this->ReceiverPdu_;
}

void X3DGroupingNode::
ReceiverPdu (const ReceiverPdu_sequence& s)
{
  this->ReceiverPdu_ = s;
}

const X3DGroupingNode::SignalPdu_sequence& X3DGroupingNode::
SignalPdu () const
{
  return this->SignalPdu_;
}

X3DGroupingNode::SignalPdu_sequence& X3DGroupingNode::
SignalPdu ()
{
  return this->SignalPdu_;
}

void X3DGroupingNode::
SignalPdu (const SignalPdu_sequence& s)
{
  this->SignalPdu_ = s;
}

const X3DGroupingNode::TransmitterPdu_sequence& X3DGroupingNode::
TransmitterPdu () const
{
  return this->TransmitterPdu_;
}

X3DGroupingNode::TransmitterPdu_sequence& X3DGroupingNode::
TransmitterPdu ()
{
  return this->TransmitterPdu_;
}

void X3DGroupingNode::
TransmitterPdu (const TransmitterPdu_sequence& s)
{
  this->TransmitterPdu_ = s;
}

const X3DGroupingNode::GeoLocation_sequence& X3DGroupingNode::
GeoLocation () const
{
  return this->GeoLocation_;
}

X3DGroupingNode::GeoLocation_sequence& X3DGroupingNode::
GeoLocation ()
{
  return this->GeoLocation_;
}

void X3DGroupingNode::
GeoLocation (const GeoLocation_sequence& s)
{
  this->GeoLocation_ = s;
}

const X3DGroupingNode::GeoLOD_sequence& X3DGroupingNode::
GeoLOD () const
{
  return this->GeoLOD_;
}

X3DGroupingNode::GeoLOD_sequence& X3DGroupingNode::
GeoLOD ()
{
  return this->GeoLOD_;
}

void X3DGroupingNode::
GeoLOD (const GeoLOD_sequence& s)
{
  this->GeoLOD_ = s;
}

const X3DGroupingNode::GeoMetadata_sequence& X3DGroupingNode::
GeoMetadata () const
{
  return this->GeoMetadata_;
}

X3DGroupingNode::GeoMetadata_sequence& X3DGroupingNode::
GeoMetadata ()
{
  return this->GeoMetadata_;
}

void X3DGroupingNode::
GeoMetadata (const GeoMetadata_sequence& s)
{
  this->GeoMetadata_ = s;
}

const X3DGroupingNode::GeoOrigin_sequence& X3DGroupingNode::
GeoOrigin () const
{
  return this->GeoOrigin_;
}

X3DGroupingNode::GeoOrigin_sequence& X3DGroupingNode::
GeoOrigin ()
{
  return this->GeoOrigin_;
}

void X3DGroupingNode::
GeoOrigin (const GeoOrigin_sequence& s)
{
  this->GeoOrigin_ = s;
}

const X3DGroupingNode::GeoPositionInterpolator_sequence& X3DGroupingNode::
GeoPositionInterpolator () const
{
  return this->GeoPositionInterpolator_;
}

X3DGroupingNode::GeoPositionInterpolator_sequence& X3DGroupingNode::
GeoPositionInterpolator ()
{
  return this->GeoPositionInterpolator_;
}

void X3DGroupingNode::
GeoPositionInterpolator (const GeoPositionInterpolator_sequence& s)
{
  this->GeoPositionInterpolator_ = s;
}

const X3DGroupingNode::GeoTouchSensor_sequence& X3DGroupingNode::
GeoTouchSensor () const
{
  return this->GeoTouchSensor_;
}

X3DGroupingNode::GeoTouchSensor_sequence& X3DGroupingNode::
GeoTouchSensor ()
{
  return this->GeoTouchSensor_;
}

void X3DGroupingNode::
GeoTouchSensor (const GeoTouchSensor_sequence& s)
{
  this->GeoTouchSensor_ = s;
}

const X3DGroupingNode::GeoViewpoint_sequence& X3DGroupingNode::
GeoViewpoint () const
{
  return this->GeoViewpoint_;
}

X3DGroupingNode::GeoViewpoint_sequence& X3DGroupingNode::
GeoViewpoint ()
{
  return this->GeoViewpoint_;
}

void X3DGroupingNode::
GeoViewpoint (const GeoViewpoint_sequence& s)
{
  this->GeoViewpoint_ = s;
}

const X3DGroupingNode::HAnimHumanoid_sequence& X3DGroupingNode::
HAnimHumanoid () const
{
  return this->HAnimHumanoid_;
}

X3DGroupingNode::HAnimHumanoid_sequence& X3DGroupingNode::
HAnimHumanoid ()
{
  return this->HAnimHumanoid_;
}

void X3DGroupingNode::
HAnimHumanoid (const HAnimHumanoid_sequence& s)
{
  this->HAnimHumanoid_ = s;
}

const X3DGroupingNode::HAnimJoint_sequence& X3DGroupingNode::
HAnimJoint () const
{
  return this->HAnimJoint_;
}

X3DGroupingNode::HAnimJoint_sequence& X3DGroupingNode::
HAnimJoint ()
{
  return this->HAnimJoint_;
}

void X3DGroupingNode::
HAnimJoint (const HAnimJoint_sequence& s)
{
  this->HAnimJoint_ = s;
}

const X3DGroupingNode::HAnimSegment_sequence& X3DGroupingNode::
HAnimSegment () const
{
  return this->HAnimSegment_;
}

X3DGroupingNode::HAnimSegment_sequence& X3DGroupingNode::
HAnimSegment ()
{
  return this->HAnimSegment_;
}

void X3DGroupingNode::
HAnimSegment (const HAnimSegment_sequence& s)
{
  this->HAnimSegment_ = s;
}

const X3DGroupingNode::HAnimSite_sequence& X3DGroupingNode::
HAnimSite () const
{
  return this->HAnimSite_;
}

X3DGroupingNode::HAnimSite_sequence& X3DGroupingNode::
HAnimSite ()
{
  return this->HAnimSite_;
}

void X3DGroupingNode::
HAnimSite (const HAnimSite_sequence& s)
{
  this->HAnimSite_ = s;
}

const X3DGroupingNode::NurbsOrientationInterpolator_sequence& X3DGroupingNode::
NurbsOrientationInterpolator () const
{
  return this->NurbsOrientationInterpolator_;
}

X3DGroupingNode::NurbsOrientationInterpolator_sequence& X3DGroupingNode::
NurbsOrientationInterpolator ()
{
  return this->NurbsOrientationInterpolator_;
}

void X3DGroupingNode::
NurbsOrientationInterpolator (const NurbsOrientationInterpolator_sequence& s)
{
  this->NurbsOrientationInterpolator_ = s;
}

const X3DGroupingNode::NurbsPositionInterpolator_sequence& X3DGroupingNode::
NurbsPositionInterpolator () const
{
  return this->NurbsPositionInterpolator_;
}

X3DGroupingNode::NurbsPositionInterpolator_sequence& X3DGroupingNode::
NurbsPositionInterpolator ()
{
  return this->NurbsPositionInterpolator_;
}

void X3DGroupingNode::
NurbsPositionInterpolator (const NurbsPositionInterpolator_sequence& s)
{
  this->NurbsPositionInterpolator_ = s;
}

const X3DGroupingNode::NurbsSurfaceInterpolator_sequence& X3DGroupingNode::
NurbsSurfaceInterpolator () const
{
  return this->NurbsSurfaceInterpolator_;
}

X3DGroupingNode::NurbsSurfaceInterpolator_sequence& X3DGroupingNode::
NurbsSurfaceInterpolator ()
{
  return this->NurbsSurfaceInterpolator_;
}

void X3DGroupingNode::
NurbsSurfaceInterpolator (const NurbsSurfaceInterpolator_sequence& s)
{
  this->NurbsSurfaceInterpolator_ = s;
}

const X3DGroupingNode::NurbsSet_sequence& X3DGroupingNode::
NurbsSet () const
{
  return this->NurbsSet_;
}

X3DGroupingNode::NurbsSet_sequence& X3DGroupingNode::
NurbsSet ()
{
  return this->NurbsSet_;
}

void X3DGroupingNode::
NurbsSet (const NurbsSet_sequence& s)
{
  this->NurbsSet_ = s;
}

const X3DGroupingNode::ProtoInstance_sequence& X3DGroupingNode::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

X3DGroupingNode::ProtoInstance_sequence& X3DGroupingNode::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void X3DGroupingNode::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const X3DGroupingNode::ROUTE_sequence& X3DGroupingNode::
ROUTE () const
{
  return this->ROUTE_;
}

X3DGroupingNode::ROUTE_sequence& X3DGroupingNode::
ROUTE ()
{
  return this->ROUTE_;
}

void X3DGroupingNode::
ROUTE (const ROUTE_sequence& s)
{
  this->ROUTE_ = s;
}

const X3DGroupingNode::ExternProtoDeclare_sequence& X3DGroupingNode::
ExternProtoDeclare () const
{
  return this->ExternProtoDeclare_;
}

X3DGroupingNode::ExternProtoDeclare_sequence& X3DGroupingNode::
ExternProtoDeclare ()
{
  return this->ExternProtoDeclare_;
}

void X3DGroupingNode::
ExternProtoDeclare (const ExternProtoDeclare_sequence& s)
{
  this->ExternProtoDeclare_ = s;
}

const X3DGroupingNode::ProtoDeclare_sequence& X3DGroupingNode::
ProtoDeclare () const
{
  return this->ProtoDeclare_;
}

X3DGroupingNode::ProtoDeclare_sequence& X3DGroupingNode::
ProtoDeclare ()
{
  return this->ProtoDeclare_;
}

void X3DGroupingNode::
ProtoDeclare (const ProtoDeclare_sequence& s)
{
  this->ProtoDeclare_ = s;
}

const X3DGroupingNode::IMPORT_sequence& X3DGroupingNode::
IMPORT () const
{
  return this->IMPORT_;
}

X3DGroupingNode::IMPORT_sequence& X3DGroupingNode::
IMPORT ()
{
  return this->IMPORT_;
}

void X3DGroupingNode::
IMPORT (const IMPORT_sequence& s)
{
  this->IMPORT_ = s;
}

const X3DGroupingNode::EXPORT_sequence& X3DGroupingNode::
EXPORT () const
{
  return this->EXPORT_;
}

X3DGroupingNode::EXPORT_sequence& X3DGroupingNode::
EXPORT ()
{
  return this->EXPORT_;
}

void X3DGroupingNode::
EXPORT (const EXPORT_sequence& s)
{
  this->EXPORT_ = s;
}

const X3DGroupingNode::bboxCenter_type& X3DGroupingNode::
bboxCenter () const
{
  return this->bboxCenter_.get ();
}

X3DGroupingNode::bboxCenter_type& X3DGroupingNode::
bboxCenter ()
{
  return this->bboxCenter_.get ();
}

void X3DGroupingNode::
bboxCenter (const bboxCenter_type& x)
{
  this->bboxCenter_.set (x);
}

void X3DGroupingNode::
bboxCenter (::std::auto_ptr< bboxCenter_type > x)
{
  this->bboxCenter_.set (x);
}

const X3DGroupingNode::bboxCenter_type& X3DGroupingNode::
bboxCenter_default_value ()
{
  return bboxCenter_default_value_;
}

const X3DGroupingNode::bboxSize_type& X3DGroupingNode::
bboxSize () const
{
  return this->bboxSize_.get ();
}

X3DGroupingNode::bboxSize_type& X3DGroupingNode::
bboxSize ()
{
  return this->bboxSize_.get ();
}

void X3DGroupingNode::
bboxSize (const bboxSize_type& x)
{
  this->bboxSize_.set (x);
}

void X3DGroupingNode::
bboxSize (::std::auto_ptr< bboxSize_type > x)
{
  this->bboxSize_.set (x);
}

const X3DGroupingNode::bboxSize_type& X3DGroupingNode::
bboxSize_default_value ()
{
  return bboxSize_default_value_;
}


// X3DHumanoidNode
// 


// X3DInfoNode
// 


// X3DInterpolatorNode
// 

const X3DInterpolatorNode::key_optional& X3DInterpolatorNode::
key () const
{
  return this->key_;
}

X3DInterpolatorNode::key_optional& X3DInterpolatorNode::
key ()
{
  return this->key_;
}

void X3DInterpolatorNode::
key (const key_type& x)
{
  this->key_.set (x);
}

void X3DInterpolatorNode::
key (const key_optional& x)
{
  this->key_ = x;
}

void X3DInterpolatorNode::
key (::std::auto_ptr< key_type > x)
{
  this->key_.set (x);
}


// X3DKeyDeviceSensorNode
// 


// X3DLightNode
// 

const X3DLightNode::ambientIntensity_type& X3DLightNode::
ambientIntensity () const
{
  return this->ambientIntensity_.get ();
}

X3DLightNode::ambientIntensity_type& X3DLightNode::
ambientIntensity ()
{
  return this->ambientIntensity_.get ();
}

void X3DLightNode::
ambientIntensity (const ambientIntensity_type& x)
{
  this->ambientIntensity_.set (x);
}

void X3DLightNode::
ambientIntensity (::std::auto_ptr< ambientIntensity_type > x)
{
  this->ambientIntensity_.set (x);
}

const X3DLightNode::ambientIntensity_type& X3DLightNode::
ambientIntensity_default_value ()
{
  return ambientIntensity_default_value_;
}

const X3DLightNode::color_type& X3DLightNode::
color () const
{
  return this->color_.get ();
}

X3DLightNode::color_type& X3DLightNode::
color ()
{
  return this->color_.get ();
}

void X3DLightNode::
color (const color_type& x)
{
  this->color_.set (x);
}

void X3DLightNode::
color (::std::auto_ptr< color_type > x)
{
  this->color_.set (x);
}

const X3DLightNode::color_type& X3DLightNode::
color_default_value ()
{
  return color_default_value_;
}

const X3DLightNode::intensity_type& X3DLightNode::
intensity () const
{
  return this->intensity_.get ();
}

X3DLightNode::intensity_type& X3DLightNode::
intensity ()
{
  return this->intensity_.get ();
}

void X3DLightNode::
intensity (const intensity_type& x)
{
  this->intensity_.set (x);
}

void X3DLightNode::
intensity (::std::auto_ptr< intensity_type > x)
{
  this->intensity_.set (x);
}

const X3DLightNode::intensity_type& X3DLightNode::
intensity_default_value ()
{
  return intensity_default_value_;
}

const X3DLightNode::on_type& X3DLightNode::
on () const
{
  return this->on_.get ();
}

X3DLightNode::on_type& X3DLightNode::
on ()
{
  return this->on_.get ();
}

void X3DLightNode::
on (const on_type& x)
{
  this->on_.set (x);
}

void X3DLightNode::
on (::std::auto_ptr< on_type > x)
{
  this->on_.set (x);
}

const X3DLightNode::on_type& X3DLightNode::
on_default_value ()
{
  return on_default_value_;
}


// X3DMaterialNode
// 

const X3DMaterialNode::containerField_type& X3DMaterialNode::
containerField () const
{
  return this->containerField_.get ();
}

X3DMaterialNode::containerField_type& X3DMaterialNode::
containerField ()
{
  return this->containerField_.get ();
}

void X3DMaterialNode::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void X3DMaterialNode::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const X3DMaterialNode::containerField_type& X3DMaterialNode::
containerField_default_value ()
{
  return containerField_default_value_;
}


// X3DMetadataObject
// 

const X3DMetadataObject::name_optional& X3DMetadataObject::
name () const
{
  return this->name_;
}

X3DMetadataObject::name_optional& X3DMetadataObject::
name ()
{
  return this->name_;
}

void X3DMetadataObject::
name (const name_type& x)
{
  this->name_.set (x);
}

void X3DMetadataObject::
name (const name_optional& x)
{
  this->name_ = x;
}

void X3DMetadataObject::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const X3DMetadataObject::reference_optional& X3DMetadataObject::
reference () const
{
  return this->reference_;
}

X3DMetadataObject::reference_optional& X3DMetadataObject::
reference ()
{
  return this->reference_;
}

void X3DMetadataObject::
reference (const reference_type& x)
{
  this->reference_.set (x);
}

void X3DMetadataObject::
reference (const reference_optional& x)
{
  this->reference_ = x;
}

void X3DMetadataObject::
reference (::std::auto_ptr< reference_type > x)
{
  this->reference_.set (x);
}

const X3DMetadataObject::containerField_type& X3DMetadataObject::
containerField () const
{
  return this->containerField_.get ();
}

X3DMetadataObject::containerField_type& X3DMetadataObject::
containerField ()
{
  return this->containerField_.get ();
}

void X3DMetadataObject::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void X3DMetadataObject::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const X3DMetadataObject::containerField_type& X3DMetadataObject::
containerField_default_value ()
{
  return containerField_default_value_;
}


// X3DNetworkSensorNode
// 

const X3DNetworkSensorNode::Anchor_sequence& X3DNetworkSensorNode::
Anchor () const
{
  return this->Anchor_;
}

X3DNetworkSensorNode::Anchor_sequence& X3DNetworkSensorNode::
Anchor ()
{
  return this->Anchor_;
}

void X3DNetworkSensorNode::
Anchor (const Anchor_sequence& s)
{
  this->Anchor_ = s;
}

const X3DNetworkSensorNode::AudioClip_sequence& X3DNetworkSensorNode::
AudioClip () const
{
  return this->AudioClip_;
}

X3DNetworkSensorNode::AudioClip_sequence& X3DNetworkSensorNode::
AudioClip ()
{
  return this->AudioClip_;
}

void X3DNetworkSensorNode::
AudioClip (const AudioClip_sequence& s)
{
  this->AudioClip_ = s;
}

const X3DNetworkSensorNode::GeoMetadata_sequence& X3DNetworkSensorNode::
GeoMetadata () const
{
  return this->GeoMetadata_;
}

X3DNetworkSensorNode::GeoMetadata_sequence& X3DNetworkSensorNode::
GeoMetadata ()
{
  return this->GeoMetadata_;
}

void X3DNetworkSensorNode::
GeoMetadata (const GeoMetadata_sequence& s)
{
  this->GeoMetadata_ = s;
}

const X3DNetworkSensorNode::ImageCubeMapTexture_sequence& X3DNetworkSensorNode::
ImageCubeMapTexture () const
{
  return this->ImageCubeMapTexture_;
}

X3DNetworkSensorNode::ImageCubeMapTexture_sequence& X3DNetworkSensorNode::
ImageCubeMapTexture ()
{
  return this->ImageCubeMapTexture_;
}

void X3DNetworkSensorNode::
ImageCubeMapTexture (const ImageCubeMapTexture_sequence& s)
{
  this->ImageCubeMapTexture_ = s;
}

const X3DNetworkSensorNode::ImageTexture_sequence& X3DNetworkSensorNode::
ImageTexture () const
{
  return this->ImageTexture_;
}

X3DNetworkSensorNode::ImageTexture_sequence& X3DNetworkSensorNode::
ImageTexture ()
{
  return this->ImageTexture_;
}

void X3DNetworkSensorNode::
ImageTexture (const ImageTexture_sequence& s)
{
  this->ImageTexture_ = s;
}

const X3DNetworkSensorNode::ImageTexture3D_sequence& X3DNetworkSensorNode::
ImageTexture3D () const
{
  return this->ImageTexture3D_;
}

X3DNetworkSensorNode::ImageTexture3D_sequence& X3DNetworkSensorNode::
ImageTexture3D ()
{
  return this->ImageTexture3D_;
}

void X3DNetworkSensorNode::
ImageTexture3D (const ImageTexture3D_sequence& s)
{
  this->ImageTexture3D_ = s;
}

const X3DNetworkSensorNode::Inline_sequence& X3DNetworkSensorNode::
Inline () const
{
  return this->Inline_;
}

X3DNetworkSensorNode::Inline_sequence& X3DNetworkSensorNode::
Inline ()
{
  return this->Inline_;
}

void X3DNetworkSensorNode::
Inline (const Inline_sequence& s)
{
  this->Inline_ = s;
}

const X3DNetworkSensorNode::MovieTexture_sequence& X3DNetworkSensorNode::
MovieTexture () const
{
  return this->MovieTexture_;
}

X3DNetworkSensorNode::MovieTexture_sequence& X3DNetworkSensorNode::
MovieTexture ()
{
  return this->MovieTexture_;
}

void X3DNetworkSensorNode::
MovieTexture (const MovieTexture_sequence& s)
{
  this->MovieTexture_ = s;
}

const X3DNetworkSensorNode::PackagedShader_sequence& X3DNetworkSensorNode::
PackagedShader () const
{
  return this->PackagedShader_;
}

X3DNetworkSensorNode::PackagedShader_sequence& X3DNetworkSensorNode::
PackagedShader ()
{
  return this->PackagedShader_;
}

void X3DNetworkSensorNode::
PackagedShader (const PackagedShader_sequence& s)
{
  this->PackagedShader_ = s;
}

const X3DNetworkSensorNode::ProtoInstance_sequence& X3DNetworkSensorNode::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

X3DNetworkSensorNode::ProtoInstance_sequence& X3DNetworkSensorNode::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void X3DNetworkSensorNode::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const X3DNetworkSensorNode::Script_sequence& X3DNetworkSensorNode::
Script () const
{
  return this->Script_;
}

X3DNetworkSensorNode::Script_sequence& X3DNetworkSensorNode::
Script ()
{
  return this->Script_;
}

void X3DNetworkSensorNode::
Script (const Script_sequence& s)
{
  this->Script_ = s;
}

const X3DNetworkSensorNode::ShaderPart_sequence& X3DNetworkSensorNode::
ShaderPart () const
{
  return this->ShaderPart_;
}

X3DNetworkSensorNode::ShaderPart_sequence& X3DNetworkSensorNode::
ShaderPart ()
{
  return this->ShaderPart_;
}

void X3DNetworkSensorNode::
ShaderPart (const ShaderPart_sequence& s)
{
  this->ShaderPart_ = s;
}

const X3DNetworkSensorNode::ShaderProgram_sequence& X3DNetworkSensorNode::
ShaderProgram () const
{
  return this->ShaderProgram_;
}

X3DNetworkSensorNode::ShaderProgram_sequence& X3DNetworkSensorNode::
ShaderProgram ()
{
  return this->ShaderProgram_;
}

void X3DNetworkSensorNode::
ShaderProgram (const ShaderProgram_sequence& s)
{
  this->ShaderProgram_ = s;
}


// X3DNormalNode
// 

const X3DNormalNode::containerField_type& X3DNormalNode::
containerField () const
{
  return this->containerField_.get ();
}

X3DNormalNode::containerField_type& X3DNormalNode::
containerField ()
{
  return this->containerField_.get ();
}

void X3DNormalNode::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void X3DNormalNode::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const X3DNormalNode::containerField_type& X3DNormalNode::
containerField_default_value ()
{
  return containerField_default_value_;
}


// X3DNurbsControlCurveNode
// 

const X3DNurbsControlCurveNode::controlPoint_optional& X3DNurbsControlCurveNode::
controlPoint () const
{
  return this->controlPoint_;
}

X3DNurbsControlCurveNode::controlPoint_optional& X3DNurbsControlCurveNode::
controlPoint ()
{
  return this->controlPoint_;
}

void X3DNurbsControlCurveNode::
controlPoint (const controlPoint_type& x)
{
  this->controlPoint_.set (x);
}

void X3DNurbsControlCurveNode::
controlPoint (const controlPoint_optional& x)
{
  this->controlPoint_ = x;
}

void X3DNurbsControlCurveNode::
controlPoint (::std::auto_ptr< controlPoint_type > x)
{
  this->controlPoint_.set (x);
}


// X3DParametricGeometryNode
// 


// X3DNurbsSurfaceGeometryNode
// 

const X3DNurbsSurfaceGeometryNode::uClosed_type& X3DNurbsSurfaceGeometryNode::
uClosed () const
{
  return this->uClosed_.get ();
}

X3DNurbsSurfaceGeometryNode::uClosed_type& X3DNurbsSurfaceGeometryNode::
uClosed ()
{
  return this->uClosed_.get ();
}

void X3DNurbsSurfaceGeometryNode::
uClosed (const uClosed_type& x)
{
  this->uClosed_.set (x);
}

void X3DNurbsSurfaceGeometryNode::
uClosed (::std::auto_ptr< uClosed_type > x)
{
  this->uClosed_.set (x);
}

const X3DNurbsSurfaceGeometryNode::uClosed_type& X3DNurbsSurfaceGeometryNode::
uClosed_default_value ()
{
  return uClosed_default_value_;
}

const X3DNurbsSurfaceGeometryNode::vClosed_type& X3DNurbsSurfaceGeometryNode::
vClosed () const
{
  return this->vClosed_.get ();
}

X3DNurbsSurfaceGeometryNode::vClosed_type& X3DNurbsSurfaceGeometryNode::
vClosed ()
{
  return this->vClosed_.get ();
}

void X3DNurbsSurfaceGeometryNode::
vClosed (const vClosed_type& x)
{
  this->vClosed_.set (x);
}

void X3DNurbsSurfaceGeometryNode::
vClosed (::std::auto_ptr< vClosed_type > x)
{
  this->vClosed_.set (x);
}

const X3DNurbsSurfaceGeometryNode::vClosed_type& X3DNurbsSurfaceGeometryNode::
vClosed_default_value ()
{
  return vClosed_default_value_;
}

const X3DNurbsSurfaceGeometryNode::uDimension_type& X3DNurbsSurfaceGeometryNode::
uDimension () const
{
  return this->uDimension_.get ();
}

X3DNurbsSurfaceGeometryNode::uDimension_type& X3DNurbsSurfaceGeometryNode::
uDimension ()
{
  return this->uDimension_.get ();
}

void X3DNurbsSurfaceGeometryNode::
uDimension (const uDimension_type& x)
{
  this->uDimension_.set (x);
}

void X3DNurbsSurfaceGeometryNode::
uDimension (::std::auto_ptr< uDimension_type > x)
{
  this->uDimension_.set (x);
}

const X3DNurbsSurfaceGeometryNode::uDimension_type& X3DNurbsSurfaceGeometryNode::
uDimension_default_value ()
{
  return uDimension_default_value_;
}

const X3DNurbsSurfaceGeometryNode::vDimension_type& X3DNurbsSurfaceGeometryNode::
vDimension () const
{
  return this->vDimension_.get ();
}

X3DNurbsSurfaceGeometryNode::vDimension_type& X3DNurbsSurfaceGeometryNode::
vDimension ()
{
  return this->vDimension_.get ();
}

void X3DNurbsSurfaceGeometryNode::
vDimension (const vDimension_type& x)
{
  this->vDimension_.set (x);
}

void X3DNurbsSurfaceGeometryNode::
vDimension (::std::auto_ptr< vDimension_type > x)
{
  this->vDimension_.set (x);
}

const X3DNurbsSurfaceGeometryNode::vDimension_type& X3DNurbsSurfaceGeometryNode::
vDimension_default_value ()
{
  return vDimension_default_value_;
}

const X3DNurbsSurfaceGeometryNode::uKnot_optional& X3DNurbsSurfaceGeometryNode::
uKnot () const
{
  return this->uKnot_;
}

X3DNurbsSurfaceGeometryNode::uKnot_optional& X3DNurbsSurfaceGeometryNode::
uKnot ()
{
  return this->uKnot_;
}

void X3DNurbsSurfaceGeometryNode::
uKnot (const uKnot_type& x)
{
  this->uKnot_.set (x);
}

void X3DNurbsSurfaceGeometryNode::
uKnot (const uKnot_optional& x)
{
  this->uKnot_ = x;
}

void X3DNurbsSurfaceGeometryNode::
uKnot (::std::auto_ptr< uKnot_type > x)
{
  this->uKnot_.set (x);
}

const X3DNurbsSurfaceGeometryNode::vKnot_optional& X3DNurbsSurfaceGeometryNode::
vKnot () const
{
  return this->vKnot_;
}

X3DNurbsSurfaceGeometryNode::vKnot_optional& X3DNurbsSurfaceGeometryNode::
vKnot ()
{
  return this->vKnot_;
}

void X3DNurbsSurfaceGeometryNode::
vKnot (const vKnot_type& x)
{
  this->vKnot_.set (x);
}

void X3DNurbsSurfaceGeometryNode::
vKnot (const vKnot_optional& x)
{
  this->vKnot_ = x;
}

void X3DNurbsSurfaceGeometryNode::
vKnot (::std::auto_ptr< vKnot_type > x)
{
  this->vKnot_.set (x);
}

const X3DNurbsSurfaceGeometryNode::uOrder_type& X3DNurbsSurfaceGeometryNode::
uOrder () const
{
  return this->uOrder_.get ();
}

X3DNurbsSurfaceGeometryNode::uOrder_type& X3DNurbsSurfaceGeometryNode::
uOrder ()
{
  return this->uOrder_.get ();
}

void X3DNurbsSurfaceGeometryNode::
uOrder (const uOrder_type& x)
{
  this->uOrder_.set (x);
}

void X3DNurbsSurfaceGeometryNode::
uOrder (::std::auto_ptr< uOrder_type > x)
{
  this->uOrder_.set (x);
}

const X3DNurbsSurfaceGeometryNode::uOrder_type& X3DNurbsSurfaceGeometryNode::
uOrder_default_value ()
{
  return uOrder_default_value_;
}

const X3DNurbsSurfaceGeometryNode::vOrder_type& X3DNurbsSurfaceGeometryNode::
vOrder () const
{
  return this->vOrder_.get ();
}

X3DNurbsSurfaceGeometryNode::vOrder_type& X3DNurbsSurfaceGeometryNode::
vOrder ()
{
  return this->vOrder_.get ();
}

void X3DNurbsSurfaceGeometryNode::
vOrder (const vOrder_type& x)
{
  this->vOrder_.set (x);
}

void X3DNurbsSurfaceGeometryNode::
vOrder (::std::auto_ptr< vOrder_type > x)
{
  this->vOrder_.set (x);
}

const X3DNurbsSurfaceGeometryNode::vOrder_type& X3DNurbsSurfaceGeometryNode::
vOrder_default_value ()
{
  return vOrder_default_value_;
}

const X3DNurbsSurfaceGeometryNode::uTessellation_type& X3DNurbsSurfaceGeometryNode::
uTessellation () const
{
  return this->uTessellation_.get ();
}

X3DNurbsSurfaceGeometryNode::uTessellation_type& X3DNurbsSurfaceGeometryNode::
uTessellation ()
{
  return this->uTessellation_.get ();
}

void X3DNurbsSurfaceGeometryNode::
uTessellation (const uTessellation_type& x)
{
  this->uTessellation_.set (x);
}

void X3DNurbsSurfaceGeometryNode::
uTessellation (::std::auto_ptr< uTessellation_type > x)
{
  this->uTessellation_.set (x);
}

const X3DNurbsSurfaceGeometryNode::uTessellation_type& X3DNurbsSurfaceGeometryNode::
uTessellation_default_value ()
{
  return uTessellation_default_value_;
}

const X3DNurbsSurfaceGeometryNode::vTessellation_type& X3DNurbsSurfaceGeometryNode::
vTessellation () const
{
  return this->vTessellation_.get ();
}

X3DNurbsSurfaceGeometryNode::vTessellation_type& X3DNurbsSurfaceGeometryNode::
vTessellation ()
{
  return this->vTessellation_.get ();
}

void X3DNurbsSurfaceGeometryNode::
vTessellation (const vTessellation_type& x)
{
  this->vTessellation_.set (x);
}

void X3DNurbsSurfaceGeometryNode::
vTessellation (::std::auto_ptr< vTessellation_type > x)
{
  this->vTessellation_.set (x);
}

const X3DNurbsSurfaceGeometryNode::vTessellation_type& X3DNurbsSurfaceGeometryNode::
vTessellation_default_value ()
{
  return vTessellation_default_value_;
}

const X3DNurbsSurfaceGeometryNode::weight_optional& X3DNurbsSurfaceGeometryNode::
weight () const
{
  return this->weight_;
}

X3DNurbsSurfaceGeometryNode::weight_optional& X3DNurbsSurfaceGeometryNode::
weight ()
{
  return this->weight_;
}

void X3DNurbsSurfaceGeometryNode::
weight (const weight_type& x)
{
  this->weight_.set (x);
}

void X3DNurbsSurfaceGeometryNode::
weight (const weight_optional& x)
{
  this->weight_ = x;
}

void X3DNurbsSurfaceGeometryNode::
weight (::std::auto_ptr< weight_type > x)
{
  this->weight_.set (x);
}

const X3DNurbsSurfaceGeometryNode::solid_type& X3DNurbsSurfaceGeometryNode::
solid () const
{
  return this->solid_.get ();
}

X3DNurbsSurfaceGeometryNode::solid_type& X3DNurbsSurfaceGeometryNode::
solid ()
{
  return this->solid_.get ();
}

void X3DNurbsSurfaceGeometryNode::
solid (const solid_type& x)
{
  this->solid_.set (x);
}

void X3DNurbsSurfaceGeometryNode::
solid (::std::auto_ptr< solid_type > x)
{
  this->solid_.set (x);
}

const X3DNurbsSurfaceGeometryNode::solid_type& X3DNurbsSurfaceGeometryNode::
solid_default_value ()
{
  return solid_default_value_;
}


// X3DProductStructureChildNode
// 


// X3DProgrammableShaderObject
// 


// X3DPrototypeInstanceNode
// 


// X3DScriptNode
// 

const X3DScriptNode::MetadataDouble_optional& X3DScriptNode::
MetadataDouble () const
{
  return this->MetadataDouble_;
}

X3DScriptNode::MetadataDouble_optional& X3DScriptNode::
MetadataDouble ()
{
  return this->MetadataDouble_;
}

void X3DScriptNode::
MetadataDouble (const MetadataDouble_type& x)
{
  this->MetadataDouble_.set (x);
}

void X3DScriptNode::
MetadataDouble (const MetadataDouble_optional& x)
{
  this->MetadataDouble_ = x;
}

void X3DScriptNode::
MetadataDouble (::std::auto_ptr< MetadataDouble_type > x)
{
  this->MetadataDouble_.set (x);
}

const X3DScriptNode::MetadataFloat_optional& X3DScriptNode::
MetadataFloat () const
{
  return this->MetadataFloat_;
}

X3DScriptNode::MetadataFloat_optional& X3DScriptNode::
MetadataFloat ()
{
  return this->MetadataFloat_;
}

void X3DScriptNode::
MetadataFloat (const MetadataFloat_type& x)
{
  this->MetadataFloat_.set (x);
}

void X3DScriptNode::
MetadataFloat (const MetadataFloat_optional& x)
{
  this->MetadataFloat_ = x;
}

void X3DScriptNode::
MetadataFloat (::std::auto_ptr< MetadataFloat_type > x)
{
  this->MetadataFloat_.set (x);
}

const X3DScriptNode::MetadataInteger_optional& X3DScriptNode::
MetadataInteger () const
{
  return this->MetadataInteger_;
}

X3DScriptNode::MetadataInteger_optional& X3DScriptNode::
MetadataInteger ()
{
  return this->MetadataInteger_;
}

void X3DScriptNode::
MetadataInteger (const MetadataInteger_type& x)
{
  this->MetadataInteger_.set (x);
}

void X3DScriptNode::
MetadataInteger (const MetadataInteger_optional& x)
{
  this->MetadataInteger_ = x;
}

void X3DScriptNode::
MetadataInteger (::std::auto_ptr< MetadataInteger_type > x)
{
  this->MetadataInteger_.set (x);
}

const X3DScriptNode::MetadataSet_optional& X3DScriptNode::
MetadataSet () const
{
  return this->MetadataSet_;
}

X3DScriptNode::MetadataSet_optional& X3DScriptNode::
MetadataSet ()
{
  return this->MetadataSet_;
}

void X3DScriptNode::
MetadataSet (const MetadataSet_type& x)
{
  this->MetadataSet_.set (x);
}

void X3DScriptNode::
MetadataSet (const MetadataSet_optional& x)
{
  this->MetadataSet_ = x;
}

void X3DScriptNode::
MetadataSet (::std::auto_ptr< MetadataSet_type > x)
{
  this->MetadataSet_.set (x);
}

const X3DScriptNode::MetadataString_optional& X3DScriptNode::
MetadataString () const
{
  return this->MetadataString_;
}

X3DScriptNode::MetadataString_optional& X3DScriptNode::
MetadataString ()
{
  return this->MetadataString_;
}

void X3DScriptNode::
MetadataString (const MetadataString_type& x)
{
  this->MetadataString_.set (x);
}

void X3DScriptNode::
MetadataString (const MetadataString_optional& x)
{
  this->MetadataString_ = x;
}

void X3DScriptNode::
MetadataString (::std::auto_ptr< MetadataString_type > x)
{
  this->MetadataString_.set (x);
}

const X3DScriptNode::field_sequence& X3DScriptNode::
field () const
{
  return this->field_;
}

X3DScriptNode::field_sequence& X3DScriptNode::
field ()
{
  return this->field_;
}

void X3DScriptNode::
field (const field_sequence& s)
{
  this->field_ = s;
}

const X3DScriptNode::IS_optional& X3DScriptNode::
IS () const
{
  return this->IS_;
}

X3DScriptNode::IS_optional& X3DScriptNode::
IS ()
{
  return this->IS_;
}

void X3DScriptNode::
IS (const IS_type& x)
{
  this->IS_.set (x);
}

void X3DScriptNode::
IS (const IS_optional& x)
{
  this->IS_ = x;
}

void X3DScriptNode::
IS (::std::auto_ptr< IS_type > x)
{
  this->IS_.set (x);
}

const X3DScriptNode::DEF_optional& X3DScriptNode::
DEF () const
{
  return this->DEF_;
}

X3DScriptNode::DEF_optional& X3DScriptNode::
DEF ()
{
  return this->DEF_;
}

void X3DScriptNode::
DEF (const DEF_type& x)
{
  this->DEF_.set (x);
}

void X3DScriptNode::
DEF (const DEF_optional& x)
{
  this->DEF_ = x;
}

void X3DScriptNode::
DEF (::std::auto_ptr< DEF_type > x)
{
  this->DEF_.set (x);
}

const X3DScriptNode::USE_optional& X3DScriptNode::
USE () const
{
  return this->USE_;
}

X3DScriptNode::USE_optional& X3DScriptNode::
USE ()
{
  return this->USE_;
}

void X3DScriptNode::
USE (const USE_type& x)
{
  this->USE_.set (x);
}

void X3DScriptNode::
USE (const USE_optional& x)
{
  this->USE_ = x;
}

void X3DScriptNode::
USE (::std::auto_ptr< USE_type > x)
{
  this->USE_.set (x);
}

const X3DScriptNode::class_optional& X3DScriptNode::
class_ () const
{
  return this->class__;
}

X3DScriptNode::class_optional& X3DScriptNode::
class_ ()
{
  return this->class__;
}

void X3DScriptNode::
class_ (const class_type& x)
{
  this->class__.set (x);
}

void X3DScriptNode::
class_ (const class_optional& x)
{
  this->class__ = x;
}

void X3DScriptNode::
class_ (::std::auto_ptr< class_type > x)
{
  this->class__.set (x);
}

const X3DScriptNode::containerField_type& X3DScriptNode::
containerField () const
{
  return this->containerField_.get ();
}

X3DScriptNode::containerField_type& X3DScriptNode::
containerField ()
{
  return this->containerField_.get ();
}

void X3DScriptNode::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void X3DScriptNode::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const X3DScriptNode::containerField_type& X3DScriptNode::
containerField_default_value ()
{
  return containerField_default_value_;
}


// X3DSequencerNode
// 

const X3DSequencerNode::key_optional& X3DSequencerNode::
key () const
{
  return this->key_;
}

X3DSequencerNode::key_optional& X3DSequencerNode::
key ()
{
  return this->key_;
}

void X3DSequencerNode::
key (const key_type& x)
{
  this->key_.set (x);
}

void X3DSequencerNode::
key (const key_optional& x)
{
  this->key_ = x;
}

void X3DSequencerNode::
key (::std::auto_ptr< key_type > x)
{
  this->key_.set (x);
}


// X3DShaderNode
// 

const X3DShaderNode::language_optional& X3DShaderNode::
language () const
{
  return this->language_;
}

X3DShaderNode::language_optional& X3DShaderNode::
language ()
{
  return this->language_;
}

void X3DShaderNode::
language (const language_type& x)
{
  this->language_.set (x);
}

void X3DShaderNode::
language (const language_optional& x)
{
  this->language_ = x;
}

void X3DShaderNode::
language (::std::auto_ptr< language_type > x)
{
  this->language_.set (x);
}

const X3DShaderNode::containerField_type& X3DShaderNode::
containerField () const
{
  return this->containerField_.get ();
}

X3DShaderNode::containerField_type& X3DShaderNode::
containerField ()
{
  return this->containerField_.get ();
}

void X3DShaderNode::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void X3DShaderNode::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const X3DShaderNode::containerField_type& X3DShaderNode::
containerField_default_value ()
{
  return containerField_default_value_;
}


// X3DShapeNode
// 

const X3DShapeNode::Appearance_optional& X3DShapeNode::
Appearance () const
{
  return this->Appearance_;
}

X3DShapeNode::Appearance_optional& X3DShapeNode::
Appearance ()
{
  return this->Appearance_;
}

void X3DShapeNode::
Appearance (const Appearance_type& x)
{
  this->Appearance_.set (x);
}

void X3DShapeNode::
Appearance (const Appearance_optional& x)
{
  this->Appearance_ = x;
}

void X3DShapeNode::
Appearance (::std::auto_ptr< Appearance_type > x)
{
  this->Appearance_.set (x);
}

const X3DShapeNode::Box_optional& X3DShapeNode::
Box () const
{
  return this->Box_;
}

X3DShapeNode::Box_optional& X3DShapeNode::
Box ()
{
  return this->Box_;
}

void X3DShapeNode::
Box (const Box_type& x)
{
  this->Box_.set (x);
}

void X3DShapeNode::
Box (const Box_optional& x)
{
  this->Box_ = x;
}

void X3DShapeNode::
Box (::std::auto_ptr< Box_type > x)
{
  this->Box_.set (x);
}

const X3DShapeNode::Cone_optional& X3DShapeNode::
Cone () const
{
  return this->Cone_;
}

X3DShapeNode::Cone_optional& X3DShapeNode::
Cone ()
{
  return this->Cone_;
}

void X3DShapeNode::
Cone (const Cone_type& x)
{
  this->Cone_.set (x);
}

void X3DShapeNode::
Cone (const Cone_optional& x)
{
  this->Cone_ = x;
}

void X3DShapeNode::
Cone (::std::auto_ptr< Cone_type > x)
{
  this->Cone_.set (x);
}

const X3DShapeNode::Cylinder_optional& X3DShapeNode::
Cylinder () const
{
  return this->Cylinder_;
}

X3DShapeNode::Cylinder_optional& X3DShapeNode::
Cylinder ()
{
  return this->Cylinder_;
}

void X3DShapeNode::
Cylinder (const Cylinder_type& x)
{
  this->Cylinder_.set (x);
}

void X3DShapeNode::
Cylinder (const Cylinder_optional& x)
{
  this->Cylinder_ = x;
}

void X3DShapeNode::
Cylinder (::std::auto_ptr< Cylinder_type > x)
{
  this->Cylinder_.set (x);
}

const X3DShapeNode::IndexedFaceSet_optional& X3DShapeNode::
IndexedFaceSet () const
{
  return this->IndexedFaceSet_;
}

X3DShapeNode::IndexedFaceSet_optional& X3DShapeNode::
IndexedFaceSet ()
{
  return this->IndexedFaceSet_;
}

void X3DShapeNode::
IndexedFaceSet (const IndexedFaceSet_type& x)
{
  this->IndexedFaceSet_.set (x);
}

void X3DShapeNode::
IndexedFaceSet (const IndexedFaceSet_optional& x)
{
  this->IndexedFaceSet_ = x;
}

void X3DShapeNode::
IndexedFaceSet (::std::auto_ptr< IndexedFaceSet_type > x)
{
  this->IndexedFaceSet_.set (x);
}

const X3DShapeNode::IndexedLineSet_optional& X3DShapeNode::
IndexedLineSet () const
{
  return this->IndexedLineSet_;
}

X3DShapeNode::IndexedLineSet_optional& X3DShapeNode::
IndexedLineSet ()
{
  return this->IndexedLineSet_;
}

void X3DShapeNode::
IndexedLineSet (const IndexedLineSet_type& x)
{
  this->IndexedLineSet_.set (x);
}

void X3DShapeNode::
IndexedLineSet (const IndexedLineSet_optional& x)
{
  this->IndexedLineSet_ = x;
}

void X3DShapeNode::
IndexedLineSet (::std::auto_ptr< IndexedLineSet_type > x)
{
  this->IndexedLineSet_.set (x);
}

const X3DShapeNode::IndexedTriangleFanSet_optional& X3DShapeNode::
IndexedTriangleFanSet () const
{
  return this->IndexedTriangleFanSet_;
}

X3DShapeNode::IndexedTriangleFanSet_optional& X3DShapeNode::
IndexedTriangleFanSet ()
{
  return this->IndexedTriangleFanSet_;
}

void X3DShapeNode::
IndexedTriangleFanSet (const IndexedTriangleFanSet_type& x)
{
  this->IndexedTriangleFanSet_.set (x);
}

void X3DShapeNode::
IndexedTriangleFanSet (const IndexedTriangleFanSet_optional& x)
{
  this->IndexedTriangleFanSet_ = x;
}

void X3DShapeNode::
IndexedTriangleFanSet (::std::auto_ptr< IndexedTriangleFanSet_type > x)
{
  this->IndexedTriangleFanSet_.set (x);
}

const X3DShapeNode::IndexedTriangleSet_optional& X3DShapeNode::
IndexedTriangleSet () const
{
  return this->IndexedTriangleSet_;
}

X3DShapeNode::IndexedTriangleSet_optional& X3DShapeNode::
IndexedTriangleSet ()
{
  return this->IndexedTriangleSet_;
}

void X3DShapeNode::
IndexedTriangleSet (const IndexedTriangleSet_type& x)
{
  this->IndexedTriangleSet_.set (x);
}

void X3DShapeNode::
IndexedTriangleSet (const IndexedTriangleSet_optional& x)
{
  this->IndexedTriangleSet_ = x;
}

void X3DShapeNode::
IndexedTriangleSet (::std::auto_ptr< IndexedTriangleSet_type > x)
{
  this->IndexedTriangleSet_.set (x);
}

const X3DShapeNode::IndexedTriangleStripSet_optional& X3DShapeNode::
IndexedTriangleStripSet () const
{
  return this->IndexedTriangleStripSet_;
}

X3DShapeNode::IndexedTriangleStripSet_optional& X3DShapeNode::
IndexedTriangleStripSet ()
{
  return this->IndexedTriangleStripSet_;
}

void X3DShapeNode::
IndexedTriangleStripSet (const IndexedTriangleStripSet_type& x)
{
  this->IndexedTriangleStripSet_.set (x);
}

void X3DShapeNode::
IndexedTriangleStripSet (const IndexedTriangleStripSet_optional& x)
{
  this->IndexedTriangleStripSet_ = x;
}

void X3DShapeNode::
IndexedTriangleStripSet (::std::auto_ptr< IndexedTriangleStripSet_type > x)
{
  this->IndexedTriangleStripSet_.set (x);
}

const X3DShapeNode::LineSet_optional& X3DShapeNode::
LineSet () const
{
  return this->LineSet_;
}

X3DShapeNode::LineSet_optional& X3DShapeNode::
LineSet ()
{
  return this->LineSet_;
}

void X3DShapeNode::
LineSet (const LineSet_type& x)
{
  this->LineSet_.set (x);
}

void X3DShapeNode::
LineSet (const LineSet_optional& x)
{
  this->LineSet_ = x;
}

void X3DShapeNode::
LineSet (::std::auto_ptr< LineSet_type > x)
{
  this->LineSet_.set (x);
}

const X3DShapeNode::PointSet_optional& X3DShapeNode::
PointSet () const
{
  return this->PointSet_;
}

X3DShapeNode::PointSet_optional& X3DShapeNode::
PointSet ()
{
  return this->PointSet_;
}

void X3DShapeNode::
PointSet (const PointSet_type& x)
{
  this->PointSet_.set (x);
}

void X3DShapeNode::
PointSet (const PointSet_optional& x)
{
  this->PointSet_ = x;
}

void X3DShapeNode::
PointSet (::std::auto_ptr< PointSet_type > x)
{
  this->PointSet_.set (x);
}

const X3DShapeNode::Sphere_optional& X3DShapeNode::
Sphere () const
{
  return this->Sphere_;
}

X3DShapeNode::Sphere_optional& X3DShapeNode::
Sphere ()
{
  return this->Sphere_;
}

void X3DShapeNode::
Sphere (const Sphere_type& x)
{
  this->Sphere_.set (x);
}

void X3DShapeNode::
Sphere (const Sphere_optional& x)
{
  this->Sphere_ = x;
}

void X3DShapeNode::
Sphere (::std::auto_ptr< Sphere_type > x)
{
  this->Sphere_.set (x);
}

const X3DShapeNode::TriangleFanSet_optional& X3DShapeNode::
TriangleFanSet () const
{
  return this->TriangleFanSet_;
}

X3DShapeNode::TriangleFanSet_optional& X3DShapeNode::
TriangleFanSet ()
{
  return this->TriangleFanSet_;
}

void X3DShapeNode::
TriangleFanSet (const TriangleFanSet_type& x)
{
  this->TriangleFanSet_.set (x);
}

void X3DShapeNode::
TriangleFanSet (const TriangleFanSet_optional& x)
{
  this->TriangleFanSet_ = x;
}

void X3DShapeNode::
TriangleFanSet (::std::auto_ptr< TriangleFanSet_type > x)
{
  this->TriangleFanSet_.set (x);
}

const X3DShapeNode::TriangleSet_optional& X3DShapeNode::
TriangleSet () const
{
  return this->TriangleSet_;
}

X3DShapeNode::TriangleSet_optional& X3DShapeNode::
TriangleSet ()
{
  return this->TriangleSet_;
}

void X3DShapeNode::
TriangleSet (const TriangleSet_type& x)
{
  this->TriangleSet_.set (x);
}

void X3DShapeNode::
TriangleSet (const TriangleSet_optional& x)
{
  this->TriangleSet_ = x;
}

void X3DShapeNode::
TriangleSet (::std::auto_ptr< TriangleSet_type > x)
{
  this->TriangleSet_.set (x);
}

const X3DShapeNode::TriangleStripSet_optional& X3DShapeNode::
TriangleStripSet () const
{
  return this->TriangleStripSet_;
}

X3DShapeNode::TriangleStripSet_optional& X3DShapeNode::
TriangleStripSet ()
{
  return this->TriangleStripSet_;
}

void X3DShapeNode::
TriangleStripSet (const TriangleStripSet_type& x)
{
  this->TriangleStripSet_.set (x);
}

void X3DShapeNode::
TriangleStripSet (const TriangleStripSet_optional& x)
{
  this->TriangleStripSet_ = x;
}

void X3DShapeNode::
TriangleStripSet (::std::auto_ptr< TriangleStripSet_type > x)
{
  this->TriangleStripSet_.set (x);
}

const X3DShapeNode::ElevationGrid_optional& X3DShapeNode::
ElevationGrid () const
{
  return this->ElevationGrid_;
}

X3DShapeNode::ElevationGrid_optional& X3DShapeNode::
ElevationGrid ()
{
  return this->ElevationGrid_;
}

void X3DShapeNode::
ElevationGrid (const ElevationGrid_type& x)
{
  this->ElevationGrid_.set (x);
}

void X3DShapeNode::
ElevationGrid (const ElevationGrid_optional& x)
{
  this->ElevationGrid_ = x;
}

void X3DShapeNode::
ElevationGrid (::std::auto_ptr< ElevationGrid_type > x)
{
  this->ElevationGrid_.set (x);
}

const X3DShapeNode::Polyline2D_optional& X3DShapeNode::
Polyline2D () const
{
  return this->Polyline2D_;
}

X3DShapeNode::Polyline2D_optional& X3DShapeNode::
Polyline2D ()
{
  return this->Polyline2D_;
}

void X3DShapeNode::
Polyline2D (const Polyline2D_type& x)
{
  this->Polyline2D_.set (x);
}

void X3DShapeNode::
Polyline2D (const Polyline2D_optional& x)
{
  this->Polyline2D_ = x;
}

void X3DShapeNode::
Polyline2D (::std::auto_ptr< Polyline2D_type > x)
{
  this->Polyline2D_.set (x);
}

const X3DShapeNode::Polypoint2D_optional& X3DShapeNode::
Polypoint2D () const
{
  return this->Polypoint2D_;
}

X3DShapeNode::Polypoint2D_optional& X3DShapeNode::
Polypoint2D ()
{
  return this->Polypoint2D_;
}

void X3DShapeNode::
Polypoint2D (const Polypoint2D_type& x)
{
  this->Polypoint2D_.set (x);
}

void X3DShapeNode::
Polypoint2D (const Polypoint2D_optional& x)
{
  this->Polypoint2D_ = x;
}

void X3DShapeNode::
Polypoint2D (::std::auto_ptr< Polypoint2D_type > x)
{
  this->Polypoint2D_.set (x);
}

const X3DShapeNode::Rectangle2D_optional& X3DShapeNode::
Rectangle2D () const
{
  return this->Rectangle2D_;
}

X3DShapeNode::Rectangle2D_optional& X3DShapeNode::
Rectangle2D ()
{
  return this->Rectangle2D_;
}

void X3DShapeNode::
Rectangle2D (const Rectangle2D_type& x)
{
  this->Rectangle2D_.set (x);
}

void X3DShapeNode::
Rectangle2D (const Rectangle2D_optional& x)
{
  this->Rectangle2D_ = x;
}

void X3DShapeNode::
Rectangle2D (::std::auto_ptr< Rectangle2D_type > x)
{
  this->Rectangle2D_.set (x);
}

const X3DShapeNode::TriangleSet2D_optional& X3DShapeNode::
TriangleSet2D () const
{
  return this->TriangleSet2D_;
}

X3DShapeNode::TriangleSet2D_optional& X3DShapeNode::
TriangleSet2D ()
{
  return this->TriangleSet2D_;
}

void X3DShapeNode::
TriangleSet2D (const TriangleSet2D_type& x)
{
  this->TriangleSet2D_.set (x);
}

void X3DShapeNode::
TriangleSet2D (const TriangleSet2D_optional& x)
{
  this->TriangleSet2D_ = x;
}

void X3DShapeNode::
TriangleSet2D (::std::auto_ptr< TriangleSet2D_type > x)
{
  this->TriangleSet2D_.set (x);
}

const X3DShapeNode::Extrusion_optional& X3DShapeNode::
Extrusion () const
{
  return this->Extrusion_;
}

X3DShapeNode::Extrusion_optional& X3DShapeNode::
Extrusion ()
{
  return this->Extrusion_;
}

void X3DShapeNode::
Extrusion (const Extrusion_type& x)
{
  this->Extrusion_.set (x);
}

void X3DShapeNode::
Extrusion (const Extrusion_optional& x)
{
  this->Extrusion_ = x;
}

void X3DShapeNode::
Extrusion (::std::auto_ptr< Extrusion_type > x)
{
  this->Extrusion_.set (x);
}

const X3DShapeNode::Text_optional& X3DShapeNode::
Text () const
{
  return this->Text_;
}

X3DShapeNode::Text_optional& X3DShapeNode::
Text ()
{
  return this->Text_;
}

void X3DShapeNode::
Text (const Text_type& x)
{
  this->Text_.set (x);
}

void X3DShapeNode::
Text (const Text_optional& x)
{
  this->Text_ = x;
}

void X3DShapeNode::
Text (::std::auto_ptr< Text_type > x)
{
  this->Text_.set (x);
}

const X3DShapeNode::Arc2D_optional& X3DShapeNode::
Arc2D () const
{
  return this->Arc2D_;
}

X3DShapeNode::Arc2D_optional& X3DShapeNode::
Arc2D ()
{
  return this->Arc2D_;
}

void X3DShapeNode::
Arc2D (const Arc2D_type& x)
{
  this->Arc2D_.set (x);
}

void X3DShapeNode::
Arc2D (const Arc2D_optional& x)
{
  this->Arc2D_ = x;
}

void X3DShapeNode::
Arc2D (::std::auto_ptr< Arc2D_type > x)
{
  this->Arc2D_.set (x);
}

const X3DShapeNode::ArcClose2D_optional& X3DShapeNode::
ArcClose2D () const
{
  return this->ArcClose2D_;
}

X3DShapeNode::ArcClose2D_optional& X3DShapeNode::
ArcClose2D ()
{
  return this->ArcClose2D_;
}

void X3DShapeNode::
ArcClose2D (const ArcClose2D_type& x)
{
  this->ArcClose2D_.set (x);
}

void X3DShapeNode::
ArcClose2D (const ArcClose2D_optional& x)
{
  this->ArcClose2D_ = x;
}

void X3DShapeNode::
ArcClose2D (::std::auto_ptr< ArcClose2D_type > x)
{
  this->ArcClose2D_.set (x);
}

const X3DShapeNode::Circle2D_optional& X3DShapeNode::
Circle2D () const
{
  return this->Circle2D_;
}

X3DShapeNode::Circle2D_optional& X3DShapeNode::
Circle2D ()
{
  return this->Circle2D_;
}

void X3DShapeNode::
Circle2D (const Circle2D_type& x)
{
  this->Circle2D_.set (x);
}

void X3DShapeNode::
Circle2D (const Circle2D_optional& x)
{
  this->Circle2D_ = x;
}

void X3DShapeNode::
Circle2D (::std::auto_ptr< Circle2D_type > x)
{
  this->Circle2D_.set (x);
}

const X3DShapeNode::Disk2D_optional& X3DShapeNode::
Disk2D () const
{
  return this->Disk2D_;
}

X3DShapeNode::Disk2D_optional& X3DShapeNode::
Disk2D ()
{
  return this->Disk2D_;
}

void X3DShapeNode::
Disk2D (const Disk2D_type& x)
{
  this->Disk2D_.set (x);
}

void X3DShapeNode::
Disk2D (const Disk2D_optional& x)
{
  this->Disk2D_ = x;
}

void X3DShapeNode::
Disk2D (::std::auto_ptr< Disk2D_type > x)
{
  this->Disk2D_.set (x);
}

const X3DShapeNode::QuadSet_optional& X3DShapeNode::
QuadSet () const
{
  return this->QuadSet_;
}

X3DShapeNode::QuadSet_optional& X3DShapeNode::
QuadSet ()
{
  return this->QuadSet_;
}

void X3DShapeNode::
QuadSet (const QuadSet_type& x)
{
  this->QuadSet_.set (x);
}

void X3DShapeNode::
QuadSet (const QuadSet_optional& x)
{
  this->QuadSet_ = x;
}

void X3DShapeNode::
QuadSet (::std::auto_ptr< QuadSet_type > x)
{
  this->QuadSet_.set (x);
}

const X3DShapeNode::IndexedQuadSet_optional& X3DShapeNode::
IndexedQuadSet () const
{
  return this->IndexedQuadSet_;
}

X3DShapeNode::IndexedQuadSet_optional& X3DShapeNode::
IndexedQuadSet ()
{
  return this->IndexedQuadSet_;
}

void X3DShapeNode::
IndexedQuadSet (const IndexedQuadSet_type& x)
{
  this->IndexedQuadSet_.set (x);
}

void X3DShapeNode::
IndexedQuadSet (const IndexedQuadSet_optional& x)
{
  this->IndexedQuadSet_ = x;
}

void X3DShapeNode::
IndexedQuadSet (::std::auto_ptr< IndexedQuadSet_type > x)
{
  this->IndexedQuadSet_.set (x);
}

const X3DShapeNode::GeoElevationGrid_optional& X3DShapeNode::
GeoElevationGrid () const
{
  return this->GeoElevationGrid_;
}

X3DShapeNode::GeoElevationGrid_optional& X3DShapeNode::
GeoElevationGrid ()
{
  return this->GeoElevationGrid_;
}

void X3DShapeNode::
GeoElevationGrid (const GeoElevationGrid_type& x)
{
  this->GeoElevationGrid_.set (x);
}

void X3DShapeNode::
GeoElevationGrid (const GeoElevationGrid_optional& x)
{
  this->GeoElevationGrid_ = x;
}

void X3DShapeNode::
GeoElevationGrid (::std::auto_ptr< GeoElevationGrid_type > x)
{
  this->GeoElevationGrid_.set (x);
}

const X3DShapeNode::NurbsCurve_optional& X3DShapeNode::
NurbsCurve () const
{
  return this->NurbsCurve_;
}

X3DShapeNode::NurbsCurve_optional& X3DShapeNode::
NurbsCurve ()
{
  return this->NurbsCurve_;
}

void X3DShapeNode::
NurbsCurve (const NurbsCurve_type& x)
{
  this->NurbsCurve_.set (x);
}

void X3DShapeNode::
NurbsCurve (const NurbsCurve_optional& x)
{
  this->NurbsCurve_ = x;
}

void X3DShapeNode::
NurbsCurve (::std::auto_ptr< NurbsCurve_type > x)
{
  this->NurbsCurve_.set (x);
}

const X3DShapeNode::NurbsCurve2D_optional& X3DShapeNode::
NurbsCurve2D () const
{
  return this->NurbsCurve2D_;
}

X3DShapeNode::NurbsCurve2D_optional& X3DShapeNode::
NurbsCurve2D ()
{
  return this->NurbsCurve2D_;
}

void X3DShapeNode::
NurbsCurve2D (const NurbsCurve2D_type& x)
{
  this->NurbsCurve2D_.set (x);
}

void X3DShapeNode::
NurbsCurve2D (const NurbsCurve2D_optional& x)
{
  this->NurbsCurve2D_ = x;
}

void X3DShapeNode::
NurbsCurve2D (::std::auto_ptr< NurbsCurve2D_type > x)
{
  this->NurbsCurve2D_.set (x);
}

const X3DShapeNode::NurbsPatchSurface_optional& X3DShapeNode::
NurbsPatchSurface () const
{
  return this->NurbsPatchSurface_;
}

X3DShapeNode::NurbsPatchSurface_optional& X3DShapeNode::
NurbsPatchSurface ()
{
  return this->NurbsPatchSurface_;
}

void X3DShapeNode::
NurbsPatchSurface (const NurbsPatchSurface_type& x)
{
  this->NurbsPatchSurface_.set (x);
}

void X3DShapeNode::
NurbsPatchSurface (const NurbsPatchSurface_optional& x)
{
  this->NurbsPatchSurface_ = x;
}

void X3DShapeNode::
NurbsPatchSurface (::std::auto_ptr< NurbsPatchSurface_type > x)
{
  this->NurbsPatchSurface_.set (x);
}

const X3DShapeNode::NurbsSweptSurface_optional& X3DShapeNode::
NurbsSweptSurface () const
{
  return this->NurbsSweptSurface_;
}

X3DShapeNode::NurbsSweptSurface_optional& X3DShapeNode::
NurbsSweptSurface ()
{
  return this->NurbsSweptSurface_;
}

void X3DShapeNode::
NurbsSweptSurface (const NurbsSweptSurface_type& x)
{
  this->NurbsSweptSurface_.set (x);
}

void X3DShapeNode::
NurbsSweptSurface (const NurbsSweptSurface_optional& x)
{
  this->NurbsSweptSurface_ = x;
}

void X3DShapeNode::
NurbsSweptSurface (::std::auto_ptr< NurbsSweptSurface_type > x)
{
  this->NurbsSweptSurface_.set (x);
}

const X3DShapeNode::NurbsSwungSurface_optional& X3DShapeNode::
NurbsSwungSurface () const
{
  return this->NurbsSwungSurface_;
}

X3DShapeNode::NurbsSwungSurface_optional& X3DShapeNode::
NurbsSwungSurface ()
{
  return this->NurbsSwungSurface_;
}

void X3DShapeNode::
NurbsSwungSurface (const NurbsSwungSurface_type& x)
{
  this->NurbsSwungSurface_.set (x);
}

void X3DShapeNode::
NurbsSwungSurface (const NurbsSwungSurface_optional& x)
{
  this->NurbsSwungSurface_ = x;
}

void X3DShapeNode::
NurbsSwungSurface (::std::auto_ptr< NurbsSwungSurface_type > x)
{
  this->NurbsSwungSurface_.set (x);
}

const X3DShapeNode::NurbsTrimmedSurface_optional& X3DShapeNode::
NurbsTrimmedSurface () const
{
  return this->NurbsTrimmedSurface_;
}

X3DShapeNode::NurbsTrimmedSurface_optional& X3DShapeNode::
NurbsTrimmedSurface ()
{
  return this->NurbsTrimmedSurface_;
}

void X3DShapeNode::
NurbsTrimmedSurface (const NurbsTrimmedSurface_type& x)
{
  this->NurbsTrimmedSurface_.set (x);
}

void X3DShapeNode::
NurbsTrimmedSurface (const NurbsTrimmedSurface_optional& x)
{
  this->NurbsTrimmedSurface_ = x;
}

void X3DShapeNode::
NurbsTrimmedSurface (::std::auto_ptr< NurbsTrimmedSurface_type > x)
{
  this->NurbsTrimmedSurface_.set (x);
}

const X3DShapeNode::ProtoInstance_sequence& X3DShapeNode::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

X3DShapeNode::ProtoInstance_sequence& X3DShapeNode::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void X3DShapeNode::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const X3DShapeNode::bboxCenter_type& X3DShapeNode::
bboxCenter () const
{
  return this->bboxCenter_.get ();
}

X3DShapeNode::bboxCenter_type& X3DShapeNode::
bboxCenter ()
{
  return this->bboxCenter_.get ();
}

void X3DShapeNode::
bboxCenter (const bboxCenter_type& x)
{
  this->bboxCenter_.set (x);
}

void X3DShapeNode::
bboxCenter (::std::auto_ptr< bboxCenter_type > x)
{
  this->bboxCenter_.set (x);
}

const X3DShapeNode::bboxCenter_type& X3DShapeNode::
bboxCenter_default_value ()
{
  return bboxCenter_default_value_;
}

const X3DShapeNode::bboxSize_type& X3DShapeNode::
bboxSize () const
{
  return this->bboxSize_.get ();
}

X3DShapeNode::bboxSize_type& X3DShapeNode::
bboxSize ()
{
  return this->bboxSize_.get ();
}

void X3DShapeNode::
bboxSize (const bboxSize_type& x)
{
  this->bboxSize_.set (x);
}

void X3DShapeNode::
bboxSize (::std::auto_ptr< bboxSize_type > x)
{
  this->bboxSize_.set (x);
}

const X3DShapeNode::bboxSize_type& X3DShapeNode::
bboxSize_default_value ()
{
  return bboxSize_default_value_;
}


// X3DSoundNode
// 

const X3DSoundNode::AudioClip_optional& X3DSoundNode::
AudioClip () const
{
  return this->AudioClip_;
}

X3DSoundNode::AudioClip_optional& X3DSoundNode::
AudioClip ()
{
  return this->AudioClip_;
}

void X3DSoundNode::
AudioClip (const AudioClip_type& x)
{
  this->AudioClip_.set (x);
}

void X3DSoundNode::
AudioClip (const AudioClip_optional& x)
{
  this->AudioClip_ = x;
}

void X3DSoundNode::
AudioClip (::std::auto_ptr< AudioClip_type > x)
{
  this->AudioClip_.set (x);
}

const X3DSoundNode::MovieTexture_optional& X3DSoundNode::
MovieTexture () const
{
  return this->MovieTexture_;
}

X3DSoundNode::MovieTexture_optional& X3DSoundNode::
MovieTexture ()
{
  return this->MovieTexture_;
}

void X3DSoundNode::
MovieTexture (const MovieTexture_type& x)
{
  this->MovieTexture_.set (x);
}

void X3DSoundNode::
MovieTexture (const MovieTexture_optional& x)
{
  this->MovieTexture_ = x;
}

void X3DSoundNode::
MovieTexture (::std::auto_ptr< MovieTexture_type > x)
{
  this->MovieTexture_.set (x);
}

const X3DSoundNode::ProtoInstance_optional& X3DSoundNode::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

X3DSoundNode::ProtoInstance_optional& X3DSoundNode::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void X3DSoundNode::
ProtoInstance (const ProtoInstance_type& x)
{
  this->ProtoInstance_.set (x);
}

void X3DSoundNode::
ProtoInstance (const ProtoInstance_optional& x)
{
  this->ProtoInstance_ = x;
}

void X3DSoundNode::
ProtoInstance (::std::auto_ptr< ProtoInstance_type > x)
{
  this->ProtoInstance_.set (x);
}


// X3DTimeDependentNode
// 

const X3DTimeDependentNode::loop_type& X3DTimeDependentNode::
loop () const
{
  return this->loop_.get ();
}

X3DTimeDependentNode::loop_type& X3DTimeDependentNode::
loop ()
{
  return this->loop_.get ();
}

void X3DTimeDependentNode::
loop (const loop_type& x)
{
  this->loop_.set (x);
}

void X3DTimeDependentNode::
loop (::std::auto_ptr< loop_type > x)
{
  this->loop_.set (x);
}

const X3DTimeDependentNode::loop_type& X3DTimeDependentNode::
loop_default_value ()
{
  return loop_default_value_;
}

const X3DTimeDependentNode::pauseTime_type& X3DTimeDependentNode::
pauseTime () const
{
  return this->pauseTime_.get ();
}

X3DTimeDependentNode::pauseTime_type& X3DTimeDependentNode::
pauseTime ()
{
  return this->pauseTime_.get ();
}

void X3DTimeDependentNode::
pauseTime (const pauseTime_type& x)
{
  this->pauseTime_.set (x);
}

void X3DTimeDependentNode::
pauseTime (::std::auto_ptr< pauseTime_type > x)
{
  this->pauseTime_.set (x);
}

const X3DTimeDependentNode::pauseTime_type& X3DTimeDependentNode::
pauseTime_default_value ()
{
  return pauseTime_default_value_;
}

const X3DTimeDependentNode::resumeTime_type& X3DTimeDependentNode::
resumeTime () const
{
  return this->resumeTime_.get ();
}

X3DTimeDependentNode::resumeTime_type& X3DTimeDependentNode::
resumeTime ()
{
  return this->resumeTime_.get ();
}

void X3DTimeDependentNode::
resumeTime (const resumeTime_type& x)
{
  this->resumeTime_.set (x);
}

void X3DTimeDependentNode::
resumeTime (::std::auto_ptr< resumeTime_type > x)
{
  this->resumeTime_.set (x);
}

const X3DTimeDependentNode::resumeTime_type& X3DTimeDependentNode::
resumeTime_default_value ()
{
  return resumeTime_default_value_;
}

const X3DTimeDependentNode::startTime_type& X3DTimeDependentNode::
startTime () const
{
  return this->startTime_.get ();
}

X3DTimeDependentNode::startTime_type& X3DTimeDependentNode::
startTime ()
{
  return this->startTime_.get ();
}

void X3DTimeDependentNode::
startTime (const startTime_type& x)
{
  this->startTime_.set (x);
}

void X3DTimeDependentNode::
startTime (::std::auto_ptr< startTime_type > x)
{
  this->startTime_.set (x);
}

const X3DTimeDependentNode::startTime_type& X3DTimeDependentNode::
startTime_default_value ()
{
  return startTime_default_value_;
}

const X3DTimeDependentNode::stopTime_type& X3DTimeDependentNode::
stopTime () const
{
  return this->stopTime_.get ();
}

X3DTimeDependentNode::stopTime_type& X3DTimeDependentNode::
stopTime ()
{
  return this->stopTime_.get ();
}

void X3DTimeDependentNode::
stopTime (const stopTime_type& x)
{
  this->stopTime_.set (x);
}

void X3DTimeDependentNode::
stopTime (::std::auto_ptr< stopTime_type > x)
{
  this->stopTime_.set (x);
}

const X3DTimeDependentNode::stopTime_type& X3DTimeDependentNode::
stopTime_default_value ()
{
  return stopTime_default_value_;
}


// X3DSoundSourceNode
// 

const X3DSoundSourceNode::pitch_type& X3DSoundSourceNode::
pitch () const
{
  return this->pitch_.get ();
}

X3DSoundSourceNode::pitch_type& X3DSoundSourceNode::
pitch ()
{
  return this->pitch_.get ();
}

void X3DSoundSourceNode::
pitch (const pitch_type& x)
{
  this->pitch_.set (x);
}

void X3DSoundSourceNode::
pitch (::std::auto_ptr< pitch_type > x)
{
  this->pitch_.set (x);
}

const X3DSoundSourceNode::pitch_type& X3DSoundSourceNode::
pitch_default_value ()
{
  return pitch_default_value_;
}


// X3DTextureNode
// 

const X3DTextureNode::containerField_type& X3DTextureNode::
containerField () const
{
  return this->containerField_.get ();
}

X3DTextureNode::containerField_type& X3DTextureNode::
containerField ()
{
  return this->containerField_.get ();
}

void X3DTextureNode::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void X3DTextureNode::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const X3DTextureNode::containerField_type& X3DTextureNode::
containerField_default_value ()
{
  return containerField_default_value_;
}


// X3DTexture2DNode
// 

const X3DTexture2DNode::repeatS_type& X3DTexture2DNode::
repeatS () const
{
  return this->repeatS_.get ();
}

X3DTexture2DNode::repeatS_type& X3DTexture2DNode::
repeatS ()
{
  return this->repeatS_.get ();
}

void X3DTexture2DNode::
repeatS (const repeatS_type& x)
{
  this->repeatS_.set (x);
}

void X3DTexture2DNode::
repeatS (::std::auto_ptr< repeatS_type > x)
{
  this->repeatS_.set (x);
}

const X3DTexture2DNode::repeatS_type& X3DTexture2DNode::
repeatS_default_value ()
{
  return repeatS_default_value_;
}

const X3DTexture2DNode::repeatT_type& X3DTexture2DNode::
repeatT () const
{
  return this->repeatT_.get ();
}

X3DTexture2DNode::repeatT_type& X3DTexture2DNode::
repeatT ()
{
  return this->repeatT_.get ();
}

void X3DTexture2DNode::
repeatT (const repeatT_type& x)
{
  this->repeatT_.set (x);
}

void X3DTexture2DNode::
repeatT (::std::auto_ptr< repeatT_type > x)
{
  this->repeatT_.set (x);
}

const X3DTexture2DNode::repeatT_type& X3DTexture2DNode::
repeatT_default_value ()
{
  return repeatT_default_value_;
}


// X3DTexture3DNode
// 

const X3DTexture3DNode::repeatS_type& X3DTexture3DNode::
repeatS () const
{
  return this->repeatS_.get ();
}

X3DTexture3DNode::repeatS_type& X3DTexture3DNode::
repeatS ()
{
  return this->repeatS_.get ();
}

void X3DTexture3DNode::
repeatS (const repeatS_type& x)
{
  this->repeatS_.set (x);
}

void X3DTexture3DNode::
repeatS (::std::auto_ptr< repeatS_type > x)
{
  this->repeatS_.set (x);
}

const X3DTexture3DNode::repeatS_type& X3DTexture3DNode::
repeatS_default_value ()
{
  return repeatS_default_value_;
}

const X3DTexture3DNode::repeatT_type& X3DTexture3DNode::
repeatT () const
{
  return this->repeatT_.get ();
}

X3DTexture3DNode::repeatT_type& X3DTexture3DNode::
repeatT ()
{
  return this->repeatT_.get ();
}

void X3DTexture3DNode::
repeatT (const repeatT_type& x)
{
  this->repeatT_.set (x);
}

void X3DTexture3DNode::
repeatT (::std::auto_ptr< repeatT_type > x)
{
  this->repeatT_.set (x);
}

const X3DTexture3DNode::repeatT_type& X3DTexture3DNode::
repeatT_default_value ()
{
  return repeatT_default_value_;
}

const X3DTexture3DNode::repeatR_type& X3DTexture3DNode::
repeatR () const
{
  return this->repeatR_.get ();
}

X3DTexture3DNode::repeatR_type& X3DTexture3DNode::
repeatR ()
{
  return this->repeatR_.get ();
}

void X3DTexture3DNode::
repeatR (const repeatR_type& x)
{
  this->repeatR_.set (x);
}

void X3DTexture3DNode::
repeatR (::std::auto_ptr< repeatR_type > x)
{
  this->repeatR_.set (x);
}

const X3DTexture3DNode::repeatR_type& X3DTexture3DNode::
repeatR_default_value ()
{
  return repeatR_default_value_;
}


// X3DTextureCoordinateNode
// 

const X3DTextureCoordinateNode::containerField_type& X3DTextureCoordinateNode::
containerField () const
{
  return this->containerField_.get ();
}

X3DTextureCoordinateNode::containerField_type& X3DTextureCoordinateNode::
containerField ()
{
  return this->containerField_.get ();
}

void X3DTextureCoordinateNode::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void X3DTextureCoordinateNode::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const X3DTextureCoordinateNode::containerField_type& X3DTextureCoordinateNode::
containerField_default_value ()
{
  return containerField_default_value_;
}


// X3DTextureTransformNode
// 

const X3DTextureTransformNode::containerField_type& X3DTextureTransformNode::
containerField () const
{
  return this->containerField_.get ();
}

X3DTextureTransformNode::containerField_type& X3DTextureTransformNode::
containerField ()
{
  return this->containerField_.get ();
}

void X3DTextureTransformNode::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void X3DTextureTransformNode::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const X3DTextureTransformNode::containerField_type& X3DTextureTransformNode::
containerField_default_value ()
{
  return containerField_default_value_;
}


// X3DTextureTransform2DNode
// 

const X3DTextureTransform2DNode::center_type& X3DTextureTransform2DNode::
center () const
{
  return this->center_.get ();
}

X3DTextureTransform2DNode::center_type& X3DTextureTransform2DNode::
center ()
{
  return this->center_.get ();
}

void X3DTextureTransform2DNode::
center (const center_type& x)
{
  this->center_.set (x);
}

void X3DTextureTransform2DNode::
center (::std::auto_ptr< center_type > x)
{
  this->center_.set (x);
}

const X3DTextureTransform2DNode::center_type& X3DTextureTransform2DNode::
center_default_value ()
{
  return center_default_value_;
}

const X3DTextureTransform2DNode::rotation_type& X3DTextureTransform2DNode::
rotation () const
{
  return this->rotation_.get ();
}

X3DTextureTransform2DNode::rotation_type& X3DTextureTransform2DNode::
rotation ()
{
  return this->rotation_.get ();
}

void X3DTextureTransform2DNode::
rotation (const rotation_type& x)
{
  this->rotation_.set (x);
}

void X3DTextureTransform2DNode::
rotation (::std::auto_ptr< rotation_type > x)
{
  this->rotation_.set (x);
}

const X3DTextureTransform2DNode::rotation_type& X3DTextureTransform2DNode::
rotation_default_value ()
{
  return rotation_default_value_;
}

const X3DTextureTransform2DNode::scale_type& X3DTextureTransform2DNode::
scale () const
{
  return this->scale_.get ();
}

X3DTextureTransform2DNode::scale_type& X3DTextureTransform2DNode::
scale ()
{
  return this->scale_.get ();
}

void X3DTextureTransform2DNode::
scale (const scale_type& x)
{
  this->scale_.set (x);
}

void X3DTextureTransform2DNode::
scale (::std::auto_ptr< scale_type > x)
{
  this->scale_.set (x);
}

const X3DTextureTransform2DNode::scale_type& X3DTextureTransform2DNode::
scale_default_value ()
{
  return scale_default_value_;
}

const X3DTextureTransform2DNode::translation_type& X3DTextureTransform2DNode::
translation () const
{
  return this->translation_.get ();
}

X3DTextureTransform2DNode::translation_type& X3DTextureTransform2DNode::
translation ()
{
  return this->translation_.get ();
}

void X3DTextureTransform2DNode::
translation (const translation_type& x)
{
  this->translation_.set (x);
}

void X3DTextureTransform2DNode::
translation (::std::auto_ptr< translation_type > x)
{
  this->translation_.set (x);
}

const X3DTextureTransform2DNode::translation_type& X3DTextureTransform2DNode::
translation_default_value ()
{
  return translation_default_value_;
}


// X3DTouchSensorNode
// 


// X3DTriggerNode
// 


// X3DUrlObject
// 

const X3DUrlObject::url_optional& X3DUrlObject::
url () const
{
  return this->url_;
}

X3DUrlObject::url_optional& X3DUrlObject::
url ()
{
  return this->url_;
}

void X3DUrlObject::
url (const url_type& x)
{
  this->url_.set (x);
}

void X3DUrlObject::
url (const url_optional& x)
{
  this->url_ = x;
}

void X3DUrlObject::
url (::std::auto_ptr< url_type > x)
{
  this->url_.set (x);
}


// X3DVertexAttributeNode
// 

const X3DVertexAttributeNode::name_optional& X3DVertexAttributeNode::
name () const
{
  return this->name_;
}

X3DVertexAttributeNode::name_optional& X3DVertexAttributeNode::
name ()
{
  return this->name_;
}

void X3DVertexAttributeNode::
name (const name_type& x)
{
  this->name_.set (x);
}

void X3DVertexAttributeNode::
name (const name_optional& x)
{
  this->name_ = x;
}

void X3DVertexAttributeNode::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const X3DVertexAttributeNode::containerField_type& X3DVertexAttributeNode::
containerField () const
{
  return this->containerField_.get ();
}

X3DVertexAttributeNode::containerField_type& X3DVertexAttributeNode::
containerField ()
{
  return this->containerField_.get ();
}

void X3DVertexAttributeNode::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void X3DVertexAttributeNode::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const X3DVertexAttributeNode::containerField_type& X3DVertexAttributeNode::
containerField_default_value ()
{
  return containerField_default_value_;
}


// SceneGraphStructureNodeType
// 


// X3DPrototype
// 

const X3DPrototype::name_type& X3DPrototype::
name () const
{
  return this->name_.get ();
}

X3DPrototype::name_type& X3DPrototype::
name ()
{
  return this->name_.get ();
}

void X3DPrototype::
name (const name_type& x)
{
  this->name_.set (x);
}

void X3DPrototype::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}


// WildcardNodeType
// 


// geoSystemType
// 


// jointName
// 

jointName::
jointName (value v)
: ::xml_schema::string (_xsd_jointName_literals_[v])
{
}

jointName::
jointName (const char* v)
: ::xml_schema::string (v)
{
}

jointName::
jointName (const ::std::string& v)
: ::xml_schema::string (v)
{
}

jointName::
jointName (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

jointName::
jointName (const jointName& v,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

jointName& jointName::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_jointName_literals_[v]);

  return *this;
}


// ambientIntensity
// 


// intensity
// 


// Anchor
// 

const Anchor::description_optional& Anchor::
description () const
{
  return this->description_;
}

Anchor::description_optional& Anchor::
description ()
{
  return this->description_;
}

void Anchor::
description (const description_type& x)
{
  this->description_.set (x);
}

void Anchor::
description (const description_optional& x)
{
  this->description_ = x;
}

void Anchor::
description (::std::auto_ptr< description_type > x)
{
  this->description_.set (x);
}

const Anchor::parameter_optional& Anchor::
parameter () const
{
  return this->parameter_;
}

Anchor::parameter_optional& Anchor::
parameter ()
{
  return this->parameter_;
}

void Anchor::
parameter (const parameter_type& x)
{
  this->parameter_.set (x);
}

void Anchor::
parameter (const parameter_optional& x)
{
  this->parameter_ = x;
}

void Anchor::
parameter (::std::auto_ptr< parameter_type > x)
{
  this->parameter_.set (x);
}

const Anchor::url_optional& Anchor::
url () const
{
  return this->url_;
}

Anchor::url_optional& Anchor::
url ()
{
  return this->url_;
}

void Anchor::
url (const url_type& x)
{
  this->url_.set (x);
}

void Anchor::
url (const url_optional& x)
{
  this->url_ = x;
}

void Anchor::
url (::std::auto_ptr< url_type > x)
{
  this->url_.set (x);
}


// Appearance
// 


// Arc2D
// 

const Arc2D::radius_type& Arc2D::
radius () const
{
  return this->radius_.get ();
}

Arc2D::radius_type& Arc2D::
radius ()
{
  return this->radius_.get ();
}

void Arc2D::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void Arc2D::
radius (::std::auto_ptr< radius_type > x)
{
  this->radius_.set (x);
}

const Arc2D::radius_type& Arc2D::
radius_default_value ()
{
  return radius_default_value_;
}

const Arc2D::startAngle_type& Arc2D::
startAngle () const
{
  return this->startAngle_.get ();
}

Arc2D::startAngle_type& Arc2D::
startAngle ()
{
  return this->startAngle_.get ();
}

void Arc2D::
startAngle (const startAngle_type& x)
{
  this->startAngle_.set (x);
}

void Arc2D::
startAngle (::std::auto_ptr< startAngle_type > x)
{
  this->startAngle_.set (x);
}

const Arc2D::startAngle_type& Arc2D::
startAngle_default_value ()
{
  return startAngle_default_value_;
}

const Arc2D::endAngle_type& Arc2D::
endAngle () const
{
  return this->endAngle_.get ();
}

Arc2D::endAngle_type& Arc2D::
endAngle ()
{
  return this->endAngle_.get ();
}

void Arc2D::
endAngle (const endAngle_type& x)
{
  this->endAngle_.set (x);
}

void Arc2D::
endAngle (::std::auto_ptr< endAngle_type > x)
{
  this->endAngle_.set (x);
}

const Arc2D::endAngle_type& Arc2D::
endAngle_default_value ()
{
  return endAngle_default_value_;
}


// ArcClose2D
// 

const ArcClose2D::radius_type& ArcClose2D::
radius () const
{
  return this->radius_.get ();
}

ArcClose2D::radius_type& ArcClose2D::
radius ()
{
  return this->radius_.get ();
}

void ArcClose2D::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void ArcClose2D::
radius (::std::auto_ptr< radius_type > x)
{
  this->radius_.set (x);
}

const ArcClose2D::radius_type& ArcClose2D::
radius_default_value ()
{
  return radius_default_value_;
}

const ArcClose2D::startAngle_type& ArcClose2D::
startAngle () const
{
  return this->startAngle_.get ();
}

ArcClose2D::startAngle_type& ArcClose2D::
startAngle ()
{
  return this->startAngle_.get ();
}

void ArcClose2D::
startAngle (const startAngle_type& x)
{
  this->startAngle_.set (x);
}

void ArcClose2D::
startAngle (::std::auto_ptr< startAngle_type > x)
{
  this->startAngle_.set (x);
}

const ArcClose2D::startAngle_type& ArcClose2D::
startAngle_default_value ()
{
  return startAngle_default_value_;
}

const ArcClose2D::endAngle_type& ArcClose2D::
endAngle () const
{
  return this->endAngle_.get ();
}

ArcClose2D::endAngle_type& ArcClose2D::
endAngle ()
{
  return this->endAngle_.get ();
}

void ArcClose2D::
endAngle (const endAngle_type& x)
{
  this->endAngle_.set (x);
}

void ArcClose2D::
endAngle (::std::auto_ptr< endAngle_type > x)
{
  this->endAngle_.set (x);
}

const ArcClose2D::endAngle_type& ArcClose2D::
endAngle_default_value ()
{
  return endAngle_default_value_;
}

const ArcClose2D::closureType_type& ArcClose2D::
closureType () const
{
  return this->closureType_.get ();
}

ArcClose2D::closureType_type& ArcClose2D::
closureType ()
{
  return this->closureType_.get ();
}

void ArcClose2D::
closureType (const closureType_type& x)
{
  this->closureType_.set (x);
}

void ArcClose2D::
closureType (::std::auto_ptr< closureType_type > x)
{
  this->closureType_.set (x);
}

const ArcClose2D::closureType_type& ArcClose2D::
closureType_default_value ()
{
  return closureType_default_value_;
}

const ArcClose2D::solid_type& ArcClose2D::
solid () const
{
  return this->solid_.get ();
}

ArcClose2D::solid_type& ArcClose2D::
solid ()
{
  return this->solid_.get ();
}

void ArcClose2D::
solid (const solid_type& x)
{
  this->solid_.set (x);
}

void ArcClose2D::
solid (::std::auto_ptr< solid_type > x)
{
  this->solid_.set (x);
}

const ArcClose2D::solid_type& ArcClose2D::
solid_default_value ()
{
  return solid_default_value_;
}


// AudioClip
// 

const AudioClip::description_optional& AudioClip::
description () const
{
  return this->description_;
}

AudioClip::description_optional& AudioClip::
description ()
{
  return this->description_;
}

void AudioClip::
description (const description_type& x)
{
  this->description_.set (x);
}

void AudioClip::
description (const description_optional& x)
{
  this->description_ = x;
}

void AudioClip::
description (::std::auto_ptr< description_type > x)
{
  this->description_.set (x);
}

const AudioClip::url_optional& AudioClip::
url () const
{
  return this->url_;
}

AudioClip::url_optional& AudioClip::
url ()
{
  return this->url_;
}

void AudioClip::
url (const url_type& x)
{
  this->url_.set (x);
}

void AudioClip::
url (const url_optional& x)
{
  this->url_ = x;
}

void AudioClip::
url (::std::auto_ptr< url_type > x)
{
  this->url_.set (x);
}


// Background
// 

const Background::backUrl_optional& Background::
backUrl () const
{
  return this->backUrl_;
}

Background::backUrl_optional& Background::
backUrl ()
{
  return this->backUrl_;
}

void Background::
backUrl (const backUrl_type& x)
{
  this->backUrl_.set (x);
}

void Background::
backUrl (const backUrl_optional& x)
{
  this->backUrl_ = x;
}

void Background::
backUrl (::std::auto_ptr< backUrl_type > x)
{
  this->backUrl_.set (x);
}

const Background::bottomUrl_optional& Background::
bottomUrl () const
{
  return this->bottomUrl_;
}

Background::bottomUrl_optional& Background::
bottomUrl ()
{
  return this->bottomUrl_;
}

void Background::
bottomUrl (const bottomUrl_type& x)
{
  this->bottomUrl_.set (x);
}

void Background::
bottomUrl (const bottomUrl_optional& x)
{
  this->bottomUrl_ = x;
}

void Background::
bottomUrl (::std::auto_ptr< bottomUrl_type > x)
{
  this->bottomUrl_.set (x);
}

const Background::frontUrl_optional& Background::
frontUrl () const
{
  return this->frontUrl_;
}

Background::frontUrl_optional& Background::
frontUrl ()
{
  return this->frontUrl_;
}

void Background::
frontUrl (const frontUrl_type& x)
{
  this->frontUrl_.set (x);
}

void Background::
frontUrl (const frontUrl_optional& x)
{
  this->frontUrl_ = x;
}

void Background::
frontUrl (::std::auto_ptr< frontUrl_type > x)
{
  this->frontUrl_.set (x);
}

const Background::leftUrl_optional& Background::
leftUrl () const
{
  return this->leftUrl_;
}

Background::leftUrl_optional& Background::
leftUrl ()
{
  return this->leftUrl_;
}

void Background::
leftUrl (const leftUrl_type& x)
{
  this->leftUrl_.set (x);
}

void Background::
leftUrl (const leftUrl_optional& x)
{
  this->leftUrl_ = x;
}

void Background::
leftUrl (::std::auto_ptr< leftUrl_type > x)
{
  this->leftUrl_.set (x);
}

const Background::rightUrl_optional& Background::
rightUrl () const
{
  return this->rightUrl_;
}

Background::rightUrl_optional& Background::
rightUrl ()
{
  return this->rightUrl_;
}

void Background::
rightUrl (const rightUrl_type& x)
{
  this->rightUrl_.set (x);
}

void Background::
rightUrl (const rightUrl_optional& x)
{
  this->rightUrl_ = x;
}

void Background::
rightUrl (::std::auto_ptr< rightUrl_type > x)
{
  this->rightUrl_.set (x);
}

const Background::topUrl_optional& Background::
topUrl () const
{
  return this->topUrl_;
}

Background::topUrl_optional& Background::
topUrl ()
{
  return this->topUrl_;
}

void Background::
topUrl (const topUrl_type& x)
{
  this->topUrl_.set (x);
}

void Background::
topUrl (const topUrl_optional& x)
{
  this->topUrl_ = x;
}

void Background::
topUrl (::std::auto_ptr< topUrl_type > x)
{
  this->topUrl_.set (x);
}


// Billboard
// 

const Billboard::axisOfRotation_type& Billboard::
axisOfRotation () const
{
  return this->axisOfRotation_.get ();
}

Billboard::axisOfRotation_type& Billboard::
axisOfRotation ()
{
  return this->axisOfRotation_.get ();
}

void Billboard::
axisOfRotation (const axisOfRotation_type& x)
{
  this->axisOfRotation_.set (x);
}

void Billboard::
axisOfRotation (::std::auto_ptr< axisOfRotation_type > x)
{
  this->axisOfRotation_.set (x);
}

const Billboard::axisOfRotation_type& Billboard::
axisOfRotation_default_value ()
{
  return axisOfRotation_default_value_;
}


// BooleanFilter
// 


// BooleanSequencer
// 

const BooleanSequencer::keyValue_optional& BooleanSequencer::
keyValue () const
{
  return this->keyValue_;
}

BooleanSequencer::keyValue_optional& BooleanSequencer::
keyValue ()
{
  return this->keyValue_;
}

void BooleanSequencer::
keyValue (const keyValue_type& x)
{
  this->keyValue_.set (x);
}

void BooleanSequencer::
keyValue (const keyValue_optional& x)
{
  this->keyValue_ = x;
}

void BooleanSequencer::
keyValue (::std::auto_ptr< keyValue_type > x)
{
  this->keyValue_.set (x);
}


// BooleanToggle
// 

const BooleanToggle::toggle_type& BooleanToggle::
toggle () const
{
  return this->toggle_.get ();
}

BooleanToggle::toggle_type& BooleanToggle::
toggle ()
{
  return this->toggle_.get ();
}

void BooleanToggle::
toggle (const toggle_type& x)
{
  this->toggle_.set (x);
}

void BooleanToggle::
toggle (::std::auto_ptr< toggle_type > x)
{
  this->toggle_.set (x);
}

const BooleanToggle::toggle_type& BooleanToggle::
toggle_default_value ()
{
  return toggle_default_value_;
}


// BooleanTrigger
// 


// Box
// 

const Box::size_type& Box::
size () const
{
  return this->size_.get ();
}

Box::size_type& Box::
size ()
{
  return this->size_.get ();
}

void Box::
size (const size_type& x)
{
  this->size_.set (x);
}

void Box::
size (::std::auto_ptr< size_type > x)
{
  this->size_.set (x);
}

const Box::size_type& Box::
size_default_value ()
{
  return size_default_value_;
}

const Box::solid_type& Box::
solid () const
{
  return this->solid_.get ();
}

Box::solid_type& Box::
solid ()
{
  return this->solid_.get ();
}

void Box::
solid (const solid_type& x)
{
  this->solid_.set (x);
}

void Box::
solid (::std::auto_ptr< solid_type > x)
{
  this->solid_.set (x);
}

const Box::solid_type& Box::
solid_default_value ()
{
  return solid_default_value_;
}


// Circle2D
// 

const Circle2D::radius_type& Circle2D::
radius () const
{
  return this->radius_.get ();
}

Circle2D::radius_type& Circle2D::
radius ()
{
  return this->radius_.get ();
}

void Circle2D::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void Circle2D::
radius (::std::auto_ptr< radius_type > x)
{
  this->radius_.set (x);
}

const Circle2D::radius_type& Circle2D::
radius_default_value ()
{
  return radius_default_value_;
}


// Collision
// 

const Collision::enabled_type& Collision::
enabled () const
{
  return this->enabled_.get ();
}

Collision::enabled_type& Collision::
enabled ()
{
  return this->enabled_.get ();
}

void Collision::
enabled (const enabled_type& x)
{
  this->enabled_.set (x);
}

void Collision::
enabled (::std::auto_ptr< enabled_type > x)
{
  this->enabled_.set (x);
}

const Collision::enabled_type& Collision::
enabled_default_value ()
{
  return enabled_default_value_;
}


// Color
// 

const Color::color_optional& Color::
color () const
{
  return this->color_;
}

Color::color_optional& Color::
color ()
{
  return this->color_;
}

void Color::
color (const color_type& x)
{
  this->color_.set (x);
}

void Color::
color (const color_optional& x)
{
  this->color_ = x;
}

void Color::
color (::std::auto_ptr< color_type > x)
{
  this->color_.set (x);
}


// ColorRGBA
// 

const ColorRGBA::color_optional& ColorRGBA::
color () const
{
  return this->color_;
}

ColorRGBA::color_optional& ColorRGBA::
color ()
{
  return this->color_;
}

void ColorRGBA::
color (const color_type& x)
{
  this->color_.set (x);
}

void ColorRGBA::
color (const color_optional& x)
{
  this->color_ = x;
}

void ColorRGBA::
color (::std::auto_ptr< color_type > x)
{
  this->color_.set (x);
}


// ColorInterpolator
// 

const ColorInterpolator::keyValue_optional& ColorInterpolator::
keyValue () const
{
  return this->keyValue_;
}

ColorInterpolator::keyValue_optional& ColorInterpolator::
keyValue ()
{
  return this->keyValue_;
}

void ColorInterpolator::
keyValue (const keyValue_type& x)
{
  this->keyValue_.set (x);
}

void ColorInterpolator::
keyValue (const keyValue_optional& x)
{
  this->keyValue_ = x;
}

void ColorInterpolator::
keyValue (::std::auto_ptr< keyValue_type > x)
{
  this->keyValue_.set (x);
}


// Cone
// 

const Cone::bottomRadius_type& Cone::
bottomRadius () const
{
  return this->bottomRadius_.get ();
}

Cone::bottomRadius_type& Cone::
bottomRadius ()
{
  return this->bottomRadius_.get ();
}

void Cone::
bottomRadius (const bottomRadius_type& x)
{
  this->bottomRadius_.set (x);
}

void Cone::
bottomRadius (::std::auto_ptr< bottomRadius_type > x)
{
  this->bottomRadius_.set (x);
}

const Cone::bottomRadius_type& Cone::
bottomRadius_default_value ()
{
  return bottomRadius_default_value_;
}

const Cone::height_type& Cone::
height () const
{
  return this->height_.get ();
}

Cone::height_type& Cone::
height ()
{
  return this->height_.get ();
}

void Cone::
height (const height_type& x)
{
  this->height_.set (x);
}

void Cone::
height (::std::auto_ptr< height_type > x)
{
  this->height_.set (x);
}

const Cone::height_type& Cone::
height_default_value ()
{
  return height_default_value_;
}

const Cone::side_type& Cone::
side () const
{
  return this->side_.get ();
}

Cone::side_type& Cone::
side ()
{
  return this->side_.get ();
}

void Cone::
side (const side_type& x)
{
  this->side_.set (x);
}

void Cone::
side (::std::auto_ptr< side_type > x)
{
  this->side_.set (x);
}

const Cone::side_type& Cone::
side_default_value ()
{
  return side_default_value_;
}

const Cone::bottom_type& Cone::
bottom () const
{
  return this->bottom_.get ();
}

Cone::bottom_type& Cone::
bottom ()
{
  return this->bottom_.get ();
}

void Cone::
bottom (const bottom_type& x)
{
  this->bottom_.set (x);
}

void Cone::
bottom (::std::auto_ptr< bottom_type > x)
{
  this->bottom_.set (x);
}

const Cone::bottom_type& Cone::
bottom_default_value ()
{
  return bottom_default_value_;
}

const Cone::solid_type& Cone::
solid () const
{
  return this->solid_.get ();
}

Cone::solid_type& Cone::
solid ()
{
  return this->solid_.get ();
}

void Cone::
solid (const solid_type& x)
{
  this->solid_.set (x);
}

void Cone::
solid (::std::auto_ptr< solid_type > x)
{
  this->solid_.set (x);
}

const Cone::solid_type& Cone::
solid_default_value ()
{
  return solid_default_value_;
}


// Coordinate
// 

const Coordinate::point_optional& Coordinate::
point () const
{
  return this->point_;
}

Coordinate::point_optional& Coordinate::
point ()
{
  return this->point_;
}

void Coordinate::
point (const point_type& x)
{
  this->point_.set (x);
}

void Coordinate::
point (const point_optional& x)
{
  this->point_ = x;
}

void Coordinate::
point (::std::auto_ptr< point_type > x)
{
  this->point_.set (x);
}

const Coordinate::containerField_type& Coordinate::
containerField () const
{
  return this->containerField_.get ();
}

Coordinate::containerField_type& Coordinate::
containerField ()
{
  return this->containerField_.get ();
}

void Coordinate::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void Coordinate::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const Coordinate::containerField_type& Coordinate::
containerField_default_value ()
{
  return containerField_default_value_;
}


// CoordinateDouble
// 

const CoordinateDouble::point_optional& CoordinateDouble::
point () const
{
  return this->point_;
}

CoordinateDouble::point_optional& CoordinateDouble::
point ()
{
  return this->point_;
}

void CoordinateDouble::
point (const point_type& x)
{
  this->point_.set (x);
}

void CoordinateDouble::
point (const point_optional& x)
{
  this->point_ = x;
}

void CoordinateDouble::
point (::std::auto_ptr< point_type > x)
{
  this->point_.set (x);
}

const CoordinateDouble::containerField_type& CoordinateDouble::
containerField () const
{
  return this->containerField_.get ();
}

CoordinateDouble::containerField_type& CoordinateDouble::
containerField ()
{
  return this->containerField_.get ();
}

void CoordinateDouble::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void CoordinateDouble::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const CoordinateDouble::containerField_type& CoordinateDouble::
containerField_default_value ()
{
  return containerField_default_value_;
}


// CoordinateInterpolator
// 

const CoordinateInterpolator::keyValue_optional& CoordinateInterpolator::
keyValue () const
{
  return this->keyValue_;
}

CoordinateInterpolator::keyValue_optional& CoordinateInterpolator::
keyValue ()
{
  return this->keyValue_;
}

void CoordinateInterpolator::
keyValue (const keyValue_type& x)
{
  this->keyValue_.set (x);
}

void CoordinateInterpolator::
keyValue (const keyValue_optional& x)
{
  this->keyValue_ = x;
}

void CoordinateInterpolator::
keyValue (::std::auto_ptr< keyValue_type > x)
{
  this->keyValue_.set (x);
}


// CoordinateInterpolator2D
// 

const CoordinateInterpolator2D::keyValue_optional& CoordinateInterpolator2D::
keyValue () const
{
  return this->keyValue_;
}

CoordinateInterpolator2D::keyValue_optional& CoordinateInterpolator2D::
keyValue ()
{
  return this->keyValue_;
}

void CoordinateInterpolator2D::
keyValue (const keyValue_type& x)
{
  this->keyValue_.set (x);
}

void CoordinateInterpolator2D::
keyValue (const keyValue_optional& x)
{
  this->keyValue_ = x;
}

void CoordinateInterpolator2D::
keyValue (::std::auto_ptr< keyValue_type > x)
{
  this->keyValue_.set (x);
}


// Cylinder
// 

const Cylinder::bottom_type& Cylinder::
bottom () const
{
  return this->bottom_.get ();
}

Cylinder::bottom_type& Cylinder::
bottom ()
{
  return this->bottom_.get ();
}

void Cylinder::
bottom (const bottom_type& x)
{
  this->bottom_.set (x);
}

void Cylinder::
bottom (::std::auto_ptr< bottom_type > x)
{
  this->bottom_.set (x);
}

const Cylinder::bottom_type& Cylinder::
bottom_default_value ()
{
  return bottom_default_value_;
}

const Cylinder::height_type& Cylinder::
height () const
{
  return this->height_.get ();
}

Cylinder::height_type& Cylinder::
height ()
{
  return this->height_.get ();
}

void Cylinder::
height (const height_type& x)
{
  this->height_.set (x);
}

void Cylinder::
height (::std::auto_ptr< height_type > x)
{
  this->height_.set (x);
}

const Cylinder::height_type& Cylinder::
height_default_value ()
{
  return height_default_value_;
}

const Cylinder::radius_type& Cylinder::
radius () const
{
  return this->radius_.get ();
}

Cylinder::radius_type& Cylinder::
radius ()
{
  return this->radius_.get ();
}

void Cylinder::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void Cylinder::
radius (::std::auto_ptr< radius_type > x)
{
  this->radius_.set (x);
}

const Cylinder::radius_type& Cylinder::
radius_default_value ()
{
  return radius_default_value_;
}

const Cylinder::side_type& Cylinder::
side () const
{
  return this->side_.get ();
}

Cylinder::side_type& Cylinder::
side ()
{
  return this->side_.get ();
}

void Cylinder::
side (const side_type& x)
{
  this->side_.set (x);
}

void Cylinder::
side (::std::auto_ptr< side_type > x)
{
  this->side_.set (x);
}

const Cylinder::side_type& Cylinder::
side_default_value ()
{
  return side_default_value_;
}

const Cylinder::top_type& Cylinder::
top () const
{
  return this->top_.get ();
}

Cylinder::top_type& Cylinder::
top ()
{
  return this->top_.get ();
}

void Cylinder::
top (const top_type& x)
{
  this->top_.set (x);
}

void Cylinder::
top (::std::auto_ptr< top_type > x)
{
  this->top_.set (x);
}

const Cylinder::top_type& Cylinder::
top_default_value ()
{
  return top_default_value_;
}

const Cylinder::solid_type& Cylinder::
solid () const
{
  return this->solid_.get ();
}

Cylinder::solid_type& Cylinder::
solid ()
{
  return this->solid_.get ();
}

void Cylinder::
solid (const solid_type& x)
{
  this->solid_.set (x);
}

void Cylinder::
solid (::std::auto_ptr< solid_type > x)
{
  this->solid_.set (x);
}

const Cylinder::solid_type& Cylinder::
solid_default_value ()
{
  return solid_default_value_;
}


// CylinderSensor
// 

const CylinderSensor::diskAngle_type& CylinderSensor::
diskAngle () const
{
  return this->diskAngle_.get ();
}

CylinderSensor::diskAngle_type& CylinderSensor::
diskAngle ()
{
  return this->diskAngle_.get ();
}

void CylinderSensor::
diskAngle (const diskAngle_type& x)
{
  this->diskAngle_.set (x);
}

void CylinderSensor::
diskAngle (::std::auto_ptr< diskAngle_type > x)
{
  this->diskAngle_.set (x);
}

const CylinderSensor::diskAngle_type& CylinderSensor::
diskAngle_default_value ()
{
  return diskAngle_default_value_;
}

const CylinderSensor::maxAngle_type& CylinderSensor::
maxAngle () const
{
  return this->maxAngle_.get ();
}

CylinderSensor::maxAngle_type& CylinderSensor::
maxAngle ()
{
  return this->maxAngle_.get ();
}

void CylinderSensor::
maxAngle (const maxAngle_type& x)
{
  this->maxAngle_.set (x);
}

void CylinderSensor::
maxAngle (::std::auto_ptr< maxAngle_type > x)
{
  this->maxAngle_.set (x);
}

const CylinderSensor::maxAngle_type& CylinderSensor::
maxAngle_default_value ()
{
  return maxAngle_default_value_;
}

const CylinderSensor::minAngle_type& CylinderSensor::
minAngle () const
{
  return this->minAngle_.get ();
}

CylinderSensor::minAngle_type& CylinderSensor::
minAngle ()
{
  return this->minAngle_.get ();
}

void CylinderSensor::
minAngle (const minAngle_type& x)
{
  this->minAngle_.set (x);
}

void CylinderSensor::
minAngle (::std::auto_ptr< minAngle_type > x)
{
  this->minAngle_.set (x);
}

const CylinderSensor::minAngle_type& CylinderSensor::
minAngle_default_value ()
{
  return minAngle_default_value_;
}

const CylinderSensor::offset_type& CylinderSensor::
offset () const
{
  return this->offset_.get ();
}

CylinderSensor::offset_type& CylinderSensor::
offset ()
{
  return this->offset_.get ();
}

void CylinderSensor::
offset (const offset_type& x)
{
  this->offset_.set (x);
}

void CylinderSensor::
offset (::std::auto_ptr< offset_type > x)
{
  this->offset_.set (x);
}

const CylinderSensor::offset_type& CylinderSensor::
offset_default_value ()
{
  return offset_default_value_;
}


// DirectionalLight
// 

const DirectionalLight::direction_type& DirectionalLight::
direction () const
{
  return this->direction_.get ();
}

DirectionalLight::direction_type& DirectionalLight::
direction ()
{
  return this->direction_.get ();
}

void DirectionalLight::
direction (const direction_type& x)
{
  this->direction_.set (x);
}

void DirectionalLight::
direction (::std::auto_ptr< direction_type > x)
{
  this->direction_.set (x);
}

const DirectionalLight::direction_type& DirectionalLight::
direction_default_value ()
{
  return direction_default_value_;
}

const DirectionalLight::global_type& DirectionalLight::
global () const
{
  return this->global_.get ();
}

DirectionalLight::global_type& DirectionalLight::
global ()
{
  return this->global_.get ();
}

void DirectionalLight::
global (const global_type& x)
{
  this->global_.set (x);
}

void DirectionalLight::
global (::std::auto_ptr< global_type > x)
{
  this->global_.set (x);
}

const DirectionalLight::global_type& DirectionalLight::
global_default_value ()
{
  return global_default_value_;
}


// Disk2D
// 

const Disk2D::innerRadius_type& Disk2D::
innerRadius () const
{
  return this->innerRadius_.get ();
}

Disk2D::innerRadius_type& Disk2D::
innerRadius ()
{
  return this->innerRadius_.get ();
}

void Disk2D::
innerRadius (const innerRadius_type& x)
{
  this->innerRadius_.set (x);
}

void Disk2D::
innerRadius (::std::auto_ptr< innerRadius_type > x)
{
  this->innerRadius_.set (x);
}

const Disk2D::innerRadius_type& Disk2D::
innerRadius_default_value ()
{
  return innerRadius_default_value_;
}

const Disk2D::outerRadius_type& Disk2D::
outerRadius () const
{
  return this->outerRadius_.get ();
}

Disk2D::outerRadius_type& Disk2D::
outerRadius ()
{
  return this->outerRadius_.get ();
}

void Disk2D::
outerRadius (const outerRadius_type& x)
{
  this->outerRadius_.set (x);
}

void Disk2D::
outerRadius (::std::auto_ptr< outerRadius_type > x)
{
  this->outerRadius_.set (x);
}

const Disk2D::outerRadius_type& Disk2D::
outerRadius_default_value ()
{
  return outerRadius_default_value_;
}

const Disk2D::solid_type& Disk2D::
solid () const
{
  return this->solid_.get ();
}

Disk2D::solid_type& Disk2D::
solid ()
{
  return this->solid_.get ();
}

void Disk2D::
solid (const solid_type& x)
{
  this->solid_.set (x);
}

void Disk2D::
solid (::std::auto_ptr< solid_type > x)
{
  this->solid_.set (x);
}

const Disk2D::solid_type& Disk2D::
solid_default_value ()
{
  return solid_default_value_;
}


// ElevationGrid
// 

const ElevationGrid::FloatVertexAttribute_sequence& ElevationGrid::
FloatVertexAttribute () const
{
  return this->FloatVertexAttribute_;
}

ElevationGrid::FloatVertexAttribute_sequence& ElevationGrid::
FloatVertexAttribute ()
{
  return this->FloatVertexAttribute_;
}

void ElevationGrid::
FloatVertexAttribute (const FloatVertexAttribute_sequence& s)
{
  this->FloatVertexAttribute_ = s;
}

const ElevationGrid::Matrix3VertexAttribute_sequence& ElevationGrid::
Matrix3VertexAttribute () const
{
  return this->Matrix3VertexAttribute_;
}

ElevationGrid::Matrix3VertexAttribute_sequence& ElevationGrid::
Matrix3VertexAttribute ()
{
  return this->Matrix3VertexAttribute_;
}

void ElevationGrid::
Matrix3VertexAttribute (const Matrix3VertexAttribute_sequence& s)
{
  this->Matrix3VertexAttribute_ = s;
}

const ElevationGrid::Matrix4VertexAttribute_sequence& ElevationGrid::
Matrix4VertexAttribute () const
{
  return this->Matrix4VertexAttribute_;
}

ElevationGrid::Matrix4VertexAttribute_sequence& ElevationGrid::
Matrix4VertexAttribute ()
{
  return this->Matrix4VertexAttribute_;
}

void ElevationGrid::
Matrix4VertexAttribute (const Matrix4VertexAttribute_sequence& s)
{
  this->Matrix4VertexAttribute_ = s;
}

const ElevationGrid::Color_sequence& ElevationGrid::
Color () const
{
  return this->Color_;
}

ElevationGrid::Color_sequence& ElevationGrid::
Color ()
{
  return this->Color_;
}

void ElevationGrid::
Color (const Color_sequence& s)
{
  this->Color_ = s;
}

const ElevationGrid::ColorRGBA_sequence& ElevationGrid::
ColorRGBA () const
{
  return this->ColorRGBA_;
}

ElevationGrid::ColorRGBA_sequence& ElevationGrid::
ColorRGBA ()
{
  return this->ColorRGBA_;
}

void ElevationGrid::
ColorRGBA (const ColorRGBA_sequence& s)
{
  this->ColorRGBA_ = s;
}

const ElevationGrid::FogCoordinate_sequence& ElevationGrid::
FogCoordinate () const
{
  return this->FogCoordinate_;
}

ElevationGrid::FogCoordinate_sequence& ElevationGrid::
FogCoordinate ()
{
  return this->FogCoordinate_;
}

void ElevationGrid::
FogCoordinate (const FogCoordinate_sequence& s)
{
  this->FogCoordinate_ = s;
}

const ElevationGrid::Normal_sequence& ElevationGrid::
Normal () const
{
  return this->Normal_;
}

ElevationGrid::Normal_sequence& ElevationGrid::
Normal ()
{
  return this->Normal_;
}

void ElevationGrid::
Normal (const Normal_sequence& s)
{
  this->Normal_ = s;
}

const ElevationGrid::TextureCoordinate_sequence& ElevationGrid::
TextureCoordinate () const
{
  return this->TextureCoordinate_;
}

ElevationGrid::TextureCoordinate_sequence& ElevationGrid::
TextureCoordinate ()
{
  return this->TextureCoordinate_;
}

void ElevationGrid::
TextureCoordinate (const TextureCoordinate_sequence& s)
{
  this->TextureCoordinate_ = s;
}

const ElevationGrid::TextureCoordinate3D_sequence& ElevationGrid::
TextureCoordinate3D () const
{
  return this->TextureCoordinate3D_;
}

ElevationGrid::TextureCoordinate3D_sequence& ElevationGrid::
TextureCoordinate3D ()
{
  return this->TextureCoordinate3D_;
}

void ElevationGrid::
TextureCoordinate3D (const TextureCoordinate3D_sequence& s)
{
  this->TextureCoordinate3D_ = s;
}

const ElevationGrid::TextureCoordinate4D_sequence& ElevationGrid::
TextureCoordinate4D () const
{
  return this->TextureCoordinate4D_;
}

ElevationGrid::TextureCoordinate4D_sequence& ElevationGrid::
TextureCoordinate4D ()
{
  return this->TextureCoordinate4D_;
}

void ElevationGrid::
TextureCoordinate4D (const TextureCoordinate4D_sequence& s)
{
  this->TextureCoordinate4D_ = s;
}

const ElevationGrid::TextureCoordinateGenerator_sequence& ElevationGrid::
TextureCoordinateGenerator () const
{
  return this->TextureCoordinateGenerator_;
}

ElevationGrid::TextureCoordinateGenerator_sequence& ElevationGrid::
TextureCoordinateGenerator ()
{
  return this->TextureCoordinateGenerator_;
}

void ElevationGrid::
TextureCoordinateGenerator (const TextureCoordinateGenerator_sequence& s)
{
  this->TextureCoordinateGenerator_ = s;
}

const ElevationGrid::MultiTextureCoordinate_sequence& ElevationGrid::
MultiTextureCoordinate () const
{
  return this->MultiTextureCoordinate_;
}

ElevationGrid::MultiTextureCoordinate_sequence& ElevationGrid::
MultiTextureCoordinate ()
{
  return this->MultiTextureCoordinate_;
}

void ElevationGrid::
MultiTextureCoordinate (const MultiTextureCoordinate_sequence& s)
{
  this->MultiTextureCoordinate_ = s;
}

const ElevationGrid::NurbsTextureCoordinate_sequence& ElevationGrid::
NurbsTextureCoordinate () const
{
  return this->NurbsTextureCoordinate_;
}

ElevationGrid::NurbsTextureCoordinate_sequence& ElevationGrid::
NurbsTextureCoordinate ()
{
  return this->NurbsTextureCoordinate_;
}

void ElevationGrid::
NurbsTextureCoordinate (const NurbsTextureCoordinate_sequence& s)
{
  this->NurbsTextureCoordinate_ = s;
}

const ElevationGrid::ProtoInstance_sequence& ElevationGrid::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

ElevationGrid::ProtoInstance_sequence& ElevationGrid::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void ElevationGrid::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const ElevationGrid::height_optional& ElevationGrid::
height () const
{
  return this->height_;
}

ElevationGrid::height_optional& ElevationGrid::
height ()
{
  return this->height_;
}

void ElevationGrid::
height (const height_type& x)
{
  this->height_.set (x);
}

void ElevationGrid::
height (const height_optional& x)
{
  this->height_ = x;
}

void ElevationGrid::
height (::std::auto_ptr< height_type > x)
{
  this->height_.set (x);
}

const ElevationGrid::ccw_type& ElevationGrid::
ccw () const
{
  return this->ccw_.get ();
}

ElevationGrid::ccw_type& ElevationGrid::
ccw ()
{
  return this->ccw_.get ();
}

void ElevationGrid::
ccw (const ccw_type& x)
{
  this->ccw_.set (x);
}

void ElevationGrid::
ccw (::std::auto_ptr< ccw_type > x)
{
  this->ccw_.set (x);
}

const ElevationGrid::ccw_type& ElevationGrid::
ccw_default_value ()
{
  return ccw_default_value_;
}

const ElevationGrid::colorPerVertex_type& ElevationGrid::
colorPerVertex () const
{
  return this->colorPerVertex_.get ();
}

ElevationGrid::colorPerVertex_type& ElevationGrid::
colorPerVertex ()
{
  return this->colorPerVertex_.get ();
}

void ElevationGrid::
colorPerVertex (const colorPerVertex_type& x)
{
  this->colorPerVertex_.set (x);
}

void ElevationGrid::
colorPerVertex (::std::auto_ptr< colorPerVertex_type > x)
{
  this->colorPerVertex_.set (x);
}

const ElevationGrid::colorPerVertex_type& ElevationGrid::
colorPerVertex_default_value ()
{
  return colorPerVertex_default_value_;
}

const ElevationGrid::creaseAngle_type& ElevationGrid::
creaseAngle () const
{
  return this->creaseAngle_.get ();
}

ElevationGrid::creaseAngle_type& ElevationGrid::
creaseAngle ()
{
  return this->creaseAngle_.get ();
}

void ElevationGrid::
creaseAngle (const creaseAngle_type& x)
{
  this->creaseAngle_.set (x);
}

void ElevationGrid::
creaseAngle (::std::auto_ptr< creaseAngle_type > x)
{
  this->creaseAngle_.set (x);
}

const ElevationGrid::creaseAngle_type& ElevationGrid::
creaseAngle_default_value ()
{
  return creaseAngle_default_value_;
}

const ElevationGrid::normalPerVertex_type& ElevationGrid::
normalPerVertex () const
{
  return this->normalPerVertex_.get ();
}

ElevationGrid::normalPerVertex_type& ElevationGrid::
normalPerVertex ()
{
  return this->normalPerVertex_.get ();
}

void ElevationGrid::
normalPerVertex (const normalPerVertex_type& x)
{
  this->normalPerVertex_.set (x);
}

void ElevationGrid::
normalPerVertex (::std::auto_ptr< normalPerVertex_type > x)
{
  this->normalPerVertex_.set (x);
}

const ElevationGrid::normalPerVertex_type& ElevationGrid::
normalPerVertex_default_value ()
{
  return normalPerVertex_default_value_;
}

const ElevationGrid::solid_type& ElevationGrid::
solid () const
{
  return this->solid_.get ();
}

ElevationGrid::solid_type& ElevationGrid::
solid ()
{
  return this->solid_.get ();
}

void ElevationGrid::
solid (const solid_type& x)
{
  this->solid_.set (x);
}

void ElevationGrid::
solid (::std::auto_ptr< solid_type > x)
{
  this->solid_.set (x);
}

const ElevationGrid::solid_type& ElevationGrid::
solid_default_value ()
{
  return solid_default_value_;
}

const ElevationGrid::xDimension_type& ElevationGrid::
xDimension () const
{
  return this->xDimension_.get ();
}

ElevationGrid::xDimension_type& ElevationGrid::
xDimension ()
{
  return this->xDimension_.get ();
}

void ElevationGrid::
xDimension (const xDimension_type& x)
{
  this->xDimension_.set (x);
}

void ElevationGrid::
xDimension (::std::auto_ptr< xDimension_type > x)
{
  this->xDimension_.set (x);
}

const ElevationGrid::xDimension_type& ElevationGrid::
xDimension_default_value ()
{
  return xDimension_default_value_;
}

const ElevationGrid::xSpacing_type& ElevationGrid::
xSpacing () const
{
  return this->xSpacing_.get ();
}

ElevationGrid::xSpacing_type& ElevationGrid::
xSpacing ()
{
  return this->xSpacing_.get ();
}

void ElevationGrid::
xSpacing (const xSpacing_type& x)
{
  this->xSpacing_.set (x);
}

void ElevationGrid::
xSpacing (::std::auto_ptr< xSpacing_type > x)
{
  this->xSpacing_.set (x);
}

const ElevationGrid::xSpacing_type& ElevationGrid::
xSpacing_default_value ()
{
  return xSpacing_default_value_;
}

const ElevationGrid::zDimension_type& ElevationGrid::
zDimension () const
{
  return this->zDimension_.get ();
}

ElevationGrid::zDimension_type& ElevationGrid::
zDimension ()
{
  return this->zDimension_.get ();
}

void ElevationGrid::
zDimension (const zDimension_type& x)
{
  this->zDimension_.set (x);
}

void ElevationGrid::
zDimension (::std::auto_ptr< zDimension_type > x)
{
  this->zDimension_.set (x);
}

const ElevationGrid::zDimension_type& ElevationGrid::
zDimension_default_value ()
{
  return zDimension_default_value_;
}

const ElevationGrid::zSpacing_type& ElevationGrid::
zSpacing () const
{
  return this->zSpacing_.get ();
}

ElevationGrid::zSpacing_type& ElevationGrid::
zSpacing ()
{
  return this->zSpacing_.get ();
}

void ElevationGrid::
zSpacing (const zSpacing_type& x)
{
  this->zSpacing_.set (x);
}

void ElevationGrid::
zSpacing (::std::auto_ptr< zSpacing_type > x)
{
  this->zSpacing_.set (x);
}

const ElevationGrid::zSpacing_type& ElevationGrid::
zSpacing_default_value ()
{
  return zSpacing_default_value_;
}


// Extrusion
// 

const Extrusion::beginCap_type& Extrusion::
beginCap () const
{
  return this->beginCap_.get ();
}

Extrusion::beginCap_type& Extrusion::
beginCap ()
{
  return this->beginCap_.get ();
}

void Extrusion::
beginCap (const beginCap_type& x)
{
  this->beginCap_.set (x);
}

void Extrusion::
beginCap (::std::auto_ptr< beginCap_type > x)
{
  this->beginCap_.set (x);
}

const Extrusion::beginCap_type& Extrusion::
beginCap_default_value ()
{
  return beginCap_default_value_;
}

const Extrusion::ccw_type& Extrusion::
ccw () const
{
  return this->ccw_.get ();
}

Extrusion::ccw_type& Extrusion::
ccw ()
{
  return this->ccw_.get ();
}

void Extrusion::
ccw (const ccw_type& x)
{
  this->ccw_.set (x);
}

void Extrusion::
ccw (::std::auto_ptr< ccw_type > x)
{
  this->ccw_.set (x);
}

const Extrusion::ccw_type& Extrusion::
ccw_default_value ()
{
  return ccw_default_value_;
}

const Extrusion::convex_type& Extrusion::
convex () const
{
  return this->convex_.get ();
}

Extrusion::convex_type& Extrusion::
convex ()
{
  return this->convex_.get ();
}

void Extrusion::
convex (const convex_type& x)
{
  this->convex_.set (x);
}

void Extrusion::
convex (::std::auto_ptr< convex_type > x)
{
  this->convex_.set (x);
}

const Extrusion::convex_type& Extrusion::
convex_default_value ()
{
  return convex_default_value_;
}

const Extrusion::creaseAngle_type& Extrusion::
creaseAngle () const
{
  return this->creaseAngle_.get ();
}

Extrusion::creaseAngle_type& Extrusion::
creaseAngle ()
{
  return this->creaseAngle_.get ();
}

void Extrusion::
creaseAngle (const creaseAngle_type& x)
{
  this->creaseAngle_.set (x);
}

void Extrusion::
creaseAngle (::std::auto_ptr< creaseAngle_type > x)
{
  this->creaseAngle_.set (x);
}

const Extrusion::creaseAngle_type& Extrusion::
creaseAngle_default_value ()
{
  return creaseAngle_default_value_;
}

const Extrusion::crossSection_type& Extrusion::
crossSection () const
{
  return this->crossSection_.get ();
}

Extrusion::crossSection_type& Extrusion::
crossSection ()
{
  return this->crossSection_.get ();
}

void Extrusion::
crossSection (const crossSection_type& x)
{
  this->crossSection_.set (x);
}

void Extrusion::
crossSection (::std::auto_ptr< crossSection_type > x)
{
  this->crossSection_.set (x);
}

const Extrusion::crossSection_type& Extrusion::
crossSection_default_value ()
{
  return crossSection_default_value_;
}

const Extrusion::endCap_type& Extrusion::
endCap () const
{
  return this->endCap_.get ();
}

Extrusion::endCap_type& Extrusion::
endCap ()
{
  return this->endCap_.get ();
}

void Extrusion::
endCap (const endCap_type& x)
{
  this->endCap_.set (x);
}

void Extrusion::
endCap (::std::auto_ptr< endCap_type > x)
{
  this->endCap_.set (x);
}

const Extrusion::endCap_type& Extrusion::
endCap_default_value ()
{
  return endCap_default_value_;
}

const Extrusion::orientation_type& Extrusion::
orientation () const
{
  return this->orientation_.get ();
}

Extrusion::orientation_type& Extrusion::
orientation ()
{
  return this->orientation_.get ();
}

void Extrusion::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void Extrusion::
orientation (::std::auto_ptr< orientation_type > x)
{
  this->orientation_.set (x);
}

const Extrusion::orientation_type& Extrusion::
orientation_default_value ()
{
  return orientation_default_value_;
}

const Extrusion::scale_type& Extrusion::
scale () const
{
  return this->scale_.get ();
}

Extrusion::scale_type& Extrusion::
scale ()
{
  return this->scale_.get ();
}

void Extrusion::
scale (const scale_type& x)
{
  this->scale_.set (x);
}

void Extrusion::
scale (::std::auto_ptr< scale_type > x)
{
  this->scale_.set (x);
}

const Extrusion::scale_type& Extrusion::
scale_default_value ()
{
  return scale_default_value_;
}

const Extrusion::solid_type& Extrusion::
solid () const
{
  return this->solid_.get ();
}

Extrusion::solid_type& Extrusion::
solid ()
{
  return this->solid_.get ();
}

void Extrusion::
solid (const solid_type& x)
{
  this->solid_.set (x);
}

void Extrusion::
solid (::std::auto_ptr< solid_type > x)
{
  this->solid_.set (x);
}

const Extrusion::solid_type& Extrusion::
solid_default_value ()
{
  return solid_default_value_;
}

const Extrusion::spine_type& Extrusion::
spine () const
{
  return this->spine_.get ();
}

Extrusion::spine_type& Extrusion::
spine ()
{
  return this->spine_.get ();
}

void Extrusion::
spine (const spine_type& x)
{
  this->spine_.set (x);
}

void Extrusion::
spine (::std::auto_ptr< spine_type > x)
{
  this->spine_.set (x);
}

const Extrusion::spine_type& Extrusion::
spine_default_value ()
{
  return spine_default_value_;
}


// FillProperties
// 

const FillProperties::filled_type& FillProperties::
filled () const
{
  return this->filled_.get ();
}

FillProperties::filled_type& FillProperties::
filled ()
{
  return this->filled_.get ();
}

void FillProperties::
filled (const filled_type& x)
{
  this->filled_.set (x);
}

void FillProperties::
filled (::std::auto_ptr< filled_type > x)
{
  this->filled_.set (x);
}

const FillProperties::filled_type& FillProperties::
filled_default_value ()
{
  return filled_default_value_;
}

const FillProperties::hatched_type& FillProperties::
hatched () const
{
  return this->hatched_.get ();
}

FillProperties::hatched_type& FillProperties::
hatched ()
{
  return this->hatched_.get ();
}

void FillProperties::
hatched (const hatched_type& x)
{
  this->hatched_.set (x);
}

void FillProperties::
hatched (::std::auto_ptr< hatched_type > x)
{
  this->hatched_.set (x);
}

const FillProperties::hatched_type& FillProperties::
hatched_default_value ()
{
  return hatched_default_value_;
}

const FillProperties::hatchStyle_type& FillProperties::
hatchStyle () const
{
  return this->hatchStyle_.get ();
}

FillProperties::hatchStyle_type& FillProperties::
hatchStyle ()
{
  return this->hatchStyle_.get ();
}

void FillProperties::
hatchStyle (const hatchStyle_type& x)
{
  this->hatchStyle_.set (x);
}

void FillProperties::
hatchStyle (::std::auto_ptr< hatchStyle_type > x)
{
  this->hatchStyle_.set (x);
}

const FillProperties::hatchStyle_type& FillProperties::
hatchStyle_default_value ()
{
  return hatchStyle_default_value_;
}

const FillProperties::hatchColor_type& FillProperties::
hatchColor () const
{
  return this->hatchColor_.get ();
}

FillProperties::hatchColor_type& FillProperties::
hatchColor ()
{
  return this->hatchColor_.get ();
}

void FillProperties::
hatchColor (const hatchColor_type& x)
{
  this->hatchColor_.set (x);
}

void FillProperties::
hatchColor (::std::auto_ptr< hatchColor_type > x)
{
  this->hatchColor_.set (x);
}

const FillProperties::hatchColor_type& FillProperties::
hatchColor_default_value ()
{
  return hatchColor_default_value_;
}

const FillProperties::containerField_type& FillProperties::
containerField () const
{
  return this->containerField_.get ();
}

FillProperties::containerField_type& FillProperties::
containerField ()
{
  return this->containerField_.get ();
}

void FillProperties::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void FillProperties::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const FillProperties::containerField_type& FillProperties::
containerField_default_value ()
{
  return containerField_default_value_;
}


// Fog
// 

const Fog::color_type& Fog::
color () const
{
  return this->color_.get ();
}

Fog::color_type& Fog::
color ()
{
  return this->color_.get ();
}

void Fog::
color (const color_type& x)
{
  this->color_.set (x);
}

void Fog::
color (::std::auto_ptr< color_type > x)
{
  this->color_.set (x);
}

const Fog::color_type& Fog::
color_default_value ()
{
  return color_default_value_;
}

const Fog::fogType_type& Fog::
fogType () const
{
  return this->fogType_.get ();
}

Fog::fogType_type& Fog::
fogType ()
{
  return this->fogType_.get ();
}

void Fog::
fogType (const fogType_type& x)
{
  this->fogType_.set (x);
}

void Fog::
fogType (::std::auto_ptr< fogType_type > x)
{
  this->fogType_.set (x);
}

const Fog::fogType_type& Fog::
fogType_default_value ()
{
  return fogType_default_value_;
}

const Fog::visibilityRange_type& Fog::
visibilityRange () const
{
  return this->visibilityRange_.get ();
}

Fog::visibilityRange_type& Fog::
visibilityRange ()
{
  return this->visibilityRange_.get ();
}

void Fog::
visibilityRange (const visibilityRange_type& x)
{
  this->visibilityRange_.set (x);
}

void Fog::
visibilityRange (::std::auto_ptr< visibilityRange_type > x)
{
  this->visibilityRange_.set (x);
}

const Fog::visibilityRange_type& Fog::
visibilityRange_default_value ()
{
  return visibilityRange_default_value_;
}


// FogCoordinate
// 

const FogCoordinate::depth_optional& FogCoordinate::
depth () const
{
  return this->depth_;
}

FogCoordinate::depth_optional& FogCoordinate::
depth ()
{
  return this->depth_;
}

void FogCoordinate::
depth (const depth_type& x)
{
  this->depth_.set (x);
}

void FogCoordinate::
depth (const depth_optional& x)
{
  this->depth_ = x;
}

void FogCoordinate::
depth (::std::auto_ptr< depth_type > x)
{
  this->depth_.set (x);
}

const FogCoordinate::containerField_type& FogCoordinate::
containerField () const
{
  return this->containerField_.get ();
}

FogCoordinate::containerField_type& FogCoordinate::
containerField ()
{
  return this->containerField_.get ();
}

void FogCoordinate::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void FogCoordinate::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const FogCoordinate::containerField_type& FogCoordinate::
containerField_default_value ()
{
  return containerField_default_value_;
}


// FontStyle
// 

const FontStyle::family_type& FontStyle::
family () const
{
  return this->family_.get ();
}

FontStyle::family_type& FontStyle::
family ()
{
  return this->family_.get ();
}

void FontStyle::
family (const family_type& x)
{
  this->family_.set (x);
}

void FontStyle::
family (::std::auto_ptr< family_type > x)
{
  this->family_.set (x);
}

const FontStyle::family_type& FontStyle::
family_default_value ()
{
  return family_default_value_;
}

const FontStyle::horizontal_type& FontStyle::
horizontal () const
{
  return this->horizontal_.get ();
}

FontStyle::horizontal_type& FontStyle::
horizontal ()
{
  return this->horizontal_.get ();
}

void FontStyle::
horizontal (const horizontal_type& x)
{
  this->horizontal_.set (x);
}

void FontStyle::
horizontal (::std::auto_ptr< horizontal_type > x)
{
  this->horizontal_.set (x);
}

const FontStyle::horizontal_type& FontStyle::
horizontal_default_value ()
{
  return horizontal_default_value_;
}

const FontStyle::justify_type& FontStyle::
justify () const
{
  return this->justify_.get ();
}

FontStyle::justify_type& FontStyle::
justify ()
{
  return this->justify_.get ();
}

void FontStyle::
justify (const justify_type& x)
{
  this->justify_.set (x);
}

void FontStyle::
justify (::std::auto_ptr< justify_type > x)
{
  this->justify_.set (x);
}

const FontStyle::justify_type& FontStyle::
justify_default_value ()
{
  return justify_default_value_;
}

const FontStyle::language_optional& FontStyle::
language () const
{
  return this->language_;
}

FontStyle::language_optional& FontStyle::
language ()
{
  return this->language_;
}

void FontStyle::
language (const language_type& x)
{
  this->language_.set (x);
}

void FontStyle::
language (const language_optional& x)
{
  this->language_ = x;
}

void FontStyle::
language (::std::auto_ptr< language_type > x)
{
  this->language_.set (x);
}

const FontStyle::leftToRight_type& FontStyle::
leftToRight () const
{
  return this->leftToRight_.get ();
}

FontStyle::leftToRight_type& FontStyle::
leftToRight ()
{
  return this->leftToRight_.get ();
}

void FontStyle::
leftToRight (const leftToRight_type& x)
{
  this->leftToRight_.set (x);
}

void FontStyle::
leftToRight (::std::auto_ptr< leftToRight_type > x)
{
  this->leftToRight_.set (x);
}

const FontStyle::leftToRight_type& FontStyle::
leftToRight_default_value ()
{
  return leftToRight_default_value_;
}

const FontStyle::size_type& FontStyle::
size () const
{
  return this->size_.get ();
}

FontStyle::size_type& FontStyle::
size ()
{
  return this->size_.get ();
}

void FontStyle::
size (const size_type& x)
{
  this->size_.set (x);
}

void FontStyle::
size (::std::auto_ptr< size_type > x)
{
  this->size_.set (x);
}

const FontStyle::size_type& FontStyle::
size_default_value ()
{
  return size_default_value_;
}

const FontStyle::spacing_type& FontStyle::
spacing () const
{
  return this->spacing_.get ();
}

FontStyle::spacing_type& FontStyle::
spacing ()
{
  return this->spacing_.get ();
}

void FontStyle::
spacing (const spacing_type& x)
{
  this->spacing_.set (x);
}

void FontStyle::
spacing (::std::auto_ptr< spacing_type > x)
{
  this->spacing_.set (x);
}

const FontStyle::spacing_type& FontStyle::
spacing_default_value ()
{
  return spacing_default_value_;
}

const FontStyle::style_type& FontStyle::
style () const
{
  return this->style_.get ();
}

FontStyle::style_type& FontStyle::
style ()
{
  return this->style_.get ();
}

void FontStyle::
style (const style_type& x)
{
  this->style_.set (x);
}

void FontStyle::
style (::std::auto_ptr< style_type > x)
{
  this->style_.set (x);
}

const FontStyle::style_type& FontStyle::
style_default_value ()
{
  return style_default_value_;
}

const FontStyle::topToBottom_type& FontStyle::
topToBottom () const
{
  return this->topToBottom_.get ();
}

FontStyle::topToBottom_type& FontStyle::
topToBottom ()
{
  return this->topToBottom_.get ();
}

void FontStyle::
topToBottom (const topToBottom_type& x)
{
  this->topToBottom_.set (x);
}

void FontStyle::
topToBottom (::std::auto_ptr< topToBottom_type > x)
{
  this->topToBottom_.set (x);
}

const FontStyle::topToBottom_type& FontStyle::
topToBottom_default_value ()
{
  return topToBottom_default_value_;
}


// Group
// 


// ImageTexture
// 

const ImageTexture::url_optional& ImageTexture::
url () const
{
  return this->url_;
}

ImageTexture::url_optional& ImageTexture::
url ()
{
  return this->url_;
}

void ImageTexture::
url (const url_type& x)
{
  this->url_.set (x);
}

void ImageTexture::
url (const url_optional& x)
{
  this->url_ = x;
}

void ImageTexture::
url (::std::auto_ptr< url_type > x)
{
  this->url_.set (x);
}


// IndexedFaceSet
// 

const IndexedFaceSet::convex_type& IndexedFaceSet::
convex () const
{
  return this->convex_.get ();
}

IndexedFaceSet::convex_type& IndexedFaceSet::
convex ()
{
  return this->convex_.get ();
}

void IndexedFaceSet::
convex (const convex_type& x)
{
  this->convex_.set (x);
}

void IndexedFaceSet::
convex (::std::auto_ptr< convex_type > x)
{
  this->convex_.set (x);
}

const IndexedFaceSet::convex_type& IndexedFaceSet::
convex_default_value ()
{
  return convex_default_value_;
}

const IndexedFaceSet::creaseAngle_type& IndexedFaceSet::
creaseAngle () const
{
  return this->creaseAngle_.get ();
}

IndexedFaceSet::creaseAngle_type& IndexedFaceSet::
creaseAngle ()
{
  return this->creaseAngle_.get ();
}

void IndexedFaceSet::
creaseAngle (const creaseAngle_type& x)
{
  this->creaseAngle_.set (x);
}

void IndexedFaceSet::
creaseAngle (::std::auto_ptr< creaseAngle_type > x)
{
  this->creaseAngle_.set (x);
}

const IndexedFaceSet::creaseAngle_type& IndexedFaceSet::
creaseAngle_default_value ()
{
  return creaseAngle_default_value_;
}

const IndexedFaceSet::colorIndex_optional& IndexedFaceSet::
colorIndex () const
{
  return this->colorIndex_;
}

IndexedFaceSet::colorIndex_optional& IndexedFaceSet::
colorIndex ()
{
  return this->colorIndex_;
}

void IndexedFaceSet::
colorIndex (const colorIndex_type& x)
{
  this->colorIndex_.set (x);
}

void IndexedFaceSet::
colorIndex (const colorIndex_optional& x)
{
  this->colorIndex_ = x;
}

void IndexedFaceSet::
colorIndex (::std::auto_ptr< colorIndex_type > x)
{
  this->colorIndex_.set (x);
}

const IndexedFaceSet::coordIndex_optional& IndexedFaceSet::
coordIndex () const
{
  return this->coordIndex_;
}

IndexedFaceSet::coordIndex_optional& IndexedFaceSet::
coordIndex ()
{
  return this->coordIndex_;
}

void IndexedFaceSet::
coordIndex (const coordIndex_type& x)
{
  this->coordIndex_.set (x);
}

void IndexedFaceSet::
coordIndex (const coordIndex_optional& x)
{
  this->coordIndex_ = x;
}

void IndexedFaceSet::
coordIndex (::std::auto_ptr< coordIndex_type > x)
{
  this->coordIndex_.set (x);
}

const IndexedFaceSet::normalIndex_optional& IndexedFaceSet::
normalIndex () const
{
  return this->normalIndex_;
}

IndexedFaceSet::normalIndex_optional& IndexedFaceSet::
normalIndex ()
{
  return this->normalIndex_;
}

void IndexedFaceSet::
normalIndex (const normalIndex_type& x)
{
  this->normalIndex_.set (x);
}

void IndexedFaceSet::
normalIndex (const normalIndex_optional& x)
{
  this->normalIndex_ = x;
}

void IndexedFaceSet::
normalIndex (::std::auto_ptr< normalIndex_type > x)
{
  this->normalIndex_.set (x);
}

const IndexedFaceSet::texCoordIndex_optional& IndexedFaceSet::
texCoordIndex () const
{
  return this->texCoordIndex_;
}

IndexedFaceSet::texCoordIndex_optional& IndexedFaceSet::
texCoordIndex ()
{
  return this->texCoordIndex_;
}

void IndexedFaceSet::
texCoordIndex (const texCoordIndex_type& x)
{
  this->texCoordIndex_.set (x);
}

void IndexedFaceSet::
texCoordIndex (const texCoordIndex_optional& x)
{
  this->texCoordIndex_ = x;
}

void IndexedFaceSet::
texCoordIndex (::std::auto_ptr< texCoordIndex_type > x)
{
  this->texCoordIndex_.set (x);
}


// IndexedLineSet
// 

const IndexedLineSet::Color_optional& IndexedLineSet::
Color () const
{
  return this->Color_;
}

IndexedLineSet::Color_optional& IndexedLineSet::
Color ()
{
  return this->Color_;
}

void IndexedLineSet::
Color (const Color_type& x)
{
  this->Color_.set (x);
}

void IndexedLineSet::
Color (const Color_optional& x)
{
  this->Color_ = x;
}

void IndexedLineSet::
Color (::std::auto_ptr< Color_type > x)
{
  this->Color_.set (x);
}

const IndexedLineSet::ColorRGBA_optional& IndexedLineSet::
ColorRGBA () const
{
  return this->ColorRGBA_;
}

IndexedLineSet::ColorRGBA_optional& IndexedLineSet::
ColorRGBA ()
{
  return this->ColorRGBA_;
}

void IndexedLineSet::
ColorRGBA (const ColorRGBA_type& x)
{
  this->ColorRGBA_.set (x);
}

void IndexedLineSet::
ColorRGBA (const ColorRGBA_optional& x)
{
  this->ColorRGBA_ = x;
}

void IndexedLineSet::
ColorRGBA (::std::auto_ptr< ColorRGBA_type > x)
{
  this->ColorRGBA_.set (x);
}

const IndexedLineSet::Coordinate_optional& IndexedLineSet::
Coordinate () const
{
  return this->Coordinate_;
}

IndexedLineSet::Coordinate_optional& IndexedLineSet::
Coordinate ()
{
  return this->Coordinate_;
}

void IndexedLineSet::
Coordinate (const Coordinate_type& x)
{
  this->Coordinate_.set (x);
}

void IndexedLineSet::
Coordinate (const Coordinate_optional& x)
{
  this->Coordinate_ = x;
}

void IndexedLineSet::
Coordinate (::std::auto_ptr< Coordinate_type > x)
{
  this->Coordinate_.set (x);
}

const IndexedLineSet::CoordinateDouble_optional& IndexedLineSet::
CoordinateDouble () const
{
  return this->CoordinateDouble_;
}

IndexedLineSet::CoordinateDouble_optional& IndexedLineSet::
CoordinateDouble ()
{
  return this->CoordinateDouble_;
}

void IndexedLineSet::
CoordinateDouble (const CoordinateDouble_type& x)
{
  this->CoordinateDouble_.set (x);
}

void IndexedLineSet::
CoordinateDouble (const CoordinateDouble_optional& x)
{
  this->CoordinateDouble_ = x;
}

void IndexedLineSet::
CoordinateDouble (::std::auto_ptr< CoordinateDouble_type > x)
{
  this->CoordinateDouble_.set (x);
}

const IndexedLineSet::GeoCoordinate_optional& IndexedLineSet::
GeoCoordinate () const
{
  return this->GeoCoordinate_;
}

IndexedLineSet::GeoCoordinate_optional& IndexedLineSet::
GeoCoordinate ()
{
  return this->GeoCoordinate_;
}

void IndexedLineSet::
GeoCoordinate (const GeoCoordinate_type& x)
{
  this->GeoCoordinate_.set (x);
}

void IndexedLineSet::
GeoCoordinate (const GeoCoordinate_optional& x)
{
  this->GeoCoordinate_ = x;
}

void IndexedLineSet::
GeoCoordinate (::std::auto_ptr< GeoCoordinate_type > x)
{
  this->GeoCoordinate_.set (x);
}

const IndexedLineSet::ProtoInstance_sequence& IndexedLineSet::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

IndexedLineSet::ProtoInstance_sequence& IndexedLineSet::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void IndexedLineSet::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const IndexedLineSet::colorPerVertex_type& IndexedLineSet::
colorPerVertex () const
{
  return this->colorPerVertex_.get ();
}

IndexedLineSet::colorPerVertex_type& IndexedLineSet::
colorPerVertex ()
{
  return this->colorPerVertex_.get ();
}

void IndexedLineSet::
colorPerVertex (const colorPerVertex_type& x)
{
  this->colorPerVertex_.set (x);
}

void IndexedLineSet::
colorPerVertex (::std::auto_ptr< colorPerVertex_type > x)
{
  this->colorPerVertex_.set (x);
}

const IndexedLineSet::colorPerVertex_type& IndexedLineSet::
colorPerVertex_default_value ()
{
  return colorPerVertex_default_value_;
}

const IndexedLineSet::colorIndex_optional& IndexedLineSet::
colorIndex () const
{
  return this->colorIndex_;
}

IndexedLineSet::colorIndex_optional& IndexedLineSet::
colorIndex ()
{
  return this->colorIndex_;
}

void IndexedLineSet::
colorIndex (const colorIndex_type& x)
{
  this->colorIndex_.set (x);
}

void IndexedLineSet::
colorIndex (const colorIndex_optional& x)
{
  this->colorIndex_ = x;
}

void IndexedLineSet::
colorIndex (::std::auto_ptr< colorIndex_type > x)
{
  this->colorIndex_.set (x);
}

const IndexedLineSet::coordIndex_optional& IndexedLineSet::
coordIndex () const
{
  return this->coordIndex_;
}

IndexedLineSet::coordIndex_optional& IndexedLineSet::
coordIndex ()
{
  return this->coordIndex_;
}

void IndexedLineSet::
coordIndex (const coordIndex_type& x)
{
  this->coordIndex_.set (x);
}

void IndexedLineSet::
coordIndex (const coordIndex_optional& x)
{
  this->coordIndex_ = x;
}

void IndexedLineSet::
coordIndex (::std::auto_ptr< coordIndex_type > x)
{
  this->coordIndex_.set (x);
}


// IndexedTriangleFanSet
// 

const IndexedTriangleFanSet::index_optional& IndexedTriangleFanSet::
index () const
{
  return this->index_;
}

IndexedTriangleFanSet::index_optional& IndexedTriangleFanSet::
index ()
{
  return this->index_;
}

void IndexedTriangleFanSet::
index (const index_type& x)
{
  this->index_.set (x);
}

void IndexedTriangleFanSet::
index (const index_optional& x)
{
  this->index_ = x;
}

void IndexedTriangleFanSet::
index (::std::auto_ptr< index_type > x)
{
  this->index_.set (x);
}


// IndexedTriangleSet
// 

const IndexedTriangleSet::index_optional& IndexedTriangleSet::
index () const
{
  return this->index_;
}

IndexedTriangleSet::index_optional& IndexedTriangleSet::
index ()
{
  return this->index_;
}

void IndexedTriangleSet::
index (const index_type& x)
{
  this->index_.set (x);
}

void IndexedTriangleSet::
index (const index_optional& x)
{
  this->index_ = x;
}

void IndexedTriangleSet::
index (::std::auto_ptr< index_type > x)
{
  this->index_.set (x);
}


// IndexedTriangleStripSet
// 

const IndexedTriangleStripSet::index_optional& IndexedTriangleStripSet::
index () const
{
  return this->index_;
}

IndexedTriangleStripSet::index_optional& IndexedTriangleStripSet::
index ()
{
  return this->index_;
}

void IndexedTriangleStripSet::
index (const index_type& x)
{
  this->index_.set (x);
}

void IndexedTriangleStripSet::
index (const index_optional& x)
{
  this->index_ = x;
}

void IndexedTriangleStripSet::
index (::std::auto_ptr< index_type > x)
{
  this->index_.set (x);
}


// Inline
// 

const Inline::load_type& Inline::
load () const
{
  return this->load_.get ();
}

Inline::load_type& Inline::
load ()
{
  return this->load_.get ();
}

void Inline::
load (const load_type& x)
{
  this->load_.set (x);
}

void Inline::
load (::std::auto_ptr< load_type > x)
{
  this->load_.set (x);
}

const Inline::load_type& Inline::
load_default_value ()
{
  return load_default_value_;
}

const Inline::bboxCenter_type& Inline::
bboxCenter () const
{
  return this->bboxCenter_.get ();
}

Inline::bboxCenter_type& Inline::
bboxCenter ()
{
  return this->bboxCenter_.get ();
}

void Inline::
bboxCenter (const bboxCenter_type& x)
{
  this->bboxCenter_.set (x);
}

void Inline::
bboxCenter (::std::auto_ptr< bboxCenter_type > x)
{
  this->bboxCenter_.set (x);
}

const Inline::bboxCenter_type& Inline::
bboxCenter_default_value ()
{
  return bboxCenter_default_value_;
}

const Inline::bboxSize_type& Inline::
bboxSize () const
{
  return this->bboxSize_.get ();
}

Inline::bboxSize_type& Inline::
bboxSize ()
{
  return this->bboxSize_.get ();
}

void Inline::
bboxSize (const bboxSize_type& x)
{
  this->bboxSize_.set (x);
}

void Inline::
bboxSize (::std::auto_ptr< bboxSize_type > x)
{
  this->bboxSize_.set (x);
}

const Inline::bboxSize_type& Inline::
bboxSize_default_value ()
{
  return bboxSize_default_value_;
}

const Inline::url_optional& Inline::
url () const
{
  return this->url_;
}

Inline::url_optional& Inline::
url ()
{
  return this->url_;
}

void Inline::
url (const url_type& x)
{
  this->url_.set (x);
}

void Inline::
url (const url_optional& x)
{
  this->url_ = x;
}

void Inline::
url (::std::auto_ptr< url_type > x)
{
  this->url_.set (x);
}


// IntegerSequencer
// 

const IntegerSequencer::keyValue_optional& IntegerSequencer::
keyValue () const
{
  return this->keyValue_;
}

IntegerSequencer::keyValue_optional& IntegerSequencer::
keyValue ()
{
  return this->keyValue_;
}

void IntegerSequencer::
keyValue (const keyValue_type& x)
{
  this->keyValue_.set (x);
}

void IntegerSequencer::
keyValue (const keyValue_optional& x)
{
  this->keyValue_ = x;
}

void IntegerSequencer::
keyValue (::std::auto_ptr< keyValue_type > x)
{
  this->keyValue_.set (x);
}


// IntegerTrigger
// 

const IntegerTrigger::integerKey_type& IntegerTrigger::
integerKey () const
{
  return this->integerKey_.get ();
}

IntegerTrigger::integerKey_type& IntegerTrigger::
integerKey ()
{
  return this->integerKey_.get ();
}

void IntegerTrigger::
integerKey (const integerKey_type& x)
{
  this->integerKey_.set (x);
}

void IntegerTrigger::
integerKey (::std::auto_ptr< integerKey_type > x)
{
  this->integerKey_.set (x);
}

const IntegerTrigger::integerKey_type& IntegerTrigger::
integerKey_default_value ()
{
  return integerKey_default_value_;
}


// KeySensor
// 


// LineProperties
// 

const LineProperties::applied_type& LineProperties::
applied () const
{
  return this->applied_.get ();
}

LineProperties::applied_type& LineProperties::
applied ()
{
  return this->applied_.get ();
}

void LineProperties::
applied (const applied_type& x)
{
  this->applied_.set (x);
}

void LineProperties::
applied (::std::auto_ptr< applied_type > x)
{
  this->applied_.set (x);
}

const LineProperties::applied_type& LineProperties::
applied_default_value ()
{
  return applied_default_value_;
}

const LineProperties::linetype_type& LineProperties::
linetype () const
{
  return this->linetype_.get ();
}

LineProperties::linetype_type& LineProperties::
linetype ()
{
  return this->linetype_.get ();
}

void LineProperties::
linetype (const linetype_type& x)
{
  this->linetype_.set (x);
}

void LineProperties::
linetype (::std::auto_ptr< linetype_type > x)
{
  this->linetype_.set (x);
}

const LineProperties::linetype_type& LineProperties::
linetype_default_value ()
{
  return linetype_default_value_;
}

const LineProperties::linewidthScaleFactor_type& LineProperties::
linewidthScaleFactor () const
{
  return this->linewidthScaleFactor_.get ();
}

LineProperties::linewidthScaleFactor_type& LineProperties::
linewidthScaleFactor ()
{
  return this->linewidthScaleFactor_.get ();
}

void LineProperties::
linewidthScaleFactor (const linewidthScaleFactor_type& x)
{
  this->linewidthScaleFactor_.set (x);
}

void LineProperties::
linewidthScaleFactor (::std::auto_ptr< linewidthScaleFactor_type > x)
{
  this->linewidthScaleFactor_.set (x);
}

const LineProperties::linewidthScaleFactor_type& LineProperties::
linewidthScaleFactor_default_value ()
{
  return linewidthScaleFactor_default_value_;
}

const LineProperties::containerField_type& LineProperties::
containerField () const
{
  return this->containerField_.get ();
}

LineProperties::containerField_type& LineProperties::
containerField ()
{
  return this->containerField_.get ();
}

void LineProperties::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void LineProperties::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const LineProperties::containerField_type& LineProperties::
containerField_default_value ()
{
  return containerField_default_value_;
}


// LineSet
// 

const LineSet::Color_optional& LineSet::
Color () const
{
  return this->Color_;
}

LineSet::Color_optional& LineSet::
Color ()
{
  return this->Color_;
}

void LineSet::
Color (const Color_type& x)
{
  this->Color_.set (x);
}

void LineSet::
Color (const Color_optional& x)
{
  this->Color_ = x;
}

void LineSet::
Color (::std::auto_ptr< Color_type > x)
{
  this->Color_.set (x);
}

const LineSet::ColorRGBA_optional& LineSet::
ColorRGBA () const
{
  return this->ColorRGBA_;
}

LineSet::ColorRGBA_optional& LineSet::
ColorRGBA ()
{
  return this->ColorRGBA_;
}

void LineSet::
ColorRGBA (const ColorRGBA_type& x)
{
  this->ColorRGBA_.set (x);
}

void LineSet::
ColorRGBA (const ColorRGBA_optional& x)
{
  this->ColorRGBA_ = x;
}

void LineSet::
ColorRGBA (::std::auto_ptr< ColorRGBA_type > x)
{
  this->ColorRGBA_.set (x);
}

const LineSet::Coordinate_optional& LineSet::
Coordinate () const
{
  return this->Coordinate_;
}

LineSet::Coordinate_optional& LineSet::
Coordinate ()
{
  return this->Coordinate_;
}

void LineSet::
Coordinate (const Coordinate_type& x)
{
  this->Coordinate_.set (x);
}

void LineSet::
Coordinate (const Coordinate_optional& x)
{
  this->Coordinate_ = x;
}

void LineSet::
Coordinate (::std::auto_ptr< Coordinate_type > x)
{
  this->Coordinate_.set (x);
}

const LineSet::CoordinateDouble_optional& LineSet::
CoordinateDouble () const
{
  return this->CoordinateDouble_;
}

LineSet::CoordinateDouble_optional& LineSet::
CoordinateDouble ()
{
  return this->CoordinateDouble_;
}

void LineSet::
CoordinateDouble (const CoordinateDouble_type& x)
{
  this->CoordinateDouble_.set (x);
}

void LineSet::
CoordinateDouble (const CoordinateDouble_optional& x)
{
  this->CoordinateDouble_ = x;
}

void LineSet::
CoordinateDouble (::std::auto_ptr< CoordinateDouble_type > x)
{
  this->CoordinateDouble_.set (x);
}

const LineSet::GeoCoordinate_optional& LineSet::
GeoCoordinate () const
{
  return this->GeoCoordinate_;
}

LineSet::GeoCoordinate_optional& LineSet::
GeoCoordinate ()
{
  return this->GeoCoordinate_;
}

void LineSet::
GeoCoordinate (const GeoCoordinate_type& x)
{
  this->GeoCoordinate_.set (x);
}

void LineSet::
GeoCoordinate (const GeoCoordinate_optional& x)
{
  this->GeoCoordinate_ = x;
}

void LineSet::
GeoCoordinate (::std::auto_ptr< GeoCoordinate_type > x)
{
  this->GeoCoordinate_.set (x);
}

const LineSet::ProtoInstance_sequence& LineSet::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

LineSet::ProtoInstance_sequence& LineSet::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void LineSet::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const LineSet::vertexCount_optional& LineSet::
vertexCount () const
{
  return this->vertexCount_;
}

LineSet::vertexCount_optional& LineSet::
vertexCount ()
{
  return this->vertexCount_;
}

void LineSet::
vertexCount (const vertexCount_type& x)
{
  this->vertexCount_.set (x);
}

void LineSet::
vertexCount (const vertexCount_optional& x)
{
  this->vertexCount_ = x;
}

void LineSet::
vertexCount (::std::auto_ptr< vertexCount_type > x)
{
  this->vertexCount_.set (x);
}


// LoadSensor
// 

const LoadSensor::timeOut_type& LoadSensor::
timeOut () const
{
  return this->timeOut_.get ();
}

LoadSensor::timeOut_type& LoadSensor::
timeOut ()
{
  return this->timeOut_.get ();
}

void LoadSensor::
timeOut (const timeOut_type& x)
{
  this->timeOut_.set (x);
}

void LoadSensor::
timeOut (::std::auto_ptr< timeOut_type > x)
{
  this->timeOut_.set (x);
}

const LoadSensor::timeOut_type& LoadSensor::
timeOut_default_value ()
{
  return timeOut_default_value_;
}


// LocalFog
// 

const LocalFog::enabled_type& LocalFog::
enabled () const
{
  return this->enabled_.get ();
}

LocalFog::enabled_type& LocalFog::
enabled ()
{
  return this->enabled_.get ();
}

void LocalFog::
enabled (const enabled_type& x)
{
  this->enabled_.set (x);
}

void LocalFog::
enabled (::std::auto_ptr< enabled_type > x)
{
  this->enabled_.set (x);
}

const LocalFog::enabled_type& LocalFog::
enabled_default_value ()
{
  return enabled_default_value_;
}

const LocalFog::color_type& LocalFog::
color () const
{
  return this->color_.get ();
}

LocalFog::color_type& LocalFog::
color ()
{
  return this->color_.get ();
}

void LocalFog::
color (const color_type& x)
{
  this->color_.set (x);
}

void LocalFog::
color (::std::auto_ptr< color_type > x)
{
  this->color_.set (x);
}

const LocalFog::color_type& LocalFog::
color_default_value ()
{
  return color_default_value_;
}

const LocalFog::fogType_type& LocalFog::
fogType () const
{
  return this->fogType_.get ();
}

LocalFog::fogType_type& LocalFog::
fogType ()
{
  return this->fogType_.get ();
}

void LocalFog::
fogType (const fogType_type& x)
{
  this->fogType_.set (x);
}

void LocalFog::
fogType (::std::auto_ptr< fogType_type > x)
{
  this->fogType_.set (x);
}

const LocalFog::fogType_type& LocalFog::
fogType_default_value ()
{
  return fogType_default_value_;
}

const LocalFog::visibilityRange_type& LocalFog::
visibilityRange () const
{
  return this->visibilityRange_.get ();
}

LocalFog::visibilityRange_type& LocalFog::
visibilityRange ()
{
  return this->visibilityRange_.get ();
}

void LocalFog::
visibilityRange (const visibilityRange_type& x)
{
  this->visibilityRange_.set (x);
}

void LocalFog::
visibilityRange (::std::auto_ptr< visibilityRange_type > x)
{
  this->visibilityRange_.set (x);
}

const LocalFog::visibilityRange_type& LocalFog::
visibilityRange_default_value ()
{
  return visibilityRange_default_value_;
}


// LOD
// 

const LOD::forceTransitions_type& LOD::
forceTransitions () const
{
  return this->forceTransitions_.get ();
}

LOD::forceTransitions_type& LOD::
forceTransitions ()
{
  return this->forceTransitions_.get ();
}

void LOD::
forceTransitions (const forceTransitions_type& x)
{
  this->forceTransitions_.set (x);
}

void LOD::
forceTransitions (::std::auto_ptr< forceTransitions_type > x)
{
  this->forceTransitions_.set (x);
}

const LOD::forceTransitions_type& LOD::
forceTransitions_default_value ()
{
  return forceTransitions_default_value_;
}

const LOD::center_type& LOD::
center () const
{
  return this->center_.get ();
}

LOD::center_type& LOD::
center ()
{
  return this->center_.get ();
}

void LOD::
center (const center_type& x)
{
  this->center_.set (x);
}

void LOD::
center (::std::auto_ptr< center_type > x)
{
  this->center_.set (x);
}

const LOD::center_type& LOD::
center_default_value ()
{
  return center_default_value_;
}

const LOD::range_optional& LOD::
range () const
{
  return this->range_;
}

LOD::range_optional& LOD::
range ()
{
  return this->range_;
}

void LOD::
range (const range_type& x)
{
  this->range_.set (x);
}

void LOD::
range (const range_optional& x)
{
  this->range_ = x;
}

void LOD::
range (::std::auto_ptr< range_type > x)
{
  this->range_.set (x);
}


// Material
// 

const Material::ambientIntensity_type& Material::
ambientIntensity () const
{
  return this->ambientIntensity_.get ();
}

Material::ambientIntensity_type& Material::
ambientIntensity ()
{
  return this->ambientIntensity_.get ();
}

void Material::
ambientIntensity (const ambientIntensity_type& x)
{
  this->ambientIntensity_.set (x);
}

void Material::
ambientIntensity (::std::auto_ptr< ambientIntensity_type > x)
{
  this->ambientIntensity_.set (x);
}

const Material::ambientIntensity_type& Material::
ambientIntensity_default_value ()
{
  return ambientIntensity_default_value_;
}

const Material::diffuseColor_type& Material::
diffuseColor () const
{
  return this->diffuseColor_.get ();
}

Material::diffuseColor_type& Material::
diffuseColor ()
{
  return this->diffuseColor_.get ();
}

void Material::
diffuseColor (const diffuseColor_type& x)
{
  this->diffuseColor_.set (x);
}

void Material::
diffuseColor (::std::auto_ptr< diffuseColor_type > x)
{
  this->diffuseColor_.set (x);
}

const Material::diffuseColor_type& Material::
diffuseColor_default_value ()
{
  return diffuseColor_default_value_;
}

const Material::emissiveColor_type& Material::
emissiveColor () const
{
  return this->emissiveColor_.get ();
}

Material::emissiveColor_type& Material::
emissiveColor ()
{
  return this->emissiveColor_.get ();
}

void Material::
emissiveColor (const emissiveColor_type& x)
{
  this->emissiveColor_.set (x);
}

void Material::
emissiveColor (::std::auto_ptr< emissiveColor_type > x)
{
  this->emissiveColor_.set (x);
}

const Material::emissiveColor_type& Material::
emissiveColor_default_value ()
{
  return emissiveColor_default_value_;
}

const Material::shininess_type& Material::
shininess () const
{
  return this->shininess_.get ();
}

Material::shininess_type& Material::
shininess ()
{
  return this->shininess_.get ();
}

void Material::
shininess (const shininess_type& x)
{
  this->shininess_.set (x);
}

void Material::
shininess (::std::auto_ptr< shininess_type > x)
{
  this->shininess_.set (x);
}

const Material::shininess_type& Material::
shininess_default_value ()
{
  return shininess_default_value_;
}

const Material::specularColor_type& Material::
specularColor () const
{
  return this->specularColor_.get ();
}

Material::specularColor_type& Material::
specularColor ()
{
  return this->specularColor_.get ();
}

void Material::
specularColor (const specularColor_type& x)
{
  this->specularColor_.set (x);
}

void Material::
specularColor (::std::auto_ptr< specularColor_type > x)
{
  this->specularColor_.set (x);
}

const Material::specularColor_type& Material::
specularColor_default_value ()
{
  return specularColor_default_value_;
}

const Material::transparency_type& Material::
transparency () const
{
  return this->transparency_.get ();
}

Material::transparency_type& Material::
transparency ()
{
  return this->transparency_.get ();
}

void Material::
transparency (const transparency_type& x)
{
  this->transparency_.set (x);
}

void Material::
transparency (::std::auto_ptr< transparency_type > x)
{
  this->transparency_.set (x);
}

const Material::transparency_type& Material::
transparency_default_value ()
{
  return transparency_default_value_;
}


// MetadataDouble
// 

const MetadataDouble::value_optional& MetadataDouble::
value () const
{
  return this->value_;
}

MetadataDouble::value_optional& MetadataDouble::
value ()
{
  return this->value_;
}

void MetadataDouble::
value (const value_type& x)
{
  this->value_.set (x);
}

void MetadataDouble::
value (const value_optional& x)
{
  this->value_ = x;
}

void MetadataDouble::
value (::std::auto_ptr< value_type > x)
{
  this->value_.set (x);
}


// MetadataFloat
// 

const MetadataFloat::value_optional& MetadataFloat::
value () const
{
  return this->value_;
}

MetadataFloat::value_optional& MetadataFloat::
value ()
{
  return this->value_;
}

void MetadataFloat::
value (const value_type& x)
{
  this->value_.set (x);
}

void MetadataFloat::
value (const value_optional& x)
{
  this->value_ = x;
}

void MetadataFloat::
value (::std::auto_ptr< value_type > x)
{
  this->value_.set (x);
}


// MetadataInteger
// 

const MetadataInteger::value_optional& MetadataInteger::
value () const
{
  return this->value_;
}

MetadataInteger::value_optional& MetadataInteger::
value ()
{
  return this->value_;
}

void MetadataInteger::
value (const value_type& x)
{
  this->value_.set (x);
}

void MetadataInteger::
value (const value_optional& x)
{
  this->value_ = x;
}

void MetadataInteger::
value (::std::auto_ptr< value_type > x)
{
  this->value_.set (x);
}


// MetadataSet
// 

const MetadataSet::IS_optional& MetadataSet::
IS () const
{
  return this->IS_;
}

MetadataSet::IS_optional& MetadataSet::
IS ()
{
  return this->IS_;
}

void MetadataSet::
IS (const IS_type& x)
{
  this->IS_.set (x);
}

void MetadataSet::
IS (const IS_optional& x)
{
  this->IS_ = x;
}

void MetadataSet::
IS (::std::auto_ptr< IS_type > x)
{
  this->IS_.set (x);
}

const MetadataSet::MetadataDouble_sequence& MetadataSet::
MetadataDouble () const
{
  return this->MetadataDouble_;
}

MetadataSet::MetadataDouble_sequence& MetadataSet::
MetadataDouble ()
{
  return this->MetadataDouble_;
}

void MetadataSet::
MetadataDouble (const MetadataDouble_sequence& s)
{
  this->MetadataDouble_ = s;
}

const MetadataSet::MetadataFloat_sequence& MetadataSet::
MetadataFloat () const
{
  return this->MetadataFloat_;
}

MetadataSet::MetadataFloat_sequence& MetadataSet::
MetadataFloat ()
{
  return this->MetadataFloat_;
}

void MetadataSet::
MetadataFloat (const MetadataFloat_sequence& s)
{
  this->MetadataFloat_ = s;
}

const MetadataSet::MetadataInteger_sequence& MetadataSet::
MetadataInteger () const
{
  return this->MetadataInteger_;
}

MetadataSet::MetadataInteger_sequence& MetadataSet::
MetadataInteger ()
{
  return this->MetadataInteger_;
}

void MetadataSet::
MetadataInteger (const MetadataInteger_sequence& s)
{
  this->MetadataInteger_ = s;
}

const MetadataSet::MetadataSet1_sequence& MetadataSet::
MetadataSet1 () const
{
  return this->MetadataSet1_;
}

MetadataSet::MetadataSet1_sequence& MetadataSet::
MetadataSet1 ()
{
  return this->MetadataSet1_;
}

void MetadataSet::
MetadataSet1 (const MetadataSet1_sequence& s)
{
  this->MetadataSet1_ = s;
}

const MetadataSet::MetadataString_sequence& MetadataSet::
MetadataString () const
{
  return this->MetadataString_;
}

MetadataSet::MetadataString_sequence& MetadataSet::
MetadataString ()
{
  return this->MetadataString_;
}

void MetadataSet::
MetadataString (const MetadataString_sequence& s)
{
  this->MetadataString_ = s;
}

const MetadataSet::DEF_optional& MetadataSet::
DEF () const
{
  return this->DEF_;
}

MetadataSet::DEF_optional& MetadataSet::
DEF ()
{
  return this->DEF_;
}

void MetadataSet::
DEF (const DEF_type& x)
{
  this->DEF_.set (x);
}

void MetadataSet::
DEF (const DEF_optional& x)
{
  this->DEF_ = x;
}

void MetadataSet::
DEF (::std::auto_ptr< DEF_type > x)
{
  this->DEF_.set (x);
}

const MetadataSet::USE_optional& MetadataSet::
USE () const
{
  return this->USE_;
}

MetadataSet::USE_optional& MetadataSet::
USE ()
{
  return this->USE_;
}

void MetadataSet::
USE (const USE_type& x)
{
  this->USE_.set (x);
}

void MetadataSet::
USE (const USE_optional& x)
{
  this->USE_ = x;
}

void MetadataSet::
USE (::std::auto_ptr< USE_type > x)
{
  this->USE_.set (x);
}

const MetadataSet::class_optional& MetadataSet::
class_ () const
{
  return this->class__;
}

MetadataSet::class_optional& MetadataSet::
class_ ()
{
  return this->class__;
}

void MetadataSet::
class_ (const class_type& x)
{
  this->class__.set (x);
}

void MetadataSet::
class_ (const class_optional& x)
{
  this->class__ = x;
}

void MetadataSet::
class_ (::std::auto_ptr< class_type > x)
{
  this->class__.set (x);
}

const MetadataSet::name_optional& MetadataSet::
name () const
{
  return this->name_;
}

MetadataSet::name_optional& MetadataSet::
name ()
{
  return this->name_;
}

void MetadataSet::
name (const name_type& x)
{
  this->name_.set (x);
}

void MetadataSet::
name (const name_optional& x)
{
  this->name_ = x;
}

void MetadataSet::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const MetadataSet::reference_optional& MetadataSet::
reference () const
{
  return this->reference_;
}

MetadataSet::reference_optional& MetadataSet::
reference ()
{
  return this->reference_;
}

void MetadataSet::
reference (const reference_type& x)
{
  this->reference_.set (x);
}

void MetadataSet::
reference (const reference_optional& x)
{
  this->reference_ = x;
}

void MetadataSet::
reference (::std::auto_ptr< reference_type > x)
{
  this->reference_.set (x);
}

const MetadataSet::containerField_type& MetadataSet::
containerField () const
{
  return this->containerField_.get ();
}

MetadataSet::containerField_type& MetadataSet::
containerField ()
{
  return this->containerField_.get ();
}

void MetadataSet::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void MetadataSet::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const MetadataSet::containerField_type& MetadataSet::
containerField_default_value ()
{
  return containerField_default_value_;
}


// MetadataString
// 

const MetadataString::value_optional& MetadataString::
value () const
{
  return this->value_;
}

MetadataString::value_optional& MetadataString::
value ()
{
  return this->value_;
}

void MetadataString::
value (const value_type& x)
{
  this->value_.set (x);
}

void MetadataString::
value (const value_optional& x)
{
  this->value_ = x;
}

void MetadataString::
value (::std::auto_ptr< value_type > x)
{
  this->value_.set (x);
}


// MovieTexture
// 

const MovieTexture::description_optional& MovieTexture::
description () const
{
  return this->description_;
}

MovieTexture::description_optional& MovieTexture::
description ()
{
  return this->description_;
}

void MovieTexture::
description (const description_type& x)
{
  this->description_.set (x);
}

void MovieTexture::
description (const description_optional& x)
{
  this->description_ = x;
}

void MovieTexture::
description (::std::auto_ptr< description_type > x)
{
  this->description_.set (x);
}

const MovieTexture::url_optional& MovieTexture::
url () const
{
  return this->url_;
}

MovieTexture::url_optional& MovieTexture::
url ()
{
  return this->url_;
}

void MovieTexture::
url (const url_type& x)
{
  this->url_.set (x);
}

void MovieTexture::
url (const url_optional& x)
{
  this->url_ = x;
}

void MovieTexture::
url (::std::auto_ptr< url_type > x)
{
  this->url_.set (x);
}

const MovieTexture::repeatS_type& MovieTexture::
repeatS () const
{
  return this->repeatS_.get ();
}

MovieTexture::repeatS_type& MovieTexture::
repeatS ()
{
  return this->repeatS_.get ();
}

void MovieTexture::
repeatS (const repeatS_type& x)
{
  this->repeatS_.set (x);
}

void MovieTexture::
repeatS (::std::auto_ptr< repeatS_type > x)
{
  this->repeatS_.set (x);
}

const MovieTexture::repeatS_type& MovieTexture::
repeatS_default_value ()
{
  return repeatS_default_value_;
}

const MovieTexture::repeatT_type& MovieTexture::
repeatT () const
{
  return this->repeatT_.get ();
}

MovieTexture::repeatT_type& MovieTexture::
repeatT ()
{
  return this->repeatT_.get ();
}

void MovieTexture::
repeatT (const repeatT_type& x)
{
  this->repeatT_.set (x);
}

void MovieTexture::
repeatT (::std::auto_ptr< repeatT_type > x)
{
  this->repeatT_.set (x);
}

const MovieTexture::repeatT_type& MovieTexture::
repeatT_default_value ()
{
  return repeatT_default_value_;
}

const MovieTexture::speed_type& MovieTexture::
speed () const
{
  return this->speed_.get ();
}

MovieTexture::speed_type& MovieTexture::
speed ()
{
  return this->speed_.get ();
}

void MovieTexture::
speed (const speed_type& x)
{
  this->speed_.set (x);
}

void MovieTexture::
speed (::std::auto_ptr< speed_type > x)
{
  this->speed_.set (x);
}

const MovieTexture::speed_type& MovieTexture::
speed_default_value ()
{
  return speed_default_value_;
}


// MultiTexture
// 

const MultiTexture::ImageTexture_sequence& MultiTexture::
ImageTexture () const
{
  return this->ImageTexture_;
}

MultiTexture::ImageTexture_sequence& MultiTexture::
ImageTexture ()
{
  return this->ImageTexture_;
}

void MultiTexture::
ImageTexture (const ImageTexture_sequence& s)
{
  this->ImageTexture_ = s;
}

const MultiTexture::MovieTexture_sequence& MultiTexture::
MovieTexture () const
{
  return this->MovieTexture_;
}

MultiTexture::MovieTexture_sequence& MultiTexture::
MovieTexture ()
{
  return this->MovieTexture_;
}

void MultiTexture::
MovieTexture (const MovieTexture_sequence& s)
{
  this->MovieTexture_ = s;
}

const MultiTexture::PixelTexture_sequence& MultiTexture::
PixelTexture () const
{
  return this->PixelTexture_;
}

MultiTexture::PixelTexture_sequence& MultiTexture::
PixelTexture ()
{
  return this->PixelTexture_;
}

void MultiTexture::
PixelTexture (const PixelTexture_sequence& s)
{
  this->PixelTexture_ = s;
}

const MultiTexture::ProtoInstance_sequence& MultiTexture::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

MultiTexture::ProtoInstance_sequence& MultiTexture::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void MultiTexture::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const MultiTexture::alpha_type& MultiTexture::
alpha () const
{
  return this->alpha_.get ();
}

MultiTexture::alpha_type& MultiTexture::
alpha ()
{
  return this->alpha_.get ();
}

void MultiTexture::
alpha (const alpha_type& x)
{
  this->alpha_.set (x);
}

void MultiTexture::
alpha (::std::auto_ptr< alpha_type > x)
{
  this->alpha_.set (x);
}

const MultiTexture::alpha_type& MultiTexture::
alpha_default_value ()
{
  return alpha_default_value_;
}

const MultiTexture::color_type& MultiTexture::
color () const
{
  return this->color_.get ();
}

MultiTexture::color_type& MultiTexture::
color ()
{
  return this->color_.get ();
}

void MultiTexture::
color (const color_type& x)
{
  this->color_.set (x);
}

void MultiTexture::
color (::std::auto_ptr< color_type > x)
{
  this->color_.set (x);
}

const MultiTexture::color_type& MultiTexture::
color_default_value ()
{
  return color_default_value_;
}

const MultiTexture::function_optional& MultiTexture::
function () const
{
  return this->function_;
}

MultiTexture::function_optional& MultiTexture::
function ()
{
  return this->function_;
}

void MultiTexture::
function (const function_type& x)
{
  this->function_.set (x);
}

void MultiTexture::
function (const function_optional& x)
{
  this->function_ = x;
}

void MultiTexture::
function (::std::auto_ptr< function_type > x)
{
  this->function_.set (x);
}

const MultiTexture::mode_optional& MultiTexture::
mode () const
{
  return this->mode_;
}

MultiTexture::mode_optional& MultiTexture::
mode ()
{
  return this->mode_;
}

void MultiTexture::
mode (const mode_type& x)
{
  this->mode_.set (x);
}

void MultiTexture::
mode (const mode_optional& x)
{
  this->mode_ = x;
}

void MultiTexture::
mode (::std::auto_ptr< mode_type > x)
{
  this->mode_.set (x);
}

const MultiTexture::source_optional& MultiTexture::
source () const
{
  return this->source_;
}

MultiTexture::source_optional& MultiTexture::
source ()
{
  return this->source_;
}

void MultiTexture::
source (const source_type& x)
{
  this->source_.set (x);
}

void MultiTexture::
source (const source_optional& x)
{
  this->source_ = x;
}

void MultiTexture::
source (::std::auto_ptr< source_type > x)
{
  this->source_.set (x);
}

const MultiTexture::transparent_type& MultiTexture::
transparent () const
{
  return this->transparent_.get ();
}

MultiTexture::transparent_type& MultiTexture::
transparent ()
{
  return this->transparent_.get ();
}

void MultiTexture::
transparent (const transparent_type& x)
{
  this->transparent_.set (x);
}

void MultiTexture::
transparent (::std::auto_ptr< transparent_type > x)
{
  this->transparent_.set (x);
}

const MultiTexture::transparent_type& MultiTexture::
transparent_default_value ()
{
  return transparent_default_value_;
}


// MultiTextureCoordinate
// 


// MultiTextureTransform
// 

const MultiTextureTransform::TextureTransform_sequence& MultiTextureTransform::
TextureTransform () const
{
  return this->TextureTransform_;
}

MultiTextureTransform::TextureTransform_sequence& MultiTextureTransform::
TextureTransform ()
{
  return this->TextureTransform_;
}

void MultiTextureTransform::
TextureTransform (const TextureTransform_sequence& s)
{
  this->TextureTransform_ = s;
}

const MultiTextureTransform::ProtoInstance_sequence& MultiTextureTransform::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

MultiTextureTransform::ProtoInstance_sequence& MultiTextureTransform::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void MultiTextureTransform::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}


// NavigationInfo
// 

const NavigationInfo::avatarSize_type& NavigationInfo::
avatarSize () const
{
  return this->avatarSize_.get ();
}

NavigationInfo::avatarSize_type& NavigationInfo::
avatarSize ()
{
  return this->avatarSize_.get ();
}

void NavigationInfo::
avatarSize (const avatarSize_type& x)
{
  this->avatarSize_.set (x);
}

void NavigationInfo::
avatarSize (::std::auto_ptr< avatarSize_type > x)
{
  this->avatarSize_.set (x);
}

const NavigationInfo::avatarSize_type& NavigationInfo::
avatarSize_default_value ()
{
  return avatarSize_default_value_;
}

const NavigationInfo::headlight_type& NavigationInfo::
headlight () const
{
  return this->headlight_.get ();
}

NavigationInfo::headlight_type& NavigationInfo::
headlight ()
{
  return this->headlight_.get ();
}

void NavigationInfo::
headlight (const headlight_type& x)
{
  this->headlight_.set (x);
}

void NavigationInfo::
headlight (::std::auto_ptr< headlight_type > x)
{
  this->headlight_.set (x);
}

const NavigationInfo::headlight_type& NavigationInfo::
headlight_default_value ()
{
  return headlight_default_value_;
}

const NavigationInfo::speed_type& NavigationInfo::
speed () const
{
  return this->speed_.get ();
}

NavigationInfo::speed_type& NavigationInfo::
speed ()
{
  return this->speed_.get ();
}

void NavigationInfo::
speed (const speed_type& x)
{
  this->speed_.set (x);
}

void NavigationInfo::
speed (::std::auto_ptr< speed_type > x)
{
  this->speed_.set (x);
}

const NavigationInfo::speed_type& NavigationInfo::
speed_default_value ()
{
  return speed_default_value_;
}

const NavigationInfo::type_type& NavigationInfo::
type () const
{
  return this->type_.get ();
}

NavigationInfo::type_type& NavigationInfo::
type ()
{
  return this->type_.get ();
}

void NavigationInfo::
type (const type_type& x)
{
  this->type_.set (x);
}

void NavigationInfo::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const NavigationInfo::type_type& NavigationInfo::
type_default_value ()
{
  return type_default_value_;
}

const NavigationInfo::transitionType_type& NavigationInfo::
transitionType () const
{
  return this->transitionType_.get ();
}

NavigationInfo::transitionType_type& NavigationInfo::
transitionType ()
{
  return this->transitionType_.get ();
}

void NavigationInfo::
transitionType (const transitionType_type& x)
{
  this->transitionType_.set (x);
}

void NavigationInfo::
transitionType (::std::auto_ptr< transitionType_type > x)
{
  this->transitionType_.set (x);
}

const NavigationInfo::transitionType_type& NavigationInfo::
transitionType_default_value ()
{
  return transitionType_default_value_;
}

const NavigationInfo::transitionTime_type& NavigationInfo::
transitionTime () const
{
  return this->transitionTime_.get ();
}

NavigationInfo::transitionTime_type& NavigationInfo::
transitionTime ()
{
  return this->transitionTime_.get ();
}

void NavigationInfo::
transitionTime (const transitionTime_type& x)
{
  this->transitionTime_.set (x);
}

void NavigationInfo::
transitionTime (::std::auto_ptr< transitionTime_type > x)
{
  this->transitionTime_.set (x);
}

const NavigationInfo::transitionTime_type& NavigationInfo::
transitionTime_default_value ()
{
  return transitionTime_default_value_;
}

const NavigationInfo::visibilityLimit_type& NavigationInfo::
visibilityLimit () const
{
  return this->visibilityLimit_.get ();
}

NavigationInfo::visibilityLimit_type& NavigationInfo::
visibilityLimit ()
{
  return this->visibilityLimit_.get ();
}

void NavigationInfo::
visibilityLimit (const visibilityLimit_type& x)
{
  this->visibilityLimit_.set (x);
}

void NavigationInfo::
visibilityLimit (::std::auto_ptr< visibilityLimit_type > x)
{
  this->visibilityLimit_.set (x);
}

const NavigationInfo::visibilityLimit_type& NavigationInfo::
visibilityLimit_default_value ()
{
  return visibilityLimit_default_value_;
}


// Normal
// 

const Normal::vector_optional& Normal::
vector () const
{
  return this->vector_;
}

Normal::vector_optional& Normal::
vector ()
{
  return this->vector_;
}

void Normal::
vector (const vector_type& x)
{
  this->vector_.set (x);
}

void Normal::
vector (const vector_optional& x)
{
  this->vector_ = x;
}

void Normal::
vector (::std::auto_ptr< vector_type > x)
{
  this->vector_.set (x);
}


// NormalInterpolator
// 

const NormalInterpolator::keyValue_optional& NormalInterpolator::
keyValue () const
{
  return this->keyValue_;
}

NormalInterpolator::keyValue_optional& NormalInterpolator::
keyValue ()
{
  return this->keyValue_;
}

void NormalInterpolator::
keyValue (const keyValue_type& x)
{
  this->keyValue_.set (x);
}

void NormalInterpolator::
keyValue (const keyValue_optional& x)
{
  this->keyValue_ = x;
}

void NormalInterpolator::
keyValue (::std::auto_ptr< keyValue_type > x)
{
  this->keyValue_.set (x);
}


// OrientationInterpolator
// 

const OrientationInterpolator::keyValue_optional& OrientationInterpolator::
keyValue () const
{
  return this->keyValue_;
}

OrientationInterpolator::keyValue_optional& OrientationInterpolator::
keyValue ()
{
  return this->keyValue_;
}

void OrientationInterpolator::
keyValue (const keyValue_type& x)
{
  this->keyValue_.set (x);
}

void OrientationInterpolator::
keyValue (const keyValue_optional& x)
{
  this->keyValue_ = x;
}

void OrientationInterpolator::
keyValue (::std::auto_ptr< keyValue_type > x)
{
  this->keyValue_.set (x);
}


// PixelTexture
// 

const PixelTexture::image_type& PixelTexture::
image () const
{
  return this->image_.get ();
}

PixelTexture::image_type& PixelTexture::
image ()
{
  return this->image_.get ();
}

void PixelTexture::
image (const image_type& x)
{
  this->image_.set (x);
}

void PixelTexture::
image (::std::auto_ptr< image_type > x)
{
  this->image_.set (x);
}

const PixelTexture::image_type& PixelTexture::
image_default_value ()
{
  return image_default_value_;
}


// PlaneSensor
// 

const PlaneSensor::maxPosition_type& PlaneSensor::
maxPosition () const
{
  return this->maxPosition_.get ();
}

PlaneSensor::maxPosition_type& PlaneSensor::
maxPosition ()
{
  return this->maxPosition_.get ();
}

void PlaneSensor::
maxPosition (const maxPosition_type& x)
{
  this->maxPosition_.set (x);
}

void PlaneSensor::
maxPosition (::std::auto_ptr< maxPosition_type > x)
{
  this->maxPosition_.set (x);
}

const PlaneSensor::maxPosition_type& PlaneSensor::
maxPosition_default_value ()
{
  return maxPosition_default_value_;
}

const PlaneSensor::minPosition_type& PlaneSensor::
minPosition () const
{
  return this->minPosition_.get ();
}

PlaneSensor::minPosition_type& PlaneSensor::
minPosition ()
{
  return this->minPosition_.get ();
}

void PlaneSensor::
minPosition (const minPosition_type& x)
{
  this->minPosition_.set (x);
}

void PlaneSensor::
minPosition (::std::auto_ptr< minPosition_type > x)
{
  this->minPosition_.set (x);
}

const PlaneSensor::minPosition_type& PlaneSensor::
minPosition_default_value ()
{
  return minPosition_default_value_;
}

const PlaneSensor::offset_type& PlaneSensor::
offset () const
{
  return this->offset_.get ();
}

PlaneSensor::offset_type& PlaneSensor::
offset ()
{
  return this->offset_.get ();
}

void PlaneSensor::
offset (const offset_type& x)
{
  this->offset_.set (x);
}

void PlaneSensor::
offset (::std::auto_ptr< offset_type > x)
{
  this->offset_.set (x);
}

const PlaneSensor::offset_type& PlaneSensor::
offset_default_value ()
{
  return offset_default_value_;
}


// PointLight
// 

const PointLight::attenuation_type& PointLight::
attenuation () const
{
  return this->attenuation_.get ();
}

PointLight::attenuation_type& PointLight::
attenuation ()
{
  return this->attenuation_.get ();
}

void PointLight::
attenuation (const attenuation_type& x)
{
  this->attenuation_.set (x);
}

void PointLight::
attenuation (::std::auto_ptr< attenuation_type > x)
{
  this->attenuation_.set (x);
}

const PointLight::attenuation_type& PointLight::
attenuation_default_value ()
{
  return attenuation_default_value_;
}

const PointLight::location_type& PointLight::
location () const
{
  return this->location_.get ();
}

PointLight::location_type& PointLight::
location ()
{
  return this->location_.get ();
}

void PointLight::
location (const location_type& x)
{
  this->location_.set (x);
}

void PointLight::
location (::std::auto_ptr< location_type > x)
{
  this->location_.set (x);
}

const PointLight::location_type& PointLight::
location_default_value ()
{
  return location_default_value_;
}

const PointLight::radius_type& PointLight::
radius () const
{
  return this->radius_.get ();
}

PointLight::radius_type& PointLight::
radius ()
{
  return this->radius_.get ();
}

void PointLight::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void PointLight::
radius (::std::auto_ptr< radius_type > x)
{
  this->radius_.set (x);
}

const PointLight::radius_type& PointLight::
radius_default_value ()
{
  return radius_default_value_;
}

const PointLight::global_type& PointLight::
global () const
{
  return this->global_.get ();
}

PointLight::global_type& PointLight::
global ()
{
  return this->global_.get ();
}

void PointLight::
global (const global_type& x)
{
  this->global_.set (x);
}

void PointLight::
global (::std::auto_ptr< global_type > x)
{
  this->global_.set (x);
}

const PointLight::global_type& PointLight::
global_default_value ()
{
  return global_default_value_;
}


// PointSet
// 

const PointSet::Color_optional& PointSet::
Color () const
{
  return this->Color_;
}

PointSet::Color_optional& PointSet::
Color ()
{
  return this->Color_;
}

void PointSet::
Color (const Color_type& x)
{
  this->Color_.set (x);
}

void PointSet::
Color (const Color_optional& x)
{
  this->Color_ = x;
}

void PointSet::
Color (::std::auto_ptr< Color_type > x)
{
  this->Color_.set (x);
}

const PointSet::ColorRGBA_optional& PointSet::
ColorRGBA () const
{
  return this->ColorRGBA_;
}

PointSet::ColorRGBA_optional& PointSet::
ColorRGBA ()
{
  return this->ColorRGBA_;
}

void PointSet::
ColorRGBA (const ColorRGBA_type& x)
{
  this->ColorRGBA_.set (x);
}

void PointSet::
ColorRGBA (const ColorRGBA_optional& x)
{
  this->ColorRGBA_ = x;
}

void PointSet::
ColorRGBA (::std::auto_ptr< ColorRGBA_type > x)
{
  this->ColorRGBA_.set (x);
}

const PointSet::Coordinate_optional& PointSet::
Coordinate () const
{
  return this->Coordinate_;
}

PointSet::Coordinate_optional& PointSet::
Coordinate ()
{
  return this->Coordinate_;
}

void PointSet::
Coordinate (const Coordinate_type& x)
{
  this->Coordinate_.set (x);
}

void PointSet::
Coordinate (const Coordinate_optional& x)
{
  this->Coordinate_ = x;
}

void PointSet::
Coordinate (::std::auto_ptr< Coordinate_type > x)
{
  this->Coordinate_.set (x);
}

const PointSet::CoordinateDouble_optional& PointSet::
CoordinateDouble () const
{
  return this->CoordinateDouble_;
}

PointSet::CoordinateDouble_optional& PointSet::
CoordinateDouble ()
{
  return this->CoordinateDouble_;
}

void PointSet::
CoordinateDouble (const CoordinateDouble_type& x)
{
  this->CoordinateDouble_.set (x);
}

void PointSet::
CoordinateDouble (const CoordinateDouble_optional& x)
{
  this->CoordinateDouble_ = x;
}

void PointSet::
CoordinateDouble (::std::auto_ptr< CoordinateDouble_type > x)
{
  this->CoordinateDouble_.set (x);
}

const PointSet::GeoCoordinate_optional& PointSet::
GeoCoordinate () const
{
  return this->GeoCoordinate_;
}

PointSet::GeoCoordinate_optional& PointSet::
GeoCoordinate ()
{
  return this->GeoCoordinate_;
}

void PointSet::
GeoCoordinate (const GeoCoordinate_type& x)
{
  this->GeoCoordinate_.set (x);
}

void PointSet::
GeoCoordinate (const GeoCoordinate_optional& x)
{
  this->GeoCoordinate_ = x;
}

void PointSet::
GeoCoordinate (::std::auto_ptr< GeoCoordinate_type > x)
{
  this->GeoCoordinate_.set (x);
}

const PointSet::ProtoInstance_sequence& PointSet::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

PointSet::ProtoInstance_sequence& PointSet::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void PointSet::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}


// Polyline2D
// 

const Polyline2D::lineSegments_optional& Polyline2D::
lineSegments () const
{
  return this->lineSegments_;
}

Polyline2D::lineSegments_optional& Polyline2D::
lineSegments ()
{
  return this->lineSegments_;
}

void Polyline2D::
lineSegments (const lineSegments_type& x)
{
  this->lineSegments_.set (x);
}

void Polyline2D::
lineSegments (const lineSegments_optional& x)
{
  this->lineSegments_ = x;
}

void Polyline2D::
lineSegments (::std::auto_ptr< lineSegments_type > x)
{
  this->lineSegments_.set (x);
}


// Polypoint2D
// 

const Polypoint2D::point_optional& Polypoint2D::
point () const
{
  return this->point_;
}

Polypoint2D::point_optional& Polypoint2D::
point ()
{
  return this->point_;
}

void Polypoint2D::
point (const point_type& x)
{
  this->point_.set (x);
}

void Polypoint2D::
point (const point_optional& x)
{
  this->point_ = x;
}

void Polypoint2D::
point (::std::auto_ptr< point_type > x)
{
  this->point_.set (x);
}


// PositionInterpolator
// 

const PositionInterpolator::keyValue_optional& PositionInterpolator::
keyValue () const
{
  return this->keyValue_;
}

PositionInterpolator::keyValue_optional& PositionInterpolator::
keyValue ()
{
  return this->keyValue_;
}

void PositionInterpolator::
keyValue (const keyValue_type& x)
{
  this->keyValue_.set (x);
}

void PositionInterpolator::
keyValue (const keyValue_optional& x)
{
  this->keyValue_ = x;
}

void PositionInterpolator::
keyValue (::std::auto_ptr< keyValue_type > x)
{
  this->keyValue_.set (x);
}


// PositionInterpolator2D
// 

const PositionInterpolator2D::keyValue_optional& PositionInterpolator2D::
keyValue () const
{
  return this->keyValue_;
}

PositionInterpolator2D::keyValue_optional& PositionInterpolator2D::
keyValue ()
{
  return this->keyValue_;
}

void PositionInterpolator2D::
keyValue (const keyValue_type& x)
{
  this->keyValue_.set (x);
}

void PositionInterpolator2D::
keyValue (const keyValue_optional& x)
{
  this->keyValue_ = x;
}

void PositionInterpolator2D::
keyValue (::std::auto_ptr< keyValue_type > x)
{
  this->keyValue_.set (x);
}


// ProximitySensor
// 


// Rectangle2D
// 

const Rectangle2D::size_type& Rectangle2D::
size () const
{
  return this->size_.get ();
}

Rectangle2D::size_type& Rectangle2D::
size ()
{
  return this->size_.get ();
}

void Rectangle2D::
size (const size_type& x)
{
  this->size_.set (x);
}

void Rectangle2D::
size (::std::auto_ptr< size_type > x)
{
  this->size_.set (x);
}

const Rectangle2D::size_type& Rectangle2D::
size_default_value ()
{
  return size_default_value_;
}

const Rectangle2D::solid_type& Rectangle2D::
solid () const
{
  return this->solid_.get ();
}

Rectangle2D::solid_type& Rectangle2D::
solid ()
{
  return this->solid_.get ();
}

void Rectangle2D::
solid (const solid_type& x)
{
  this->solid_.set (x);
}

void Rectangle2D::
solid (::std::auto_ptr< solid_type > x)
{
  this->solid_.set (x);
}

const Rectangle2D::solid_type& Rectangle2D::
solid_default_value ()
{
  return solid_default_value_;
}


// ScalarInterpolator
// 

const ScalarInterpolator::keyValue_optional& ScalarInterpolator::
keyValue () const
{
  return this->keyValue_;
}

ScalarInterpolator::keyValue_optional& ScalarInterpolator::
keyValue ()
{
  return this->keyValue_;
}

void ScalarInterpolator::
keyValue (const keyValue_type& x)
{
  this->keyValue_.set (x);
}

void ScalarInterpolator::
keyValue (const keyValue_optional& x)
{
  this->keyValue_ = x;
}

void ScalarInterpolator::
keyValue (::std::auto_ptr< keyValue_type > x)
{
  this->keyValue_.set (x);
}


// Script
// 

const Script::directOutput_type& Script::
directOutput () const
{
  return this->directOutput_.get ();
}

Script::directOutput_type& Script::
directOutput ()
{
  return this->directOutput_.get ();
}

void Script::
directOutput (const directOutput_type& x)
{
  this->directOutput_.set (x);
}

void Script::
directOutput (::std::auto_ptr< directOutput_type > x)
{
  this->directOutput_.set (x);
}

const Script::directOutput_type& Script::
directOutput_default_value ()
{
  return directOutput_default_value_;
}

const Script::mustEvaluate_type& Script::
mustEvaluate () const
{
  return this->mustEvaluate_.get ();
}

Script::mustEvaluate_type& Script::
mustEvaluate ()
{
  return this->mustEvaluate_.get ();
}

void Script::
mustEvaluate (const mustEvaluate_type& x)
{
  this->mustEvaluate_.set (x);
}

void Script::
mustEvaluate (::std::auto_ptr< mustEvaluate_type > x)
{
  this->mustEvaluate_.set (x);
}

const Script::mustEvaluate_type& Script::
mustEvaluate_default_value ()
{
  return mustEvaluate_default_value_;
}

const Script::url_optional& Script::
url () const
{
  return this->url_;
}

Script::url_optional& Script::
url ()
{
  return this->url_;
}

void Script::
url (const url_type& x)
{
  this->url_.set (x);
}

void Script::
url (const url_optional& x)
{
  this->url_ = x;
}

void Script::
url (::std::auto_ptr< url_type > x)
{
  this->url_.set (x);
}


// Shape
// 


// Sound
// 

const Sound::direction_type& Sound::
direction () const
{
  return this->direction_.get ();
}

Sound::direction_type& Sound::
direction ()
{
  return this->direction_.get ();
}

void Sound::
direction (const direction_type& x)
{
  this->direction_.set (x);
}

void Sound::
direction (::std::auto_ptr< direction_type > x)
{
  this->direction_.set (x);
}

const Sound::direction_type& Sound::
direction_default_value ()
{
  return direction_default_value_;
}

const Sound::intensity_type& Sound::
intensity () const
{
  return this->intensity_.get ();
}

Sound::intensity_type& Sound::
intensity ()
{
  return this->intensity_.get ();
}

void Sound::
intensity (const intensity_type& x)
{
  this->intensity_.set (x);
}

void Sound::
intensity (::std::auto_ptr< intensity_type > x)
{
  this->intensity_.set (x);
}

const Sound::intensity_type& Sound::
intensity_default_value ()
{
  return intensity_default_value_;
}

const Sound::location_type& Sound::
location () const
{
  return this->location_.get ();
}

Sound::location_type& Sound::
location ()
{
  return this->location_.get ();
}

void Sound::
location (const location_type& x)
{
  this->location_.set (x);
}

void Sound::
location (::std::auto_ptr< location_type > x)
{
  this->location_.set (x);
}

const Sound::location_type& Sound::
location_default_value ()
{
  return location_default_value_;
}

const Sound::maxBack_type& Sound::
maxBack () const
{
  return this->maxBack_.get ();
}

Sound::maxBack_type& Sound::
maxBack ()
{
  return this->maxBack_.get ();
}

void Sound::
maxBack (const maxBack_type& x)
{
  this->maxBack_.set (x);
}

void Sound::
maxBack (::std::auto_ptr< maxBack_type > x)
{
  this->maxBack_.set (x);
}

const Sound::maxBack_type& Sound::
maxBack_default_value ()
{
  return maxBack_default_value_;
}

const Sound::maxFront_type& Sound::
maxFront () const
{
  return this->maxFront_.get ();
}

Sound::maxFront_type& Sound::
maxFront ()
{
  return this->maxFront_.get ();
}

void Sound::
maxFront (const maxFront_type& x)
{
  this->maxFront_.set (x);
}

void Sound::
maxFront (::std::auto_ptr< maxFront_type > x)
{
  this->maxFront_.set (x);
}

const Sound::maxFront_type& Sound::
maxFront_default_value ()
{
  return maxFront_default_value_;
}

const Sound::minBack_type& Sound::
minBack () const
{
  return this->minBack_.get ();
}

Sound::minBack_type& Sound::
minBack ()
{
  return this->minBack_.get ();
}

void Sound::
minBack (const minBack_type& x)
{
  this->minBack_.set (x);
}

void Sound::
minBack (::std::auto_ptr< minBack_type > x)
{
  this->minBack_.set (x);
}

const Sound::minBack_type& Sound::
minBack_default_value ()
{
  return minBack_default_value_;
}

const Sound::minFront_type& Sound::
minFront () const
{
  return this->minFront_.get ();
}

Sound::minFront_type& Sound::
minFront ()
{
  return this->minFront_.get ();
}

void Sound::
minFront (const minFront_type& x)
{
  this->minFront_.set (x);
}

void Sound::
minFront (::std::auto_ptr< minFront_type > x)
{
  this->minFront_.set (x);
}

const Sound::minFront_type& Sound::
minFront_default_value ()
{
  return minFront_default_value_;
}

const Sound::priority_type& Sound::
priority () const
{
  return this->priority_.get ();
}

Sound::priority_type& Sound::
priority ()
{
  return this->priority_.get ();
}

void Sound::
priority (const priority_type& x)
{
  this->priority_.set (x);
}

void Sound::
priority (::std::auto_ptr< priority_type > x)
{
  this->priority_.set (x);
}

const Sound::priority_type& Sound::
priority_default_value ()
{
  return priority_default_value_;
}

const Sound::spatialize_type& Sound::
spatialize () const
{
  return this->spatialize_.get ();
}

Sound::spatialize_type& Sound::
spatialize ()
{
  return this->spatialize_.get ();
}

void Sound::
spatialize (const spatialize_type& x)
{
  this->spatialize_.set (x);
}

void Sound::
spatialize (::std::auto_ptr< spatialize_type > x)
{
  this->spatialize_.set (x);
}

const Sound::spatialize_type& Sound::
spatialize_default_value ()
{
  return spatialize_default_value_;
}


// Sphere
// 

const Sphere::radius_type& Sphere::
radius () const
{
  return this->radius_.get ();
}

Sphere::radius_type& Sphere::
radius ()
{
  return this->radius_.get ();
}

void Sphere::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void Sphere::
radius (::std::auto_ptr< radius_type > x)
{
  this->radius_.set (x);
}

const Sphere::radius_type& Sphere::
radius_default_value ()
{
  return radius_default_value_;
}

const Sphere::solid_type& Sphere::
solid () const
{
  return this->solid_.get ();
}

Sphere::solid_type& Sphere::
solid ()
{
  return this->solid_.get ();
}

void Sphere::
solid (const solid_type& x)
{
  this->solid_.set (x);
}

void Sphere::
solid (::std::auto_ptr< solid_type > x)
{
  this->solid_.set (x);
}

const Sphere::solid_type& Sphere::
solid_default_value ()
{
  return solid_default_value_;
}


// SphereSensor
// 

const SphereSensor::offset_type& SphereSensor::
offset () const
{
  return this->offset_.get ();
}

SphereSensor::offset_type& SphereSensor::
offset ()
{
  return this->offset_.get ();
}

void SphereSensor::
offset (const offset_type& x)
{
  this->offset_.set (x);
}

void SphereSensor::
offset (::std::auto_ptr< offset_type > x)
{
  this->offset_.set (x);
}

const SphereSensor::offset_type& SphereSensor::
offset_default_value ()
{
  return offset_default_value_;
}


// SpotLight
// 

const SpotLight::attenuation_type& SpotLight::
attenuation () const
{
  return this->attenuation_.get ();
}

SpotLight::attenuation_type& SpotLight::
attenuation ()
{
  return this->attenuation_.get ();
}

void SpotLight::
attenuation (const attenuation_type& x)
{
  this->attenuation_.set (x);
}

void SpotLight::
attenuation (::std::auto_ptr< attenuation_type > x)
{
  this->attenuation_.set (x);
}

const SpotLight::attenuation_type& SpotLight::
attenuation_default_value ()
{
  return attenuation_default_value_;
}

const SpotLight::beamWidth_type& SpotLight::
beamWidth () const
{
  return this->beamWidth_.get ();
}

SpotLight::beamWidth_type& SpotLight::
beamWidth ()
{
  return this->beamWidth_.get ();
}

void SpotLight::
beamWidth (const beamWidth_type& x)
{
  this->beamWidth_.set (x);
}

void SpotLight::
beamWidth (::std::auto_ptr< beamWidth_type > x)
{
  this->beamWidth_.set (x);
}

const SpotLight::beamWidth_type& SpotLight::
beamWidth_default_value ()
{
  return beamWidth_default_value_;
}

const SpotLight::cutOffAngle_type& SpotLight::
cutOffAngle () const
{
  return this->cutOffAngle_.get ();
}

SpotLight::cutOffAngle_type& SpotLight::
cutOffAngle ()
{
  return this->cutOffAngle_.get ();
}

void SpotLight::
cutOffAngle (const cutOffAngle_type& x)
{
  this->cutOffAngle_.set (x);
}

void SpotLight::
cutOffAngle (::std::auto_ptr< cutOffAngle_type > x)
{
  this->cutOffAngle_.set (x);
}

const SpotLight::cutOffAngle_type& SpotLight::
cutOffAngle_default_value ()
{
  return cutOffAngle_default_value_;
}

const SpotLight::direction_type& SpotLight::
direction () const
{
  return this->direction_.get ();
}

SpotLight::direction_type& SpotLight::
direction ()
{
  return this->direction_.get ();
}

void SpotLight::
direction (const direction_type& x)
{
  this->direction_.set (x);
}

void SpotLight::
direction (::std::auto_ptr< direction_type > x)
{
  this->direction_.set (x);
}

const SpotLight::direction_type& SpotLight::
direction_default_value ()
{
  return direction_default_value_;
}

const SpotLight::location_type& SpotLight::
location () const
{
  return this->location_.get ();
}

SpotLight::location_type& SpotLight::
location ()
{
  return this->location_.get ();
}

void SpotLight::
location (const location_type& x)
{
  this->location_.set (x);
}

void SpotLight::
location (::std::auto_ptr< location_type > x)
{
  this->location_.set (x);
}

const SpotLight::location_type& SpotLight::
location_default_value ()
{
  return location_default_value_;
}

const SpotLight::radius_type& SpotLight::
radius () const
{
  return this->radius_.get ();
}

SpotLight::radius_type& SpotLight::
radius ()
{
  return this->radius_.get ();
}

void SpotLight::
radius (const radius_type& x)
{
  this->radius_.set (x);
}

void SpotLight::
radius (::std::auto_ptr< radius_type > x)
{
  this->radius_.set (x);
}

const SpotLight::radius_type& SpotLight::
radius_default_value ()
{
  return radius_default_value_;
}

const SpotLight::global_type& SpotLight::
global () const
{
  return this->global_.get ();
}

SpotLight::global_type& SpotLight::
global ()
{
  return this->global_.get ();
}

void SpotLight::
global (const global_type& x)
{
  this->global_.set (x);
}

void SpotLight::
global (::std::auto_ptr< global_type > x)
{
  this->global_.set (x);
}

const SpotLight::global_type& SpotLight::
global_default_value ()
{
  return global_default_value_;
}


// StaticGroup
// 


// StringSensor
// 

const StringSensor::deletionAllowed_type& StringSensor::
deletionAllowed () const
{
  return this->deletionAllowed_.get ();
}

StringSensor::deletionAllowed_type& StringSensor::
deletionAllowed ()
{
  return this->deletionAllowed_.get ();
}

void StringSensor::
deletionAllowed (const deletionAllowed_type& x)
{
  this->deletionAllowed_.set (x);
}

void StringSensor::
deletionAllowed (::std::auto_ptr< deletionAllowed_type > x)
{
  this->deletionAllowed_.set (x);
}

const StringSensor::deletionAllowed_type& StringSensor::
deletionAllowed_default_value ()
{
  return deletionAllowed_default_value_;
}


// Switch
// 

const Switch::whichChoice_type& Switch::
whichChoice () const
{
  return this->whichChoice_.get ();
}

Switch::whichChoice_type& Switch::
whichChoice ()
{
  return this->whichChoice_.get ();
}

void Switch::
whichChoice (const whichChoice_type& x)
{
  this->whichChoice_.set (x);
}

void Switch::
whichChoice (::std::auto_ptr< whichChoice_type > x)
{
  this->whichChoice_.set (x);
}

const Switch::whichChoice_type& Switch::
whichChoice_default_value ()
{
  return whichChoice_default_value_;
}


// Text
// 

const Text::FontStyle_optional& Text::
FontStyle () const
{
  return this->FontStyle_;
}

Text::FontStyle_optional& Text::
FontStyle ()
{
  return this->FontStyle_;
}

void Text::
FontStyle (const FontStyle_type& x)
{
  this->FontStyle_.set (x);
}

void Text::
FontStyle (const FontStyle_optional& x)
{
  this->FontStyle_ = x;
}

void Text::
FontStyle (::std::auto_ptr< FontStyle_type > x)
{
  this->FontStyle_.set (x);
}

const Text::ProtoInstance_optional& Text::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

Text::ProtoInstance_optional& Text::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void Text::
ProtoInstance (const ProtoInstance_type& x)
{
  this->ProtoInstance_.set (x);
}

void Text::
ProtoInstance (const ProtoInstance_optional& x)
{
  this->ProtoInstance_ = x;
}

void Text::
ProtoInstance (::std::auto_ptr< ProtoInstance_type > x)
{
  this->ProtoInstance_.set (x);
}

const Text::string_optional& Text::
string () const
{
  return this->string_;
}

Text::string_optional& Text::
string ()
{
  return this->string_;
}

void Text::
string (const string_type& x)
{
  this->string_.set (x);
}

void Text::
string (const string_optional& x)
{
  this->string_ = x;
}

void Text::
string (::std::auto_ptr< string_type > x)
{
  this->string_.set (x);
}

const Text::length_optional& Text::
length () const
{
  return this->length_;
}

Text::length_optional& Text::
length ()
{
  return this->length_;
}

void Text::
length (const length_type& x)
{
  this->length_.set (x);
}

void Text::
length (const length_optional& x)
{
  this->length_ = x;
}

void Text::
length (::std::auto_ptr< length_type > x)
{
  this->length_.set (x);
}

const Text::maxExtent_type& Text::
maxExtent () const
{
  return this->maxExtent_.get ();
}

Text::maxExtent_type& Text::
maxExtent ()
{
  return this->maxExtent_.get ();
}

void Text::
maxExtent (const maxExtent_type& x)
{
  this->maxExtent_.set (x);
}

void Text::
maxExtent (::std::auto_ptr< maxExtent_type > x)
{
  this->maxExtent_.set (x);
}

const Text::maxExtent_type& Text::
maxExtent_default_value ()
{
  return maxExtent_default_value_;
}

const Text::solid_type& Text::
solid () const
{
  return this->solid_.get ();
}

Text::solid_type& Text::
solid ()
{
  return this->solid_.get ();
}

void Text::
solid (const solid_type& x)
{
  this->solid_.set (x);
}

void Text::
solid (::std::auto_ptr< solid_type > x)
{
  this->solid_.set (x);
}

const Text::solid_type& Text::
solid_default_value ()
{
  return solid_default_value_;
}


// TextureBackground
// 

const TextureBackground::ImageTexture_sequence& TextureBackground::
ImageTexture () const
{
  return this->ImageTexture_;
}

TextureBackground::ImageTexture_sequence& TextureBackground::
ImageTexture ()
{
  return this->ImageTexture_;
}

void TextureBackground::
ImageTexture (const ImageTexture_sequence& s)
{
  this->ImageTexture_ = s;
}

const TextureBackground::MovieTexture_sequence& TextureBackground::
MovieTexture () const
{
  return this->MovieTexture_;
}

TextureBackground::MovieTexture_sequence& TextureBackground::
MovieTexture ()
{
  return this->MovieTexture_;
}

void TextureBackground::
MovieTexture (const MovieTexture_sequence& s)
{
  this->MovieTexture_ = s;
}

const TextureBackground::MultiTexture_sequence& TextureBackground::
MultiTexture () const
{
  return this->MultiTexture_;
}

TextureBackground::MultiTexture_sequence& TextureBackground::
MultiTexture ()
{
  return this->MultiTexture_;
}

void TextureBackground::
MultiTexture (const MultiTexture_sequence& s)
{
  this->MultiTexture_ = s;
}

const TextureBackground::PixelTexture_sequence& TextureBackground::
PixelTexture () const
{
  return this->PixelTexture_;
}

TextureBackground::PixelTexture_sequence& TextureBackground::
PixelTexture ()
{
  return this->PixelTexture_;
}

void TextureBackground::
PixelTexture (const PixelTexture_sequence& s)
{
  this->PixelTexture_ = s;
}

const TextureBackground::ProtoInstance_sequence& TextureBackground::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

TextureBackground::ProtoInstance_sequence& TextureBackground::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void TextureBackground::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const TextureBackground::transparency_type& TextureBackground::
transparency () const
{
  return this->transparency_.get ();
}

TextureBackground::transparency_type& TextureBackground::
transparency ()
{
  return this->transparency_.get ();
}

void TextureBackground::
transparency (const transparency_type& x)
{
  this->transparency_.set (x);
}

void TextureBackground::
transparency (::std::auto_ptr< transparency_type > x)
{
  this->transparency_.set (x);
}

const TextureBackground::transparency_type& TextureBackground::
transparency_default_value ()
{
  return transparency_default_value_;
}


// TextureCoordinate
// 

const TextureCoordinate::point_optional& TextureCoordinate::
point () const
{
  return this->point_;
}

TextureCoordinate::point_optional& TextureCoordinate::
point ()
{
  return this->point_;
}

void TextureCoordinate::
point (const point_type& x)
{
  this->point_.set (x);
}

void TextureCoordinate::
point (const point_optional& x)
{
  this->point_ = x;
}

void TextureCoordinate::
point (::std::auto_ptr< point_type > x)
{
  this->point_.set (x);
}


// TextureCoordinateGenerator
// 

const TextureCoordinateGenerator::mode_type& TextureCoordinateGenerator::
mode () const
{
  return this->mode_.get ();
}

TextureCoordinateGenerator::mode_type& TextureCoordinateGenerator::
mode ()
{
  return this->mode_.get ();
}

void TextureCoordinateGenerator::
mode (const mode_type& x)
{
  this->mode_.set (x);
}

void TextureCoordinateGenerator::
mode (::std::auto_ptr< mode_type > x)
{
  this->mode_.set (x);
}

const TextureCoordinateGenerator::mode_type& TextureCoordinateGenerator::
mode_default_value ()
{
  return mode_default_value_;
}

const TextureCoordinateGenerator::parameter_optional& TextureCoordinateGenerator::
parameter () const
{
  return this->parameter_;
}

TextureCoordinateGenerator::parameter_optional& TextureCoordinateGenerator::
parameter ()
{
  return this->parameter_;
}

void TextureCoordinateGenerator::
parameter (const parameter_type& x)
{
  this->parameter_.set (x);
}

void TextureCoordinateGenerator::
parameter (const parameter_optional& x)
{
  this->parameter_ = x;
}

void TextureCoordinateGenerator::
parameter (::std::auto_ptr< parameter_type > x)
{
  this->parameter_.set (x);
}


// TextureTransform
// 


// TimeSensor
// 

const TimeSensor::cycleInterval_type& TimeSensor::
cycleInterval () const
{
  return this->cycleInterval_.get ();
}

TimeSensor::cycleInterval_type& TimeSensor::
cycleInterval ()
{
  return this->cycleInterval_.get ();
}

void TimeSensor::
cycleInterval (const cycleInterval_type& x)
{
  this->cycleInterval_.set (x);
}

void TimeSensor::
cycleInterval (::std::auto_ptr< cycleInterval_type > x)
{
  this->cycleInterval_.set (x);
}

const TimeSensor::cycleInterval_type& TimeSensor::
cycleInterval_default_value ()
{
  return cycleInterval_default_value_;
}

const TimeSensor::enabled_type& TimeSensor::
enabled () const
{
  return this->enabled_.get ();
}

TimeSensor::enabled_type& TimeSensor::
enabled ()
{
  return this->enabled_.get ();
}

void TimeSensor::
enabled (const enabled_type& x)
{
  this->enabled_.set (x);
}

void TimeSensor::
enabled (::std::auto_ptr< enabled_type > x)
{
  this->enabled_.set (x);
}

const TimeSensor::enabled_type& TimeSensor::
enabled_default_value ()
{
  return enabled_default_value_;
}


// TimeTrigger
// 


// TouchSensor
// 


// Transform
// 

const Transform::center_type& Transform::
center () const
{
  return this->center_.get ();
}

Transform::center_type& Transform::
center ()
{
  return this->center_.get ();
}

void Transform::
center (const center_type& x)
{
  this->center_.set (x);
}

void Transform::
center (::std::auto_ptr< center_type > x)
{
  this->center_.set (x);
}

const Transform::center_type& Transform::
center_default_value ()
{
  return center_default_value_;
}

const Transform::rotation_type& Transform::
rotation () const
{
  return this->rotation_.get ();
}

Transform::rotation_type& Transform::
rotation ()
{
  return this->rotation_.get ();
}

void Transform::
rotation (const rotation_type& x)
{
  this->rotation_.set (x);
}

void Transform::
rotation (::std::auto_ptr< rotation_type > x)
{
  this->rotation_.set (x);
}

const Transform::rotation_type& Transform::
rotation_default_value ()
{
  return rotation_default_value_;
}

const Transform::scale_type& Transform::
scale () const
{
  return this->scale_.get ();
}

Transform::scale_type& Transform::
scale ()
{
  return this->scale_.get ();
}

void Transform::
scale (const scale_type& x)
{
  this->scale_.set (x);
}

void Transform::
scale (::std::auto_ptr< scale_type > x)
{
  this->scale_.set (x);
}

const Transform::scale_type& Transform::
scale_default_value ()
{
  return scale_default_value_;
}

const Transform::scaleOrientation_type& Transform::
scaleOrientation () const
{
  return this->scaleOrientation_.get ();
}

Transform::scaleOrientation_type& Transform::
scaleOrientation ()
{
  return this->scaleOrientation_.get ();
}

void Transform::
scaleOrientation (const scaleOrientation_type& x)
{
  this->scaleOrientation_.set (x);
}

void Transform::
scaleOrientation (::std::auto_ptr< scaleOrientation_type > x)
{
  this->scaleOrientation_.set (x);
}

const Transform::scaleOrientation_type& Transform::
scaleOrientation_default_value ()
{
  return scaleOrientation_default_value_;
}

const Transform::translation_type& Transform::
translation () const
{
  return this->translation_.get ();
}

Transform::translation_type& Transform::
translation ()
{
  return this->translation_.get ();
}

void Transform::
translation (const translation_type& x)
{
  this->translation_.set (x);
}

void Transform::
translation (::std::auto_ptr< translation_type > x)
{
  this->translation_.set (x);
}

const Transform::translation_type& Transform::
translation_default_value ()
{
  return translation_default_value_;
}


// TriangleFanSet
// 

const TriangleFanSet::fanCount_optional& TriangleFanSet::
fanCount () const
{
  return this->fanCount_;
}

TriangleFanSet::fanCount_optional& TriangleFanSet::
fanCount ()
{
  return this->fanCount_;
}

void TriangleFanSet::
fanCount (const fanCount_type& x)
{
  this->fanCount_.set (x);
}

void TriangleFanSet::
fanCount (const fanCount_optional& x)
{
  this->fanCount_ = x;
}

void TriangleFanSet::
fanCount (::std::auto_ptr< fanCount_type > x)
{
  this->fanCount_.set (x);
}


// TriangleSet
// 


// TriangleSet2D
// 

const TriangleSet2D::vertices_optional& TriangleSet2D::
vertices () const
{
  return this->vertices_;
}

TriangleSet2D::vertices_optional& TriangleSet2D::
vertices ()
{
  return this->vertices_;
}

void TriangleSet2D::
vertices (const vertices_type& x)
{
  this->vertices_.set (x);
}

void TriangleSet2D::
vertices (const vertices_optional& x)
{
  this->vertices_ = x;
}

void TriangleSet2D::
vertices (::std::auto_ptr< vertices_type > x)
{
  this->vertices_.set (x);
}

const TriangleSet2D::solid_type& TriangleSet2D::
solid () const
{
  return this->solid_.get ();
}

TriangleSet2D::solid_type& TriangleSet2D::
solid ()
{
  return this->solid_.get ();
}

void TriangleSet2D::
solid (const solid_type& x)
{
  this->solid_.set (x);
}

void TriangleSet2D::
solid (::std::auto_ptr< solid_type > x)
{
  this->solid_.set (x);
}

const TriangleSet2D::solid_type& TriangleSet2D::
solid_default_value ()
{
  return solid_default_value_;
}


// TriangleStripSet
// 

const TriangleStripSet::stripCount_optional& TriangleStripSet::
stripCount () const
{
  return this->stripCount_;
}

TriangleStripSet::stripCount_optional& TriangleStripSet::
stripCount ()
{
  return this->stripCount_;
}

void TriangleStripSet::
stripCount (const stripCount_type& x)
{
  this->stripCount_.set (x);
}

void TriangleStripSet::
stripCount (const stripCount_optional& x)
{
  this->stripCount_ = x;
}

void TriangleStripSet::
stripCount (::std::auto_ptr< stripCount_type > x)
{
  this->stripCount_.set (x);
}


// Viewpoint
// 

const Viewpoint::fieldOfView_type& Viewpoint::
fieldOfView () const
{
  return this->fieldOfView_.get ();
}

Viewpoint::fieldOfView_type& Viewpoint::
fieldOfView ()
{
  return this->fieldOfView_.get ();
}

void Viewpoint::
fieldOfView (const fieldOfView_type& x)
{
  this->fieldOfView_.set (x);
}

void Viewpoint::
fieldOfView (::std::auto_ptr< fieldOfView_type > x)
{
  this->fieldOfView_.set (x);
}

const Viewpoint::fieldOfView_type& Viewpoint::
fieldOfView_default_value ()
{
  return fieldOfView_default_value_;
}

const Viewpoint::jump_type& Viewpoint::
jump () const
{
  return this->jump_.get ();
}

Viewpoint::jump_type& Viewpoint::
jump ()
{
  return this->jump_.get ();
}

void Viewpoint::
jump (const jump_type& x)
{
  this->jump_.set (x);
}

void Viewpoint::
jump (::std::auto_ptr< jump_type > x)
{
  this->jump_.set (x);
}

const Viewpoint::jump_type& Viewpoint::
jump_default_value ()
{
  return jump_default_value_;
}

const Viewpoint::orientation_type& Viewpoint::
orientation () const
{
  return this->orientation_.get ();
}

Viewpoint::orientation_type& Viewpoint::
orientation ()
{
  return this->orientation_.get ();
}

void Viewpoint::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void Viewpoint::
orientation (::std::auto_ptr< orientation_type > x)
{
  this->orientation_.set (x);
}

const Viewpoint::orientation_type& Viewpoint::
orientation_default_value ()
{
  return orientation_default_value_;
}

const Viewpoint::position_type& Viewpoint::
position () const
{
  return this->position_.get ();
}

Viewpoint::position_type& Viewpoint::
position ()
{
  return this->position_.get ();
}

void Viewpoint::
position (const position_type& x)
{
  this->position_.set (x);
}

void Viewpoint::
position (::std::auto_ptr< position_type > x)
{
  this->position_.set (x);
}

const Viewpoint::position_type& Viewpoint::
position_default_value ()
{
  return position_default_value_;
}

const Viewpoint::description_optional& Viewpoint::
description () const
{
  return this->description_;
}

Viewpoint::description_optional& Viewpoint::
description ()
{
  return this->description_;
}

void Viewpoint::
description (const description_type& x)
{
  this->description_.set (x);
}

void Viewpoint::
description (const description_optional& x)
{
  this->description_ = x;
}

void Viewpoint::
description (::std::auto_ptr< description_type > x)
{
  this->description_.set (x);
}

const Viewpoint::centerOfRotation_type& Viewpoint::
centerOfRotation () const
{
  return this->centerOfRotation_.get ();
}

Viewpoint::centerOfRotation_type& Viewpoint::
centerOfRotation ()
{
  return this->centerOfRotation_.get ();
}

void Viewpoint::
centerOfRotation (const centerOfRotation_type& x)
{
  this->centerOfRotation_.set (x);
}

void Viewpoint::
centerOfRotation (::std::auto_ptr< centerOfRotation_type > x)
{
  this->centerOfRotation_.set (x);
}

const Viewpoint::centerOfRotation_type& Viewpoint::
centerOfRotation_default_value ()
{
  return centerOfRotation_default_value_;
}


// VisibilitySensor
// 


// WorldInfo
// 

const WorldInfo::info_optional& WorldInfo::
info () const
{
  return this->info_;
}

WorldInfo::info_optional& WorldInfo::
info ()
{
  return this->info_;
}

void WorldInfo::
info (const info_type& x)
{
  this->info_.set (x);
}

void WorldInfo::
info (const info_optional& x)
{
  this->info_ = x;
}

void WorldInfo::
info (::std::auto_ptr< info_type > x)
{
  this->info_.set (x);
}

const WorldInfo::title_optional& WorldInfo::
title () const
{
  return this->title_;
}

WorldInfo::title_optional& WorldInfo::
title ()
{
  return this->title_;
}

void WorldInfo::
title (const title_type& x)
{
  this->title_.set (x);
}

void WorldInfo::
title (const title_optional& x)
{
  this->title_ = x;
}

void WorldInfo::
title (::std::auto_ptr< title_type > x)
{
  this->title_.set (x);
}


// component
// 

const component::name_type& component::
name () const
{
  return this->name_.get ();
}

component::name_type& component::
name ()
{
  return this->name_.get ();
}

void component::
name (const name_type& x)
{
  this->name_.set (x);
}

void component::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const component::level_type& component::
level () const
{
  return this->level_.get ();
}

component::level_type& component::
level ()
{
  return this->level_.get ();
}

void component::
level (const level_type& x)
{
  this->level_.set (x);
}

void component::
level (::std::auto_ptr< level_type > x)
{
  this->level_.set (x);
}


// EXPORT
// 

const EXPORT::localDEF_type& EXPORT::
localDEF () const
{
  return this->localDEF_.get ();
}

EXPORT::localDEF_type& EXPORT::
localDEF ()
{
  return this->localDEF_.get ();
}

void EXPORT::
localDEF (const localDEF_type& x)
{
  this->localDEF_.set (x);
}

void EXPORT::
localDEF (::std::auto_ptr< localDEF_type > x)
{
  this->localDEF_.set (x);
}

const EXPORT::AS_optional& EXPORT::
AS () const
{
  return this->AS_;
}

EXPORT::AS_optional& EXPORT::
AS ()
{
  return this->AS_;
}

void EXPORT::
AS (const AS_type& x)
{
  this->AS_.set (x);
}

void EXPORT::
AS (const AS_optional& x)
{
  this->AS_ = x;
}

void EXPORT::
AS (::std::auto_ptr< AS_type > x)
{
  this->AS_.set (x);
}


// IMPORT
// 

const IMPORT::inlineDEF_type& IMPORT::
inlineDEF () const
{
  return this->inlineDEF_.get ();
}

IMPORT::inlineDEF_type& IMPORT::
inlineDEF ()
{
  return this->inlineDEF_.get ();
}

void IMPORT::
inlineDEF (const inlineDEF_type& x)
{
  this->inlineDEF_.set (x);
}

void IMPORT::
inlineDEF (::std::auto_ptr< inlineDEF_type > x)
{
  this->inlineDEF_.set (x);
}

const IMPORT::importedDEF_type& IMPORT::
importedDEF () const
{
  return this->importedDEF_.get ();
}

IMPORT::importedDEF_type& IMPORT::
importedDEF ()
{
  return this->importedDEF_.get ();
}

void IMPORT::
importedDEF (const importedDEF_type& x)
{
  this->importedDEF_.set (x);
}

void IMPORT::
importedDEF (::std::auto_ptr< importedDEF_type > x)
{
  this->importedDEF_.set (x);
}

const IMPORT::AS_optional& IMPORT::
AS () const
{
  return this->AS_;
}

IMPORT::AS_optional& IMPORT::
AS ()
{
  return this->AS_;
}

void IMPORT::
AS (const AS_type& x)
{
  this->AS_.set (x);
}

void IMPORT::
AS (const AS_optional& x)
{
  this->AS_ = x;
}

void IMPORT::
AS (::std::auto_ptr< AS_type > x)
{
  this->AS_.set (x);
}


// IS
// 

const IS::connect_sequence& IS::
connect () const
{
  return this->connect_;
}

IS::connect_sequence& IS::
connect ()
{
  return this->connect_;
}

void IS::
connect (const connect_sequence& s)
{
  this->connect_ = s;
}


// connect
// 

const connect::nodeField_type& connect::
nodeField () const
{
  return this->nodeField_.get ();
}

connect::nodeField_type& connect::
nodeField ()
{
  return this->nodeField_.get ();
}

void connect::
nodeField (const nodeField_type& x)
{
  this->nodeField_.set (x);
}

void connect::
nodeField (::std::auto_ptr< nodeField_type > x)
{
  this->nodeField_.set (x);
}

const connect::protoField_type& connect::
protoField () const
{
  return this->protoField_.get ();
}

connect::protoField_type& connect::
protoField ()
{
  return this->protoField_.get ();
}

void connect::
protoField (const protoField_type& x)
{
  this->protoField_.set (x);
}

void connect::
protoField (::std::auto_ptr< protoField_type > x)
{
  this->protoField_.set (x);
}


// field
// 

const field::FillProperties_sequence& field::
FillProperties () const
{
  return this->FillProperties_;
}

field::FillProperties_sequence& field::
FillProperties ()
{
  return this->FillProperties_;
}

void field::
FillProperties (const FillProperties_sequence& s)
{
  this->FillProperties_ = s;
}

const field::LineProperties_sequence& field::
LineProperties () const
{
  return this->LineProperties_;
}

field::LineProperties_sequence& field::
LineProperties ()
{
  return this->LineProperties_;
}

void field::
LineProperties (const LineProperties_sequence& s)
{
  this->LineProperties_ = s;
}

const field::Material_sequence& field::
Material () const
{
  return this->Material_;
}

field::Material_sequence& field::
Material ()
{
  return this->Material_;
}

void field::
Material (const Material_sequence& s)
{
  this->Material_ = s;
}

const field::ComposedShader_sequence& field::
ComposedShader () const
{
  return this->ComposedShader_;
}

field::ComposedShader_sequence& field::
ComposedShader ()
{
  return this->ComposedShader_;
}

void field::
ComposedShader (const ComposedShader_sequence& s)
{
  this->ComposedShader_ = s;
}

const field::PackagedShader_sequence& field::
PackagedShader () const
{
  return this->PackagedShader_;
}

field::PackagedShader_sequence& field::
PackagedShader ()
{
  return this->PackagedShader_;
}

void field::
PackagedShader (const PackagedShader_sequence& s)
{
  this->PackagedShader_ = s;
}

const field::ProgramShader_sequence& field::
ProgramShader () const
{
  return this->ProgramShader_;
}

field::ProgramShader_sequence& field::
ProgramShader ()
{
  return this->ProgramShader_;
}

void field::
ProgramShader (const ProgramShader_sequence& s)
{
  this->ProgramShader_ = s;
}

const field::ComposedCubeMapTexture_sequence& field::
ComposedCubeMapTexture () const
{
  return this->ComposedCubeMapTexture_;
}

field::ComposedCubeMapTexture_sequence& field::
ComposedCubeMapTexture ()
{
  return this->ComposedCubeMapTexture_;
}

void field::
ComposedCubeMapTexture (const ComposedCubeMapTexture_sequence& s)
{
  this->ComposedCubeMapTexture_ = s;
}

const field::ImageTexture_sequence& field::
ImageTexture () const
{
  return this->ImageTexture_;
}

field::ImageTexture_sequence& field::
ImageTexture ()
{
  return this->ImageTexture_;
}

void field::
ImageTexture (const ImageTexture_sequence& s)
{
  this->ImageTexture_ = s;
}

const field::MovieTexture_sequence& field::
MovieTexture () const
{
  return this->MovieTexture_;
}

field::MovieTexture_sequence& field::
MovieTexture ()
{
  return this->MovieTexture_;
}

void field::
MovieTexture (const MovieTexture_sequence& s)
{
  this->MovieTexture_ = s;
}

const field::MultiTexture_sequence& field::
MultiTexture () const
{
  return this->MultiTexture_;
}

field::MultiTexture_sequence& field::
MultiTexture ()
{
  return this->MultiTexture_;
}

void field::
MultiTexture (const MultiTexture_sequence& s)
{
  this->MultiTexture_ = s;
}

const field::PixelTexture_sequence& field::
PixelTexture () const
{
  return this->PixelTexture_;
}

field::PixelTexture_sequence& field::
PixelTexture ()
{
  return this->PixelTexture_;
}

void field::
PixelTexture (const PixelTexture_sequence& s)
{
  this->PixelTexture_ = s;
}

const field::GeneratedCubeMapTexture_sequence& field::
GeneratedCubeMapTexture () const
{
  return this->GeneratedCubeMapTexture_;
}

field::GeneratedCubeMapTexture_sequence& field::
GeneratedCubeMapTexture ()
{
  return this->GeneratedCubeMapTexture_;
}

void field::
GeneratedCubeMapTexture (const GeneratedCubeMapTexture_sequence& s)
{
  this->GeneratedCubeMapTexture_ = s;
}

const field::ImageCubeMapTexture_sequence& field::
ImageCubeMapTexture () const
{
  return this->ImageCubeMapTexture_;
}

field::ImageCubeMapTexture_sequence& field::
ImageCubeMapTexture ()
{
  return this->ImageCubeMapTexture_;
}

void field::
ImageCubeMapTexture (const ImageCubeMapTexture_sequence& s)
{
  this->ImageCubeMapTexture_ = s;
}

const field::MultiTextureTransform_sequence& field::
MultiTextureTransform () const
{
  return this->MultiTextureTransform_;
}

field::MultiTextureTransform_sequence& field::
MultiTextureTransform ()
{
  return this->MultiTextureTransform_;
}

void field::
MultiTextureTransform (const MultiTextureTransform_sequence& s)
{
  this->MultiTextureTransform_ = s;
}

const field::TextureTransform_sequence& field::
TextureTransform () const
{
  return this->TextureTransform_;
}

field::TextureTransform_sequence& field::
TextureTransform ()
{
  return this->TextureTransform_;
}

void field::
TextureTransform (const TextureTransform_sequence& s)
{
  this->TextureTransform_ = s;
}

const field::MetadataDouble_sequence& field::
MetadataDouble () const
{
  return this->MetadataDouble_;
}

field::MetadataDouble_sequence& field::
MetadataDouble ()
{
  return this->MetadataDouble_;
}

void field::
MetadataDouble (const MetadataDouble_sequence& s)
{
  this->MetadataDouble_ = s;
}

const field::MetadataFloat_sequence& field::
MetadataFloat () const
{
  return this->MetadataFloat_;
}

field::MetadataFloat_sequence& field::
MetadataFloat ()
{
  return this->MetadataFloat_;
}

void field::
MetadataFloat (const MetadataFloat_sequence& s)
{
  this->MetadataFloat_ = s;
}

const field::MetadataInteger_sequence& field::
MetadataInteger () const
{
  return this->MetadataInteger_;
}

field::MetadataInteger_sequence& field::
MetadataInteger ()
{
  return this->MetadataInteger_;
}

void field::
MetadataInteger (const MetadataInteger_sequence& s)
{
  this->MetadataInteger_ = s;
}

const field::MetadataSet_sequence& field::
MetadataSet () const
{
  return this->MetadataSet_;
}

field::MetadataSet_sequence& field::
MetadataSet ()
{
  return this->MetadataSet_;
}

void field::
MetadataSet (const MetadataSet_sequence& s)
{
  this->MetadataSet_ = s;
}

const field::MetadataString_sequence& field::
MetadataString () const
{
  return this->MetadataString_;
}

field::MetadataString_sequence& field::
MetadataString ()
{
  return this->MetadataString_;
}

void field::
MetadataString (const MetadataString_sequence& s)
{
  this->MetadataString_ = s;
}

const field::Appearance_sequence& field::
Appearance () const
{
  return this->Appearance_;
}

field::Appearance_sequence& field::
Appearance ()
{
  return this->Appearance_;
}

void field::
Appearance (const Appearance_sequence& s)
{
  this->Appearance_ = s;
}

const field::Background_sequence& field::
Background () const
{
  return this->Background_;
}

field::Background_sequence& field::
Background ()
{
  return this->Background_;
}

void field::
Background (const Background_sequence& s)
{
  this->Background_ = s;
}

const field::ColorInterpolator_sequence& field::
ColorInterpolator () const
{
  return this->ColorInterpolator_;
}

field::ColorInterpolator_sequence& field::
ColorInterpolator ()
{
  return this->ColorInterpolator_;
}

void field::
ColorInterpolator (const ColorInterpolator_sequence& s)
{
  this->ColorInterpolator_ = s;
}

const field::CoordinateInterpolator_sequence& field::
CoordinateInterpolator () const
{
  return this->CoordinateInterpolator_;
}

field::CoordinateInterpolator_sequence& field::
CoordinateInterpolator ()
{
  return this->CoordinateInterpolator_;
}

void field::
CoordinateInterpolator (const CoordinateInterpolator_sequence& s)
{
  this->CoordinateInterpolator_ = s;
}

const field::DirectionalLight_sequence& field::
DirectionalLight () const
{
  return this->DirectionalLight_;
}

field::DirectionalLight_sequence& field::
DirectionalLight ()
{
  return this->DirectionalLight_;
}

void field::
DirectionalLight (const DirectionalLight_sequence& s)
{
  this->DirectionalLight_ = s;
}

const field::Group_sequence& field::
Group () const
{
  return this->Group_;
}

field::Group_sequence& field::
Group ()
{
  return this->Group_;
}

void field::
Group (const Group_sequence& s)
{
  this->Group_ = s;
}

const field::NavigationInfo_sequence& field::
NavigationInfo () const
{
  return this->NavigationInfo_;
}

field::NavigationInfo_sequence& field::
NavigationInfo ()
{
  return this->NavigationInfo_;
}

void field::
NavigationInfo (const NavigationInfo_sequence& s)
{
  this->NavigationInfo_ = s;
}

const field::NormalInterpolator_sequence& field::
NormalInterpolator () const
{
  return this->NormalInterpolator_;
}

field::NormalInterpolator_sequence& field::
NormalInterpolator ()
{
  return this->NormalInterpolator_;
}

void field::
NormalInterpolator (const NormalInterpolator_sequence& s)
{
  this->NormalInterpolator_ = s;
}

const field::OrientationInterpolator_sequence& field::
OrientationInterpolator () const
{
  return this->OrientationInterpolator_;
}

field::OrientationInterpolator_sequence& field::
OrientationInterpolator ()
{
  return this->OrientationInterpolator_;
}

void field::
OrientationInterpolator (const OrientationInterpolator_sequence& s)
{
  this->OrientationInterpolator_ = s;
}

const field::PositionInterpolator_sequence& field::
PositionInterpolator () const
{
  return this->PositionInterpolator_;
}

field::PositionInterpolator_sequence& field::
PositionInterpolator ()
{
  return this->PositionInterpolator_;
}

void field::
PositionInterpolator (const PositionInterpolator_sequence& s)
{
  this->PositionInterpolator_ = s;
}

const field::ScalarInterpolator_sequence& field::
ScalarInterpolator () const
{
  return this->ScalarInterpolator_;
}

field::ScalarInterpolator_sequence& field::
ScalarInterpolator ()
{
  return this->ScalarInterpolator_;
}

void field::
ScalarInterpolator (const ScalarInterpolator_sequence& s)
{
  this->ScalarInterpolator_ = s;
}

const field::Shape_sequence& field::
Shape () const
{
  return this->Shape_;
}

field::Shape_sequence& field::
Shape ()
{
  return this->Shape_;
}

void field::
Shape (const Shape_sequence& s)
{
  this->Shape_ = s;
}

const field::TimeSensor_sequence& field::
TimeSensor () const
{
  return this->TimeSensor_;
}

field::TimeSensor_sequence& field::
TimeSensor ()
{
  return this->TimeSensor_;
}

void field::
TimeSensor (const TimeSensor_sequence& s)
{
  this->TimeSensor_ = s;
}

const field::Transform_sequence& field::
Transform () const
{
  return this->Transform_;
}

field::Transform_sequence& field::
Transform ()
{
  return this->Transform_;
}

void field::
Transform (const Transform_sequence& s)
{
  this->Transform_ = s;
}

const field::Viewpoint_sequence& field::
Viewpoint () const
{
  return this->Viewpoint_;
}

field::Viewpoint_sequence& field::
Viewpoint ()
{
  return this->Viewpoint_;
}

void field::
Viewpoint (const Viewpoint_sequence& s)
{
  this->Viewpoint_ = s;
}

const field::WorldInfo_sequence& field::
WorldInfo () const
{
  return this->WorldInfo_;
}

field::WorldInfo_sequence& field::
WorldInfo ()
{
  return this->WorldInfo_;
}

void field::
WorldInfo (const WorldInfo_sequence& s)
{
  this->WorldInfo_ = s;
}

const field::Anchor_sequence& field::
Anchor () const
{
  return this->Anchor_;
}

field::Anchor_sequence& field::
Anchor ()
{
  return this->Anchor_;
}

void field::
Anchor (const Anchor_sequence& s)
{
  this->Anchor_ = s;
}

const field::BooleanFilter_sequence& field::
BooleanFilter () const
{
  return this->BooleanFilter_;
}

field::BooleanFilter_sequence& field::
BooleanFilter ()
{
  return this->BooleanFilter_;
}

void field::
BooleanFilter (const BooleanFilter_sequence& s)
{
  this->BooleanFilter_ = s;
}

const field::BooleanSequencer_sequence& field::
BooleanSequencer () const
{
  return this->BooleanSequencer_;
}

field::BooleanSequencer_sequence& field::
BooleanSequencer ()
{
  return this->BooleanSequencer_;
}

void field::
BooleanSequencer (const BooleanSequencer_sequence& s)
{
  this->BooleanSequencer_ = s;
}

const field::BooleanToggle_sequence& field::
BooleanToggle () const
{
  return this->BooleanToggle_;
}

field::BooleanToggle_sequence& field::
BooleanToggle ()
{
  return this->BooleanToggle_;
}

void field::
BooleanToggle (const BooleanToggle_sequence& s)
{
  this->BooleanToggle_ = s;
}

const field::BooleanTrigger_sequence& field::
BooleanTrigger () const
{
  return this->BooleanTrigger_;
}

field::BooleanTrigger_sequence& field::
BooleanTrigger ()
{
  return this->BooleanTrigger_;
}

void field::
BooleanTrigger (const BooleanTrigger_sequence& s)
{
  this->BooleanTrigger_ = s;
}

const field::CylinderSensor_sequence& field::
CylinderSensor () const
{
  return this->CylinderSensor_;
}

field::CylinderSensor_sequence& field::
CylinderSensor ()
{
  return this->CylinderSensor_;
}

void field::
CylinderSensor (const CylinderSensor_sequence& s)
{
  this->CylinderSensor_ = s;
}

const field::Inline_sequence& field::
Inline () const
{
  return this->Inline_;
}

field::Inline_sequence& field::
Inline ()
{
  return this->Inline_;
}

void field::
Inline (const Inline_sequence& s)
{
  this->Inline_ = s;
}

const field::IntegerSequencer_sequence& field::
IntegerSequencer () const
{
  return this->IntegerSequencer_;
}

field::IntegerSequencer_sequence& field::
IntegerSequencer ()
{
  return this->IntegerSequencer_;
}

void field::
IntegerSequencer (const IntegerSequencer_sequence& s)
{
  this->IntegerSequencer_ = s;
}

const field::IntegerTrigger_sequence& field::
IntegerTrigger () const
{
  return this->IntegerTrigger_;
}

field::IntegerTrigger_sequence& field::
IntegerTrigger ()
{
  return this->IntegerTrigger_;
}

void field::
IntegerTrigger (const IntegerTrigger_sequence& s)
{
  this->IntegerTrigger_ = s;
}

const field::KeySensor_sequence& field::
KeySensor () const
{
  return this->KeySensor_;
}

field::KeySensor_sequence& field::
KeySensor ()
{
  return this->KeySensor_;
}

void field::
KeySensor (const KeySensor_sequence& s)
{
  this->KeySensor_ = s;
}

const field::PlaneSensor_sequence& field::
PlaneSensor () const
{
  return this->PlaneSensor_;
}

field::PlaneSensor_sequence& field::
PlaneSensor ()
{
  return this->PlaneSensor_;
}

void field::
PlaneSensor (const PlaneSensor_sequence& s)
{
  this->PlaneSensor_ = s;
}

const field::PointLight_sequence& field::
PointLight () const
{
  return this->PointLight_;
}

field::PointLight_sequence& field::
PointLight ()
{
  return this->PointLight_;
}

void field::
PointLight (const PointLight_sequence& s)
{
  this->PointLight_ = s;
}

const field::ProximitySensor_sequence& field::
ProximitySensor () const
{
  return this->ProximitySensor_;
}

field::ProximitySensor_sequence& field::
ProximitySensor ()
{
  return this->ProximitySensor_;
}

void field::
ProximitySensor (const ProximitySensor_sequence& s)
{
  this->ProximitySensor_ = s;
}

const field::SphereSensor_sequence& field::
SphereSensor () const
{
  return this->SphereSensor_;
}

field::SphereSensor_sequence& field::
SphereSensor ()
{
  return this->SphereSensor_;
}

void field::
SphereSensor (const SphereSensor_sequence& s)
{
  this->SphereSensor_ = s;
}

const field::SpotLight_sequence& field::
SpotLight () const
{
  return this->SpotLight_;
}

field::SpotLight_sequence& field::
SpotLight ()
{
  return this->SpotLight_;
}

void field::
SpotLight (const SpotLight_sequence& s)
{
  this->SpotLight_ = s;
}

const field::StringSensor_sequence& field::
StringSensor () const
{
  return this->StringSensor_;
}

field::StringSensor_sequence& field::
StringSensor ()
{
  return this->StringSensor_;
}

void field::
StringSensor (const StringSensor_sequence& s)
{
  this->StringSensor_ = s;
}

const field::Switch_sequence& field::
Switch () const
{
  return this->Switch_;
}

field::Switch_sequence& field::
Switch ()
{
  return this->Switch_;
}

void field::
Switch (const Switch_sequence& s)
{
  this->Switch_ = s;
}

const field::TimeTrigger_sequence& field::
TimeTrigger () const
{
  return this->TimeTrigger_;
}

field::TimeTrigger_sequence& field::
TimeTrigger ()
{
  return this->TimeTrigger_;
}

void field::
TimeTrigger (const TimeTrigger_sequence& s)
{
  this->TimeTrigger_ = s;
}

const field::TouchSensor_sequence& field::
TouchSensor () const
{
  return this->TouchSensor_;
}

field::TouchSensor_sequence& field::
TouchSensor ()
{
  return this->TouchSensor_;
}

void field::
TouchSensor (const TouchSensor_sequence& s)
{
  this->TouchSensor_ = s;
}

const field::AudioClip_sequence& field::
AudioClip () const
{
  return this->AudioClip_;
}

field::AudioClip_sequence& field::
AudioClip ()
{
  return this->AudioClip_;
}

void field::
AudioClip (const AudioClip_sequence& s)
{
  this->AudioClip_ = s;
}

const field::Billboard_sequence& field::
Billboard () const
{
  return this->Billboard_;
}

field::Billboard_sequence& field::
Billboard ()
{
  return this->Billboard_;
}

void field::
Billboard (const Billboard_sequence& s)
{
  this->Billboard_ = s;
}

const field::Collision_sequence& field::
Collision () const
{
  return this->Collision_;
}

field::Collision_sequence& field::
Collision ()
{
  return this->Collision_;
}

void field::
Collision (const Collision_sequence& s)
{
  this->Collision_ = s;
}

const field::Fog_sequence& field::
Fog () const
{
  return this->Fog_;
}

field::Fog_sequence& field::
Fog ()
{
  return this->Fog_;
}

void field::
Fog (const Fog_sequence& s)
{
  this->Fog_ = s;
}

const field::LoadSensor_sequence& field::
LoadSensor () const
{
  return this->LoadSensor_;
}

field::LoadSensor_sequence& field::
LoadSensor ()
{
  return this->LoadSensor_;
}

void field::
LoadSensor (const LoadSensor_sequence& s)
{
  this->LoadSensor_ = s;
}

const field::LocalFog_sequence& field::
LocalFog () const
{
  return this->LocalFog_;
}

field::LocalFog_sequence& field::
LocalFog ()
{
  return this->LocalFog_;
}

void field::
LocalFog (const LocalFog_sequence& s)
{
  this->LocalFog_ = s;
}

const field::LOD_sequence& field::
LOD () const
{
  return this->LOD_;
}

field::LOD_sequence& field::
LOD ()
{
  return this->LOD_;
}

void field::
LOD (const LOD_sequence& s)
{
  this->LOD_ = s;
}

const field::Script_sequence& field::
Script () const
{
  return this->Script_;
}

field::Script_sequence& field::
Script ()
{
  return this->Script_;
}

void field::
Script (const Script_sequence& s)
{
  this->Script_ = s;
}

const field::Sound_sequence& field::
Sound () const
{
  return this->Sound_;
}

field::Sound_sequence& field::
Sound ()
{
  return this->Sound_;
}

void field::
Sound (const Sound_sequence& s)
{
  this->Sound_ = s;
}

const field::VisibilitySensor_sequence& field::
VisibilitySensor () const
{
  return this->VisibilitySensor_;
}

field::VisibilitySensor_sequence& field::
VisibilitySensor ()
{
  return this->VisibilitySensor_;
}

void field::
VisibilitySensor (const VisibilitySensor_sequence& s)
{
  this->VisibilitySensor_ = s;
}

const field::CoordinateInterpolator2D_sequence& field::
CoordinateInterpolator2D () const
{
  return this->CoordinateInterpolator2D_;
}

field::CoordinateInterpolator2D_sequence& field::
CoordinateInterpolator2D ()
{
  return this->CoordinateInterpolator2D_;
}

void field::
CoordinateInterpolator2D (const CoordinateInterpolator2D_sequence& s)
{
  this->CoordinateInterpolator2D_ = s;
}

const field::PositionInterpolator2D_sequence& field::
PositionInterpolator2D () const
{
  return this->PositionInterpolator2D_;
}

field::PositionInterpolator2D_sequence& field::
PositionInterpolator2D ()
{
  return this->PositionInterpolator2D_;
}

void field::
PositionInterpolator2D (const PositionInterpolator2D_sequence& s)
{
  this->PositionInterpolator2D_ = s;
}

const field::StaticGroup_sequence& field::
StaticGroup () const
{
  return this->StaticGroup_;
}

field::StaticGroup_sequence& field::
StaticGroup ()
{
  return this->StaticGroup_;
}

void field::
StaticGroup (const StaticGroup_sequence& s)
{
  this->StaticGroup_ = s;
}

const field::CADAssembly_sequence& field::
CADAssembly () const
{
  return this->CADAssembly_;
}

field::CADAssembly_sequence& field::
CADAssembly ()
{
  return this->CADAssembly_;
}

void field::
CADAssembly (const CADAssembly_sequence& s)
{
  this->CADAssembly_ = s;
}

const field::CADLayer_sequence& field::
CADLayer () const
{
  return this->CADLayer_;
}

field::CADLayer_sequence& field::
CADLayer ()
{
  return this->CADLayer_;
}

void field::
CADLayer (const CADLayer_sequence& s)
{
  this->CADLayer_ = s;
}

const field::EspduTransform_sequence& field::
EspduTransform () const
{
  return this->EspduTransform_;
}

field::EspduTransform_sequence& field::
EspduTransform ()
{
  return this->EspduTransform_;
}

void field::
EspduTransform (const EspduTransform_sequence& s)
{
  this->EspduTransform_ = s;
}

const field::ReceiverPdu_sequence& field::
ReceiverPdu () const
{
  return this->ReceiverPdu_;
}

field::ReceiverPdu_sequence& field::
ReceiverPdu ()
{
  return this->ReceiverPdu_;
}

void field::
ReceiverPdu (const ReceiverPdu_sequence& s)
{
  this->ReceiverPdu_ = s;
}

const field::SignalPdu_sequence& field::
SignalPdu () const
{
  return this->SignalPdu_;
}

field::SignalPdu_sequence& field::
SignalPdu ()
{
  return this->SignalPdu_;
}

void field::
SignalPdu (const SignalPdu_sequence& s)
{
  this->SignalPdu_ = s;
}

const field::TransmitterPdu_sequence& field::
TransmitterPdu () const
{
  return this->TransmitterPdu_;
}

field::TransmitterPdu_sequence& field::
TransmitterPdu ()
{
  return this->TransmitterPdu_;
}

void field::
TransmitterPdu (const TransmitterPdu_sequence& s)
{
  this->TransmitterPdu_ = s;
}

const field::GeoLocation_sequence& field::
GeoLocation () const
{
  return this->GeoLocation_;
}

field::GeoLocation_sequence& field::
GeoLocation ()
{
  return this->GeoLocation_;
}

void field::
GeoLocation (const GeoLocation_sequence& s)
{
  this->GeoLocation_ = s;
}

const field::GeoLOD_sequence& field::
GeoLOD () const
{
  return this->GeoLOD_;
}

field::GeoLOD_sequence& field::
GeoLOD ()
{
  return this->GeoLOD_;
}

void field::
GeoLOD (const GeoLOD_sequence& s)
{
  this->GeoLOD_ = s;
}

const field::GeoMetadata_sequence& field::
GeoMetadata () const
{
  return this->GeoMetadata_;
}

field::GeoMetadata_sequence& field::
GeoMetadata ()
{
  return this->GeoMetadata_;
}

void field::
GeoMetadata (const GeoMetadata_sequence& s)
{
  this->GeoMetadata_ = s;
}

const field::GeoOrigin_sequence& field::
GeoOrigin () const
{
  return this->GeoOrigin_;
}

field::GeoOrigin_sequence& field::
GeoOrigin ()
{
  return this->GeoOrigin_;
}

void field::
GeoOrigin (const GeoOrigin_sequence& s)
{
  this->GeoOrigin_ = s;
}

const field::GeoPositionInterpolator_sequence& field::
GeoPositionInterpolator () const
{
  return this->GeoPositionInterpolator_;
}

field::GeoPositionInterpolator_sequence& field::
GeoPositionInterpolator ()
{
  return this->GeoPositionInterpolator_;
}

void field::
GeoPositionInterpolator (const GeoPositionInterpolator_sequence& s)
{
  this->GeoPositionInterpolator_ = s;
}

const field::GeoTouchSensor_sequence& field::
GeoTouchSensor () const
{
  return this->GeoTouchSensor_;
}

field::GeoTouchSensor_sequence& field::
GeoTouchSensor ()
{
  return this->GeoTouchSensor_;
}

void field::
GeoTouchSensor (const GeoTouchSensor_sequence& s)
{
  this->GeoTouchSensor_ = s;
}

const field::GeoViewpoint_sequence& field::
GeoViewpoint () const
{
  return this->GeoViewpoint_;
}

field::GeoViewpoint_sequence& field::
GeoViewpoint ()
{
  return this->GeoViewpoint_;
}

void field::
GeoViewpoint (const GeoViewpoint_sequence& s)
{
  this->GeoViewpoint_ = s;
}

const field::HAnimHumanoid_sequence& field::
HAnimHumanoid () const
{
  return this->HAnimHumanoid_;
}

field::HAnimHumanoid_sequence& field::
HAnimHumanoid ()
{
  return this->HAnimHumanoid_;
}

void field::
HAnimHumanoid (const HAnimHumanoid_sequence& s)
{
  this->HAnimHumanoid_ = s;
}

const field::HAnimJoint_sequence& field::
HAnimJoint () const
{
  return this->HAnimJoint_;
}

field::HAnimJoint_sequence& field::
HAnimJoint ()
{
  return this->HAnimJoint_;
}

void field::
HAnimJoint (const HAnimJoint_sequence& s)
{
  this->HAnimJoint_ = s;
}

const field::HAnimSegment_sequence& field::
HAnimSegment () const
{
  return this->HAnimSegment_;
}

field::HAnimSegment_sequence& field::
HAnimSegment ()
{
  return this->HAnimSegment_;
}

void field::
HAnimSegment (const HAnimSegment_sequence& s)
{
  this->HAnimSegment_ = s;
}

const field::HAnimSite_sequence& field::
HAnimSite () const
{
  return this->HAnimSite_;
}

field::HAnimSite_sequence& field::
HAnimSite ()
{
  return this->HAnimSite_;
}

void field::
HAnimSite (const HAnimSite_sequence& s)
{
  this->HAnimSite_ = s;
}

const field::NurbsOrientationInterpolator_sequence& field::
NurbsOrientationInterpolator () const
{
  return this->NurbsOrientationInterpolator_;
}

field::NurbsOrientationInterpolator_sequence& field::
NurbsOrientationInterpolator ()
{
  return this->NurbsOrientationInterpolator_;
}

void field::
NurbsOrientationInterpolator (const NurbsOrientationInterpolator_sequence& s)
{
  this->NurbsOrientationInterpolator_ = s;
}

const field::NurbsPositionInterpolator_sequence& field::
NurbsPositionInterpolator () const
{
  return this->NurbsPositionInterpolator_;
}

field::NurbsPositionInterpolator_sequence& field::
NurbsPositionInterpolator ()
{
  return this->NurbsPositionInterpolator_;
}

void field::
NurbsPositionInterpolator (const NurbsPositionInterpolator_sequence& s)
{
  this->NurbsPositionInterpolator_ = s;
}

const field::NurbsSurfaceInterpolator_sequence& field::
NurbsSurfaceInterpolator () const
{
  return this->NurbsSurfaceInterpolator_;
}

field::NurbsSurfaceInterpolator_sequence& field::
NurbsSurfaceInterpolator ()
{
  return this->NurbsSurfaceInterpolator_;
}

void field::
NurbsSurfaceInterpolator (const NurbsSurfaceInterpolator_sequence& s)
{
  this->NurbsSurfaceInterpolator_ = s;
}

const field::NurbsSet_sequence& field::
NurbsSet () const
{
  return this->NurbsSet_;
}

field::NurbsSet_sequence& field::
NurbsSet ()
{
  return this->NurbsSet_;
}

void field::
NurbsSet (const NurbsSet_sequence& s)
{
  this->NurbsSet_ = s;
}

const field::ProtoInstance_sequence& field::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

field::ProtoInstance_sequence& field::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void field::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const field::Box_sequence& field::
Box () const
{
  return this->Box_;
}

field::Box_sequence& field::
Box ()
{
  return this->Box_;
}

void field::
Box (const Box_sequence& s)
{
  this->Box_ = s;
}

const field::Cone_sequence& field::
Cone () const
{
  return this->Cone_;
}

field::Cone_sequence& field::
Cone ()
{
  return this->Cone_;
}

void field::
Cone (const Cone_sequence& s)
{
  this->Cone_ = s;
}

const field::Cylinder_sequence& field::
Cylinder () const
{
  return this->Cylinder_;
}

field::Cylinder_sequence& field::
Cylinder ()
{
  return this->Cylinder_;
}

void field::
Cylinder (const Cylinder_sequence& s)
{
  this->Cylinder_ = s;
}

const field::IndexedFaceSet_sequence& field::
IndexedFaceSet () const
{
  return this->IndexedFaceSet_;
}

field::IndexedFaceSet_sequence& field::
IndexedFaceSet ()
{
  return this->IndexedFaceSet_;
}

void field::
IndexedFaceSet (const IndexedFaceSet_sequence& s)
{
  this->IndexedFaceSet_ = s;
}

const field::IndexedLineSet_sequence& field::
IndexedLineSet () const
{
  return this->IndexedLineSet_;
}

field::IndexedLineSet_sequence& field::
IndexedLineSet ()
{
  return this->IndexedLineSet_;
}

void field::
IndexedLineSet (const IndexedLineSet_sequence& s)
{
  this->IndexedLineSet_ = s;
}

const field::IndexedTriangleFanSet_sequence& field::
IndexedTriangleFanSet () const
{
  return this->IndexedTriangleFanSet_;
}

field::IndexedTriangleFanSet_sequence& field::
IndexedTriangleFanSet ()
{
  return this->IndexedTriangleFanSet_;
}

void field::
IndexedTriangleFanSet (const IndexedTriangleFanSet_sequence& s)
{
  this->IndexedTriangleFanSet_ = s;
}

const field::IndexedTriangleSet_sequence& field::
IndexedTriangleSet () const
{
  return this->IndexedTriangleSet_;
}

field::IndexedTriangleSet_sequence& field::
IndexedTriangleSet ()
{
  return this->IndexedTriangleSet_;
}

void field::
IndexedTriangleSet (const IndexedTriangleSet_sequence& s)
{
  this->IndexedTriangleSet_ = s;
}

const field::IndexedTriangleStripSet_sequence& field::
IndexedTriangleStripSet () const
{
  return this->IndexedTriangleStripSet_;
}

field::IndexedTriangleStripSet_sequence& field::
IndexedTriangleStripSet ()
{
  return this->IndexedTriangleStripSet_;
}

void field::
IndexedTriangleStripSet (const IndexedTriangleStripSet_sequence& s)
{
  this->IndexedTriangleStripSet_ = s;
}

const field::LineSet_sequence& field::
LineSet () const
{
  return this->LineSet_;
}

field::LineSet_sequence& field::
LineSet ()
{
  return this->LineSet_;
}

void field::
LineSet (const LineSet_sequence& s)
{
  this->LineSet_ = s;
}

const field::PointSet_sequence& field::
PointSet () const
{
  return this->PointSet_;
}

field::PointSet_sequence& field::
PointSet ()
{
  return this->PointSet_;
}

void field::
PointSet (const PointSet_sequence& s)
{
  this->PointSet_ = s;
}

const field::Sphere_sequence& field::
Sphere () const
{
  return this->Sphere_;
}

field::Sphere_sequence& field::
Sphere ()
{
  return this->Sphere_;
}

void field::
Sphere (const Sphere_sequence& s)
{
  this->Sphere_ = s;
}

const field::TriangleFanSet_sequence& field::
TriangleFanSet () const
{
  return this->TriangleFanSet_;
}

field::TriangleFanSet_sequence& field::
TriangleFanSet ()
{
  return this->TriangleFanSet_;
}

void field::
TriangleFanSet (const TriangleFanSet_sequence& s)
{
  this->TriangleFanSet_ = s;
}

const field::TriangleSet_sequence& field::
TriangleSet () const
{
  return this->TriangleSet_;
}

field::TriangleSet_sequence& field::
TriangleSet ()
{
  return this->TriangleSet_;
}

void field::
TriangleSet (const TriangleSet_sequence& s)
{
  this->TriangleSet_ = s;
}

const field::TriangleStripSet_sequence& field::
TriangleStripSet () const
{
  return this->TriangleStripSet_;
}

field::TriangleStripSet_sequence& field::
TriangleStripSet ()
{
  return this->TriangleStripSet_;
}

void field::
TriangleStripSet (const TriangleStripSet_sequence& s)
{
  this->TriangleStripSet_ = s;
}

const field::ElevationGrid_sequence& field::
ElevationGrid () const
{
  return this->ElevationGrid_;
}

field::ElevationGrid_sequence& field::
ElevationGrid ()
{
  return this->ElevationGrid_;
}

void field::
ElevationGrid (const ElevationGrid_sequence& s)
{
  this->ElevationGrid_ = s;
}

const field::Polyline2D_sequence& field::
Polyline2D () const
{
  return this->Polyline2D_;
}

field::Polyline2D_sequence& field::
Polyline2D ()
{
  return this->Polyline2D_;
}

void field::
Polyline2D (const Polyline2D_sequence& s)
{
  this->Polyline2D_ = s;
}

const field::Polypoint2D_sequence& field::
Polypoint2D () const
{
  return this->Polypoint2D_;
}

field::Polypoint2D_sequence& field::
Polypoint2D ()
{
  return this->Polypoint2D_;
}

void field::
Polypoint2D (const Polypoint2D_sequence& s)
{
  this->Polypoint2D_ = s;
}

const field::Rectangle2D_sequence& field::
Rectangle2D () const
{
  return this->Rectangle2D_;
}

field::Rectangle2D_sequence& field::
Rectangle2D ()
{
  return this->Rectangle2D_;
}

void field::
Rectangle2D (const Rectangle2D_sequence& s)
{
  this->Rectangle2D_ = s;
}

const field::TriangleSet2D_sequence& field::
TriangleSet2D () const
{
  return this->TriangleSet2D_;
}

field::TriangleSet2D_sequence& field::
TriangleSet2D ()
{
  return this->TriangleSet2D_;
}

void field::
TriangleSet2D (const TriangleSet2D_sequence& s)
{
  this->TriangleSet2D_ = s;
}

const field::Extrusion_sequence& field::
Extrusion () const
{
  return this->Extrusion_;
}

field::Extrusion_sequence& field::
Extrusion ()
{
  return this->Extrusion_;
}

void field::
Extrusion (const Extrusion_sequence& s)
{
  this->Extrusion_ = s;
}

const field::Text_sequence& field::
Text () const
{
  return this->Text_;
}

field::Text_sequence& field::
Text ()
{
  return this->Text_;
}

void field::
Text (const Text_sequence& s)
{
  this->Text_ = s;
}

const field::Arc2D_sequence& field::
Arc2D () const
{
  return this->Arc2D_;
}

field::Arc2D_sequence& field::
Arc2D ()
{
  return this->Arc2D_;
}

void field::
Arc2D (const Arc2D_sequence& s)
{
  this->Arc2D_ = s;
}

const field::ArcClose2D_sequence& field::
ArcClose2D () const
{
  return this->ArcClose2D_;
}

field::ArcClose2D_sequence& field::
ArcClose2D ()
{
  return this->ArcClose2D_;
}

void field::
ArcClose2D (const ArcClose2D_sequence& s)
{
  this->ArcClose2D_ = s;
}

const field::Circle2D_sequence& field::
Circle2D () const
{
  return this->Circle2D_;
}

field::Circle2D_sequence& field::
Circle2D ()
{
  return this->Circle2D_;
}

void field::
Circle2D (const Circle2D_sequence& s)
{
  this->Circle2D_ = s;
}

const field::Disk2D_sequence& field::
Disk2D () const
{
  return this->Disk2D_;
}

field::Disk2D_sequence& field::
Disk2D ()
{
  return this->Disk2D_;
}

void field::
Disk2D (const Disk2D_sequence& s)
{
  this->Disk2D_ = s;
}

const field::QuadSet_sequence& field::
QuadSet () const
{
  return this->QuadSet_;
}

field::QuadSet_sequence& field::
QuadSet ()
{
  return this->QuadSet_;
}

void field::
QuadSet (const QuadSet_sequence& s)
{
  this->QuadSet_ = s;
}

const field::IndexedQuadSet_sequence& field::
IndexedQuadSet () const
{
  return this->IndexedQuadSet_;
}

field::IndexedQuadSet_sequence& field::
IndexedQuadSet ()
{
  return this->IndexedQuadSet_;
}

void field::
IndexedQuadSet (const IndexedQuadSet_sequence& s)
{
  this->IndexedQuadSet_ = s;
}

const field::GeoElevationGrid_sequence& field::
GeoElevationGrid () const
{
  return this->GeoElevationGrid_;
}

field::GeoElevationGrid_sequence& field::
GeoElevationGrid ()
{
  return this->GeoElevationGrid_;
}

void field::
GeoElevationGrid (const GeoElevationGrid_sequence& s)
{
  this->GeoElevationGrid_ = s;
}

const field::NurbsCurve_sequence& field::
NurbsCurve () const
{
  return this->NurbsCurve_;
}

field::NurbsCurve_sequence& field::
NurbsCurve ()
{
  return this->NurbsCurve_;
}

void field::
NurbsCurve (const NurbsCurve_sequence& s)
{
  this->NurbsCurve_ = s;
}

const field::NurbsCurve2D_sequence& field::
NurbsCurve2D () const
{
  return this->NurbsCurve2D_;
}

field::NurbsCurve2D_sequence& field::
NurbsCurve2D ()
{
  return this->NurbsCurve2D_;
}

void field::
NurbsCurve2D (const NurbsCurve2D_sequence& s)
{
  this->NurbsCurve2D_ = s;
}

const field::NurbsPatchSurface_sequence& field::
NurbsPatchSurface () const
{
  return this->NurbsPatchSurface_;
}

field::NurbsPatchSurface_sequence& field::
NurbsPatchSurface ()
{
  return this->NurbsPatchSurface_;
}

void field::
NurbsPatchSurface (const NurbsPatchSurface_sequence& s)
{
  this->NurbsPatchSurface_ = s;
}

const field::NurbsSweptSurface_sequence& field::
NurbsSweptSurface () const
{
  return this->NurbsSweptSurface_;
}

field::NurbsSweptSurface_sequence& field::
NurbsSweptSurface ()
{
  return this->NurbsSweptSurface_;
}

void field::
NurbsSweptSurface (const NurbsSweptSurface_sequence& s)
{
  this->NurbsSweptSurface_ = s;
}

const field::NurbsSwungSurface_sequence& field::
NurbsSwungSurface () const
{
  return this->NurbsSwungSurface_;
}

field::NurbsSwungSurface_sequence& field::
NurbsSwungSurface ()
{
  return this->NurbsSwungSurface_;
}

void field::
NurbsSwungSurface (const NurbsSwungSurface_sequence& s)
{
  this->NurbsSwungSurface_ = s;
}

const field::NurbsTrimmedSurface_sequence& field::
NurbsTrimmedSurface () const
{
  return this->NurbsTrimmedSurface_;
}

field::NurbsTrimmedSurface_sequence& field::
NurbsTrimmedSurface ()
{
  return this->NurbsTrimmedSurface_;
}

void field::
NurbsTrimmedSurface (const NurbsTrimmedSurface_sequence& s)
{
  this->NurbsTrimmedSurface_ = s;
}

const field::Color_sequence& field::
Color () const
{
  return this->Color_;
}

field::Color_sequence& field::
Color ()
{
  return this->Color_;
}

void field::
Color (const Color_sequence& s)
{
  this->Color_ = s;
}

const field::ColorRGBA_sequence& field::
ColorRGBA () const
{
  return this->ColorRGBA_;
}

field::ColorRGBA_sequence& field::
ColorRGBA ()
{
  return this->ColorRGBA_;
}

void field::
ColorRGBA (const ColorRGBA_sequence& s)
{
  this->ColorRGBA_ = s;
}

const field::Coordinate_sequence& field::
Coordinate () const
{
  return this->Coordinate_;
}

field::Coordinate_sequence& field::
Coordinate ()
{
  return this->Coordinate_;
}

void field::
Coordinate (const Coordinate_sequence& s)
{
  this->Coordinate_ = s;
}

const field::CoordinateDouble_sequence& field::
CoordinateDouble () const
{
  return this->CoordinateDouble_;
}

field::CoordinateDouble_sequence& field::
CoordinateDouble ()
{
  return this->CoordinateDouble_;
}

void field::
CoordinateDouble (const CoordinateDouble_sequence& s)
{
  this->CoordinateDouble_ = s;
}

const field::FontStyle_sequence& field::
FontStyle () const
{
  return this->FontStyle_;
}

field::FontStyle_sequence& field::
FontStyle ()
{
  return this->FontStyle_;
}

void field::
FontStyle (const FontStyle_sequence& s)
{
  this->FontStyle_ = s;
}

const field::GeoCoordinate_sequence& field::
GeoCoordinate () const
{
  return this->GeoCoordinate_;
}

field::GeoCoordinate_sequence& field::
GeoCoordinate ()
{
  return this->GeoCoordinate_;
}

void field::
GeoCoordinate (const GeoCoordinate_sequence& s)
{
  this->GeoCoordinate_ = s;
}

const field::Normal_sequence& field::
Normal () const
{
  return this->Normal_;
}

field::Normal_sequence& field::
Normal ()
{
  return this->Normal_;
}

void field::
Normal (const Normal_sequence& s)
{
  this->Normal_ = s;
}

const field::TextureCoordinate_sequence& field::
TextureCoordinate () const
{
  return this->TextureCoordinate_;
}

field::TextureCoordinate_sequence& field::
TextureCoordinate ()
{
  return this->TextureCoordinate_;
}

void field::
TextureCoordinate (const TextureCoordinate_sequence& s)
{
  this->TextureCoordinate_ = s;
}

const field::NurbsTextureCoordinate_sequence& field::
NurbsTextureCoordinate () const
{
  return this->NurbsTextureCoordinate_;
}

field::NurbsTextureCoordinate_sequence& field::
NurbsTextureCoordinate ()
{
  return this->NurbsTextureCoordinate_;
}

void field::
NurbsTextureCoordinate (const NurbsTextureCoordinate_sequence& s)
{
  this->NurbsTextureCoordinate_ = s;
}

const field::name_type& field::
name () const
{
  return this->name_.get ();
}

field::name_type& field::
name ()
{
  return this->name_.get ();
}

void field::
name (const name_type& x)
{
  this->name_.set (x);
}

void field::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const field::accessType_type& field::
accessType () const
{
  return this->accessType_.get ();
}

field::accessType_type& field::
accessType ()
{
  return this->accessType_.get ();
}

void field::
accessType (const accessType_type& x)
{
  this->accessType_.set (x);
}

void field::
accessType (::std::auto_ptr< accessType_type > x)
{
  this->accessType_.set (x);
}

const field::type_type& field::
type () const
{
  return this->type_.get ();
}

field::type_type& field::
type ()
{
  return this->type_.get ();
}

void field::
type (const type_type& x)
{
  this->type_.set (x);
}

void field::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}

const field::value_optional& field::
value () const
{
  return this->value_;
}

field::value_optional& field::
value ()
{
  return this->value_;
}

void field::
value (const value_type& x)
{
  this->value_.set (x);
}

void field::
value (const value_optional& x)
{
  this->value_ = x;
}

void field::
value (::std::auto_ptr< value_type > x)
{
  this->value_.set (x);
}

const field::appinfo_optional& field::
appinfo () const
{
  return this->appinfo_;
}

field::appinfo_optional& field::
appinfo ()
{
  return this->appinfo_;
}

void field::
appinfo (const appinfo_type& x)
{
  this->appinfo_.set (x);
}

void field::
appinfo (const appinfo_optional& x)
{
  this->appinfo_ = x;
}

void field::
appinfo (::std::auto_ptr< appinfo_type > x)
{
  this->appinfo_.set (x);
}

const field::documentation_optional& field::
documentation () const
{
  return this->documentation_;
}

field::documentation_optional& field::
documentation ()
{
  return this->documentation_;
}

void field::
documentation (const documentation_type& x)
{
  this->documentation_.set (x);
}

void field::
documentation (const documentation_optional& x)
{
  this->documentation_ = x;
}

void field::
documentation (::std::auto_ptr< documentation_type > x)
{
  this->documentation_.set (x);
}


// fieldValue
// 

const fieldValue::FillProperties_sequence& fieldValue::
FillProperties () const
{
  return this->FillProperties_;
}

fieldValue::FillProperties_sequence& fieldValue::
FillProperties ()
{
  return this->FillProperties_;
}

void fieldValue::
FillProperties (const FillProperties_sequence& s)
{
  this->FillProperties_ = s;
}

const fieldValue::LineProperties_sequence& fieldValue::
LineProperties () const
{
  return this->LineProperties_;
}

fieldValue::LineProperties_sequence& fieldValue::
LineProperties ()
{
  return this->LineProperties_;
}

void fieldValue::
LineProperties (const LineProperties_sequence& s)
{
  this->LineProperties_ = s;
}

const fieldValue::Material_sequence& fieldValue::
Material () const
{
  return this->Material_;
}

fieldValue::Material_sequence& fieldValue::
Material ()
{
  return this->Material_;
}

void fieldValue::
Material (const Material_sequence& s)
{
  this->Material_ = s;
}

const fieldValue::ComposedShader_sequence& fieldValue::
ComposedShader () const
{
  return this->ComposedShader_;
}

fieldValue::ComposedShader_sequence& fieldValue::
ComposedShader ()
{
  return this->ComposedShader_;
}

void fieldValue::
ComposedShader (const ComposedShader_sequence& s)
{
  this->ComposedShader_ = s;
}

const fieldValue::PackagedShader_sequence& fieldValue::
PackagedShader () const
{
  return this->PackagedShader_;
}

fieldValue::PackagedShader_sequence& fieldValue::
PackagedShader ()
{
  return this->PackagedShader_;
}

void fieldValue::
PackagedShader (const PackagedShader_sequence& s)
{
  this->PackagedShader_ = s;
}

const fieldValue::ProgramShader_sequence& fieldValue::
ProgramShader () const
{
  return this->ProgramShader_;
}

fieldValue::ProgramShader_sequence& fieldValue::
ProgramShader ()
{
  return this->ProgramShader_;
}

void fieldValue::
ProgramShader (const ProgramShader_sequence& s)
{
  this->ProgramShader_ = s;
}

const fieldValue::ComposedCubeMapTexture_sequence& fieldValue::
ComposedCubeMapTexture () const
{
  return this->ComposedCubeMapTexture_;
}

fieldValue::ComposedCubeMapTexture_sequence& fieldValue::
ComposedCubeMapTexture ()
{
  return this->ComposedCubeMapTexture_;
}

void fieldValue::
ComposedCubeMapTexture (const ComposedCubeMapTexture_sequence& s)
{
  this->ComposedCubeMapTexture_ = s;
}

const fieldValue::ImageTexture_sequence& fieldValue::
ImageTexture () const
{
  return this->ImageTexture_;
}

fieldValue::ImageTexture_sequence& fieldValue::
ImageTexture ()
{
  return this->ImageTexture_;
}

void fieldValue::
ImageTexture (const ImageTexture_sequence& s)
{
  this->ImageTexture_ = s;
}

const fieldValue::MovieTexture_sequence& fieldValue::
MovieTexture () const
{
  return this->MovieTexture_;
}

fieldValue::MovieTexture_sequence& fieldValue::
MovieTexture ()
{
  return this->MovieTexture_;
}

void fieldValue::
MovieTexture (const MovieTexture_sequence& s)
{
  this->MovieTexture_ = s;
}

const fieldValue::MultiTexture_sequence& fieldValue::
MultiTexture () const
{
  return this->MultiTexture_;
}

fieldValue::MultiTexture_sequence& fieldValue::
MultiTexture ()
{
  return this->MultiTexture_;
}

void fieldValue::
MultiTexture (const MultiTexture_sequence& s)
{
  this->MultiTexture_ = s;
}

const fieldValue::PixelTexture_sequence& fieldValue::
PixelTexture () const
{
  return this->PixelTexture_;
}

fieldValue::PixelTexture_sequence& fieldValue::
PixelTexture ()
{
  return this->PixelTexture_;
}

void fieldValue::
PixelTexture (const PixelTexture_sequence& s)
{
  this->PixelTexture_ = s;
}

const fieldValue::GeneratedCubeMapTexture_sequence& fieldValue::
GeneratedCubeMapTexture () const
{
  return this->GeneratedCubeMapTexture_;
}

fieldValue::GeneratedCubeMapTexture_sequence& fieldValue::
GeneratedCubeMapTexture ()
{
  return this->GeneratedCubeMapTexture_;
}

void fieldValue::
GeneratedCubeMapTexture (const GeneratedCubeMapTexture_sequence& s)
{
  this->GeneratedCubeMapTexture_ = s;
}

const fieldValue::ImageCubeMapTexture_sequence& fieldValue::
ImageCubeMapTexture () const
{
  return this->ImageCubeMapTexture_;
}

fieldValue::ImageCubeMapTexture_sequence& fieldValue::
ImageCubeMapTexture ()
{
  return this->ImageCubeMapTexture_;
}

void fieldValue::
ImageCubeMapTexture (const ImageCubeMapTexture_sequence& s)
{
  this->ImageCubeMapTexture_ = s;
}

const fieldValue::MultiTextureTransform_sequence& fieldValue::
MultiTextureTransform () const
{
  return this->MultiTextureTransform_;
}

fieldValue::MultiTextureTransform_sequence& fieldValue::
MultiTextureTransform ()
{
  return this->MultiTextureTransform_;
}

void fieldValue::
MultiTextureTransform (const MultiTextureTransform_sequence& s)
{
  this->MultiTextureTransform_ = s;
}

const fieldValue::TextureTransform_sequence& fieldValue::
TextureTransform () const
{
  return this->TextureTransform_;
}

fieldValue::TextureTransform_sequence& fieldValue::
TextureTransform ()
{
  return this->TextureTransform_;
}

void fieldValue::
TextureTransform (const TextureTransform_sequence& s)
{
  this->TextureTransform_ = s;
}

const fieldValue::MetadataDouble_sequence& fieldValue::
MetadataDouble () const
{
  return this->MetadataDouble_;
}

fieldValue::MetadataDouble_sequence& fieldValue::
MetadataDouble ()
{
  return this->MetadataDouble_;
}

void fieldValue::
MetadataDouble (const MetadataDouble_sequence& s)
{
  this->MetadataDouble_ = s;
}

const fieldValue::MetadataFloat_sequence& fieldValue::
MetadataFloat () const
{
  return this->MetadataFloat_;
}

fieldValue::MetadataFloat_sequence& fieldValue::
MetadataFloat ()
{
  return this->MetadataFloat_;
}

void fieldValue::
MetadataFloat (const MetadataFloat_sequence& s)
{
  this->MetadataFloat_ = s;
}

const fieldValue::MetadataInteger_sequence& fieldValue::
MetadataInteger () const
{
  return this->MetadataInteger_;
}

fieldValue::MetadataInteger_sequence& fieldValue::
MetadataInteger ()
{
  return this->MetadataInteger_;
}

void fieldValue::
MetadataInteger (const MetadataInteger_sequence& s)
{
  this->MetadataInteger_ = s;
}

const fieldValue::MetadataSet_sequence& fieldValue::
MetadataSet () const
{
  return this->MetadataSet_;
}

fieldValue::MetadataSet_sequence& fieldValue::
MetadataSet ()
{
  return this->MetadataSet_;
}

void fieldValue::
MetadataSet (const MetadataSet_sequence& s)
{
  this->MetadataSet_ = s;
}

const fieldValue::MetadataString_sequence& fieldValue::
MetadataString () const
{
  return this->MetadataString_;
}

fieldValue::MetadataString_sequence& fieldValue::
MetadataString ()
{
  return this->MetadataString_;
}

void fieldValue::
MetadataString (const MetadataString_sequence& s)
{
  this->MetadataString_ = s;
}

const fieldValue::Appearance_sequence& fieldValue::
Appearance () const
{
  return this->Appearance_;
}

fieldValue::Appearance_sequence& fieldValue::
Appearance ()
{
  return this->Appearance_;
}

void fieldValue::
Appearance (const Appearance_sequence& s)
{
  this->Appearance_ = s;
}

const fieldValue::Background_sequence& fieldValue::
Background () const
{
  return this->Background_;
}

fieldValue::Background_sequence& fieldValue::
Background ()
{
  return this->Background_;
}

void fieldValue::
Background (const Background_sequence& s)
{
  this->Background_ = s;
}

const fieldValue::ColorInterpolator_sequence& fieldValue::
ColorInterpolator () const
{
  return this->ColorInterpolator_;
}

fieldValue::ColorInterpolator_sequence& fieldValue::
ColorInterpolator ()
{
  return this->ColorInterpolator_;
}

void fieldValue::
ColorInterpolator (const ColorInterpolator_sequence& s)
{
  this->ColorInterpolator_ = s;
}

const fieldValue::CoordinateInterpolator_sequence& fieldValue::
CoordinateInterpolator () const
{
  return this->CoordinateInterpolator_;
}

fieldValue::CoordinateInterpolator_sequence& fieldValue::
CoordinateInterpolator ()
{
  return this->CoordinateInterpolator_;
}

void fieldValue::
CoordinateInterpolator (const CoordinateInterpolator_sequence& s)
{
  this->CoordinateInterpolator_ = s;
}

const fieldValue::DirectionalLight_sequence& fieldValue::
DirectionalLight () const
{
  return this->DirectionalLight_;
}

fieldValue::DirectionalLight_sequence& fieldValue::
DirectionalLight ()
{
  return this->DirectionalLight_;
}

void fieldValue::
DirectionalLight (const DirectionalLight_sequence& s)
{
  this->DirectionalLight_ = s;
}

const fieldValue::Group_sequence& fieldValue::
Group () const
{
  return this->Group_;
}

fieldValue::Group_sequence& fieldValue::
Group ()
{
  return this->Group_;
}

void fieldValue::
Group (const Group_sequence& s)
{
  this->Group_ = s;
}

const fieldValue::NavigationInfo_sequence& fieldValue::
NavigationInfo () const
{
  return this->NavigationInfo_;
}

fieldValue::NavigationInfo_sequence& fieldValue::
NavigationInfo ()
{
  return this->NavigationInfo_;
}

void fieldValue::
NavigationInfo (const NavigationInfo_sequence& s)
{
  this->NavigationInfo_ = s;
}

const fieldValue::NormalInterpolator_sequence& fieldValue::
NormalInterpolator () const
{
  return this->NormalInterpolator_;
}

fieldValue::NormalInterpolator_sequence& fieldValue::
NormalInterpolator ()
{
  return this->NormalInterpolator_;
}

void fieldValue::
NormalInterpolator (const NormalInterpolator_sequence& s)
{
  this->NormalInterpolator_ = s;
}

const fieldValue::OrientationInterpolator_sequence& fieldValue::
OrientationInterpolator () const
{
  return this->OrientationInterpolator_;
}

fieldValue::OrientationInterpolator_sequence& fieldValue::
OrientationInterpolator ()
{
  return this->OrientationInterpolator_;
}

void fieldValue::
OrientationInterpolator (const OrientationInterpolator_sequence& s)
{
  this->OrientationInterpolator_ = s;
}

const fieldValue::PositionInterpolator_sequence& fieldValue::
PositionInterpolator () const
{
  return this->PositionInterpolator_;
}

fieldValue::PositionInterpolator_sequence& fieldValue::
PositionInterpolator ()
{
  return this->PositionInterpolator_;
}

void fieldValue::
PositionInterpolator (const PositionInterpolator_sequence& s)
{
  this->PositionInterpolator_ = s;
}

const fieldValue::ScalarInterpolator_sequence& fieldValue::
ScalarInterpolator () const
{
  return this->ScalarInterpolator_;
}

fieldValue::ScalarInterpolator_sequence& fieldValue::
ScalarInterpolator ()
{
  return this->ScalarInterpolator_;
}

void fieldValue::
ScalarInterpolator (const ScalarInterpolator_sequence& s)
{
  this->ScalarInterpolator_ = s;
}

const fieldValue::Shape_sequence& fieldValue::
Shape () const
{
  return this->Shape_;
}

fieldValue::Shape_sequence& fieldValue::
Shape ()
{
  return this->Shape_;
}

void fieldValue::
Shape (const Shape_sequence& s)
{
  this->Shape_ = s;
}

const fieldValue::TimeSensor_sequence& fieldValue::
TimeSensor () const
{
  return this->TimeSensor_;
}

fieldValue::TimeSensor_sequence& fieldValue::
TimeSensor ()
{
  return this->TimeSensor_;
}

void fieldValue::
TimeSensor (const TimeSensor_sequence& s)
{
  this->TimeSensor_ = s;
}

const fieldValue::Transform_sequence& fieldValue::
Transform () const
{
  return this->Transform_;
}

fieldValue::Transform_sequence& fieldValue::
Transform ()
{
  return this->Transform_;
}

void fieldValue::
Transform (const Transform_sequence& s)
{
  this->Transform_ = s;
}

const fieldValue::Viewpoint_sequence& fieldValue::
Viewpoint () const
{
  return this->Viewpoint_;
}

fieldValue::Viewpoint_sequence& fieldValue::
Viewpoint ()
{
  return this->Viewpoint_;
}

void fieldValue::
Viewpoint (const Viewpoint_sequence& s)
{
  this->Viewpoint_ = s;
}

const fieldValue::WorldInfo_sequence& fieldValue::
WorldInfo () const
{
  return this->WorldInfo_;
}

fieldValue::WorldInfo_sequence& fieldValue::
WorldInfo ()
{
  return this->WorldInfo_;
}

void fieldValue::
WorldInfo (const WorldInfo_sequence& s)
{
  this->WorldInfo_ = s;
}

const fieldValue::Anchor_sequence& fieldValue::
Anchor () const
{
  return this->Anchor_;
}

fieldValue::Anchor_sequence& fieldValue::
Anchor ()
{
  return this->Anchor_;
}

void fieldValue::
Anchor (const Anchor_sequence& s)
{
  this->Anchor_ = s;
}

const fieldValue::BooleanFilter_sequence& fieldValue::
BooleanFilter () const
{
  return this->BooleanFilter_;
}

fieldValue::BooleanFilter_sequence& fieldValue::
BooleanFilter ()
{
  return this->BooleanFilter_;
}

void fieldValue::
BooleanFilter (const BooleanFilter_sequence& s)
{
  this->BooleanFilter_ = s;
}

const fieldValue::BooleanSequencer_sequence& fieldValue::
BooleanSequencer () const
{
  return this->BooleanSequencer_;
}

fieldValue::BooleanSequencer_sequence& fieldValue::
BooleanSequencer ()
{
  return this->BooleanSequencer_;
}

void fieldValue::
BooleanSequencer (const BooleanSequencer_sequence& s)
{
  this->BooleanSequencer_ = s;
}

const fieldValue::BooleanToggle_sequence& fieldValue::
BooleanToggle () const
{
  return this->BooleanToggle_;
}

fieldValue::BooleanToggle_sequence& fieldValue::
BooleanToggle ()
{
  return this->BooleanToggle_;
}

void fieldValue::
BooleanToggle (const BooleanToggle_sequence& s)
{
  this->BooleanToggle_ = s;
}

const fieldValue::BooleanTrigger_sequence& fieldValue::
BooleanTrigger () const
{
  return this->BooleanTrigger_;
}

fieldValue::BooleanTrigger_sequence& fieldValue::
BooleanTrigger ()
{
  return this->BooleanTrigger_;
}

void fieldValue::
BooleanTrigger (const BooleanTrigger_sequence& s)
{
  this->BooleanTrigger_ = s;
}

const fieldValue::CylinderSensor_sequence& fieldValue::
CylinderSensor () const
{
  return this->CylinderSensor_;
}

fieldValue::CylinderSensor_sequence& fieldValue::
CylinderSensor ()
{
  return this->CylinderSensor_;
}

void fieldValue::
CylinderSensor (const CylinderSensor_sequence& s)
{
  this->CylinderSensor_ = s;
}

const fieldValue::Inline_sequence& fieldValue::
Inline () const
{
  return this->Inline_;
}

fieldValue::Inline_sequence& fieldValue::
Inline ()
{
  return this->Inline_;
}

void fieldValue::
Inline (const Inline_sequence& s)
{
  this->Inline_ = s;
}

const fieldValue::IntegerSequencer_sequence& fieldValue::
IntegerSequencer () const
{
  return this->IntegerSequencer_;
}

fieldValue::IntegerSequencer_sequence& fieldValue::
IntegerSequencer ()
{
  return this->IntegerSequencer_;
}

void fieldValue::
IntegerSequencer (const IntegerSequencer_sequence& s)
{
  this->IntegerSequencer_ = s;
}

const fieldValue::IntegerTrigger_sequence& fieldValue::
IntegerTrigger () const
{
  return this->IntegerTrigger_;
}

fieldValue::IntegerTrigger_sequence& fieldValue::
IntegerTrigger ()
{
  return this->IntegerTrigger_;
}

void fieldValue::
IntegerTrigger (const IntegerTrigger_sequence& s)
{
  this->IntegerTrigger_ = s;
}

const fieldValue::KeySensor_sequence& fieldValue::
KeySensor () const
{
  return this->KeySensor_;
}

fieldValue::KeySensor_sequence& fieldValue::
KeySensor ()
{
  return this->KeySensor_;
}

void fieldValue::
KeySensor (const KeySensor_sequence& s)
{
  this->KeySensor_ = s;
}

const fieldValue::PlaneSensor_sequence& fieldValue::
PlaneSensor () const
{
  return this->PlaneSensor_;
}

fieldValue::PlaneSensor_sequence& fieldValue::
PlaneSensor ()
{
  return this->PlaneSensor_;
}

void fieldValue::
PlaneSensor (const PlaneSensor_sequence& s)
{
  this->PlaneSensor_ = s;
}

const fieldValue::PointLight_sequence& fieldValue::
PointLight () const
{
  return this->PointLight_;
}

fieldValue::PointLight_sequence& fieldValue::
PointLight ()
{
  return this->PointLight_;
}

void fieldValue::
PointLight (const PointLight_sequence& s)
{
  this->PointLight_ = s;
}

const fieldValue::ProximitySensor_sequence& fieldValue::
ProximitySensor () const
{
  return this->ProximitySensor_;
}

fieldValue::ProximitySensor_sequence& fieldValue::
ProximitySensor ()
{
  return this->ProximitySensor_;
}

void fieldValue::
ProximitySensor (const ProximitySensor_sequence& s)
{
  this->ProximitySensor_ = s;
}

const fieldValue::SphereSensor_sequence& fieldValue::
SphereSensor () const
{
  return this->SphereSensor_;
}

fieldValue::SphereSensor_sequence& fieldValue::
SphereSensor ()
{
  return this->SphereSensor_;
}

void fieldValue::
SphereSensor (const SphereSensor_sequence& s)
{
  this->SphereSensor_ = s;
}

const fieldValue::SpotLight_sequence& fieldValue::
SpotLight () const
{
  return this->SpotLight_;
}

fieldValue::SpotLight_sequence& fieldValue::
SpotLight ()
{
  return this->SpotLight_;
}

void fieldValue::
SpotLight (const SpotLight_sequence& s)
{
  this->SpotLight_ = s;
}

const fieldValue::StringSensor_sequence& fieldValue::
StringSensor () const
{
  return this->StringSensor_;
}

fieldValue::StringSensor_sequence& fieldValue::
StringSensor ()
{
  return this->StringSensor_;
}

void fieldValue::
StringSensor (const StringSensor_sequence& s)
{
  this->StringSensor_ = s;
}

const fieldValue::Switch_sequence& fieldValue::
Switch () const
{
  return this->Switch_;
}

fieldValue::Switch_sequence& fieldValue::
Switch ()
{
  return this->Switch_;
}

void fieldValue::
Switch (const Switch_sequence& s)
{
  this->Switch_ = s;
}

const fieldValue::TimeTrigger_sequence& fieldValue::
TimeTrigger () const
{
  return this->TimeTrigger_;
}

fieldValue::TimeTrigger_sequence& fieldValue::
TimeTrigger ()
{
  return this->TimeTrigger_;
}

void fieldValue::
TimeTrigger (const TimeTrigger_sequence& s)
{
  this->TimeTrigger_ = s;
}

const fieldValue::TouchSensor_sequence& fieldValue::
TouchSensor () const
{
  return this->TouchSensor_;
}

fieldValue::TouchSensor_sequence& fieldValue::
TouchSensor ()
{
  return this->TouchSensor_;
}

void fieldValue::
TouchSensor (const TouchSensor_sequence& s)
{
  this->TouchSensor_ = s;
}

const fieldValue::AudioClip_sequence& fieldValue::
AudioClip () const
{
  return this->AudioClip_;
}

fieldValue::AudioClip_sequence& fieldValue::
AudioClip ()
{
  return this->AudioClip_;
}

void fieldValue::
AudioClip (const AudioClip_sequence& s)
{
  this->AudioClip_ = s;
}

const fieldValue::Billboard_sequence& fieldValue::
Billboard () const
{
  return this->Billboard_;
}

fieldValue::Billboard_sequence& fieldValue::
Billboard ()
{
  return this->Billboard_;
}

void fieldValue::
Billboard (const Billboard_sequence& s)
{
  this->Billboard_ = s;
}

const fieldValue::Collision_sequence& fieldValue::
Collision () const
{
  return this->Collision_;
}

fieldValue::Collision_sequence& fieldValue::
Collision ()
{
  return this->Collision_;
}

void fieldValue::
Collision (const Collision_sequence& s)
{
  this->Collision_ = s;
}

const fieldValue::Fog_sequence& fieldValue::
Fog () const
{
  return this->Fog_;
}

fieldValue::Fog_sequence& fieldValue::
Fog ()
{
  return this->Fog_;
}

void fieldValue::
Fog (const Fog_sequence& s)
{
  this->Fog_ = s;
}

const fieldValue::LoadSensor_sequence& fieldValue::
LoadSensor () const
{
  return this->LoadSensor_;
}

fieldValue::LoadSensor_sequence& fieldValue::
LoadSensor ()
{
  return this->LoadSensor_;
}

void fieldValue::
LoadSensor (const LoadSensor_sequence& s)
{
  this->LoadSensor_ = s;
}

const fieldValue::LocalFog_sequence& fieldValue::
LocalFog () const
{
  return this->LocalFog_;
}

fieldValue::LocalFog_sequence& fieldValue::
LocalFog ()
{
  return this->LocalFog_;
}

void fieldValue::
LocalFog (const LocalFog_sequence& s)
{
  this->LocalFog_ = s;
}

const fieldValue::LOD_sequence& fieldValue::
LOD () const
{
  return this->LOD_;
}

fieldValue::LOD_sequence& fieldValue::
LOD ()
{
  return this->LOD_;
}

void fieldValue::
LOD (const LOD_sequence& s)
{
  this->LOD_ = s;
}

const fieldValue::Script_sequence& fieldValue::
Script () const
{
  return this->Script_;
}

fieldValue::Script_sequence& fieldValue::
Script ()
{
  return this->Script_;
}

void fieldValue::
Script (const Script_sequence& s)
{
  this->Script_ = s;
}

const fieldValue::Sound_sequence& fieldValue::
Sound () const
{
  return this->Sound_;
}

fieldValue::Sound_sequence& fieldValue::
Sound ()
{
  return this->Sound_;
}

void fieldValue::
Sound (const Sound_sequence& s)
{
  this->Sound_ = s;
}

const fieldValue::VisibilitySensor_sequence& fieldValue::
VisibilitySensor () const
{
  return this->VisibilitySensor_;
}

fieldValue::VisibilitySensor_sequence& fieldValue::
VisibilitySensor ()
{
  return this->VisibilitySensor_;
}

void fieldValue::
VisibilitySensor (const VisibilitySensor_sequence& s)
{
  this->VisibilitySensor_ = s;
}

const fieldValue::CoordinateInterpolator2D_sequence& fieldValue::
CoordinateInterpolator2D () const
{
  return this->CoordinateInterpolator2D_;
}

fieldValue::CoordinateInterpolator2D_sequence& fieldValue::
CoordinateInterpolator2D ()
{
  return this->CoordinateInterpolator2D_;
}

void fieldValue::
CoordinateInterpolator2D (const CoordinateInterpolator2D_sequence& s)
{
  this->CoordinateInterpolator2D_ = s;
}

const fieldValue::PositionInterpolator2D_sequence& fieldValue::
PositionInterpolator2D () const
{
  return this->PositionInterpolator2D_;
}

fieldValue::PositionInterpolator2D_sequence& fieldValue::
PositionInterpolator2D ()
{
  return this->PositionInterpolator2D_;
}

void fieldValue::
PositionInterpolator2D (const PositionInterpolator2D_sequence& s)
{
  this->PositionInterpolator2D_ = s;
}

const fieldValue::StaticGroup_sequence& fieldValue::
StaticGroup () const
{
  return this->StaticGroup_;
}

fieldValue::StaticGroup_sequence& fieldValue::
StaticGroup ()
{
  return this->StaticGroup_;
}

void fieldValue::
StaticGroup (const StaticGroup_sequence& s)
{
  this->StaticGroup_ = s;
}

const fieldValue::CADAssembly_sequence& fieldValue::
CADAssembly () const
{
  return this->CADAssembly_;
}

fieldValue::CADAssembly_sequence& fieldValue::
CADAssembly ()
{
  return this->CADAssembly_;
}

void fieldValue::
CADAssembly (const CADAssembly_sequence& s)
{
  this->CADAssembly_ = s;
}

const fieldValue::CADLayer_sequence& fieldValue::
CADLayer () const
{
  return this->CADLayer_;
}

fieldValue::CADLayer_sequence& fieldValue::
CADLayer ()
{
  return this->CADLayer_;
}

void fieldValue::
CADLayer (const CADLayer_sequence& s)
{
  this->CADLayer_ = s;
}

const fieldValue::EspduTransform_sequence& fieldValue::
EspduTransform () const
{
  return this->EspduTransform_;
}

fieldValue::EspduTransform_sequence& fieldValue::
EspduTransform ()
{
  return this->EspduTransform_;
}

void fieldValue::
EspduTransform (const EspduTransform_sequence& s)
{
  this->EspduTransform_ = s;
}

const fieldValue::ReceiverPdu_sequence& fieldValue::
ReceiverPdu () const
{
  return this->ReceiverPdu_;
}

fieldValue::ReceiverPdu_sequence& fieldValue::
ReceiverPdu ()
{
  return this->ReceiverPdu_;
}

void fieldValue::
ReceiverPdu (const ReceiverPdu_sequence& s)
{
  this->ReceiverPdu_ = s;
}

const fieldValue::SignalPdu_sequence& fieldValue::
SignalPdu () const
{
  return this->SignalPdu_;
}

fieldValue::SignalPdu_sequence& fieldValue::
SignalPdu ()
{
  return this->SignalPdu_;
}

void fieldValue::
SignalPdu (const SignalPdu_sequence& s)
{
  this->SignalPdu_ = s;
}

const fieldValue::TransmitterPdu_sequence& fieldValue::
TransmitterPdu () const
{
  return this->TransmitterPdu_;
}

fieldValue::TransmitterPdu_sequence& fieldValue::
TransmitterPdu ()
{
  return this->TransmitterPdu_;
}

void fieldValue::
TransmitterPdu (const TransmitterPdu_sequence& s)
{
  this->TransmitterPdu_ = s;
}

const fieldValue::GeoLocation_sequence& fieldValue::
GeoLocation () const
{
  return this->GeoLocation_;
}

fieldValue::GeoLocation_sequence& fieldValue::
GeoLocation ()
{
  return this->GeoLocation_;
}

void fieldValue::
GeoLocation (const GeoLocation_sequence& s)
{
  this->GeoLocation_ = s;
}

const fieldValue::GeoLOD_sequence& fieldValue::
GeoLOD () const
{
  return this->GeoLOD_;
}

fieldValue::GeoLOD_sequence& fieldValue::
GeoLOD ()
{
  return this->GeoLOD_;
}

void fieldValue::
GeoLOD (const GeoLOD_sequence& s)
{
  this->GeoLOD_ = s;
}

const fieldValue::GeoMetadata_sequence& fieldValue::
GeoMetadata () const
{
  return this->GeoMetadata_;
}

fieldValue::GeoMetadata_sequence& fieldValue::
GeoMetadata ()
{
  return this->GeoMetadata_;
}

void fieldValue::
GeoMetadata (const GeoMetadata_sequence& s)
{
  this->GeoMetadata_ = s;
}

const fieldValue::GeoOrigin_sequence& fieldValue::
GeoOrigin () const
{
  return this->GeoOrigin_;
}

fieldValue::GeoOrigin_sequence& fieldValue::
GeoOrigin ()
{
  return this->GeoOrigin_;
}

void fieldValue::
GeoOrigin (const GeoOrigin_sequence& s)
{
  this->GeoOrigin_ = s;
}

const fieldValue::GeoPositionInterpolator_sequence& fieldValue::
GeoPositionInterpolator () const
{
  return this->GeoPositionInterpolator_;
}

fieldValue::GeoPositionInterpolator_sequence& fieldValue::
GeoPositionInterpolator ()
{
  return this->GeoPositionInterpolator_;
}

void fieldValue::
GeoPositionInterpolator (const GeoPositionInterpolator_sequence& s)
{
  this->GeoPositionInterpolator_ = s;
}

const fieldValue::GeoTouchSensor_sequence& fieldValue::
GeoTouchSensor () const
{
  return this->GeoTouchSensor_;
}

fieldValue::GeoTouchSensor_sequence& fieldValue::
GeoTouchSensor ()
{
  return this->GeoTouchSensor_;
}

void fieldValue::
GeoTouchSensor (const GeoTouchSensor_sequence& s)
{
  this->GeoTouchSensor_ = s;
}

const fieldValue::GeoViewpoint_sequence& fieldValue::
GeoViewpoint () const
{
  return this->GeoViewpoint_;
}

fieldValue::GeoViewpoint_sequence& fieldValue::
GeoViewpoint ()
{
  return this->GeoViewpoint_;
}

void fieldValue::
GeoViewpoint (const GeoViewpoint_sequence& s)
{
  this->GeoViewpoint_ = s;
}

const fieldValue::HAnimHumanoid_sequence& fieldValue::
HAnimHumanoid () const
{
  return this->HAnimHumanoid_;
}

fieldValue::HAnimHumanoid_sequence& fieldValue::
HAnimHumanoid ()
{
  return this->HAnimHumanoid_;
}

void fieldValue::
HAnimHumanoid (const HAnimHumanoid_sequence& s)
{
  this->HAnimHumanoid_ = s;
}

const fieldValue::HAnimJoint_sequence& fieldValue::
HAnimJoint () const
{
  return this->HAnimJoint_;
}

fieldValue::HAnimJoint_sequence& fieldValue::
HAnimJoint ()
{
  return this->HAnimJoint_;
}

void fieldValue::
HAnimJoint (const HAnimJoint_sequence& s)
{
  this->HAnimJoint_ = s;
}

const fieldValue::HAnimSegment_sequence& fieldValue::
HAnimSegment () const
{
  return this->HAnimSegment_;
}

fieldValue::HAnimSegment_sequence& fieldValue::
HAnimSegment ()
{
  return this->HAnimSegment_;
}

void fieldValue::
HAnimSegment (const HAnimSegment_sequence& s)
{
  this->HAnimSegment_ = s;
}

const fieldValue::HAnimSite_sequence& fieldValue::
HAnimSite () const
{
  return this->HAnimSite_;
}

fieldValue::HAnimSite_sequence& fieldValue::
HAnimSite ()
{
  return this->HAnimSite_;
}

void fieldValue::
HAnimSite (const HAnimSite_sequence& s)
{
  this->HAnimSite_ = s;
}

const fieldValue::NurbsOrientationInterpolator_sequence& fieldValue::
NurbsOrientationInterpolator () const
{
  return this->NurbsOrientationInterpolator_;
}

fieldValue::NurbsOrientationInterpolator_sequence& fieldValue::
NurbsOrientationInterpolator ()
{
  return this->NurbsOrientationInterpolator_;
}

void fieldValue::
NurbsOrientationInterpolator (const NurbsOrientationInterpolator_sequence& s)
{
  this->NurbsOrientationInterpolator_ = s;
}

const fieldValue::NurbsPositionInterpolator_sequence& fieldValue::
NurbsPositionInterpolator () const
{
  return this->NurbsPositionInterpolator_;
}

fieldValue::NurbsPositionInterpolator_sequence& fieldValue::
NurbsPositionInterpolator ()
{
  return this->NurbsPositionInterpolator_;
}

void fieldValue::
NurbsPositionInterpolator (const NurbsPositionInterpolator_sequence& s)
{
  this->NurbsPositionInterpolator_ = s;
}

const fieldValue::NurbsSurfaceInterpolator_sequence& fieldValue::
NurbsSurfaceInterpolator () const
{
  return this->NurbsSurfaceInterpolator_;
}

fieldValue::NurbsSurfaceInterpolator_sequence& fieldValue::
NurbsSurfaceInterpolator ()
{
  return this->NurbsSurfaceInterpolator_;
}

void fieldValue::
NurbsSurfaceInterpolator (const NurbsSurfaceInterpolator_sequence& s)
{
  this->NurbsSurfaceInterpolator_ = s;
}

const fieldValue::NurbsSet_sequence& fieldValue::
NurbsSet () const
{
  return this->NurbsSet_;
}

fieldValue::NurbsSet_sequence& fieldValue::
NurbsSet ()
{
  return this->NurbsSet_;
}

void fieldValue::
NurbsSet (const NurbsSet_sequence& s)
{
  this->NurbsSet_ = s;
}

const fieldValue::ProtoInstance_sequence& fieldValue::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

fieldValue::ProtoInstance_sequence& fieldValue::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void fieldValue::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const fieldValue::Box_sequence& fieldValue::
Box () const
{
  return this->Box_;
}

fieldValue::Box_sequence& fieldValue::
Box ()
{
  return this->Box_;
}

void fieldValue::
Box (const Box_sequence& s)
{
  this->Box_ = s;
}

const fieldValue::Cone_sequence& fieldValue::
Cone () const
{
  return this->Cone_;
}

fieldValue::Cone_sequence& fieldValue::
Cone ()
{
  return this->Cone_;
}

void fieldValue::
Cone (const Cone_sequence& s)
{
  this->Cone_ = s;
}

const fieldValue::Cylinder_sequence& fieldValue::
Cylinder () const
{
  return this->Cylinder_;
}

fieldValue::Cylinder_sequence& fieldValue::
Cylinder ()
{
  return this->Cylinder_;
}

void fieldValue::
Cylinder (const Cylinder_sequence& s)
{
  this->Cylinder_ = s;
}

const fieldValue::IndexedFaceSet_sequence& fieldValue::
IndexedFaceSet () const
{
  return this->IndexedFaceSet_;
}

fieldValue::IndexedFaceSet_sequence& fieldValue::
IndexedFaceSet ()
{
  return this->IndexedFaceSet_;
}

void fieldValue::
IndexedFaceSet (const IndexedFaceSet_sequence& s)
{
  this->IndexedFaceSet_ = s;
}

const fieldValue::IndexedLineSet_sequence& fieldValue::
IndexedLineSet () const
{
  return this->IndexedLineSet_;
}

fieldValue::IndexedLineSet_sequence& fieldValue::
IndexedLineSet ()
{
  return this->IndexedLineSet_;
}

void fieldValue::
IndexedLineSet (const IndexedLineSet_sequence& s)
{
  this->IndexedLineSet_ = s;
}

const fieldValue::IndexedTriangleFanSet_sequence& fieldValue::
IndexedTriangleFanSet () const
{
  return this->IndexedTriangleFanSet_;
}

fieldValue::IndexedTriangleFanSet_sequence& fieldValue::
IndexedTriangleFanSet ()
{
  return this->IndexedTriangleFanSet_;
}

void fieldValue::
IndexedTriangleFanSet (const IndexedTriangleFanSet_sequence& s)
{
  this->IndexedTriangleFanSet_ = s;
}

const fieldValue::IndexedTriangleSet_sequence& fieldValue::
IndexedTriangleSet () const
{
  return this->IndexedTriangleSet_;
}

fieldValue::IndexedTriangleSet_sequence& fieldValue::
IndexedTriangleSet ()
{
  return this->IndexedTriangleSet_;
}

void fieldValue::
IndexedTriangleSet (const IndexedTriangleSet_sequence& s)
{
  this->IndexedTriangleSet_ = s;
}

const fieldValue::IndexedTriangleStripSet_sequence& fieldValue::
IndexedTriangleStripSet () const
{
  return this->IndexedTriangleStripSet_;
}

fieldValue::IndexedTriangleStripSet_sequence& fieldValue::
IndexedTriangleStripSet ()
{
  return this->IndexedTriangleStripSet_;
}

void fieldValue::
IndexedTriangleStripSet (const IndexedTriangleStripSet_sequence& s)
{
  this->IndexedTriangleStripSet_ = s;
}

const fieldValue::LineSet_sequence& fieldValue::
LineSet () const
{
  return this->LineSet_;
}

fieldValue::LineSet_sequence& fieldValue::
LineSet ()
{
  return this->LineSet_;
}

void fieldValue::
LineSet (const LineSet_sequence& s)
{
  this->LineSet_ = s;
}

const fieldValue::PointSet_sequence& fieldValue::
PointSet () const
{
  return this->PointSet_;
}

fieldValue::PointSet_sequence& fieldValue::
PointSet ()
{
  return this->PointSet_;
}

void fieldValue::
PointSet (const PointSet_sequence& s)
{
  this->PointSet_ = s;
}

const fieldValue::Sphere_sequence& fieldValue::
Sphere () const
{
  return this->Sphere_;
}

fieldValue::Sphere_sequence& fieldValue::
Sphere ()
{
  return this->Sphere_;
}

void fieldValue::
Sphere (const Sphere_sequence& s)
{
  this->Sphere_ = s;
}

const fieldValue::TriangleFanSet_sequence& fieldValue::
TriangleFanSet () const
{
  return this->TriangleFanSet_;
}

fieldValue::TriangleFanSet_sequence& fieldValue::
TriangleFanSet ()
{
  return this->TriangleFanSet_;
}

void fieldValue::
TriangleFanSet (const TriangleFanSet_sequence& s)
{
  this->TriangleFanSet_ = s;
}

const fieldValue::TriangleSet_sequence& fieldValue::
TriangleSet () const
{
  return this->TriangleSet_;
}

fieldValue::TriangleSet_sequence& fieldValue::
TriangleSet ()
{
  return this->TriangleSet_;
}

void fieldValue::
TriangleSet (const TriangleSet_sequence& s)
{
  this->TriangleSet_ = s;
}

const fieldValue::TriangleStripSet_sequence& fieldValue::
TriangleStripSet () const
{
  return this->TriangleStripSet_;
}

fieldValue::TriangleStripSet_sequence& fieldValue::
TriangleStripSet ()
{
  return this->TriangleStripSet_;
}

void fieldValue::
TriangleStripSet (const TriangleStripSet_sequence& s)
{
  this->TriangleStripSet_ = s;
}

const fieldValue::ElevationGrid_sequence& fieldValue::
ElevationGrid () const
{
  return this->ElevationGrid_;
}

fieldValue::ElevationGrid_sequence& fieldValue::
ElevationGrid ()
{
  return this->ElevationGrid_;
}

void fieldValue::
ElevationGrid (const ElevationGrid_sequence& s)
{
  this->ElevationGrid_ = s;
}

const fieldValue::Polyline2D_sequence& fieldValue::
Polyline2D () const
{
  return this->Polyline2D_;
}

fieldValue::Polyline2D_sequence& fieldValue::
Polyline2D ()
{
  return this->Polyline2D_;
}

void fieldValue::
Polyline2D (const Polyline2D_sequence& s)
{
  this->Polyline2D_ = s;
}

const fieldValue::Polypoint2D_sequence& fieldValue::
Polypoint2D () const
{
  return this->Polypoint2D_;
}

fieldValue::Polypoint2D_sequence& fieldValue::
Polypoint2D ()
{
  return this->Polypoint2D_;
}

void fieldValue::
Polypoint2D (const Polypoint2D_sequence& s)
{
  this->Polypoint2D_ = s;
}

const fieldValue::Rectangle2D_sequence& fieldValue::
Rectangle2D () const
{
  return this->Rectangle2D_;
}

fieldValue::Rectangle2D_sequence& fieldValue::
Rectangle2D ()
{
  return this->Rectangle2D_;
}

void fieldValue::
Rectangle2D (const Rectangle2D_sequence& s)
{
  this->Rectangle2D_ = s;
}

const fieldValue::TriangleSet2D_sequence& fieldValue::
TriangleSet2D () const
{
  return this->TriangleSet2D_;
}

fieldValue::TriangleSet2D_sequence& fieldValue::
TriangleSet2D ()
{
  return this->TriangleSet2D_;
}

void fieldValue::
TriangleSet2D (const TriangleSet2D_sequence& s)
{
  this->TriangleSet2D_ = s;
}

const fieldValue::Extrusion_sequence& fieldValue::
Extrusion () const
{
  return this->Extrusion_;
}

fieldValue::Extrusion_sequence& fieldValue::
Extrusion ()
{
  return this->Extrusion_;
}

void fieldValue::
Extrusion (const Extrusion_sequence& s)
{
  this->Extrusion_ = s;
}

const fieldValue::Text_sequence& fieldValue::
Text () const
{
  return this->Text_;
}

fieldValue::Text_sequence& fieldValue::
Text ()
{
  return this->Text_;
}

void fieldValue::
Text (const Text_sequence& s)
{
  this->Text_ = s;
}

const fieldValue::Arc2D_sequence& fieldValue::
Arc2D () const
{
  return this->Arc2D_;
}

fieldValue::Arc2D_sequence& fieldValue::
Arc2D ()
{
  return this->Arc2D_;
}

void fieldValue::
Arc2D (const Arc2D_sequence& s)
{
  this->Arc2D_ = s;
}

const fieldValue::ArcClose2D_sequence& fieldValue::
ArcClose2D () const
{
  return this->ArcClose2D_;
}

fieldValue::ArcClose2D_sequence& fieldValue::
ArcClose2D ()
{
  return this->ArcClose2D_;
}

void fieldValue::
ArcClose2D (const ArcClose2D_sequence& s)
{
  this->ArcClose2D_ = s;
}

const fieldValue::Circle2D_sequence& fieldValue::
Circle2D () const
{
  return this->Circle2D_;
}

fieldValue::Circle2D_sequence& fieldValue::
Circle2D ()
{
  return this->Circle2D_;
}

void fieldValue::
Circle2D (const Circle2D_sequence& s)
{
  this->Circle2D_ = s;
}

const fieldValue::Disk2D_sequence& fieldValue::
Disk2D () const
{
  return this->Disk2D_;
}

fieldValue::Disk2D_sequence& fieldValue::
Disk2D ()
{
  return this->Disk2D_;
}

void fieldValue::
Disk2D (const Disk2D_sequence& s)
{
  this->Disk2D_ = s;
}

const fieldValue::QuadSet_sequence& fieldValue::
QuadSet () const
{
  return this->QuadSet_;
}

fieldValue::QuadSet_sequence& fieldValue::
QuadSet ()
{
  return this->QuadSet_;
}

void fieldValue::
QuadSet (const QuadSet_sequence& s)
{
  this->QuadSet_ = s;
}

const fieldValue::IndexedQuadSet_sequence& fieldValue::
IndexedQuadSet () const
{
  return this->IndexedQuadSet_;
}

fieldValue::IndexedQuadSet_sequence& fieldValue::
IndexedQuadSet ()
{
  return this->IndexedQuadSet_;
}

void fieldValue::
IndexedQuadSet (const IndexedQuadSet_sequence& s)
{
  this->IndexedQuadSet_ = s;
}

const fieldValue::GeoElevationGrid_sequence& fieldValue::
GeoElevationGrid () const
{
  return this->GeoElevationGrid_;
}

fieldValue::GeoElevationGrid_sequence& fieldValue::
GeoElevationGrid ()
{
  return this->GeoElevationGrid_;
}

void fieldValue::
GeoElevationGrid (const GeoElevationGrid_sequence& s)
{
  this->GeoElevationGrid_ = s;
}

const fieldValue::NurbsCurve_sequence& fieldValue::
NurbsCurve () const
{
  return this->NurbsCurve_;
}

fieldValue::NurbsCurve_sequence& fieldValue::
NurbsCurve ()
{
  return this->NurbsCurve_;
}

void fieldValue::
NurbsCurve (const NurbsCurve_sequence& s)
{
  this->NurbsCurve_ = s;
}

const fieldValue::NurbsCurve2D_sequence& fieldValue::
NurbsCurve2D () const
{
  return this->NurbsCurve2D_;
}

fieldValue::NurbsCurve2D_sequence& fieldValue::
NurbsCurve2D ()
{
  return this->NurbsCurve2D_;
}

void fieldValue::
NurbsCurve2D (const NurbsCurve2D_sequence& s)
{
  this->NurbsCurve2D_ = s;
}

const fieldValue::NurbsPatchSurface_sequence& fieldValue::
NurbsPatchSurface () const
{
  return this->NurbsPatchSurface_;
}

fieldValue::NurbsPatchSurface_sequence& fieldValue::
NurbsPatchSurface ()
{
  return this->NurbsPatchSurface_;
}

void fieldValue::
NurbsPatchSurface (const NurbsPatchSurface_sequence& s)
{
  this->NurbsPatchSurface_ = s;
}

const fieldValue::NurbsSweptSurface_sequence& fieldValue::
NurbsSweptSurface () const
{
  return this->NurbsSweptSurface_;
}

fieldValue::NurbsSweptSurface_sequence& fieldValue::
NurbsSweptSurface ()
{
  return this->NurbsSweptSurface_;
}

void fieldValue::
NurbsSweptSurface (const NurbsSweptSurface_sequence& s)
{
  this->NurbsSweptSurface_ = s;
}

const fieldValue::NurbsSwungSurface_sequence& fieldValue::
NurbsSwungSurface () const
{
  return this->NurbsSwungSurface_;
}

fieldValue::NurbsSwungSurface_sequence& fieldValue::
NurbsSwungSurface ()
{
  return this->NurbsSwungSurface_;
}

void fieldValue::
NurbsSwungSurface (const NurbsSwungSurface_sequence& s)
{
  this->NurbsSwungSurface_ = s;
}

const fieldValue::NurbsTrimmedSurface_sequence& fieldValue::
NurbsTrimmedSurface () const
{
  return this->NurbsTrimmedSurface_;
}

fieldValue::NurbsTrimmedSurface_sequence& fieldValue::
NurbsTrimmedSurface ()
{
  return this->NurbsTrimmedSurface_;
}

void fieldValue::
NurbsTrimmedSurface (const NurbsTrimmedSurface_sequence& s)
{
  this->NurbsTrimmedSurface_ = s;
}

const fieldValue::Color_sequence& fieldValue::
Color () const
{
  return this->Color_;
}

fieldValue::Color_sequence& fieldValue::
Color ()
{
  return this->Color_;
}

void fieldValue::
Color (const Color_sequence& s)
{
  this->Color_ = s;
}

const fieldValue::ColorRGBA_sequence& fieldValue::
ColorRGBA () const
{
  return this->ColorRGBA_;
}

fieldValue::ColorRGBA_sequence& fieldValue::
ColorRGBA ()
{
  return this->ColorRGBA_;
}

void fieldValue::
ColorRGBA (const ColorRGBA_sequence& s)
{
  this->ColorRGBA_ = s;
}

const fieldValue::Coordinate_sequence& fieldValue::
Coordinate () const
{
  return this->Coordinate_;
}

fieldValue::Coordinate_sequence& fieldValue::
Coordinate ()
{
  return this->Coordinate_;
}

void fieldValue::
Coordinate (const Coordinate_sequence& s)
{
  this->Coordinate_ = s;
}

const fieldValue::CoordinateDouble_sequence& fieldValue::
CoordinateDouble () const
{
  return this->CoordinateDouble_;
}

fieldValue::CoordinateDouble_sequence& fieldValue::
CoordinateDouble ()
{
  return this->CoordinateDouble_;
}

void fieldValue::
CoordinateDouble (const CoordinateDouble_sequence& s)
{
  this->CoordinateDouble_ = s;
}

const fieldValue::FontStyle_sequence& fieldValue::
FontStyle () const
{
  return this->FontStyle_;
}

fieldValue::FontStyle_sequence& fieldValue::
FontStyle ()
{
  return this->FontStyle_;
}

void fieldValue::
FontStyle (const FontStyle_sequence& s)
{
  this->FontStyle_ = s;
}

const fieldValue::GeoCoordinate_sequence& fieldValue::
GeoCoordinate () const
{
  return this->GeoCoordinate_;
}

fieldValue::GeoCoordinate_sequence& fieldValue::
GeoCoordinate ()
{
  return this->GeoCoordinate_;
}

void fieldValue::
GeoCoordinate (const GeoCoordinate_sequence& s)
{
  this->GeoCoordinate_ = s;
}

const fieldValue::Normal_sequence& fieldValue::
Normal () const
{
  return this->Normal_;
}

fieldValue::Normal_sequence& fieldValue::
Normal ()
{
  return this->Normal_;
}

void fieldValue::
Normal (const Normal_sequence& s)
{
  this->Normal_ = s;
}

const fieldValue::TextureCoordinate_sequence& fieldValue::
TextureCoordinate () const
{
  return this->TextureCoordinate_;
}

fieldValue::TextureCoordinate_sequence& fieldValue::
TextureCoordinate ()
{
  return this->TextureCoordinate_;
}

void fieldValue::
TextureCoordinate (const TextureCoordinate_sequence& s)
{
  this->TextureCoordinate_ = s;
}

const fieldValue::NurbsTextureCoordinate_sequence& fieldValue::
NurbsTextureCoordinate () const
{
  return this->NurbsTextureCoordinate_;
}

fieldValue::NurbsTextureCoordinate_sequence& fieldValue::
NurbsTextureCoordinate ()
{
  return this->NurbsTextureCoordinate_;
}

void fieldValue::
NurbsTextureCoordinate (const NurbsTextureCoordinate_sequence& s)
{
  this->NurbsTextureCoordinate_ = s;
}

const fieldValue::name_type& fieldValue::
name () const
{
  return this->name_.get ();
}

fieldValue::name_type& fieldValue::
name ()
{
  return this->name_.get ();
}

void fieldValue::
name (const name_type& x)
{
  this->name_.set (x);
}

void fieldValue::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const fieldValue::value_optional& fieldValue::
value () const
{
  return this->value_;
}

fieldValue::value_optional& fieldValue::
value ()
{
  return this->value_;
}

void fieldValue::
value (const value_type& x)
{
  this->value_.set (x);
}

void fieldValue::
value (const value_optional& x)
{
  this->value_ = x;
}

void fieldValue::
value (::std::auto_ptr< value_type > x)
{
  this->value_.set (x);
}


// head
// 

const head::component_sequence& head::
component () const
{
  return this->component_;
}

head::component_sequence& head::
component ()
{
  return this->component_;
}

void head::
component (const component_sequence& s)
{
  this->component_ = s;
}

const head::meta_sequence& head::
meta () const
{
  return this->meta_;
}

head::meta_sequence& head::
meta ()
{
  return this->meta_;
}

void head::
meta (const meta_sequence& s)
{
  this->meta_ = s;
}


// meta
// 

const meta::name_type& meta::
name () const
{
  return this->name_.get ();
}

meta::name_type& meta::
name ()
{
  return this->name_.get ();
}

void meta::
name (const name_type& x)
{
  this->name_.set (x);
}

void meta::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const meta::content_type& meta::
content () const
{
  return this->content_.get ();
}

meta::content_type& meta::
content ()
{
  return this->content_.get ();
}

void meta::
content (const content_type& x)
{
  this->content_.set (x);
}

void meta::
content (::std::auto_ptr< content_type > x)
{
  this->content_.set (x);
}

const meta::http_equiv_optional& meta::
http_equiv () const
{
  return this->http_equiv_;
}

meta::http_equiv_optional& meta::
http_equiv ()
{
  return this->http_equiv_;
}

void meta::
http_equiv (const http_equiv_type& x)
{
  this->http_equiv_.set (x);
}

void meta::
http_equiv (const http_equiv_optional& x)
{
  this->http_equiv_ = x;
}

void meta::
http_equiv (::std::auto_ptr< http_equiv_type > x)
{
  this->http_equiv_.set (x);
}

const meta::lang_optional& meta::
lang () const
{
  return this->lang_;
}

meta::lang_optional& meta::
lang ()
{
  return this->lang_;
}

void meta::
lang (const lang_type& x)
{
  this->lang_.set (x);
}

void meta::
lang (const lang_optional& x)
{
  this->lang_ = x;
}

void meta::
lang (::std::auto_ptr< lang_type > x)
{
  this->lang_.set (x);
}

const meta::dir_optional& meta::
dir () const
{
  return this->dir_;
}

meta::dir_optional& meta::
dir ()
{
  return this->dir_;
}

void meta::
dir (const dir_type& x)
{
  this->dir_.set (x);
}

void meta::
dir (const dir_optional& x)
{
  this->dir_ = x;
}

void meta::
dir (::std::auto_ptr< dir_type > x)
{
  this->dir_.set (x);
}


// ExternProtoDeclare
// 

const ExternProtoDeclare::field_sequence& ExternProtoDeclare::
field () const
{
  return this->field_;
}

ExternProtoDeclare::field_sequence& ExternProtoDeclare::
field ()
{
  return this->field_;
}

void ExternProtoDeclare::
field (const field_sequence& s)
{
  this->field_ = s;
}

const ExternProtoDeclare::url_type& ExternProtoDeclare::
url () const
{
  return this->url_.get ();
}

ExternProtoDeclare::url_type& ExternProtoDeclare::
url ()
{
  return this->url_.get ();
}

void ExternProtoDeclare::
url (const url_type& x)
{
  this->url_.set (x);
}

void ExternProtoDeclare::
url (::std::auto_ptr< url_type > x)
{
  this->url_.set (x);
}

const ExternProtoDeclare::appinfo_optional& ExternProtoDeclare::
appinfo () const
{
  return this->appinfo_;
}

ExternProtoDeclare::appinfo_optional& ExternProtoDeclare::
appinfo ()
{
  return this->appinfo_;
}

void ExternProtoDeclare::
appinfo (const appinfo_type& x)
{
  this->appinfo_.set (x);
}

void ExternProtoDeclare::
appinfo (const appinfo_optional& x)
{
  this->appinfo_ = x;
}

void ExternProtoDeclare::
appinfo (::std::auto_ptr< appinfo_type > x)
{
  this->appinfo_.set (x);
}

const ExternProtoDeclare::documentation_optional& ExternProtoDeclare::
documentation () const
{
  return this->documentation_;
}

ExternProtoDeclare::documentation_optional& ExternProtoDeclare::
documentation ()
{
  return this->documentation_;
}

void ExternProtoDeclare::
documentation (const documentation_type& x)
{
  this->documentation_.set (x);
}

void ExternProtoDeclare::
documentation (const documentation_optional& x)
{
  this->documentation_ = x;
}

void ExternProtoDeclare::
documentation (::std::auto_ptr< documentation_type > x)
{
  this->documentation_.set (x);
}


// ProtoDeclare
// 

const ProtoDeclare::ProtoInterface_optional& ProtoDeclare::
ProtoInterface () const
{
  return this->ProtoInterface_;
}

ProtoDeclare::ProtoInterface_optional& ProtoDeclare::
ProtoInterface ()
{
  return this->ProtoInterface_;
}

void ProtoDeclare::
ProtoInterface (const ProtoInterface_type& x)
{
  this->ProtoInterface_.set (x);
}

void ProtoDeclare::
ProtoInterface (const ProtoInterface_optional& x)
{
  this->ProtoInterface_ = x;
}

void ProtoDeclare::
ProtoInterface (::std::auto_ptr< ProtoInterface_type > x)
{
  this->ProtoInterface_.set (x);
}

const ProtoDeclare::ProtoBody_type& ProtoDeclare::
ProtoBody () const
{
  return this->ProtoBody_.get ();
}

ProtoDeclare::ProtoBody_type& ProtoDeclare::
ProtoBody ()
{
  return this->ProtoBody_.get ();
}

void ProtoDeclare::
ProtoBody (const ProtoBody_type& x)
{
  this->ProtoBody_.set (x);
}

void ProtoDeclare::
ProtoBody (::std::auto_ptr< ProtoBody_type > x)
{
  this->ProtoBody_.set (x);
}

const ProtoDeclare::appinfo_optional& ProtoDeclare::
appinfo () const
{
  return this->appinfo_;
}

ProtoDeclare::appinfo_optional& ProtoDeclare::
appinfo ()
{
  return this->appinfo_;
}

void ProtoDeclare::
appinfo (const appinfo_type& x)
{
  this->appinfo_.set (x);
}

void ProtoDeclare::
appinfo (const appinfo_optional& x)
{
  this->appinfo_ = x;
}

void ProtoDeclare::
appinfo (::std::auto_ptr< appinfo_type > x)
{
  this->appinfo_.set (x);
}

const ProtoDeclare::documentation_optional& ProtoDeclare::
documentation () const
{
  return this->documentation_;
}

ProtoDeclare::documentation_optional& ProtoDeclare::
documentation ()
{
  return this->documentation_;
}

void ProtoDeclare::
documentation (const documentation_type& x)
{
  this->documentation_.set (x);
}

void ProtoDeclare::
documentation (const documentation_optional& x)
{
  this->documentation_ = x;
}

void ProtoDeclare::
documentation (::std::auto_ptr< documentation_type > x)
{
  this->documentation_.set (x);
}


// ProtoInterface
// 

const ProtoInterface::field_sequence& ProtoInterface::
field () const
{
  return this->field_;
}

ProtoInterface::field_sequence& ProtoInterface::
field ()
{
  return this->field_;
}

void ProtoInterface::
field (const field_sequence& s)
{
  this->field_ = s;
}


// ProtoBody
// 

const ProtoBody::FillProperties_sequence& ProtoBody::
FillProperties () const
{
  return this->FillProperties_;
}

ProtoBody::FillProperties_sequence& ProtoBody::
FillProperties ()
{
  return this->FillProperties_;
}

void ProtoBody::
FillProperties (const FillProperties_sequence& s)
{
  this->FillProperties_ = s;
}

const ProtoBody::LineProperties_sequence& ProtoBody::
LineProperties () const
{
  return this->LineProperties_;
}

ProtoBody::LineProperties_sequence& ProtoBody::
LineProperties ()
{
  return this->LineProperties_;
}

void ProtoBody::
LineProperties (const LineProperties_sequence& s)
{
  this->LineProperties_ = s;
}

const ProtoBody::Material_sequence& ProtoBody::
Material () const
{
  return this->Material_;
}

ProtoBody::Material_sequence& ProtoBody::
Material ()
{
  return this->Material_;
}

void ProtoBody::
Material (const Material_sequence& s)
{
  this->Material_ = s;
}

const ProtoBody::ComposedShader_sequence& ProtoBody::
ComposedShader () const
{
  return this->ComposedShader_;
}

ProtoBody::ComposedShader_sequence& ProtoBody::
ComposedShader ()
{
  return this->ComposedShader_;
}

void ProtoBody::
ComposedShader (const ComposedShader_sequence& s)
{
  this->ComposedShader_ = s;
}

const ProtoBody::PackagedShader_sequence& ProtoBody::
PackagedShader () const
{
  return this->PackagedShader_;
}

ProtoBody::PackagedShader_sequence& ProtoBody::
PackagedShader ()
{
  return this->PackagedShader_;
}

void ProtoBody::
PackagedShader (const PackagedShader_sequence& s)
{
  this->PackagedShader_ = s;
}

const ProtoBody::ProgramShader_sequence& ProtoBody::
ProgramShader () const
{
  return this->ProgramShader_;
}

ProtoBody::ProgramShader_sequence& ProtoBody::
ProgramShader ()
{
  return this->ProgramShader_;
}

void ProtoBody::
ProgramShader (const ProgramShader_sequence& s)
{
  this->ProgramShader_ = s;
}

const ProtoBody::ComposedCubeMapTexture_sequence& ProtoBody::
ComposedCubeMapTexture () const
{
  return this->ComposedCubeMapTexture_;
}

ProtoBody::ComposedCubeMapTexture_sequence& ProtoBody::
ComposedCubeMapTexture ()
{
  return this->ComposedCubeMapTexture_;
}

void ProtoBody::
ComposedCubeMapTexture (const ComposedCubeMapTexture_sequence& s)
{
  this->ComposedCubeMapTexture_ = s;
}

const ProtoBody::ImageTexture_sequence& ProtoBody::
ImageTexture () const
{
  return this->ImageTexture_;
}

ProtoBody::ImageTexture_sequence& ProtoBody::
ImageTexture ()
{
  return this->ImageTexture_;
}

void ProtoBody::
ImageTexture (const ImageTexture_sequence& s)
{
  this->ImageTexture_ = s;
}

const ProtoBody::MovieTexture_sequence& ProtoBody::
MovieTexture () const
{
  return this->MovieTexture_;
}

ProtoBody::MovieTexture_sequence& ProtoBody::
MovieTexture ()
{
  return this->MovieTexture_;
}

void ProtoBody::
MovieTexture (const MovieTexture_sequence& s)
{
  this->MovieTexture_ = s;
}

const ProtoBody::MultiTexture_sequence& ProtoBody::
MultiTexture () const
{
  return this->MultiTexture_;
}

ProtoBody::MultiTexture_sequence& ProtoBody::
MultiTexture ()
{
  return this->MultiTexture_;
}

void ProtoBody::
MultiTexture (const MultiTexture_sequence& s)
{
  this->MultiTexture_ = s;
}

const ProtoBody::PixelTexture_sequence& ProtoBody::
PixelTexture () const
{
  return this->PixelTexture_;
}

ProtoBody::PixelTexture_sequence& ProtoBody::
PixelTexture ()
{
  return this->PixelTexture_;
}

void ProtoBody::
PixelTexture (const PixelTexture_sequence& s)
{
  this->PixelTexture_ = s;
}

const ProtoBody::GeneratedCubeMapTexture_sequence& ProtoBody::
GeneratedCubeMapTexture () const
{
  return this->GeneratedCubeMapTexture_;
}

ProtoBody::GeneratedCubeMapTexture_sequence& ProtoBody::
GeneratedCubeMapTexture ()
{
  return this->GeneratedCubeMapTexture_;
}

void ProtoBody::
GeneratedCubeMapTexture (const GeneratedCubeMapTexture_sequence& s)
{
  this->GeneratedCubeMapTexture_ = s;
}

const ProtoBody::ImageCubeMapTexture_sequence& ProtoBody::
ImageCubeMapTexture () const
{
  return this->ImageCubeMapTexture_;
}

ProtoBody::ImageCubeMapTexture_sequence& ProtoBody::
ImageCubeMapTexture ()
{
  return this->ImageCubeMapTexture_;
}

void ProtoBody::
ImageCubeMapTexture (const ImageCubeMapTexture_sequence& s)
{
  this->ImageCubeMapTexture_ = s;
}

const ProtoBody::MultiTextureTransform_sequence& ProtoBody::
MultiTextureTransform () const
{
  return this->MultiTextureTransform_;
}

ProtoBody::MultiTextureTransform_sequence& ProtoBody::
MultiTextureTransform ()
{
  return this->MultiTextureTransform_;
}

void ProtoBody::
MultiTextureTransform (const MultiTextureTransform_sequence& s)
{
  this->MultiTextureTransform_ = s;
}

const ProtoBody::TextureTransform_sequence& ProtoBody::
TextureTransform () const
{
  return this->TextureTransform_;
}

ProtoBody::TextureTransform_sequence& ProtoBody::
TextureTransform ()
{
  return this->TextureTransform_;
}

void ProtoBody::
TextureTransform (const TextureTransform_sequence& s)
{
  this->TextureTransform_ = s;
}

const ProtoBody::MetadataDouble_sequence& ProtoBody::
MetadataDouble () const
{
  return this->MetadataDouble_;
}

ProtoBody::MetadataDouble_sequence& ProtoBody::
MetadataDouble ()
{
  return this->MetadataDouble_;
}

void ProtoBody::
MetadataDouble (const MetadataDouble_sequence& s)
{
  this->MetadataDouble_ = s;
}

const ProtoBody::MetadataFloat_sequence& ProtoBody::
MetadataFloat () const
{
  return this->MetadataFloat_;
}

ProtoBody::MetadataFloat_sequence& ProtoBody::
MetadataFloat ()
{
  return this->MetadataFloat_;
}

void ProtoBody::
MetadataFloat (const MetadataFloat_sequence& s)
{
  this->MetadataFloat_ = s;
}

const ProtoBody::MetadataInteger_sequence& ProtoBody::
MetadataInteger () const
{
  return this->MetadataInteger_;
}

ProtoBody::MetadataInteger_sequence& ProtoBody::
MetadataInteger ()
{
  return this->MetadataInteger_;
}

void ProtoBody::
MetadataInteger (const MetadataInteger_sequence& s)
{
  this->MetadataInteger_ = s;
}

const ProtoBody::MetadataSet_sequence& ProtoBody::
MetadataSet () const
{
  return this->MetadataSet_;
}

ProtoBody::MetadataSet_sequence& ProtoBody::
MetadataSet ()
{
  return this->MetadataSet_;
}

void ProtoBody::
MetadataSet (const MetadataSet_sequence& s)
{
  this->MetadataSet_ = s;
}

const ProtoBody::MetadataString_sequence& ProtoBody::
MetadataString () const
{
  return this->MetadataString_;
}

ProtoBody::MetadataString_sequence& ProtoBody::
MetadataString ()
{
  return this->MetadataString_;
}

void ProtoBody::
MetadataString (const MetadataString_sequence& s)
{
  this->MetadataString_ = s;
}

const ProtoBody::Appearance_sequence& ProtoBody::
Appearance () const
{
  return this->Appearance_;
}

ProtoBody::Appearance_sequence& ProtoBody::
Appearance ()
{
  return this->Appearance_;
}

void ProtoBody::
Appearance (const Appearance_sequence& s)
{
  this->Appearance_ = s;
}

const ProtoBody::Background_sequence& ProtoBody::
Background () const
{
  return this->Background_;
}

ProtoBody::Background_sequence& ProtoBody::
Background ()
{
  return this->Background_;
}

void ProtoBody::
Background (const Background_sequence& s)
{
  this->Background_ = s;
}

const ProtoBody::ColorInterpolator_sequence& ProtoBody::
ColorInterpolator () const
{
  return this->ColorInterpolator_;
}

ProtoBody::ColorInterpolator_sequence& ProtoBody::
ColorInterpolator ()
{
  return this->ColorInterpolator_;
}

void ProtoBody::
ColorInterpolator (const ColorInterpolator_sequence& s)
{
  this->ColorInterpolator_ = s;
}

const ProtoBody::CoordinateInterpolator_sequence& ProtoBody::
CoordinateInterpolator () const
{
  return this->CoordinateInterpolator_;
}

ProtoBody::CoordinateInterpolator_sequence& ProtoBody::
CoordinateInterpolator ()
{
  return this->CoordinateInterpolator_;
}

void ProtoBody::
CoordinateInterpolator (const CoordinateInterpolator_sequence& s)
{
  this->CoordinateInterpolator_ = s;
}

const ProtoBody::DirectionalLight_sequence& ProtoBody::
DirectionalLight () const
{
  return this->DirectionalLight_;
}

ProtoBody::DirectionalLight_sequence& ProtoBody::
DirectionalLight ()
{
  return this->DirectionalLight_;
}

void ProtoBody::
DirectionalLight (const DirectionalLight_sequence& s)
{
  this->DirectionalLight_ = s;
}

const ProtoBody::Group_sequence& ProtoBody::
Group () const
{
  return this->Group_;
}

ProtoBody::Group_sequence& ProtoBody::
Group ()
{
  return this->Group_;
}

void ProtoBody::
Group (const Group_sequence& s)
{
  this->Group_ = s;
}

const ProtoBody::NavigationInfo_sequence& ProtoBody::
NavigationInfo () const
{
  return this->NavigationInfo_;
}

ProtoBody::NavigationInfo_sequence& ProtoBody::
NavigationInfo ()
{
  return this->NavigationInfo_;
}

void ProtoBody::
NavigationInfo (const NavigationInfo_sequence& s)
{
  this->NavigationInfo_ = s;
}

const ProtoBody::NormalInterpolator_sequence& ProtoBody::
NormalInterpolator () const
{
  return this->NormalInterpolator_;
}

ProtoBody::NormalInterpolator_sequence& ProtoBody::
NormalInterpolator ()
{
  return this->NormalInterpolator_;
}

void ProtoBody::
NormalInterpolator (const NormalInterpolator_sequence& s)
{
  this->NormalInterpolator_ = s;
}

const ProtoBody::OrientationInterpolator_sequence& ProtoBody::
OrientationInterpolator () const
{
  return this->OrientationInterpolator_;
}

ProtoBody::OrientationInterpolator_sequence& ProtoBody::
OrientationInterpolator ()
{
  return this->OrientationInterpolator_;
}

void ProtoBody::
OrientationInterpolator (const OrientationInterpolator_sequence& s)
{
  this->OrientationInterpolator_ = s;
}

const ProtoBody::PositionInterpolator_sequence& ProtoBody::
PositionInterpolator () const
{
  return this->PositionInterpolator_;
}

ProtoBody::PositionInterpolator_sequence& ProtoBody::
PositionInterpolator ()
{
  return this->PositionInterpolator_;
}

void ProtoBody::
PositionInterpolator (const PositionInterpolator_sequence& s)
{
  this->PositionInterpolator_ = s;
}

const ProtoBody::ScalarInterpolator_sequence& ProtoBody::
ScalarInterpolator () const
{
  return this->ScalarInterpolator_;
}

ProtoBody::ScalarInterpolator_sequence& ProtoBody::
ScalarInterpolator ()
{
  return this->ScalarInterpolator_;
}

void ProtoBody::
ScalarInterpolator (const ScalarInterpolator_sequence& s)
{
  this->ScalarInterpolator_ = s;
}

const ProtoBody::Shape_sequence& ProtoBody::
Shape () const
{
  return this->Shape_;
}

ProtoBody::Shape_sequence& ProtoBody::
Shape ()
{
  return this->Shape_;
}

void ProtoBody::
Shape (const Shape_sequence& s)
{
  this->Shape_ = s;
}

const ProtoBody::TimeSensor_sequence& ProtoBody::
TimeSensor () const
{
  return this->TimeSensor_;
}

ProtoBody::TimeSensor_sequence& ProtoBody::
TimeSensor ()
{
  return this->TimeSensor_;
}

void ProtoBody::
TimeSensor (const TimeSensor_sequence& s)
{
  this->TimeSensor_ = s;
}

const ProtoBody::Transform_sequence& ProtoBody::
Transform () const
{
  return this->Transform_;
}

ProtoBody::Transform_sequence& ProtoBody::
Transform ()
{
  return this->Transform_;
}

void ProtoBody::
Transform (const Transform_sequence& s)
{
  this->Transform_ = s;
}

const ProtoBody::Viewpoint_sequence& ProtoBody::
Viewpoint () const
{
  return this->Viewpoint_;
}

ProtoBody::Viewpoint_sequence& ProtoBody::
Viewpoint ()
{
  return this->Viewpoint_;
}

void ProtoBody::
Viewpoint (const Viewpoint_sequence& s)
{
  this->Viewpoint_ = s;
}

const ProtoBody::WorldInfo_sequence& ProtoBody::
WorldInfo () const
{
  return this->WorldInfo_;
}

ProtoBody::WorldInfo_sequence& ProtoBody::
WorldInfo ()
{
  return this->WorldInfo_;
}

void ProtoBody::
WorldInfo (const WorldInfo_sequence& s)
{
  this->WorldInfo_ = s;
}

const ProtoBody::Anchor_sequence& ProtoBody::
Anchor () const
{
  return this->Anchor_;
}

ProtoBody::Anchor_sequence& ProtoBody::
Anchor ()
{
  return this->Anchor_;
}

void ProtoBody::
Anchor (const Anchor_sequence& s)
{
  this->Anchor_ = s;
}

const ProtoBody::BooleanFilter_sequence& ProtoBody::
BooleanFilter () const
{
  return this->BooleanFilter_;
}

ProtoBody::BooleanFilter_sequence& ProtoBody::
BooleanFilter ()
{
  return this->BooleanFilter_;
}

void ProtoBody::
BooleanFilter (const BooleanFilter_sequence& s)
{
  this->BooleanFilter_ = s;
}

const ProtoBody::BooleanSequencer_sequence& ProtoBody::
BooleanSequencer () const
{
  return this->BooleanSequencer_;
}

ProtoBody::BooleanSequencer_sequence& ProtoBody::
BooleanSequencer ()
{
  return this->BooleanSequencer_;
}

void ProtoBody::
BooleanSequencer (const BooleanSequencer_sequence& s)
{
  this->BooleanSequencer_ = s;
}

const ProtoBody::BooleanToggle_sequence& ProtoBody::
BooleanToggle () const
{
  return this->BooleanToggle_;
}

ProtoBody::BooleanToggle_sequence& ProtoBody::
BooleanToggle ()
{
  return this->BooleanToggle_;
}

void ProtoBody::
BooleanToggle (const BooleanToggle_sequence& s)
{
  this->BooleanToggle_ = s;
}

const ProtoBody::BooleanTrigger_sequence& ProtoBody::
BooleanTrigger () const
{
  return this->BooleanTrigger_;
}

ProtoBody::BooleanTrigger_sequence& ProtoBody::
BooleanTrigger ()
{
  return this->BooleanTrigger_;
}

void ProtoBody::
BooleanTrigger (const BooleanTrigger_sequence& s)
{
  this->BooleanTrigger_ = s;
}

const ProtoBody::CylinderSensor_sequence& ProtoBody::
CylinderSensor () const
{
  return this->CylinderSensor_;
}

ProtoBody::CylinderSensor_sequence& ProtoBody::
CylinderSensor ()
{
  return this->CylinderSensor_;
}

void ProtoBody::
CylinderSensor (const CylinderSensor_sequence& s)
{
  this->CylinderSensor_ = s;
}

const ProtoBody::Inline_sequence& ProtoBody::
Inline () const
{
  return this->Inline_;
}

ProtoBody::Inline_sequence& ProtoBody::
Inline ()
{
  return this->Inline_;
}

void ProtoBody::
Inline (const Inline_sequence& s)
{
  this->Inline_ = s;
}

const ProtoBody::IntegerSequencer_sequence& ProtoBody::
IntegerSequencer () const
{
  return this->IntegerSequencer_;
}

ProtoBody::IntegerSequencer_sequence& ProtoBody::
IntegerSequencer ()
{
  return this->IntegerSequencer_;
}

void ProtoBody::
IntegerSequencer (const IntegerSequencer_sequence& s)
{
  this->IntegerSequencer_ = s;
}

const ProtoBody::IntegerTrigger_sequence& ProtoBody::
IntegerTrigger () const
{
  return this->IntegerTrigger_;
}

ProtoBody::IntegerTrigger_sequence& ProtoBody::
IntegerTrigger ()
{
  return this->IntegerTrigger_;
}

void ProtoBody::
IntegerTrigger (const IntegerTrigger_sequence& s)
{
  this->IntegerTrigger_ = s;
}

const ProtoBody::KeySensor_sequence& ProtoBody::
KeySensor () const
{
  return this->KeySensor_;
}

ProtoBody::KeySensor_sequence& ProtoBody::
KeySensor ()
{
  return this->KeySensor_;
}

void ProtoBody::
KeySensor (const KeySensor_sequence& s)
{
  this->KeySensor_ = s;
}

const ProtoBody::PlaneSensor_sequence& ProtoBody::
PlaneSensor () const
{
  return this->PlaneSensor_;
}

ProtoBody::PlaneSensor_sequence& ProtoBody::
PlaneSensor ()
{
  return this->PlaneSensor_;
}

void ProtoBody::
PlaneSensor (const PlaneSensor_sequence& s)
{
  this->PlaneSensor_ = s;
}

const ProtoBody::PointLight_sequence& ProtoBody::
PointLight () const
{
  return this->PointLight_;
}

ProtoBody::PointLight_sequence& ProtoBody::
PointLight ()
{
  return this->PointLight_;
}

void ProtoBody::
PointLight (const PointLight_sequence& s)
{
  this->PointLight_ = s;
}

const ProtoBody::ProximitySensor_sequence& ProtoBody::
ProximitySensor () const
{
  return this->ProximitySensor_;
}

ProtoBody::ProximitySensor_sequence& ProtoBody::
ProximitySensor ()
{
  return this->ProximitySensor_;
}

void ProtoBody::
ProximitySensor (const ProximitySensor_sequence& s)
{
  this->ProximitySensor_ = s;
}

const ProtoBody::SphereSensor_sequence& ProtoBody::
SphereSensor () const
{
  return this->SphereSensor_;
}

ProtoBody::SphereSensor_sequence& ProtoBody::
SphereSensor ()
{
  return this->SphereSensor_;
}

void ProtoBody::
SphereSensor (const SphereSensor_sequence& s)
{
  this->SphereSensor_ = s;
}

const ProtoBody::SpotLight_sequence& ProtoBody::
SpotLight () const
{
  return this->SpotLight_;
}

ProtoBody::SpotLight_sequence& ProtoBody::
SpotLight ()
{
  return this->SpotLight_;
}

void ProtoBody::
SpotLight (const SpotLight_sequence& s)
{
  this->SpotLight_ = s;
}

const ProtoBody::StringSensor_sequence& ProtoBody::
StringSensor () const
{
  return this->StringSensor_;
}

ProtoBody::StringSensor_sequence& ProtoBody::
StringSensor ()
{
  return this->StringSensor_;
}

void ProtoBody::
StringSensor (const StringSensor_sequence& s)
{
  this->StringSensor_ = s;
}

const ProtoBody::Switch_sequence& ProtoBody::
Switch () const
{
  return this->Switch_;
}

ProtoBody::Switch_sequence& ProtoBody::
Switch ()
{
  return this->Switch_;
}

void ProtoBody::
Switch (const Switch_sequence& s)
{
  this->Switch_ = s;
}

const ProtoBody::TimeTrigger_sequence& ProtoBody::
TimeTrigger () const
{
  return this->TimeTrigger_;
}

ProtoBody::TimeTrigger_sequence& ProtoBody::
TimeTrigger ()
{
  return this->TimeTrigger_;
}

void ProtoBody::
TimeTrigger (const TimeTrigger_sequence& s)
{
  this->TimeTrigger_ = s;
}

const ProtoBody::TouchSensor_sequence& ProtoBody::
TouchSensor () const
{
  return this->TouchSensor_;
}

ProtoBody::TouchSensor_sequence& ProtoBody::
TouchSensor ()
{
  return this->TouchSensor_;
}

void ProtoBody::
TouchSensor (const TouchSensor_sequence& s)
{
  this->TouchSensor_ = s;
}

const ProtoBody::AudioClip_sequence& ProtoBody::
AudioClip () const
{
  return this->AudioClip_;
}

ProtoBody::AudioClip_sequence& ProtoBody::
AudioClip ()
{
  return this->AudioClip_;
}

void ProtoBody::
AudioClip (const AudioClip_sequence& s)
{
  this->AudioClip_ = s;
}

const ProtoBody::Billboard_sequence& ProtoBody::
Billboard () const
{
  return this->Billboard_;
}

ProtoBody::Billboard_sequence& ProtoBody::
Billboard ()
{
  return this->Billboard_;
}

void ProtoBody::
Billboard (const Billboard_sequence& s)
{
  this->Billboard_ = s;
}

const ProtoBody::Collision_sequence& ProtoBody::
Collision () const
{
  return this->Collision_;
}

ProtoBody::Collision_sequence& ProtoBody::
Collision ()
{
  return this->Collision_;
}

void ProtoBody::
Collision (const Collision_sequence& s)
{
  this->Collision_ = s;
}

const ProtoBody::Fog_sequence& ProtoBody::
Fog () const
{
  return this->Fog_;
}

ProtoBody::Fog_sequence& ProtoBody::
Fog ()
{
  return this->Fog_;
}

void ProtoBody::
Fog (const Fog_sequence& s)
{
  this->Fog_ = s;
}

const ProtoBody::LoadSensor_sequence& ProtoBody::
LoadSensor () const
{
  return this->LoadSensor_;
}

ProtoBody::LoadSensor_sequence& ProtoBody::
LoadSensor ()
{
  return this->LoadSensor_;
}

void ProtoBody::
LoadSensor (const LoadSensor_sequence& s)
{
  this->LoadSensor_ = s;
}

const ProtoBody::LocalFog_sequence& ProtoBody::
LocalFog () const
{
  return this->LocalFog_;
}

ProtoBody::LocalFog_sequence& ProtoBody::
LocalFog ()
{
  return this->LocalFog_;
}

void ProtoBody::
LocalFog (const LocalFog_sequence& s)
{
  this->LocalFog_ = s;
}

const ProtoBody::LOD_sequence& ProtoBody::
LOD () const
{
  return this->LOD_;
}

ProtoBody::LOD_sequence& ProtoBody::
LOD ()
{
  return this->LOD_;
}

void ProtoBody::
LOD (const LOD_sequence& s)
{
  this->LOD_ = s;
}

const ProtoBody::Script_sequence& ProtoBody::
Script () const
{
  return this->Script_;
}

ProtoBody::Script_sequence& ProtoBody::
Script ()
{
  return this->Script_;
}

void ProtoBody::
Script (const Script_sequence& s)
{
  this->Script_ = s;
}

const ProtoBody::Sound_sequence& ProtoBody::
Sound () const
{
  return this->Sound_;
}

ProtoBody::Sound_sequence& ProtoBody::
Sound ()
{
  return this->Sound_;
}

void ProtoBody::
Sound (const Sound_sequence& s)
{
  this->Sound_ = s;
}

const ProtoBody::VisibilitySensor_sequence& ProtoBody::
VisibilitySensor () const
{
  return this->VisibilitySensor_;
}

ProtoBody::VisibilitySensor_sequence& ProtoBody::
VisibilitySensor ()
{
  return this->VisibilitySensor_;
}

void ProtoBody::
VisibilitySensor (const VisibilitySensor_sequence& s)
{
  this->VisibilitySensor_ = s;
}

const ProtoBody::CoordinateInterpolator2D_sequence& ProtoBody::
CoordinateInterpolator2D () const
{
  return this->CoordinateInterpolator2D_;
}

ProtoBody::CoordinateInterpolator2D_sequence& ProtoBody::
CoordinateInterpolator2D ()
{
  return this->CoordinateInterpolator2D_;
}

void ProtoBody::
CoordinateInterpolator2D (const CoordinateInterpolator2D_sequence& s)
{
  this->CoordinateInterpolator2D_ = s;
}

const ProtoBody::PositionInterpolator2D_sequence& ProtoBody::
PositionInterpolator2D () const
{
  return this->PositionInterpolator2D_;
}

ProtoBody::PositionInterpolator2D_sequence& ProtoBody::
PositionInterpolator2D ()
{
  return this->PositionInterpolator2D_;
}

void ProtoBody::
PositionInterpolator2D (const PositionInterpolator2D_sequence& s)
{
  this->PositionInterpolator2D_ = s;
}

const ProtoBody::StaticGroup_sequence& ProtoBody::
StaticGroup () const
{
  return this->StaticGroup_;
}

ProtoBody::StaticGroup_sequence& ProtoBody::
StaticGroup ()
{
  return this->StaticGroup_;
}

void ProtoBody::
StaticGroup (const StaticGroup_sequence& s)
{
  this->StaticGroup_ = s;
}

const ProtoBody::CADAssembly_sequence& ProtoBody::
CADAssembly () const
{
  return this->CADAssembly_;
}

ProtoBody::CADAssembly_sequence& ProtoBody::
CADAssembly ()
{
  return this->CADAssembly_;
}

void ProtoBody::
CADAssembly (const CADAssembly_sequence& s)
{
  this->CADAssembly_ = s;
}

const ProtoBody::CADLayer_sequence& ProtoBody::
CADLayer () const
{
  return this->CADLayer_;
}

ProtoBody::CADLayer_sequence& ProtoBody::
CADLayer ()
{
  return this->CADLayer_;
}

void ProtoBody::
CADLayer (const CADLayer_sequence& s)
{
  this->CADLayer_ = s;
}

const ProtoBody::EspduTransform_sequence& ProtoBody::
EspduTransform () const
{
  return this->EspduTransform_;
}

ProtoBody::EspduTransform_sequence& ProtoBody::
EspduTransform ()
{
  return this->EspduTransform_;
}

void ProtoBody::
EspduTransform (const EspduTransform_sequence& s)
{
  this->EspduTransform_ = s;
}

const ProtoBody::ReceiverPdu_sequence& ProtoBody::
ReceiverPdu () const
{
  return this->ReceiverPdu_;
}

ProtoBody::ReceiverPdu_sequence& ProtoBody::
ReceiverPdu ()
{
  return this->ReceiverPdu_;
}

void ProtoBody::
ReceiverPdu (const ReceiverPdu_sequence& s)
{
  this->ReceiverPdu_ = s;
}

const ProtoBody::SignalPdu_sequence& ProtoBody::
SignalPdu () const
{
  return this->SignalPdu_;
}

ProtoBody::SignalPdu_sequence& ProtoBody::
SignalPdu ()
{
  return this->SignalPdu_;
}

void ProtoBody::
SignalPdu (const SignalPdu_sequence& s)
{
  this->SignalPdu_ = s;
}

const ProtoBody::TransmitterPdu_sequence& ProtoBody::
TransmitterPdu () const
{
  return this->TransmitterPdu_;
}

ProtoBody::TransmitterPdu_sequence& ProtoBody::
TransmitterPdu ()
{
  return this->TransmitterPdu_;
}

void ProtoBody::
TransmitterPdu (const TransmitterPdu_sequence& s)
{
  this->TransmitterPdu_ = s;
}

const ProtoBody::GeoLocation_sequence& ProtoBody::
GeoLocation () const
{
  return this->GeoLocation_;
}

ProtoBody::GeoLocation_sequence& ProtoBody::
GeoLocation ()
{
  return this->GeoLocation_;
}

void ProtoBody::
GeoLocation (const GeoLocation_sequence& s)
{
  this->GeoLocation_ = s;
}

const ProtoBody::GeoLOD_sequence& ProtoBody::
GeoLOD () const
{
  return this->GeoLOD_;
}

ProtoBody::GeoLOD_sequence& ProtoBody::
GeoLOD ()
{
  return this->GeoLOD_;
}

void ProtoBody::
GeoLOD (const GeoLOD_sequence& s)
{
  this->GeoLOD_ = s;
}

const ProtoBody::GeoMetadata_sequence& ProtoBody::
GeoMetadata () const
{
  return this->GeoMetadata_;
}

ProtoBody::GeoMetadata_sequence& ProtoBody::
GeoMetadata ()
{
  return this->GeoMetadata_;
}

void ProtoBody::
GeoMetadata (const GeoMetadata_sequence& s)
{
  this->GeoMetadata_ = s;
}

const ProtoBody::GeoOrigin_sequence& ProtoBody::
GeoOrigin () const
{
  return this->GeoOrigin_;
}

ProtoBody::GeoOrigin_sequence& ProtoBody::
GeoOrigin ()
{
  return this->GeoOrigin_;
}

void ProtoBody::
GeoOrigin (const GeoOrigin_sequence& s)
{
  this->GeoOrigin_ = s;
}

const ProtoBody::GeoPositionInterpolator_sequence& ProtoBody::
GeoPositionInterpolator () const
{
  return this->GeoPositionInterpolator_;
}

ProtoBody::GeoPositionInterpolator_sequence& ProtoBody::
GeoPositionInterpolator ()
{
  return this->GeoPositionInterpolator_;
}

void ProtoBody::
GeoPositionInterpolator (const GeoPositionInterpolator_sequence& s)
{
  this->GeoPositionInterpolator_ = s;
}

const ProtoBody::GeoTouchSensor_sequence& ProtoBody::
GeoTouchSensor () const
{
  return this->GeoTouchSensor_;
}

ProtoBody::GeoTouchSensor_sequence& ProtoBody::
GeoTouchSensor ()
{
  return this->GeoTouchSensor_;
}

void ProtoBody::
GeoTouchSensor (const GeoTouchSensor_sequence& s)
{
  this->GeoTouchSensor_ = s;
}

const ProtoBody::GeoViewpoint_sequence& ProtoBody::
GeoViewpoint () const
{
  return this->GeoViewpoint_;
}

ProtoBody::GeoViewpoint_sequence& ProtoBody::
GeoViewpoint ()
{
  return this->GeoViewpoint_;
}

void ProtoBody::
GeoViewpoint (const GeoViewpoint_sequence& s)
{
  this->GeoViewpoint_ = s;
}

const ProtoBody::HAnimHumanoid_sequence& ProtoBody::
HAnimHumanoid () const
{
  return this->HAnimHumanoid_;
}

ProtoBody::HAnimHumanoid_sequence& ProtoBody::
HAnimHumanoid ()
{
  return this->HAnimHumanoid_;
}

void ProtoBody::
HAnimHumanoid (const HAnimHumanoid_sequence& s)
{
  this->HAnimHumanoid_ = s;
}

const ProtoBody::HAnimJoint_sequence& ProtoBody::
HAnimJoint () const
{
  return this->HAnimJoint_;
}

ProtoBody::HAnimJoint_sequence& ProtoBody::
HAnimJoint ()
{
  return this->HAnimJoint_;
}

void ProtoBody::
HAnimJoint (const HAnimJoint_sequence& s)
{
  this->HAnimJoint_ = s;
}

const ProtoBody::HAnimSegment_sequence& ProtoBody::
HAnimSegment () const
{
  return this->HAnimSegment_;
}

ProtoBody::HAnimSegment_sequence& ProtoBody::
HAnimSegment ()
{
  return this->HAnimSegment_;
}

void ProtoBody::
HAnimSegment (const HAnimSegment_sequence& s)
{
  this->HAnimSegment_ = s;
}

const ProtoBody::HAnimSite_sequence& ProtoBody::
HAnimSite () const
{
  return this->HAnimSite_;
}

ProtoBody::HAnimSite_sequence& ProtoBody::
HAnimSite ()
{
  return this->HAnimSite_;
}

void ProtoBody::
HAnimSite (const HAnimSite_sequence& s)
{
  this->HAnimSite_ = s;
}

const ProtoBody::NurbsOrientationInterpolator_sequence& ProtoBody::
NurbsOrientationInterpolator () const
{
  return this->NurbsOrientationInterpolator_;
}

ProtoBody::NurbsOrientationInterpolator_sequence& ProtoBody::
NurbsOrientationInterpolator ()
{
  return this->NurbsOrientationInterpolator_;
}

void ProtoBody::
NurbsOrientationInterpolator (const NurbsOrientationInterpolator_sequence& s)
{
  this->NurbsOrientationInterpolator_ = s;
}

const ProtoBody::NurbsPositionInterpolator_sequence& ProtoBody::
NurbsPositionInterpolator () const
{
  return this->NurbsPositionInterpolator_;
}

ProtoBody::NurbsPositionInterpolator_sequence& ProtoBody::
NurbsPositionInterpolator ()
{
  return this->NurbsPositionInterpolator_;
}

void ProtoBody::
NurbsPositionInterpolator (const NurbsPositionInterpolator_sequence& s)
{
  this->NurbsPositionInterpolator_ = s;
}

const ProtoBody::NurbsSurfaceInterpolator_sequence& ProtoBody::
NurbsSurfaceInterpolator () const
{
  return this->NurbsSurfaceInterpolator_;
}

ProtoBody::NurbsSurfaceInterpolator_sequence& ProtoBody::
NurbsSurfaceInterpolator ()
{
  return this->NurbsSurfaceInterpolator_;
}

void ProtoBody::
NurbsSurfaceInterpolator (const NurbsSurfaceInterpolator_sequence& s)
{
  this->NurbsSurfaceInterpolator_ = s;
}

const ProtoBody::NurbsSet_sequence& ProtoBody::
NurbsSet () const
{
  return this->NurbsSet_;
}

ProtoBody::NurbsSet_sequence& ProtoBody::
NurbsSet ()
{
  return this->NurbsSet_;
}

void ProtoBody::
NurbsSet (const NurbsSet_sequence& s)
{
  this->NurbsSet_ = s;
}

const ProtoBody::ProtoInstance_sequence& ProtoBody::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

ProtoBody::ProtoInstance_sequence& ProtoBody::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void ProtoBody::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const ProtoBody::Box_sequence& ProtoBody::
Box () const
{
  return this->Box_;
}

ProtoBody::Box_sequence& ProtoBody::
Box ()
{
  return this->Box_;
}

void ProtoBody::
Box (const Box_sequence& s)
{
  this->Box_ = s;
}

const ProtoBody::Cone_sequence& ProtoBody::
Cone () const
{
  return this->Cone_;
}

ProtoBody::Cone_sequence& ProtoBody::
Cone ()
{
  return this->Cone_;
}

void ProtoBody::
Cone (const Cone_sequence& s)
{
  this->Cone_ = s;
}

const ProtoBody::Cylinder_sequence& ProtoBody::
Cylinder () const
{
  return this->Cylinder_;
}

ProtoBody::Cylinder_sequence& ProtoBody::
Cylinder ()
{
  return this->Cylinder_;
}

void ProtoBody::
Cylinder (const Cylinder_sequence& s)
{
  this->Cylinder_ = s;
}

const ProtoBody::IndexedFaceSet_sequence& ProtoBody::
IndexedFaceSet () const
{
  return this->IndexedFaceSet_;
}

ProtoBody::IndexedFaceSet_sequence& ProtoBody::
IndexedFaceSet ()
{
  return this->IndexedFaceSet_;
}

void ProtoBody::
IndexedFaceSet (const IndexedFaceSet_sequence& s)
{
  this->IndexedFaceSet_ = s;
}

const ProtoBody::IndexedLineSet_sequence& ProtoBody::
IndexedLineSet () const
{
  return this->IndexedLineSet_;
}

ProtoBody::IndexedLineSet_sequence& ProtoBody::
IndexedLineSet ()
{
  return this->IndexedLineSet_;
}

void ProtoBody::
IndexedLineSet (const IndexedLineSet_sequence& s)
{
  this->IndexedLineSet_ = s;
}

const ProtoBody::IndexedTriangleFanSet_sequence& ProtoBody::
IndexedTriangleFanSet () const
{
  return this->IndexedTriangleFanSet_;
}

ProtoBody::IndexedTriangleFanSet_sequence& ProtoBody::
IndexedTriangleFanSet ()
{
  return this->IndexedTriangleFanSet_;
}

void ProtoBody::
IndexedTriangleFanSet (const IndexedTriangleFanSet_sequence& s)
{
  this->IndexedTriangleFanSet_ = s;
}

const ProtoBody::IndexedTriangleSet_sequence& ProtoBody::
IndexedTriangleSet () const
{
  return this->IndexedTriangleSet_;
}

ProtoBody::IndexedTriangleSet_sequence& ProtoBody::
IndexedTriangleSet ()
{
  return this->IndexedTriangleSet_;
}

void ProtoBody::
IndexedTriangleSet (const IndexedTriangleSet_sequence& s)
{
  this->IndexedTriangleSet_ = s;
}

const ProtoBody::IndexedTriangleStripSet_sequence& ProtoBody::
IndexedTriangleStripSet () const
{
  return this->IndexedTriangleStripSet_;
}

ProtoBody::IndexedTriangleStripSet_sequence& ProtoBody::
IndexedTriangleStripSet ()
{
  return this->IndexedTriangleStripSet_;
}

void ProtoBody::
IndexedTriangleStripSet (const IndexedTriangleStripSet_sequence& s)
{
  this->IndexedTriangleStripSet_ = s;
}

const ProtoBody::LineSet_sequence& ProtoBody::
LineSet () const
{
  return this->LineSet_;
}

ProtoBody::LineSet_sequence& ProtoBody::
LineSet ()
{
  return this->LineSet_;
}

void ProtoBody::
LineSet (const LineSet_sequence& s)
{
  this->LineSet_ = s;
}

const ProtoBody::PointSet_sequence& ProtoBody::
PointSet () const
{
  return this->PointSet_;
}

ProtoBody::PointSet_sequence& ProtoBody::
PointSet ()
{
  return this->PointSet_;
}

void ProtoBody::
PointSet (const PointSet_sequence& s)
{
  this->PointSet_ = s;
}

const ProtoBody::Sphere_sequence& ProtoBody::
Sphere () const
{
  return this->Sphere_;
}

ProtoBody::Sphere_sequence& ProtoBody::
Sphere ()
{
  return this->Sphere_;
}

void ProtoBody::
Sphere (const Sphere_sequence& s)
{
  this->Sphere_ = s;
}

const ProtoBody::TriangleFanSet_sequence& ProtoBody::
TriangleFanSet () const
{
  return this->TriangleFanSet_;
}

ProtoBody::TriangleFanSet_sequence& ProtoBody::
TriangleFanSet ()
{
  return this->TriangleFanSet_;
}

void ProtoBody::
TriangleFanSet (const TriangleFanSet_sequence& s)
{
  this->TriangleFanSet_ = s;
}

const ProtoBody::TriangleSet_sequence& ProtoBody::
TriangleSet () const
{
  return this->TriangleSet_;
}

ProtoBody::TriangleSet_sequence& ProtoBody::
TriangleSet ()
{
  return this->TriangleSet_;
}

void ProtoBody::
TriangleSet (const TriangleSet_sequence& s)
{
  this->TriangleSet_ = s;
}

const ProtoBody::TriangleStripSet_sequence& ProtoBody::
TriangleStripSet () const
{
  return this->TriangleStripSet_;
}

ProtoBody::TriangleStripSet_sequence& ProtoBody::
TriangleStripSet ()
{
  return this->TriangleStripSet_;
}

void ProtoBody::
TriangleStripSet (const TriangleStripSet_sequence& s)
{
  this->TriangleStripSet_ = s;
}

const ProtoBody::ElevationGrid_sequence& ProtoBody::
ElevationGrid () const
{
  return this->ElevationGrid_;
}

ProtoBody::ElevationGrid_sequence& ProtoBody::
ElevationGrid ()
{
  return this->ElevationGrid_;
}

void ProtoBody::
ElevationGrid (const ElevationGrid_sequence& s)
{
  this->ElevationGrid_ = s;
}

const ProtoBody::Polyline2D_sequence& ProtoBody::
Polyline2D () const
{
  return this->Polyline2D_;
}

ProtoBody::Polyline2D_sequence& ProtoBody::
Polyline2D ()
{
  return this->Polyline2D_;
}

void ProtoBody::
Polyline2D (const Polyline2D_sequence& s)
{
  this->Polyline2D_ = s;
}

const ProtoBody::Polypoint2D_sequence& ProtoBody::
Polypoint2D () const
{
  return this->Polypoint2D_;
}

ProtoBody::Polypoint2D_sequence& ProtoBody::
Polypoint2D ()
{
  return this->Polypoint2D_;
}

void ProtoBody::
Polypoint2D (const Polypoint2D_sequence& s)
{
  this->Polypoint2D_ = s;
}

const ProtoBody::Rectangle2D_sequence& ProtoBody::
Rectangle2D () const
{
  return this->Rectangle2D_;
}

ProtoBody::Rectangle2D_sequence& ProtoBody::
Rectangle2D ()
{
  return this->Rectangle2D_;
}

void ProtoBody::
Rectangle2D (const Rectangle2D_sequence& s)
{
  this->Rectangle2D_ = s;
}

const ProtoBody::TriangleSet2D_sequence& ProtoBody::
TriangleSet2D () const
{
  return this->TriangleSet2D_;
}

ProtoBody::TriangleSet2D_sequence& ProtoBody::
TriangleSet2D ()
{
  return this->TriangleSet2D_;
}

void ProtoBody::
TriangleSet2D (const TriangleSet2D_sequence& s)
{
  this->TriangleSet2D_ = s;
}

const ProtoBody::Extrusion_sequence& ProtoBody::
Extrusion () const
{
  return this->Extrusion_;
}

ProtoBody::Extrusion_sequence& ProtoBody::
Extrusion ()
{
  return this->Extrusion_;
}

void ProtoBody::
Extrusion (const Extrusion_sequence& s)
{
  this->Extrusion_ = s;
}

const ProtoBody::Text_sequence& ProtoBody::
Text () const
{
  return this->Text_;
}

ProtoBody::Text_sequence& ProtoBody::
Text ()
{
  return this->Text_;
}

void ProtoBody::
Text (const Text_sequence& s)
{
  this->Text_ = s;
}

const ProtoBody::Arc2D_sequence& ProtoBody::
Arc2D () const
{
  return this->Arc2D_;
}

ProtoBody::Arc2D_sequence& ProtoBody::
Arc2D ()
{
  return this->Arc2D_;
}

void ProtoBody::
Arc2D (const Arc2D_sequence& s)
{
  this->Arc2D_ = s;
}

const ProtoBody::ArcClose2D_sequence& ProtoBody::
ArcClose2D () const
{
  return this->ArcClose2D_;
}

ProtoBody::ArcClose2D_sequence& ProtoBody::
ArcClose2D ()
{
  return this->ArcClose2D_;
}

void ProtoBody::
ArcClose2D (const ArcClose2D_sequence& s)
{
  this->ArcClose2D_ = s;
}

const ProtoBody::Circle2D_sequence& ProtoBody::
Circle2D () const
{
  return this->Circle2D_;
}

ProtoBody::Circle2D_sequence& ProtoBody::
Circle2D ()
{
  return this->Circle2D_;
}

void ProtoBody::
Circle2D (const Circle2D_sequence& s)
{
  this->Circle2D_ = s;
}

const ProtoBody::Disk2D_sequence& ProtoBody::
Disk2D () const
{
  return this->Disk2D_;
}

ProtoBody::Disk2D_sequence& ProtoBody::
Disk2D ()
{
  return this->Disk2D_;
}

void ProtoBody::
Disk2D (const Disk2D_sequence& s)
{
  this->Disk2D_ = s;
}

const ProtoBody::QuadSet_sequence& ProtoBody::
QuadSet () const
{
  return this->QuadSet_;
}

ProtoBody::QuadSet_sequence& ProtoBody::
QuadSet ()
{
  return this->QuadSet_;
}

void ProtoBody::
QuadSet (const QuadSet_sequence& s)
{
  this->QuadSet_ = s;
}

const ProtoBody::IndexedQuadSet_sequence& ProtoBody::
IndexedQuadSet () const
{
  return this->IndexedQuadSet_;
}

ProtoBody::IndexedQuadSet_sequence& ProtoBody::
IndexedQuadSet ()
{
  return this->IndexedQuadSet_;
}

void ProtoBody::
IndexedQuadSet (const IndexedQuadSet_sequence& s)
{
  this->IndexedQuadSet_ = s;
}

const ProtoBody::GeoElevationGrid_sequence& ProtoBody::
GeoElevationGrid () const
{
  return this->GeoElevationGrid_;
}

ProtoBody::GeoElevationGrid_sequence& ProtoBody::
GeoElevationGrid ()
{
  return this->GeoElevationGrid_;
}

void ProtoBody::
GeoElevationGrid (const GeoElevationGrid_sequence& s)
{
  this->GeoElevationGrid_ = s;
}

const ProtoBody::NurbsCurve_sequence& ProtoBody::
NurbsCurve () const
{
  return this->NurbsCurve_;
}

ProtoBody::NurbsCurve_sequence& ProtoBody::
NurbsCurve ()
{
  return this->NurbsCurve_;
}

void ProtoBody::
NurbsCurve (const NurbsCurve_sequence& s)
{
  this->NurbsCurve_ = s;
}

const ProtoBody::NurbsCurve2D_sequence& ProtoBody::
NurbsCurve2D () const
{
  return this->NurbsCurve2D_;
}

ProtoBody::NurbsCurve2D_sequence& ProtoBody::
NurbsCurve2D ()
{
  return this->NurbsCurve2D_;
}

void ProtoBody::
NurbsCurve2D (const NurbsCurve2D_sequence& s)
{
  this->NurbsCurve2D_ = s;
}

const ProtoBody::NurbsPatchSurface_sequence& ProtoBody::
NurbsPatchSurface () const
{
  return this->NurbsPatchSurface_;
}

ProtoBody::NurbsPatchSurface_sequence& ProtoBody::
NurbsPatchSurface ()
{
  return this->NurbsPatchSurface_;
}

void ProtoBody::
NurbsPatchSurface (const NurbsPatchSurface_sequence& s)
{
  this->NurbsPatchSurface_ = s;
}

const ProtoBody::NurbsSweptSurface_sequence& ProtoBody::
NurbsSweptSurface () const
{
  return this->NurbsSweptSurface_;
}

ProtoBody::NurbsSweptSurface_sequence& ProtoBody::
NurbsSweptSurface ()
{
  return this->NurbsSweptSurface_;
}

void ProtoBody::
NurbsSweptSurface (const NurbsSweptSurface_sequence& s)
{
  this->NurbsSweptSurface_ = s;
}

const ProtoBody::NurbsSwungSurface_sequence& ProtoBody::
NurbsSwungSurface () const
{
  return this->NurbsSwungSurface_;
}

ProtoBody::NurbsSwungSurface_sequence& ProtoBody::
NurbsSwungSurface ()
{
  return this->NurbsSwungSurface_;
}

void ProtoBody::
NurbsSwungSurface (const NurbsSwungSurface_sequence& s)
{
  this->NurbsSwungSurface_ = s;
}

const ProtoBody::NurbsTrimmedSurface_sequence& ProtoBody::
NurbsTrimmedSurface () const
{
  return this->NurbsTrimmedSurface_;
}

ProtoBody::NurbsTrimmedSurface_sequence& ProtoBody::
NurbsTrimmedSurface ()
{
  return this->NurbsTrimmedSurface_;
}

void ProtoBody::
NurbsTrimmedSurface (const NurbsTrimmedSurface_sequence& s)
{
  this->NurbsTrimmedSurface_ = s;
}

const ProtoBody::Color_sequence& ProtoBody::
Color () const
{
  return this->Color_;
}

ProtoBody::Color_sequence& ProtoBody::
Color ()
{
  return this->Color_;
}

void ProtoBody::
Color (const Color_sequence& s)
{
  this->Color_ = s;
}

const ProtoBody::ColorRGBA_sequence& ProtoBody::
ColorRGBA () const
{
  return this->ColorRGBA_;
}

ProtoBody::ColorRGBA_sequence& ProtoBody::
ColorRGBA ()
{
  return this->ColorRGBA_;
}

void ProtoBody::
ColorRGBA (const ColorRGBA_sequence& s)
{
  this->ColorRGBA_ = s;
}

const ProtoBody::Coordinate_sequence& ProtoBody::
Coordinate () const
{
  return this->Coordinate_;
}

ProtoBody::Coordinate_sequence& ProtoBody::
Coordinate ()
{
  return this->Coordinate_;
}

void ProtoBody::
Coordinate (const Coordinate_sequence& s)
{
  this->Coordinate_ = s;
}

const ProtoBody::CoordinateDouble_sequence& ProtoBody::
CoordinateDouble () const
{
  return this->CoordinateDouble_;
}

ProtoBody::CoordinateDouble_sequence& ProtoBody::
CoordinateDouble ()
{
  return this->CoordinateDouble_;
}

void ProtoBody::
CoordinateDouble (const CoordinateDouble_sequence& s)
{
  this->CoordinateDouble_ = s;
}

const ProtoBody::FontStyle_sequence& ProtoBody::
FontStyle () const
{
  return this->FontStyle_;
}

ProtoBody::FontStyle_sequence& ProtoBody::
FontStyle ()
{
  return this->FontStyle_;
}

void ProtoBody::
FontStyle (const FontStyle_sequence& s)
{
  this->FontStyle_ = s;
}

const ProtoBody::GeoCoordinate_sequence& ProtoBody::
GeoCoordinate () const
{
  return this->GeoCoordinate_;
}

ProtoBody::GeoCoordinate_sequence& ProtoBody::
GeoCoordinate ()
{
  return this->GeoCoordinate_;
}

void ProtoBody::
GeoCoordinate (const GeoCoordinate_sequence& s)
{
  this->GeoCoordinate_ = s;
}

const ProtoBody::Normal_sequence& ProtoBody::
Normal () const
{
  return this->Normal_;
}

ProtoBody::Normal_sequence& ProtoBody::
Normal ()
{
  return this->Normal_;
}

void ProtoBody::
Normal (const Normal_sequence& s)
{
  this->Normal_ = s;
}

const ProtoBody::TextureCoordinate_sequence& ProtoBody::
TextureCoordinate () const
{
  return this->TextureCoordinate_;
}

ProtoBody::TextureCoordinate_sequence& ProtoBody::
TextureCoordinate ()
{
  return this->TextureCoordinate_;
}

void ProtoBody::
TextureCoordinate (const TextureCoordinate_sequence& s)
{
  this->TextureCoordinate_ = s;
}

const ProtoBody::NurbsTextureCoordinate_sequence& ProtoBody::
NurbsTextureCoordinate () const
{
  return this->NurbsTextureCoordinate_;
}

ProtoBody::NurbsTextureCoordinate_sequence& ProtoBody::
NurbsTextureCoordinate ()
{
  return this->NurbsTextureCoordinate_;
}

void ProtoBody::
NurbsTextureCoordinate (const NurbsTextureCoordinate_sequence& s)
{
  this->NurbsTextureCoordinate_ = s;
}

const ProtoBody::ROUTE_sequence& ProtoBody::
ROUTE () const
{
  return this->ROUTE_;
}

ProtoBody::ROUTE_sequence& ProtoBody::
ROUTE ()
{
  return this->ROUTE_;
}

void ProtoBody::
ROUTE (const ROUTE_sequence& s)
{
  this->ROUTE_ = s;
}

const ProtoBody::ExternProtoDeclare_sequence& ProtoBody::
ExternProtoDeclare () const
{
  return this->ExternProtoDeclare_;
}

ProtoBody::ExternProtoDeclare_sequence& ProtoBody::
ExternProtoDeclare ()
{
  return this->ExternProtoDeclare_;
}

void ProtoBody::
ExternProtoDeclare (const ExternProtoDeclare_sequence& s)
{
  this->ExternProtoDeclare_ = s;
}

const ProtoBody::ProtoDeclare_sequence& ProtoBody::
ProtoDeclare () const
{
  return this->ProtoDeclare_;
}

ProtoBody::ProtoDeclare_sequence& ProtoBody::
ProtoDeclare ()
{
  return this->ProtoDeclare_;
}

void ProtoBody::
ProtoDeclare (const ProtoDeclare_sequence& s)
{
  this->ProtoDeclare_ = s;
}

const ProtoBody::IMPORT_sequence& ProtoBody::
IMPORT () const
{
  return this->IMPORT_;
}

ProtoBody::IMPORT_sequence& ProtoBody::
IMPORT ()
{
  return this->IMPORT_;
}

void ProtoBody::
IMPORT (const IMPORT_sequence& s)
{
  this->IMPORT_ = s;
}

const ProtoBody::EXPORT_sequence& ProtoBody::
EXPORT () const
{
  return this->EXPORT_;
}

ProtoBody::EXPORT_sequence& ProtoBody::
EXPORT ()
{
  return this->EXPORT_;
}

void ProtoBody::
EXPORT (const EXPORT_sequence& s)
{
  this->EXPORT_ = s;
}


// ProtoInstance
// 

const ProtoInstance::fieldValue_sequence& ProtoInstance::
fieldValue () const
{
  return this->fieldValue_;
}

ProtoInstance::fieldValue_sequence& ProtoInstance::
fieldValue ()
{
  return this->fieldValue_;
}

void ProtoInstance::
fieldValue (const fieldValue_sequence& s)
{
  this->fieldValue_ = s;
}

const ProtoInstance::IS_sequence& ProtoInstance::
IS () const
{
  return this->IS_;
}

ProtoInstance::IS_sequence& ProtoInstance::
IS ()
{
  return this->IS_;
}

void ProtoInstance::
IS (const IS_sequence& s)
{
  this->IS_ = s;
}

const ProtoInstance::DEF_optional& ProtoInstance::
DEF () const
{
  return this->DEF_;
}

ProtoInstance::DEF_optional& ProtoInstance::
DEF ()
{
  return this->DEF_;
}

void ProtoInstance::
DEF (const DEF_type& x)
{
  this->DEF_.set (x);
}

void ProtoInstance::
DEF (const DEF_optional& x)
{
  this->DEF_ = x;
}

void ProtoInstance::
DEF (::std::auto_ptr< DEF_type > x)
{
  this->DEF_.set (x);
}

const ProtoInstance::USE_optional& ProtoInstance::
USE () const
{
  return this->USE_;
}

ProtoInstance::USE_optional& ProtoInstance::
USE ()
{
  return this->USE_;
}

void ProtoInstance::
USE (const USE_type& x)
{
  this->USE_.set (x);
}

void ProtoInstance::
USE (const USE_optional& x)
{
  this->USE_ = x;
}

void ProtoInstance::
USE (::std::auto_ptr< USE_type > x)
{
  this->USE_.set (x);
}

const ProtoInstance::class_optional& ProtoInstance::
class_ () const
{
  return this->class__;
}

ProtoInstance::class_optional& ProtoInstance::
class_ ()
{
  return this->class__;
}

void ProtoInstance::
class_ (const class_type& x)
{
  this->class__.set (x);
}

void ProtoInstance::
class_ (const class_optional& x)
{
  this->class__ = x;
}

void ProtoInstance::
class_ (::std::auto_ptr< class_type > x)
{
  this->class__.set (x);
}

const ProtoInstance::containerField_type& ProtoInstance::
containerField () const
{
  return this->containerField_.get ();
}

ProtoInstance::containerField_type& ProtoInstance::
containerField ()
{
  return this->containerField_.get ();
}

void ProtoInstance::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void ProtoInstance::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const ProtoInstance::containerField_type& ProtoInstance::
containerField_default_value ()
{
  return containerField_default_value_;
}


// ROUTE
// 

const ROUTE::fromNode_type& ROUTE::
fromNode () const
{
  return this->fromNode_.get ();
}

ROUTE::fromNode_type& ROUTE::
fromNode ()
{
  return this->fromNode_.get ();
}

void ROUTE::
fromNode (const fromNode_type& x)
{
  this->fromNode_.set (x);
}

void ROUTE::
fromNode (::std::auto_ptr< fromNode_type > x)
{
  this->fromNode_.set (x);
}

const ROUTE::fromField_type& ROUTE::
fromField () const
{
  return this->fromField_.get ();
}

ROUTE::fromField_type& ROUTE::
fromField ()
{
  return this->fromField_.get ();
}

void ROUTE::
fromField (const fromField_type& x)
{
  this->fromField_.set (x);
}

void ROUTE::
fromField (::std::auto_ptr< fromField_type > x)
{
  this->fromField_.set (x);
}

const ROUTE::toNode_type& ROUTE::
toNode () const
{
  return this->toNode_.get ();
}

ROUTE::toNode_type& ROUTE::
toNode ()
{
  return this->toNode_.get ();
}

void ROUTE::
toNode (const toNode_type& x)
{
  this->toNode_.set (x);
}

void ROUTE::
toNode (::std::auto_ptr< toNode_type > x)
{
  this->toNode_.set (x);
}

const ROUTE::toField_type& ROUTE::
toField () const
{
  return this->toField_.get ();
}

ROUTE::toField_type& ROUTE::
toField ()
{
  return this->toField_.get ();
}

void ROUTE::
toField (const toField_type& x)
{
  this->toField_.set (x);
}

void ROUTE::
toField (::std::auto_ptr< toField_type > x)
{
  this->toField_.set (x);
}


// Scene
// 

const Scene::MetadataDouble_sequence& Scene::
MetadataDouble () const
{
  return this->MetadataDouble_;
}

Scene::MetadataDouble_sequence& Scene::
MetadataDouble ()
{
  return this->MetadataDouble_;
}

void Scene::
MetadataDouble (const MetadataDouble_sequence& s)
{
  this->MetadataDouble_ = s;
}

const Scene::MetadataFloat_sequence& Scene::
MetadataFloat () const
{
  return this->MetadataFloat_;
}

Scene::MetadataFloat_sequence& Scene::
MetadataFloat ()
{
  return this->MetadataFloat_;
}

void Scene::
MetadataFloat (const MetadataFloat_sequence& s)
{
  this->MetadataFloat_ = s;
}

const Scene::MetadataInteger_sequence& Scene::
MetadataInteger () const
{
  return this->MetadataInteger_;
}

Scene::MetadataInteger_sequence& Scene::
MetadataInteger ()
{
  return this->MetadataInteger_;
}

void Scene::
MetadataInteger (const MetadataInteger_sequence& s)
{
  this->MetadataInteger_ = s;
}

const Scene::MetadataSet_sequence& Scene::
MetadataSet () const
{
  return this->MetadataSet_;
}

Scene::MetadataSet_sequence& Scene::
MetadataSet ()
{
  return this->MetadataSet_;
}

void Scene::
MetadataSet (const MetadataSet_sequence& s)
{
  this->MetadataSet_ = s;
}

const Scene::MetadataString_sequence& Scene::
MetadataString () const
{
  return this->MetadataString_;
}

Scene::MetadataString_sequence& Scene::
MetadataString ()
{
  return this->MetadataString_;
}

void Scene::
MetadataString (const MetadataString_sequence& s)
{
  this->MetadataString_ = s;
}

const Scene::Appearance_sequence& Scene::
Appearance () const
{
  return this->Appearance_;
}

Scene::Appearance_sequence& Scene::
Appearance ()
{
  return this->Appearance_;
}

void Scene::
Appearance (const Appearance_sequence& s)
{
  this->Appearance_ = s;
}

const Scene::Background_sequence& Scene::
Background () const
{
  return this->Background_;
}

Scene::Background_sequence& Scene::
Background ()
{
  return this->Background_;
}

void Scene::
Background (const Background_sequence& s)
{
  this->Background_ = s;
}

const Scene::ColorInterpolator_sequence& Scene::
ColorInterpolator () const
{
  return this->ColorInterpolator_;
}

Scene::ColorInterpolator_sequence& Scene::
ColorInterpolator ()
{
  return this->ColorInterpolator_;
}

void Scene::
ColorInterpolator (const ColorInterpolator_sequence& s)
{
  this->ColorInterpolator_ = s;
}

const Scene::CoordinateInterpolator_sequence& Scene::
CoordinateInterpolator () const
{
  return this->CoordinateInterpolator_;
}

Scene::CoordinateInterpolator_sequence& Scene::
CoordinateInterpolator ()
{
  return this->CoordinateInterpolator_;
}

void Scene::
CoordinateInterpolator (const CoordinateInterpolator_sequence& s)
{
  this->CoordinateInterpolator_ = s;
}

const Scene::DirectionalLight_sequence& Scene::
DirectionalLight () const
{
  return this->DirectionalLight_;
}

Scene::DirectionalLight_sequence& Scene::
DirectionalLight ()
{
  return this->DirectionalLight_;
}

void Scene::
DirectionalLight (const DirectionalLight_sequence& s)
{
  this->DirectionalLight_ = s;
}

const Scene::Group_sequence& Scene::
Group () const
{
  return this->Group_;
}

Scene::Group_sequence& Scene::
Group ()
{
  return this->Group_;
}

void Scene::
Group (const Group_sequence& s)
{
  this->Group_ = s;
}

const Scene::NavigationInfo_sequence& Scene::
NavigationInfo () const
{
  return this->NavigationInfo_;
}

Scene::NavigationInfo_sequence& Scene::
NavigationInfo ()
{
  return this->NavigationInfo_;
}

void Scene::
NavigationInfo (const NavigationInfo_sequence& s)
{
  this->NavigationInfo_ = s;
}

const Scene::NormalInterpolator_sequence& Scene::
NormalInterpolator () const
{
  return this->NormalInterpolator_;
}

Scene::NormalInterpolator_sequence& Scene::
NormalInterpolator ()
{
  return this->NormalInterpolator_;
}

void Scene::
NormalInterpolator (const NormalInterpolator_sequence& s)
{
  this->NormalInterpolator_ = s;
}

const Scene::OrientationInterpolator_sequence& Scene::
OrientationInterpolator () const
{
  return this->OrientationInterpolator_;
}

Scene::OrientationInterpolator_sequence& Scene::
OrientationInterpolator ()
{
  return this->OrientationInterpolator_;
}

void Scene::
OrientationInterpolator (const OrientationInterpolator_sequence& s)
{
  this->OrientationInterpolator_ = s;
}

const Scene::PositionInterpolator_sequence& Scene::
PositionInterpolator () const
{
  return this->PositionInterpolator_;
}

Scene::PositionInterpolator_sequence& Scene::
PositionInterpolator ()
{
  return this->PositionInterpolator_;
}

void Scene::
PositionInterpolator (const PositionInterpolator_sequence& s)
{
  this->PositionInterpolator_ = s;
}

const Scene::ScalarInterpolator_sequence& Scene::
ScalarInterpolator () const
{
  return this->ScalarInterpolator_;
}

Scene::ScalarInterpolator_sequence& Scene::
ScalarInterpolator ()
{
  return this->ScalarInterpolator_;
}

void Scene::
ScalarInterpolator (const ScalarInterpolator_sequence& s)
{
  this->ScalarInterpolator_ = s;
}

const Scene::Shape_sequence& Scene::
Shape () const
{
  return this->Shape_;
}

Scene::Shape_sequence& Scene::
Shape ()
{
  return this->Shape_;
}

void Scene::
Shape (const Shape_sequence& s)
{
  this->Shape_ = s;
}

const Scene::TimeSensor_sequence& Scene::
TimeSensor () const
{
  return this->TimeSensor_;
}

Scene::TimeSensor_sequence& Scene::
TimeSensor ()
{
  return this->TimeSensor_;
}

void Scene::
TimeSensor (const TimeSensor_sequence& s)
{
  this->TimeSensor_ = s;
}

const Scene::Transform_sequence& Scene::
Transform () const
{
  return this->Transform_;
}

Scene::Transform_sequence& Scene::
Transform ()
{
  return this->Transform_;
}

void Scene::
Transform (const Transform_sequence& s)
{
  this->Transform_ = s;
}

const Scene::Viewpoint_sequence& Scene::
Viewpoint () const
{
  return this->Viewpoint_;
}

Scene::Viewpoint_sequence& Scene::
Viewpoint ()
{
  return this->Viewpoint_;
}

void Scene::
Viewpoint (const Viewpoint_sequence& s)
{
  this->Viewpoint_ = s;
}

const Scene::WorldInfo_sequence& Scene::
WorldInfo () const
{
  return this->WorldInfo_;
}

Scene::WorldInfo_sequence& Scene::
WorldInfo ()
{
  return this->WorldInfo_;
}

void Scene::
WorldInfo (const WorldInfo_sequence& s)
{
  this->WorldInfo_ = s;
}

const Scene::Anchor_sequence& Scene::
Anchor () const
{
  return this->Anchor_;
}

Scene::Anchor_sequence& Scene::
Anchor ()
{
  return this->Anchor_;
}

void Scene::
Anchor (const Anchor_sequence& s)
{
  this->Anchor_ = s;
}

const Scene::BooleanFilter_sequence& Scene::
BooleanFilter () const
{
  return this->BooleanFilter_;
}

Scene::BooleanFilter_sequence& Scene::
BooleanFilter ()
{
  return this->BooleanFilter_;
}

void Scene::
BooleanFilter (const BooleanFilter_sequence& s)
{
  this->BooleanFilter_ = s;
}

const Scene::BooleanSequencer_sequence& Scene::
BooleanSequencer () const
{
  return this->BooleanSequencer_;
}

Scene::BooleanSequencer_sequence& Scene::
BooleanSequencer ()
{
  return this->BooleanSequencer_;
}

void Scene::
BooleanSequencer (const BooleanSequencer_sequence& s)
{
  this->BooleanSequencer_ = s;
}

const Scene::BooleanToggle_sequence& Scene::
BooleanToggle () const
{
  return this->BooleanToggle_;
}

Scene::BooleanToggle_sequence& Scene::
BooleanToggle ()
{
  return this->BooleanToggle_;
}

void Scene::
BooleanToggle (const BooleanToggle_sequence& s)
{
  this->BooleanToggle_ = s;
}

const Scene::BooleanTrigger_sequence& Scene::
BooleanTrigger () const
{
  return this->BooleanTrigger_;
}

Scene::BooleanTrigger_sequence& Scene::
BooleanTrigger ()
{
  return this->BooleanTrigger_;
}

void Scene::
BooleanTrigger (const BooleanTrigger_sequence& s)
{
  this->BooleanTrigger_ = s;
}

const Scene::CylinderSensor_sequence& Scene::
CylinderSensor () const
{
  return this->CylinderSensor_;
}

Scene::CylinderSensor_sequence& Scene::
CylinderSensor ()
{
  return this->CylinderSensor_;
}

void Scene::
CylinderSensor (const CylinderSensor_sequence& s)
{
  this->CylinderSensor_ = s;
}

const Scene::Inline_sequence& Scene::
Inline () const
{
  return this->Inline_;
}

Scene::Inline_sequence& Scene::
Inline ()
{
  return this->Inline_;
}

void Scene::
Inline (const Inline_sequence& s)
{
  this->Inline_ = s;
}

const Scene::IntegerSequencer_sequence& Scene::
IntegerSequencer () const
{
  return this->IntegerSequencer_;
}

Scene::IntegerSequencer_sequence& Scene::
IntegerSequencer ()
{
  return this->IntegerSequencer_;
}

void Scene::
IntegerSequencer (const IntegerSequencer_sequence& s)
{
  this->IntegerSequencer_ = s;
}

const Scene::IntegerTrigger_sequence& Scene::
IntegerTrigger () const
{
  return this->IntegerTrigger_;
}

Scene::IntegerTrigger_sequence& Scene::
IntegerTrigger ()
{
  return this->IntegerTrigger_;
}

void Scene::
IntegerTrigger (const IntegerTrigger_sequence& s)
{
  this->IntegerTrigger_ = s;
}

const Scene::KeySensor_sequence& Scene::
KeySensor () const
{
  return this->KeySensor_;
}

Scene::KeySensor_sequence& Scene::
KeySensor ()
{
  return this->KeySensor_;
}

void Scene::
KeySensor (const KeySensor_sequence& s)
{
  this->KeySensor_ = s;
}

const Scene::PlaneSensor_sequence& Scene::
PlaneSensor () const
{
  return this->PlaneSensor_;
}

Scene::PlaneSensor_sequence& Scene::
PlaneSensor ()
{
  return this->PlaneSensor_;
}

void Scene::
PlaneSensor (const PlaneSensor_sequence& s)
{
  this->PlaneSensor_ = s;
}

const Scene::PointLight_sequence& Scene::
PointLight () const
{
  return this->PointLight_;
}

Scene::PointLight_sequence& Scene::
PointLight ()
{
  return this->PointLight_;
}

void Scene::
PointLight (const PointLight_sequence& s)
{
  this->PointLight_ = s;
}

const Scene::ProximitySensor_sequence& Scene::
ProximitySensor () const
{
  return this->ProximitySensor_;
}

Scene::ProximitySensor_sequence& Scene::
ProximitySensor ()
{
  return this->ProximitySensor_;
}

void Scene::
ProximitySensor (const ProximitySensor_sequence& s)
{
  this->ProximitySensor_ = s;
}

const Scene::SphereSensor_sequence& Scene::
SphereSensor () const
{
  return this->SphereSensor_;
}

Scene::SphereSensor_sequence& Scene::
SphereSensor ()
{
  return this->SphereSensor_;
}

void Scene::
SphereSensor (const SphereSensor_sequence& s)
{
  this->SphereSensor_ = s;
}

const Scene::SpotLight_sequence& Scene::
SpotLight () const
{
  return this->SpotLight_;
}

Scene::SpotLight_sequence& Scene::
SpotLight ()
{
  return this->SpotLight_;
}

void Scene::
SpotLight (const SpotLight_sequence& s)
{
  this->SpotLight_ = s;
}

const Scene::StringSensor_sequence& Scene::
StringSensor () const
{
  return this->StringSensor_;
}

Scene::StringSensor_sequence& Scene::
StringSensor ()
{
  return this->StringSensor_;
}

void Scene::
StringSensor (const StringSensor_sequence& s)
{
  this->StringSensor_ = s;
}

const Scene::Switch_sequence& Scene::
Switch () const
{
  return this->Switch_;
}

Scene::Switch_sequence& Scene::
Switch ()
{
  return this->Switch_;
}

void Scene::
Switch (const Switch_sequence& s)
{
  this->Switch_ = s;
}

const Scene::TimeTrigger_sequence& Scene::
TimeTrigger () const
{
  return this->TimeTrigger_;
}

Scene::TimeTrigger_sequence& Scene::
TimeTrigger ()
{
  return this->TimeTrigger_;
}

void Scene::
TimeTrigger (const TimeTrigger_sequence& s)
{
  this->TimeTrigger_ = s;
}

const Scene::TouchSensor_sequence& Scene::
TouchSensor () const
{
  return this->TouchSensor_;
}

Scene::TouchSensor_sequence& Scene::
TouchSensor ()
{
  return this->TouchSensor_;
}

void Scene::
TouchSensor (const TouchSensor_sequence& s)
{
  this->TouchSensor_ = s;
}

const Scene::AudioClip_sequence& Scene::
AudioClip () const
{
  return this->AudioClip_;
}

Scene::AudioClip_sequence& Scene::
AudioClip ()
{
  return this->AudioClip_;
}

void Scene::
AudioClip (const AudioClip_sequence& s)
{
  this->AudioClip_ = s;
}

const Scene::Billboard_sequence& Scene::
Billboard () const
{
  return this->Billboard_;
}

Scene::Billboard_sequence& Scene::
Billboard ()
{
  return this->Billboard_;
}

void Scene::
Billboard (const Billboard_sequence& s)
{
  this->Billboard_ = s;
}

const Scene::Collision_sequence& Scene::
Collision () const
{
  return this->Collision_;
}

Scene::Collision_sequence& Scene::
Collision ()
{
  return this->Collision_;
}

void Scene::
Collision (const Collision_sequence& s)
{
  this->Collision_ = s;
}

const Scene::Fog_sequence& Scene::
Fog () const
{
  return this->Fog_;
}

Scene::Fog_sequence& Scene::
Fog ()
{
  return this->Fog_;
}

void Scene::
Fog (const Fog_sequence& s)
{
  this->Fog_ = s;
}

const Scene::LoadSensor_sequence& Scene::
LoadSensor () const
{
  return this->LoadSensor_;
}

Scene::LoadSensor_sequence& Scene::
LoadSensor ()
{
  return this->LoadSensor_;
}

void Scene::
LoadSensor (const LoadSensor_sequence& s)
{
  this->LoadSensor_ = s;
}

const Scene::LocalFog_sequence& Scene::
LocalFog () const
{
  return this->LocalFog_;
}

Scene::LocalFog_sequence& Scene::
LocalFog ()
{
  return this->LocalFog_;
}

void Scene::
LocalFog (const LocalFog_sequence& s)
{
  this->LocalFog_ = s;
}

const Scene::LOD_sequence& Scene::
LOD () const
{
  return this->LOD_;
}

Scene::LOD_sequence& Scene::
LOD ()
{
  return this->LOD_;
}

void Scene::
LOD (const LOD_sequence& s)
{
  this->LOD_ = s;
}

const Scene::Script_sequence& Scene::
Script () const
{
  return this->Script_;
}

Scene::Script_sequence& Scene::
Script ()
{
  return this->Script_;
}

void Scene::
Script (const Script_sequence& s)
{
  this->Script_ = s;
}

const Scene::Sound_sequence& Scene::
Sound () const
{
  return this->Sound_;
}

Scene::Sound_sequence& Scene::
Sound ()
{
  return this->Sound_;
}

void Scene::
Sound (const Sound_sequence& s)
{
  this->Sound_ = s;
}

const Scene::VisibilitySensor_sequence& Scene::
VisibilitySensor () const
{
  return this->VisibilitySensor_;
}

Scene::VisibilitySensor_sequence& Scene::
VisibilitySensor ()
{
  return this->VisibilitySensor_;
}

void Scene::
VisibilitySensor (const VisibilitySensor_sequence& s)
{
  this->VisibilitySensor_ = s;
}

const Scene::CoordinateInterpolator2D_sequence& Scene::
CoordinateInterpolator2D () const
{
  return this->CoordinateInterpolator2D_;
}

Scene::CoordinateInterpolator2D_sequence& Scene::
CoordinateInterpolator2D ()
{
  return this->CoordinateInterpolator2D_;
}

void Scene::
CoordinateInterpolator2D (const CoordinateInterpolator2D_sequence& s)
{
  this->CoordinateInterpolator2D_ = s;
}

const Scene::PositionInterpolator2D_sequence& Scene::
PositionInterpolator2D () const
{
  return this->PositionInterpolator2D_;
}

Scene::PositionInterpolator2D_sequence& Scene::
PositionInterpolator2D ()
{
  return this->PositionInterpolator2D_;
}

void Scene::
PositionInterpolator2D (const PositionInterpolator2D_sequence& s)
{
  this->PositionInterpolator2D_ = s;
}

const Scene::StaticGroup_sequence& Scene::
StaticGroup () const
{
  return this->StaticGroup_;
}

Scene::StaticGroup_sequence& Scene::
StaticGroup ()
{
  return this->StaticGroup_;
}

void Scene::
StaticGroup (const StaticGroup_sequence& s)
{
  this->StaticGroup_ = s;
}

const Scene::CADAssembly_sequence& Scene::
CADAssembly () const
{
  return this->CADAssembly_;
}

Scene::CADAssembly_sequence& Scene::
CADAssembly ()
{
  return this->CADAssembly_;
}

void Scene::
CADAssembly (const CADAssembly_sequence& s)
{
  this->CADAssembly_ = s;
}

const Scene::CADLayer_sequence& Scene::
CADLayer () const
{
  return this->CADLayer_;
}

Scene::CADLayer_sequence& Scene::
CADLayer ()
{
  return this->CADLayer_;
}

void Scene::
CADLayer (const CADLayer_sequence& s)
{
  this->CADLayer_ = s;
}

const Scene::EspduTransform_sequence& Scene::
EspduTransform () const
{
  return this->EspduTransform_;
}

Scene::EspduTransform_sequence& Scene::
EspduTransform ()
{
  return this->EspduTransform_;
}

void Scene::
EspduTransform (const EspduTransform_sequence& s)
{
  this->EspduTransform_ = s;
}

const Scene::ReceiverPdu_sequence& Scene::
ReceiverPdu () const
{
  return this->ReceiverPdu_;
}

Scene::ReceiverPdu_sequence& Scene::
ReceiverPdu ()
{
  return this->ReceiverPdu_;
}

void Scene::
ReceiverPdu (const ReceiverPdu_sequence& s)
{
  this->ReceiverPdu_ = s;
}

const Scene::SignalPdu_sequence& Scene::
SignalPdu () const
{
  return this->SignalPdu_;
}

Scene::SignalPdu_sequence& Scene::
SignalPdu ()
{
  return this->SignalPdu_;
}

void Scene::
SignalPdu (const SignalPdu_sequence& s)
{
  this->SignalPdu_ = s;
}

const Scene::TransmitterPdu_sequence& Scene::
TransmitterPdu () const
{
  return this->TransmitterPdu_;
}

Scene::TransmitterPdu_sequence& Scene::
TransmitterPdu ()
{
  return this->TransmitterPdu_;
}

void Scene::
TransmitterPdu (const TransmitterPdu_sequence& s)
{
  this->TransmitterPdu_ = s;
}

const Scene::GeoLocation_sequence& Scene::
GeoLocation () const
{
  return this->GeoLocation_;
}

Scene::GeoLocation_sequence& Scene::
GeoLocation ()
{
  return this->GeoLocation_;
}

void Scene::
GeoLocation (const GeoLocation_sequence& s)
{
  this->GeoLocation_ = s;
}

const Scene::GeoLOD_sequence& Scene::
GeoLOD () const
{
  return this->GeoLOD_;
}

Scene::GeoLOD_sequence& Scene::
GeoLOD ()
{
  return this->GeoLOD_;
}

void Scene::
GeoLOD (const GeoLOD_sequence& s)
{
  this->GeoLOD_ = s;
}

const Scene::GeoMetadata_sequence& Scene::
GeoMetadata () const
{
  return this->GeoMetadata_;
}

Scene::GeoMetadata_sequence& Scene::
GeoMetadata ()
{
  return this->GeoMetadata_;
}

void Scene::
GeoMetadata (const GeoMetadata_sequence& s)
{
  this->GeoMetadata_ = s;
}

const Scene::GeoOrigin_sequence& Scene::
GeoOrigin () const
{
  return this->GeoOrigin_;
}

Scene::GeoOrigin_sequence& Scene::
GeoOrigin ()
{
  return this->GeoOrigin_;
}

void Scene::
GeoOrigin (const GeoOrigin_sequence& s)
{
  this->GeoOrigin_ = s;
}

const Scene::GeoPositionInterpolator_sequence& Scene::
GeoPositionInterpolator () const
{
  return this->GeoPositionInterpolator_;
}

Scene::GeoPositionInterpolator_sequence& Scene::
GeoPositionInterpolator ()
{
  return this->GeoPositionInterpolator_;
}

void Scene::
GeoPositionInterpolator (const GeoPositionInterpolator_sequence& s)
{
  this->GeoPositionInterpolator_ = s;
}

const Scene::GeoTouchSensor_sequence& Scene::
GeoTouchSensor () const
{
  return this->GeoTouchSensor_;
}

Scene::GeoTouchSensor_sequence& Scene::
GeoTouchSensor ()
{
  return this->GeoTouchSensor_;
}

void Scene::
GeoTouchSensor (const GeoTouchSensor_sequence& s)
{
  this->GeoTouchSensor_ = s;
}

const Scene::GeoViewpoint_sequence& Scene::
GeoViewpoint () const
{
  return this->GeoViewpoint_;
}

Scene::GeoViewpoint_sequence& Scene::
GeoViewpoint ()
{
  return this->GeoViewpoint_;
}

void Scene::
GeoViewpoint (const GeoViewpoint_sequence& s)
{
  this->GeoViewpoint_ = s;
}

const Scene::HAnimHumanoid_sequence& Scene::
HAnimHumanoid () const
{
  return this->HAnimHumanoid_;
}

Scene::HAnimHumanoid_sequence& Scene::
HAnimHumanoid ()
{
  return this->HAnimHumanoid_;
}

void Scene::
HAnimHumanoid (const HAnimHumanoid_sequence& s)
{
  this->HAnimHumanoid_ = s;
}

const Scene::HAnimJoint_sequence& Scene::
HAnimJoint () const
{
  return this->HAnimJoint_;
}

Scene::HAnimJoint_sequence& Scene::
HAnimJoint ()
{
  return this->HAnimJoint_;
}

void Scene::
HAnimJoint (const HAnimJoint_sequence& s)
{
  this->HAnimJoint_ = s;
}

const Scene::HAnimSegment_sequence& Scene::
HAnimSegment () const
{
  return this->HAnimSegment_;
}

Scene::HAnimSegment_sequence& Scene::
HAnimSegment ()
{
  return this->HAnimSegment_;
}

void Scene::
HAnimSegment (const HAnimSegment_sequence& s)
{
  this->HAnimSegment_ = s;
}

const Scene::HAnimSite_sequence& Scene::
HAnimSite () const
{
  return this->HAnimSite_;
}

Scene::HAnimSite_sequence& Scene::
HAnimSite ()
{
  return this->HAnimSite_;
}

void Scene::
HAnimSite (const HAnimSite_sequence& s)
{
  this->HAnimSite_ = s;
}

const Scene::NurbsOrientationInterpolator_sequence& Scene::
NurbsOrientationInterpolator () const
{
  return this->NurbsOrientationInterpolator_;
}

Scene::NurbsOrientationInterpolator_sequence& Scene::
NurbsOrientationInterpolator ()
{
  return this->NurbsOrientationInterpolator_;
}

void Scene::
NurbsOrientationInterpolator (const NurbsOrientationInterpolator_sequence& s)
{
  this->NurbsOrientationInterpolator_ = s;
}

const Scene::NurbsPositionInterpolator_sequence& Scene::
NurbsPositionInterpolator () const
{
  return this->NurbsPositionInterpolator_;
}

Scene::NurbsPositionInterpolator_sequence& Scene::
NurbsPositionInterpolator ()
{
  return this->NurbsPositionInterpolator_;
}

void Scene::
NurbsPositionInterpolator (const NurbsPositionInterpolator_sequence& s)
{
  this->NurbsPositionInterpolator_ = s;
}

const Scene::NurbsSurfaceInterpolator_sequence& Scene::
NurbsSurfaceInterpolator () const
{
  return this->NurbsSurfaceInterpolator_;
}

Scene::NurbsSurfaceInterpolator_sequence& Scene::
NurbsSurfaceInterpolator ()
{
  return this->NurbsSurfaceInterpolator_;
}

void Scene::
NurbsSurfaceInterpolator (const NurbsSurfaceInterpolator_sequence& s)
{
  this->NurbsSurfaceInterpolator_ = s;
}

const Scene::NurbsSet_sequence& Scene::
NurbsSet () const
{
  return this->NurbsSet_;
}

Scene::NurbsSet_sequence& Scene::
NurbsSet ()
{
  return this->NurbsSet_;
}

void Scene::
NurbsSet (const NurbsSet_sequence& s)
{
  this->NurbsSet_ = s;
}

const Scene::ProtoInstance_sequence& Scene::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

Scene::ProtoInstance_sequence& Scene::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void Scene::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const Scene::ROUTE_sequence& Scene::
ROUTE () const
{
  return this->ROUTE_;
}

Scene::ROUTE_sequence& Scene::
ROUTE ()
{
  return this->ROUTE_;
}

void Scene::
ROUTE (const ROUTE_sequence& s)
{
  this->ROUTE_ = s;
}

const Scene::ExternProtoDeclare_sequence& Scene::
ExternProtoDeclare () const
{
  return this->ExternProtoDeclare_;
}

Scene::ExternProtoDeclare_sequence& Scene::
ExternProtoDeclare ()
{
  return this->ExternProtoDeclare_;
}

void Scene::
ExternProtoDeclare (const ExternProtoDeclare_sequence& s)
{
  this->ExternProtoDeclare_ = s;
}

const Scene::ProtoDeclare_sequence& Scene::
ProtoDeclare () const
{
  return this->ProtoDeclare_;
}

Scene::ProtoDeclare_sequence& Scene::
ProtoDeclare ()
{
  return this->ProtoDeclare_;
}

void Scene::
ProtoDeclare (const ProtoDeclare_sequence& s)
{
  this->ProtoDeclare_ = s;
}

const Scene::IMPORT_sequence& Scene::
IMPORT () const
{
  return this->IMPORT_;
}

Scene::IMPORT_sequence& Scene::
IMPORT ()
{
  return this->IMPORT_;
}

void Scene::
IMPORT (const IMPORT_sequence& s)
{
  this->IMPORT_ = s;
}

const Scene::EXPORT_sequence& Scene::
EXPORT () const
{
  return this->EXPORT_;
}

Scene::EXPORT_sequence& Scene::
EXPORT ()
{
  return this->EXPORT_;
}

void Scene::
EXPORT (const EXPORT_sequence& s)
{
  this->EXPORT_ = s;
}


// X3D
// 

const X3D::head_optional& X3D::
head () const
{
  return this->head_;
}

X3D::head_optional& X3D::
head ()
{
  return this->head_;
}

void X3D::
head (const head_type& x)
{
  this->head_.set (x);
}

void X3D::
head (const head_optional& x)
{
  this->head_ = x;
}

void X3D::
head (::std::auto_ptr< head_type > x)
{
  this->head_.set (x);
}

const X3D::Scene_type& X3D::
Scene () const
{
  return this->Scene_.get ();
}

X3D::Scene_type& X3D::
Scene ()
{
  return this->Scene_.get ();
}

void X3D::
Scene (const Scene_type& x)
{
  this->Scene_.set (x);
}

void X3D::
Scene (::std::auto_ptr< Scene_type > x)
{
  this->Scene_.set (x);
}

const X3D::version_type& X3D::
version () const
{
  return this->version_.get ();
}

X3D::version_type& X3D::
version ()
{
  return this->version_.get ();
}

void X3D::
version (const version_type& x)
{
  this->version_.set (x);
}

void X3D::
version (::std::auto_ptr< version_type > x)
{
  this->version_.set (x);
}

const X3D::profile_type& X3D::
profile () const
{
  return this->profile_.get ();
}

X3D::profile_type& X3D::
profile ()
{
  return this->profile_.get ();
}

void X3D::
profile (const profile_type& x)
{
  this->profile_.set (x);
}

void X3D::
profile (::std::auto_ptr< profile_type > x)
{
  this->profile_.set (x);
}


// EspduTransform
// 

const EspduTransform::enabled_type& EspduTransform::
enabled () const
{
  return this->enabled_.get ();
}

EspduTransform::enabled_type& EspduTransform::
enabled ()
{
  return this->enabled_.get ();
}

void EspduTransform::
enabled (const enabled_type& x)
{
  this->enabled_.set (x);
}

void EspduTransform::
enabled (::std::auto_ptr< enabled_type > x)
{
  this->enabled_.set (x);
}

const EspduTransform::enabled_type& EspduTransform::
enabled_default_value ()
{
  return enabled_default_value_;
}

const EspduTransform::marking_optional& EspduTransform::
marking () const
{
  return this->marking_;
}

EspduTransform::marking_optional& EspduTransform::
marking ()
{
  return this->marking_;
}

void EspduTransform::
marking (const marking_type& x)
{
  this->marking_.set (x);
}

void EspduTransform::
marking (const marking_optional& x)
{
  this->marking_ = x;
}

void EspduTransform::
marking (::std::auto_ptr< marking_type > x)
{
  this->marking_.set (x);
}

const EspduTransform::siteID_type& EspduTransform::
siteID () const
{
  return this->siteID_.get ();
}

EspduTransform::siteID_type& EspduTransform::
siteID ()
{
  return this->siteID_.get ();
}

void EspduTransform::
siteID (const siteID_type& x)
{
  this->siteID_.set (x);
}

void EspduTransform::
siteID (::std::auto_ptr< siteID_type > x)
{
  this->siteID_.set (x);
}

const EspduTransform::siteID_type& EspduTransform::
siteID_default_value ()
{
  return siteID_default_value_;
}

const EspduTransform::applicationID_type& EspduTransform::
applicationID () const
{
  return this->applicationID_.get ();
}

EspduTransform::applicationID_type& EspduTransform::
applicationID ()
{
  return this->applicationID_.get ();
}

void EspduTransform::
applicationID (const applicationID_type& x)
{
  this->applicationID_.set (x);
}

void EspduTransform::
applicationID (::std::auto_ptr< applicationID_type > x)
{
  this->applicationID_.set (x);
}

const EspduTransform::applicationID_type& EspduTransform::
applicationID_default_value ()
{
  return applicationID_default_value_;
}

const EspduTransform::entityID_type& EspduTransform::
entityID () const
{
  return this->entityID_.get ();
}

EspduTransform::entityID_type& EspduTransform::
entityID ()
{
  return this->entityID_.get ();
}

void EspduTransform::
entityID (const entityID_type& x)
{
  this->entityID_.set (x);
}

void EspduTransform::
entityID (::std::auto_ptr< entityID_type > x)
{
  this->entityID_.set (x);
}

const EspduTransform::entityID_type& EspduTransform::
entityID_default_value ()
{
  return entityID_default_value_;
}

const EspduTransform::forceID_type& EspduTransform::
forceID () const
{
  return this->forceID_.get ();
}

EspduTransform::forceID_type& EspduTransform::
forceID ()
{
  return this->forceID_.get ();
}

void EspduTransform::
forceID (const forceID_type& x)
{
  this->forceID_.set (x);
}

void EspduTransform::
forceID (::std::auto_ptr< forceID_type > x)
{
  this->forceID_.set (x);
}

const EspduTransform::forceID_type& EspduTransform::
forceID_default_value ()
{
  return forceID_default_value_;
}

const EspduTransform::entityKind_type& EspduTransform::
entityKind () const
{
  return this->entityKind_.get ();
}

EspduTransform::entityKind_type& EspduTransform::
entityKind ()
{
  return this->entityKind_.get ();
}

void EspduTransform::
entityKind (const entityKind_type& x)
{
  this->entityKind_.set (x);
}

void EspduTransform::
entityKind (::std::auto_ptr< entityKind_type > x)
{
  this->entityKind_.set (x);
}

const EspduTransform::entityKind_type& EspduTransform::
entityKind_default_value ()
{
  return entityKind_default_value_;
}

const EspduTransform::entityDomain_type& EspduTransform::
entityDomain () const
{
  return this->entityDomain_.get ();
}

EspduTransform::entityDomain_type& EspduTransform::
entityDomain ()
{
  return this->entityDomain_.get ();
}

void EspduTransform::
entityDomain (const entityDomain_type& x)
{
  this->entityDomain_.set (x);
}

void EspduTransform::
entityDomain (::std::auto_ptr< entityDomain_type > x)
{
  this->entityDomain_.set (x);
}

const EspduTransform::entityDomain_type& EspduTransform::
entityDomain_default_value ()
{
  return entityDomain_default_value_;
}

const EspduTransform::entityCountry_type& EspduTransform::
entityCountry () const
{
  return this->entityCountry_.get ();
}

EspduTransform::entityCountry_type& EspduTransform::
entityCountry ()
{
  return this->entityCountry_.get ();
}

void EspduTransform::
entityCountry (const entityCountry_type& x)
{
  this->entityCountry_.set (x);
}

void EspduTransform::
entityCountry (::std::auto_ptr< entityCountry_type > x)
{
  this->entityCountry_.set (x);
}

const EspduTransform::entityCountry_type& EspduTransform::
entityCountry_default_value ()
{
  return entityCountry_default_value_;
}

const EspduTransform::entityCategory_type& EspduTransform::
entityCategory () const
{
  return this->entityCategory_.get ();
}

EspduTransform::entityCategory_type& EspduTransform::
entityCategory ()
{
  return this->entityCategory_.get ();
}

void EspduTransform::
entityCategory (const entityCategory_type& x)
{
  this->entityCategory_.set (x);
}

void EspduTransform::
entityCategory (::std::auto_ptr< entityCategory_type > x)
{
  this->entityCategory_.set (x);
}

const EspduTransform::entityCategory_type& EspduTransform::
entityCategory_default_value ()
{
  return entityCategory_default_value_;
}

const EspduTransform::entitySubCategory_type& EspduTransform::
entitySubCategory () const
{
  return this->entitySubCategory_.get ();
}

EspduTransform::entitySubCategory_type& EspduTransform::
entitySubCategory ()
{
  return this->entitySubCategory_.get ();
}

void EspduTransform::
entitySubCategory (const entitySubCategory_type& x)
{
  this->entitySubCategory_.set (x);
}

void EspduTransform::
entitySubCategory (::std::auto_ptr< entitySubCategory_type > x)
{
  this->entitySubCategory_.set (x);
}

const EspduTransform::entitySubCategory_type& EspduTransform::
entitySubCategory_default_value ()
{
  return entitySubCategory_default_value_;
}

const EspduTransform::entitySpecific_type& EspduTransform::
entitySpecific () const
{
  return this->entitySpecific_.get ();
}

EspduTransform::entitySpecific_type& EspduTransform::
entitySpecific ()
{
  return this->entitySpecific_.get ();
}

void EspduTransform::
entitySpecific (const entitySpecific_type& x)
{
  this->entitySpecific_.set (x);
}

void EspduTransform::
entitySpecific (::std::auto_ptr< entitySpecific_type > x)
{
  this->entitySpecific_.set (x);
}

const EspduTransform::entitySpecific_type& EspduTransform::
entitySpecific_default_value ()
{
  return entitySpecific_default_value_;
}

const EspduTransform::entityExtra_type& EspduTransform::
entityExtra () const
{
  return this->entityExtra_.get ();
}

EspduTransform::entityExtra_type& EspduTransform::
entityExtra ()
{
  return this->entityExtra_.get ();
}

void EspduTransform::
entityExtra (const entityExtra_type& x)
{
  this->entityExtra_.set (x);
}

void EspduTransform::
entityExtra (::std::auto_ptr< entityExtra_type > x)
{
  this->entityExtra_.set (x);
}

const EspduTransform::entityExtra_type& EspduTransform::
entityExtra_default_value ()
{
  return entityExtra_default_value_;
}

const EspduTransform::readInterval_type& EspduTransform::
readInterval () const
{
  return this->readInterval_.get ();
}

EspduTransform::readInterval_type& EspduTransform::
readInterval ()
{
  return this->readInterval_.get ();
}

void EspduTransform::
readInterval (const readInterval_type& x)
{
  this->readInterval_.set (x);
}

void EspduTransform::
readInterval (::std::auto_ptr< readInterval_type > x)
{
  this->readInterval_.set (x);
}

const EspduTransform::readInterval_type& EspduTransform::
readInterval_default_value ()
{
  return readInterval_default_value_;
}

const EspduTransform::writeInterval_type& EspduTransform::
writeInterval () const
{
  return this->writeInterval_.get ();
}

EspduTransform::writeInterval_type& EspduTransform::
writeInterval ()
{
  return this->writeInterval_.get ();
}

void EspduTransform::
writeInterval (const writeInterval_type& x)
{
  this->writeInterval_.set (x);
}

void EspduTransform::
writeInterval (::std::auto_ptr< writeInterval_type > x)
{
  this->writeInterval_.set (x);
}

const EspduTransform::writeInterval_type& EspduTransform::
writeInterval_default_value ()
{
  return writeInterval_default_value_;
}

const EspduTransform::networkMode_type& EspduTransform::
networkMode () const
{
  return this->networkMode_.get ();
}

EspduTransform::networkMode_type& EspduTransform::
networkMode ()
{
  return this->networkMode_.get ();
}

void EspduTransform::
networkMode (const networkMode_type& x)
{
  this->networkMode_.set (x);
}

void EspduTransform::
networkMode (::std::auto_ptr< networkMode_type > x)
{
  this->networkMode_.set (x);
}

const EspduTransform::networkMode_type& EspduTransform::
networkMode_default_value ()
{
  return networkMode_default_value_;
}

const EspduTransform::translation_type& EspduTransform::
translation () const
{
  return this->translation_.get ();
}

EspduTransform::translation_type& EspduTransform::
translation ()
{
  return this->translation_.get ();
}

void EspduTransform::
translation (const translation_type& x)
{
  this->translation_.set (x);
}

void EspduTransform::
translation (::std::auto_ptr< translation_type > x)
{
  this->translation_.set (x);
}

const EspduTransform::translation_type& EspduTransform::
translation_default_value ()
{
  return translation_default_value_;
}

const EspduTransform::rotation_type& EspduTransform::
rotation () const
{
  return this->rotation_.get ();
}

EspduTransform::rotation_type& EspduTransform::
rotation ()
{
  return this->rotation_.get ();
}

void EspduTransform::
rotation (const rotation_type& x)
{
  this->rotation_.set (x);
}

void EspduTransform::
rotation (::std::auto_ptr< rotation_type > x)
{
  this->rotation_.set (x);
}

const EspduTransform::rotation_type& EspduTransform::
rotation_default_value ()
{
  return rotation_default_value_;
}

const EspduTransform::scale_type& EspduTransform::
scale () const
{
  return this->scale_.get ();
}

EspduTransform::scale_type& EspduTransform::
scale ()
{
  return this->scale_.get ();
}

void EspduTransform::
scale (const scale_type& x)
{
  this->scale_.set (x);
}

void EspduTransform::
scale (::std::auto_ptr< scale_type > x)
{
  this->scale_.set (x);
}

const EspduTransform::scale_type& EspduTransform::
scale_default_value ()
{
  return scale_default_value_;
}

const EspduTransform::scaleOrientation_type& EspduTransform::
scaleOrientation () const
{
  return this->scaleOrientation_.get ();
}

EspduTransform::scaleOrientation_type& EspduTransform::
scaleOrientation ()
{
  return this->scaleOrientation_.get ();
}

void EspduTransform::
scaleOrientation (const scaleOrientation_type& x)
{
  this->scaleOrientation_.set (x);
}

void EspduTransform::
scaleOrientation (::std::auto_ptr< scaleOrientation_type > x)
{
  this->scaleOrientation_.set (x);
}

const EspduTransform::scaleOrientation_type& EspduTransform::
scaleOrientation_default_value ()
{
  return scaleOrientation_default_value_;
}

const EspduTransform::center_type& EspduTransform::
center () const
{
  return this->center_.get ();
}

EspduTransform::center_type& EspduTransform::
center ()
{
  return this->center_.get ();
}

void EspduTransform::
center (const center_type& x)
{
  this->center_.set (x);
}

void EspduTransform::
center (::std::auto_ptr< center_type > x)
{
  this->center_.set (x);
}

const EspduTransform::center_type& EspduTransform::
center_default_value ()
{
  return center_default_value_;
}

const EspduTransform::address_type& EspduTransform::
address () const
{
  return this->address_.get ();
}

EspduTransform::address_type& EspduTransform::
address ()
{
  return this->address_.get ();
}

void EspduTransform::
address (const address_type& x)
{
  this->address_.set (x);
}

void EspduTransform::
address (::std::auto_ptr< address_type > x)
{
  this->address_.set (x);
}

const EspduTransform::address_type& EspduTransform::
address_default_value ()
{
  return address_default_value_;
}

const EspduTransform::port_type& EspduTransform::
port () const
{
  return this->port_.get ();
}

EspduTransform::port_type& EspduTransform::
port ()
{
  return this->port_.get ();
}

void EspduTransform::
port (const port_type& x)
{
  this->port_.set (x);
}

void EspduTransform::
port (::std::auto_ptr< port_type > x)
{
  this->port_.set (x);
}

const EspduTransform::port_type& EspduTransform::
port_default_value ()
{
  return port_default_value_;
}

const EspduTransform::multicastRelayHost_optional& EspduTransform::
multicastRelayHost () const
{
  return this->multicastRelayHost_;
}

EspduTransform::multicastRelayHost_optional& EspduTransform::
multicastRelayHost ()
{
  return this->multicastRelayHost_;
}

void EspduTransform::
multicastRelayHost (const multicastRelayHost_type& x)
{
  this->multicastRelayHost_.set (x);
}

void EspduTransform::
multicastRelayHost (const multicastRelayHost_optional& x)
{
  this->multicastRelayHost_ = x;
}

void EspduTransform::
multicastRelayHost (::std::auto_ptr< multicastRelayHost_type > x)
{
  this->multicastRelayHost_.set (x);
}

const EspduTransform::multicastRelayPort_type& EspduTransform::
multicastRelayPort () const
{
  return this->multicastRelayPort_.get ();
}

EspduTransform::multicastRelayPort_type& EspduTransform::
multicastRelayPort ()
{
  return this->multicastRelayPort_.get ();
}

void EspduTransform::
multicastRelayPort (const multicastRelayPort_type& x)
{
  this->multicastRelayPort_.set (x);
}

void EspduTransform::
multicastRelayPort (::std::auto_ptr< multicastRelayPort_type > x)
{
  this->multicastRelayPort_.set (x);
}

const EspduTransform::multicastRelayPort_type& EspduTransform::
multicastRelayPort_default_value ()
{
  return multicastRelayPort_default_value_;
}

const EspduTransform::rtpHeaderExpected_type& EspduTransform::
rtpHeaderExpected () const
{
  return this->rtpHeaderExpected_.get ();
}

EspduTransform::rtpHeaderExpected_type& EspduTransform::
rtpHeaderExpected ()
{
  return this->rtpHeaderExpected_.get ();
}

void EspduTransform::
rtpHeaderExpected (const rtpHeaderExpected_type& x)
{
  this->rtpHeaderExpected_.set (x);
}

void EspduTransform::
rtpHeaderExpected (::std::auto_ptr< rtpHeaderExpected_type > x)
{
  this->rtpHeaderExpected_.set (x);
}

const EspduTransform::rtpHeaderExpected_type& EspduTransform::
rtpHeaderExpected_default_value ()
{
  return rtpHeaderExpected_default_value_;
}

const EspduTransform::deadReckoning_type& EspduTransform::
deadReckoning () const
{
  return this->deadReckoning_.get ();
}

EspduTransform::deadReckoning_type& EspduTransform::
deadReckoning ()
{
  return this->deadReckoning_.get ();
}

void EspduTransform::
deadReckoning (const deadReckoning_type& x)
{
  this->deadReckoning_.set (x);
}

void EspduTransform::
deadReckoning (::std::auto_ptr< deadReckoning_type > x)
{
  this->deadReckoning_.set (x);
}

const EspduTransform::deadReckoning_type& EspduTransform::
deadReckoning_default_value ()
{
  return deadReckoning_default_value_;
}

const EspduTransform::linearVelocity_type& EspduTransform::
linearVelocity () const
{
  return this->linearVelocity_.get ();
}

EspduTransform::linearVelocity_type& EspduTransform::
linearVelocity ()
{
  return this->linearVelocity_.get ();
}

void EspduTransform::
linearVelocity (const linearVelocity_type& x)
{
  this->linearVelocity_.set (x);
}

void EspduTransform::
linearVelocity (::std::auto_ptr< linearVelocity_type > x)
{
  this->linearVelocity_.set (x);
}

const EspduTransform::linearVelocity_type& EspduTransform::
linearVelocity_default_value ()
{
  return linearVelocity_default_value_;
}

const EspduTransform::linearAcceleration_type& EspduTransform::
linearAcceleration () const
{
  return this->linearAcceleration_.get ();
}

EspduTransform::linearAcceleration_type& EspduTransform::
linearAcceleration ()
{
  return this->linearAcceleration_.get ();
}

void EspduTransform::
linearAcceleration (const linearAcceleration_type& x)
{
  this->linearAcceleration_.set (x);
}

void EspduTransform::
linearAcceleration (::std::auto_ptr< linearAcceleration_type > x)
{
  this->linearAcceleration_.set (x);
}

const EspduTransform::linearAcceleration_type& EspduTransform::
linearAcceleration_default_value ()
{
  return linearAcceleration_default_value_;
}

const EspduTransform::fired1_type& EspduTransform::
fired1 () const
{
  return this->fired1_.get ();
}

EspduTransform::fired1_type& EspduTransform::
fired1 ()
{
  return this->fired1_.get ();
}

void EspduTransform::
fired1 (const fired1_type& x)
{
  this->fired1_.set (x);
}

void EspduTransform::
fired1 (::std::auto_ptr< fired1_type > x)
{
  this->fired1_.set (x);
}

const EspduTransform::fired1_type& EspduTransform::
fired1_default_value ()
{
  return fired1_default_value_;
}

const EspduTransform::fired2_type& EspduTransform::
fired2 () const
{
  return this->fired2_.get ();
}

EspduTransform::fired2_type& EspduTransform::
fired2 ()
{
  return this->fired2_.get ();
}

void EspduTransform::
fired2 (const fired2_type& x)
{
  this->fired2_.set (x);
}

void EspduTransform::
fired2 (::std::auto_ptr< fired2_type > x)
{
  this->fired2_.set (x);
}

const EspduTransform::fired2_type& EspduTransform::
fired2_default_value ()
{
  return fired2_default_value_;
}

const EspduTransform::collisionType_type& EspduTransform::
collisionType () const
{
  return this->collisionType_.get ();
}

EspduTransform::collisionType_type& EspduTransform::
collisionType ()
{
  return this->collisionType_.get ();
}

void EspduTransform::
collisionType (const collisionType_type& x)
{
  this->collisionType_.set (x);
}

void EspduTransform::
collisionType (::std::auto_ptr< collisionType_type > x)
{
  this->collisionType_.set (x);
}

const EspduTransform::collisionType_type& EspduTransform::
collisionType_default_value ()
{
  return collisionType_default_value_;
}

const EspduTransform::detonationLocation_type& EspduTransform::
detonationLocation () const
{
  return this->detonationLocation_.get ();
}

EspduTransform::detonationLocation_type& EspduTransform::
detonationLocation ()
{
  return this->detonationLocation_.get ();
}

void EspduTransform::
detonationLocation (const detonationLocation_type& x)
{
  this->detonationLocation_.set (x);
}

void EspduTransform::
detonationLocation (::std::auto_ptr< detonationLocation_type > x)
{
  this->detonationLocation_.set (x);
}

const EspduTransform::detonationLocation_type& EspduTransform::
detonationLocation_default_value ()
{
  return detonationLocation_default_value_;
}

const EspduTransform::detonationRelativeLocation_type& EspduTransform::
detonationRelativeLocation () const
{
  return this->detonationRelativeLocation_.get ();
}

EspduTransform::detonationRelativeLocation_type& EspduTransform::
detonationRelativeLocation ()
{
  return this->detonationRelativeLocation_.get ();
}

void EspduTransform::
detonationRelativeLocation (const detonationRelativeLocation_type& x)
{
  this->detonationRelativeLocation_.set (x);
}

void EspduTransform::
detonationRelativeLocation (::std::auto_ptr< detonationRelativeLocation_type > x)
{
  this->detonationRelativeLocation_.set (x);
}

const EspduTransform::detonationRelativeLocation_type& EspduTransform::
detonationRelativeLocation_default_value ()
{
  return detonationRelativeLocation_default_value_;
}

const EspduTransform::detonationResult_type& EspduTransform::
detonationResult () const
{
  return this->detonationResult_.get ();
}

EspduTransform::detonationResult_type& EspduTransform::
detonationResult ()
{
  return this->detonationResult_.get ();
}

void EspduTransform::
detonationResult (const detonationResult_type& x)
{
  this->detonationResult_.set (x);
}

void EspduTransform::
detonationResult (::std::auto_ptr< detonationResult_type > x)
{
  this->detonationResult_.set (x);
}

const EspduTransform::detonationResult_type& EspduTransform::
detonationResult_default_value ()
{
  return detonationResult_default_value_;
}

const EspduTransform::eventApplicationID_type& EspduTransform::
eventApplicationID () const
{
  return this->eventApplicationID_.get ();
}

EspduTransform::eventApplicationID_type& EspduTransform::
eventApplicationID ()
{
  return this->eventApplicationID_.get ();
}

void EspduTransform::
eventApplicationID (const eventApplicationID_type& x)
{
  this->eventApplicationID_.set (x);
}

void EspduTransform::
eventApplicationID (::std::auto_ptr< eventApplicationID_type > x)
{
  this->eventApplicationID_.set (x);
}

const EspduTransform::eventApplicationID_type& EspduTransform::
eventApplicationID_default_value ()
{
  return eventApplicationID_default_value_;
}

const EspduTransform::eventEntityID_type& EspduTransform::
eventEntityID () const
{
  return this->eventEntityID_.get ();
}

EspduTransform::eventEntityID_type& EspduTransform::
eventEntityID ()
{
  return this->eventEntityID_.get ();
}

void EspduTransform::
eventEntityID (const eventEntityID_type& x)
{
  this->eventEntityID_.set (x);
}

void EspduTransform::
eventEntityID (::std::auto_ptr< eventEntityID_type > x)
{
  this->eventEntityID_.set (x);
}

const EspduTransform::eventEntityID_type& EspduTransform::
eventEntityID_default_value ()
{
  return eventEntityID_default_value_;
}

const EspduTransform::eventNumber_type& EspduTransform::
eventNumber () const
{
  return this->eventNumber_.get ();
}

EspduTransform::eventNumber_type& EspduTransform::
eventNumber ()
{
  return this->eventNumber_.get ();
}

void EspduTransform::
eventNumber (const eventNumber_type& x)
{
  this->eventNumber_.set (x);
}

void EspduTransform::
eventNumber (::std::auto_ptr< eventNumber_type > x)
{
  this->eventNumber_.set (x);
}

const EspduTransform::eventNumber_type& EspduTransform::
eventNumber_default_value ()
{
  return eventNumber_default_value_;
}

const EspduTransform::eventSiteID_type& EspduTransform::
eventSiteID () const
{
  return this->eventSiteID_.get ();
}

EspduTransform::eventSiteID_type& EspduTransform::
eventSiteID ()
{
  return this->eventSiteID_.get ();
}

void EspduTransform::
eventSiteID (const eventSiteID_type& x)
{
  this->eventSiteID_.set (x);
}

void EspduTransform::
eventSiteID (::std::auto_ptr< eventSiteID_type > x)
{
  this->eventSiteID_.set (x);
}

const EspduTransform::eventSiteID_type& EspduTransform::
eventSiteID_default_value ()
{
  return eventSiteID_default_value_;
}

const EspduTransform::munitionStartPoint_type& EspduTransform::
munitionStartPoint () const
{
  return this->munitionStartPoint_.get ();
}

EspduTransform::munitionStartPoint_type& EspduTransform::
munitionStartPoint ()
{
  return this->munitionStartPoint_.get ();
}

void EspduTransform::
munitionStartPoint (const munitionStartPoint_type& x)
{
  this->munitionStartPoint_.set (x);
}

void EspduTransform::
munitionStartPoint (::std::auto_ptr< munitionStartPoint_type > x)
{
  this->munitionStartPoint_.set (x);
}

const EspduTransform::munitionStartPoint_type& EspduTransform::
munitionStartPoint_default_value ()
{
  return munitionStartPoint_default_value_;
}

const EspduTransform::munitionEndPoint_type& EspduTransform::
munitionEndPoint () const
{
  return this->munitionEndPoint_.get ();
}

EspduTransform::munitionEndPoint_type& EspduTransform::
munitionEndPoint ()
{
  return this->munitionEndPoint_.get ();
}

void EspduTransform::
munitionEndPoint (const munitionEndPoint_type& x)
{
  this->munitionEndPoint_.set (x);
}

void EspduTransform::
munitionEndPoint (::std::auto_ptr< munitionEndPoint_type > x)
{
  this->munitionEndPoint_.set (x);
}

const EspduTransform::munitionEndPoint_type& EspduTransform::
munitionEndPoint_default_value ()
{
  return munitionEndPoint_default_value_;
}

const EspduTransform::munitionSiteID_type& EspduTransform::
munitionSiteID () const
{
  return this->munitionSiteID_.get ();
}

EspduTransform::munitionSiteID_type& EspduTransform::
munitionSiteID ()
{
  return this->munitionSiteID_.get ();
}

void EspduTransform::
munitionSiteID (const munitionSiteID_type& x)
{
  this->munitionSiteID_.set (x);
}

void EspduTransform::
munitionSiteID (::std::auto_ptr< munitionSiteID_type > x)
{
  this->munitionSiteID_.set (x);
}

const EspduTransform::munitionSiteID_type& EspduTransform::
munitionSiteID_default_value ()
{
  return munitionSiteID_default_value_;
}

const EspduTransform::munitionApplicationID_type& EspduTransform::
munitionApplicationID () const
{
  return this->munitionApplicationID_.get ();
}

EspduTransform::munitionApplicationID_type& EspduTransform::
munitionApplicationID ()
{
  return this->munitionApplicationID_.get ();
}

void EspduTransform::
munitionApplicationID (const munitionApplicationID_type& x)
{
  this->munitionApplicationID_.set (x);
}

void EspduTransform::
munitionApplicationID (::std::auto_ptr< munitionApplicationID_type > x)
{
  this->munitionApplicationID_.set (x);
}

const EspduTransform::munitionApplicationID_type& EspduTransform::
munitionApplicationID_default_value ()
{
  return munitionApplicationID_default_value_;
}

const EspduTransform::munitionEntityID_type& EspduTransform::
munitionEntityID () const
{
  return this->munitionEntityID_.get ();
}

EspduTransform::munitionEntityID_type& EspduTransform::
munitionEntityID ()
{
  return this->munitionEntityID_.get ();
}

void EspduTransform::
munitionEntityID (const munitionEntityID_type& x)
{
  this->munitionEntityID_.set (x);
}

void EspduTransform::
munitionEntityID (::std::auto_ptr< munitionEntityID_type > x)
{
  this->munitionEntityID_.set (x);
}

const EspduTransform::munitionEntityID_type& EspduTransform::
munitionEntityID_default_value ()
{
  return munitionEntityID_default_value_;
}

const EspduTransform::fireMissionIndex_type& EspduTransform::
fireMissionIndex () const
{
  return this->fireMissionIndex_.get ();
}

EspduTransform::fireMissionIndex_type& EspduTransform::
fireMissionIndex ()
{
  return this->fireMissionIndex_.get ();
}

void EspduTransform::
fireMissionIndex (const fireMissionIndex_type& x)
{
  this->fireMissionIndex_.set (x);
}

void EspduTransform::
fireMissionIndex (::std::auto_ptr< fireMissionIndex_type > x)
{
  this->fireMissionIndex_.set (x);
}

const EspduTransform::fireMissionIndex_type& EspduTransform::
fireMissionIndex_default_value ()
{
  return fireMissionIndex_default_value_;
}

const EspduTransform::warhead_type& EspduTransform::
warhead () const
{
  return this->warhead_.get ();
}

EspduTransform::warhead_type& EspduTransform::
warhead ()
{
  return this->warhead_.get ();
}

void EspduTransform::
warhead (const warhead_type& x)
{
  this->warhead_.set (x);
}

void EspduTransform::
warhead (::std::auto_ptr< warhead_type > x)
{
  this->warhead_.set (x);
}

const EspduTransform::warhead_type& EspduTransform::
warhead_default_value ()
{
  return warhead_default_value_;
}

const EspduTransform::fuse_type& EspduTransform::
fuse () const
{
  return this->fuse_.get ();
}

EspduTransform::fuse_type& EspduTransform::
fuse ()
{
  return this->fuse_.get ();
}

void EspduTransform::
fuse (const fuse_type& x)
{
  this->fuse_.set (x);
}

void EspduTransform::
fuse (::std::auto_ptr< fuse_type > x)
{
  this->fuse_.set (x);
}

const EspduTransform::fuse_type& EspduTransform::
fuse_default_value ()
{
  return fuse_default_value_;
}

const EspduTransform::munitionQuantity_type& EspduTransform::
munitionQuantity () const
{
  return this->munitionQuantity_.get ();
}

EspduTransform::munitionQuantity_type& EspduTransform::
munitionQuantity ()
{
  return this->munitionQuantity_.get ();
}

void EspduTransform::
munitionQuantity (const munitionQuantity_type& x)
{
  this->munitionQuantity_.set (x);
}

void EspduTransform::
munitionQuantity (::std::auto_ptr< munitionQuantity_type > x)
{
  this->munitionQuantity_.set (x);
}

const EspduTransform::munitionQuantity_type& EspduTransform::
munitionQuantity_default_value ()
{
  return munitionQuantity_default_value_;
}

const EspduTransform::firingRate_type& EspduTransform::
firingRate () const
{
  return this->firingRate_.get ();
}

EspduTransform::firingRate_type& EspduTransform::
firingRate ()
{
  return this->firingRate_.get ();
}

void EspduTransform::
firingRate (const firingRate_type& x)
{
  this->firingRate_.set (x);
}

void EspduTransform::
firingRate (::std::auto_ptr< firingRate_type > x)
{
  this->firingRate_.set (x);
}

const EspduTransform::firingRate_type& EspduTransform::
firingRate_default_value ()
{
  return firingRate_default_value_;
}

const EspduTransform::firingRange_type& EspduTransform::
firingRange () const
{
  return this->firingRange_.get ();
}

EspduTransform::firingRange_type& EspduTransform::
firingRange ()
{
  return this->firingRange_.get ();
}

void EspduTransform::
firingRange (const firingRange_type& x)
{
  this->firingRange_.set (x);
}

void EspduTransform::
firingRange (::std::auto_ptr< firingRange_type > x)
{
  this->firingRange_.set (x);
}

const EspduTransform::firingRange_type& EspduTransform::
firingRange_default_value ()
{
  return firingRange_default_value_;
}

const EspduTransform::articulationParameterCount_type& EspduTransform::
articulationParameterCount () const
{
  return this->articulationParameterCount_.get ();
}

EspduTransform::articulationParameterCount_type& EspduTransform::
articulationParameterCount ()
{
  return this->articulationParameterCount_.get ();
}

void EspduTransform::
articulationParameterCount (const articulationParameterCount_type& x)
{
  this->articulationParameterCount_.set (x);
}

void EspduTransform::
articulationParameterCount (::std::auto_ptr< articulationParameterCount_type > x)
{
  this->articulationParameterCount_.set (x);
}

const EspduTransform::articulationParameterCount_type& EspduTransform::
articulationParameterCount_default_value ()
{
  return articulationParameterCount_default_value_;
}

const EspduTransform::articulationParameterDesignatorArray_optional& EspduTransform::
articulationParameterDesignatorArray () const
{
  return this->articulationParameterDesignatorArray_;
}

EspduTransform::articulationParameterDesignatorArray_optional& EspduTransform::
articulationParameterDesignatorArray ()
{
  return this->articulationParameterDesignatorArray_;
}

void EspduTransform::
articulationParameterDesignatorArray (const articulationParameterDesignatorArray_type& x)
{
  this->articulationParameterDesignatorArray_.set (x);
}

void EspduTransform::
articulationParameterDesignatorArray (const articulationParameterDesignatorArray_optional& x)
{
  this->articulationParameterDesignatorArray_ = x;
}

void EspduTransform::
articulationParameterDesignatorArray (::std::auto_ptr< articulationParameterDesignatorArray_type > x)
{
  this->articulationParameterDesignatorArray_.set (x);
}

const EspduTransform::articulationParameterChangeIndicatorArray_optional& EspduTransform::
articulationParameterChangeIndicatorArray () const
{
  return this->articulationParameterChangeIndicatorArray_;
}

EspduTransform::articulationParameterChangeIndicatorArray_optional& EspduTransform::
articulationParameterChangeIndicatorArray ()
{
  return this->articulationParameterChangeIndicatorArray_;
}

void EspduTransform::
articulationParameterChangeIndicatorArray (const articulationParameterChangeIndicatorArray_type& x)
{
  this->articulationParameterChangeIndicatorArray_.set (x);
}

void EspduTransform::
articulationParameterChangeIndicatorArray (const articulationParameterChangeIndicatorArray_optional& x)
{
  this->articulationParameterChangeIndicatorArray_ = x;
}

void EspduTransform::
articulationParameterChangeIndicatorArray (::std::auto_ptr< articulationParameterChangeIndicatorArray_type > x)
{
  this->articulationParameterChangeIndicatorArray_.set (x);
}

const EspduTransform::articulationParameterIdPartAttachedToArray_optional& EspduTransform::
articulationParameterIdPartAttachedToArray () const
{
  return this->articulationParameterIdPartAttachedToArray_;
}

EspduTransform::articulationParameterIdPartAttachedToArray_optional& EspduTransform::
articulationParameterIdPartAttachedToArray ()
{
  return this->articulationParameterIdPartAttachedToArray_;
}

void EspduTransform::
articulationParameterIdPartAttachedToArray (const articulationParameterIdPartAttachedToArray_type& x)
{
  this->articulationParameterIdPartAttachedToArray_.set (x);
}

void EspduTransform::
articulationParameterIdPartAttachedToArray (const articulationParameterIdPartAttachedToArray_optional& x)
{
  this->articulationParameterIdPartAttachedToArray_ = x;
}

void EspduTransform::
articulationParameterIdPartAttachedToArray (::std::auto_ptr< articulationParameterIdPartAttachedToArray_type > x)
{
  this->articulationParameterIdPartAttachedToArray_.set (x);
}

const EspduTransform::articulationParameterTypeArray_optional& EspduTransform::
articulationParameterTypeArray () const
{
  return this->articulationParameterTypeArray_;
}

EspduTransform::articulationParameterTypeArray_optional& EspduTransform::
articulationParameterTypeArray ()
{
  return this->articulationParameterTypeArray_;
}

void EspduTransform::
articulationParameterTypeArray (const articulationParameterTypeArray_type& x)
{
  this->articulationParameterTypeArray_.set (x);
}

void EspduTransform::
articulationParameterTypeArray (const articulationParameterTypeArray_optional& x)
{
  this->articulationParameterTypeArray_ = x;
}

void EspduTransform::
articulationParameterTypeArray (::std::auto_ptr< articulationParameterTypeArray_type > x)
{
  this->articulationParameterTypeArray_.set (x);
}

const EspduTransform::articulationParameterArray_optional& EspduTransform::
articulationParameterArray () const
{
  return this->articulationParameterArray_;
}

EspduTransform::articulationParameterArray_optional& EspduTransform::
articulationParameterArray ()
{
  return this->articulationParameterArray_;
}

void EspduTransform::
articulationParameterArray (const articulationParameterArray_type& x)
{
  this->articulationParameterArray_.set (x);
}

void EspduTransform::
articulationParameterArray (const articulationParameterArray_optional& x)
{
  this->articulationParameterArray_ = x;
}

void EspduTransform::
articulationParameterArray (::std::auto_ptr< articulationParameterArray_type > x)
{
  this->articulationParameterArray_.set (x);
}


// ReceiverPdu
// 

const ReceiverPdu::enabled_type& ReceiverPdu::
enabled () const
{
  return this->enabled_.get ();
}

ReceiverPdu::enabled_type& ReceiverPdu::
enabled ()
{
  return this->enabled_.get ();
}

void ReceiverPdu::
enabled (const enabled_type& x)
{
  this->enabled_.set (x);
}

void ReceiverPdu::
enabled (::std::auto_ptr< enabled_type > x)
{
  this->enabled_.set (x);
}

const ReceiverPdu::enabled_type& ReceiverPdu::
enabled_default_value ()
{
  return enabled_default_value_;
}

const ReceiverPdu::whichGeometry_type& ReceiverPdu::
whichGeometry () const
{
  return this->whichGeometry_.get ();
}

ReceiverPdu::whichGeometry_type& ReceiverPdu::
whichGeometry ()
{
  return this->whichGeometry_.get ();
}

void ReceiverPdu::
whichGeometry (const whichGeometry_type& x)
{
  this->whichGeometry_.set (x);
}

void ReceiverPdu::
whichGeometry (::std::auto_ptr< whichGeometry_type > x)
{
  this->whichGeometry_.set (x);
}

const ReceiverPdu::whichGeometry_type& ReceiverPdu::
whichGeometry_default_value ()
{
  return whichGeometry_default_value_;
}

const ReceiverPdu::readInterval_type& ReceiverPdu::
readInterval () const
{
  return this->readInterval_.get ();
}

ReceiverPdu::readInterval_type& ReceiverPdu::
readInterval ()
{
  return this->readInterval_.get ();
}

void ReceiverPdu::
readInterval (const readInterval_type& x)
{
  this->readInterval_.set (x);
}

void ReceiverPdu::
readInterval (::std::auto_ptr< readInterval_type > x)
{
  this->readInterval_.set (x);
}

const ReceiverPdu::readInterval_type& ReceiverPdu::
readInterval_default_value ()
{
  return readInterval_default_value_;
}

const ReceiverPdu::writeInterval_type& ReceiverPdu::
writeInterval () const
{
  return this->writeInterval_.get ();
}

ReceiverPdu::writeInterval_type& ReceiverPdu::
writeInterval ()
{
  return this->writeInterval_.get ();
}

void ReceiverPdu::
writeInterval (const writeInterval_type& x)
{
  this->writeInterval_.set (x);
}

void ReceiverPdu::
writeInterval (::std::auto_ptr< writeInterval_type > x)
{
  this->writeInterval_.set (x);
}

const ReceiverPdu::writeInterval_type& ReceiverPdu::
writeInterval_default_value ()
{
  return writeInterval_default_value_;
}

const ReceiverPdu::networkMode_type& ReceiverPdu::
networkMode () const
{
  return this->networkMode_.get ();
}

ReceiverPdu::networkMode_type& ReceiverPdu::
networkMode ()
{
  return this->networkMode_.get ();
}

void ReceiverPdu::
networkMode (const networkMode_type& x)
{
  this->networkMode_.set (x);
}

void ReceiverPdu::
networkMode (::std::auto_ptr< networkMode_type > x)
{
  this->networkMode_.set (x);
}

const ReceiverPdu::networkMode_type& ReceiverPdu::
networkMode_default_value ()
{
  return networkMode_default_value_;
}

const ReceiverPdu::siteID_type& ReceiverPdu::
siteID () const
{
  return this->siteID_.get ();
}

ReceiverPdu::siteID_type& ReceiverPdu::
siteID ()
{
  return this->siteID_.get ();
}

void ReceiverPdu::
siteID (const siteID_type& x)
{
  this->siteID_.set (x);
}

void ReceiverPdu::
siteID (::std::auto_ptr< siteID_type > x)
{
  this->siteID_.set (x);
}

const ReceiverPdu::siteID_type& ReceiverPdu::
siteID_default_value ()
{
  return siteID_default_value_;
}

const ReceiverPdu::applicationID_type& ReceiverPdu::
applicationID () const
{
  return this->applicationID_.get ();
}

ReceiverPdu::applicationID_type& ReceiverPdu::
applicationID ()
{
  return this->applicationID_.get ();
}

void ReceiverPdu::
applicationID (const applicationID_type& x)
{
  this->applicationID_.set (x);
}

void ReceiverPdu::
applicationID (::std::auto_ptr< applicationID_type > x)
{
  this->applicationID_.set (x);
}

const ReceiverPdu::applicationID_type& ReceiverPdu::
applicationID_default_value ()
{
  return applicationID_default_value_;
}

const ReceiverPdu::entityID_type& ReceiverPdu::
entityID () const
{
  return this->entityID_.get ();
}

ReceiverPdu::entityID_type& ReceiverPdu::
entityID ()
{
  return this->entityID_.get ();
}

void ReceiverPdu::
entityID (const entityID_type& x)
{
  this->entityID_.set (x);
}

void ReceiverPdu::
entityID (::std::auto_ptr< entityID_type > x)
{
  this->entityID_.set (x);
}

const ReceiverPdu::entityID_type& ReceiverPdu::
entityID_default_value ()
{
  return entityID_default_value_;
}

const ReceiverPdu::address_type& ReceiverPdu::
address () const
{
  return this->address_.get ();
}

ReceiverPdu::address_type& ReceiverPdu::
address ()
{
  return this->address_.get ();
}

void ReceiverPdu::
address (const address_type& x)
{
  this->address_.set (x);
}

void ReceiverPdu::
address (::std::auto_ptr< address_type > x)
{
  this->address_.set (x);
}

const ReceiverPdu::address_type& ReceiverPdu::
address_default_value ()
{
  return address_default_value_;
}

const ReceiverPdu::port_type& ReceiverPdu::
port () const
{
  return this->port_.get ();
}

ReceiverPdu::port_type& ReceiverPdu::
port ()
{
  return this->port_.get ();
}

void ReceiverPdu::
port (const port_type& x)
{
  this->port_.set (x);
}

void ReceiverPdu::
port (::std::auto_ptr< port_type > x)
{
  this->port_.set (x);
}

const ReceiverPdu::port_type& ReceiverPdu::
port_default_value ()
{
  return port_default_value_;
}

const ReceiverPdu::multicastRelayHost_optional& ReceiverPdu::
multicastRelayHost () const
{
  return this->multicastRelayHost_;
}

ReceiverPdu::multicastRelayHost_optional& ReceiverPdu::
multicastRelayHost ()
{
  return this->multicastRelayHost_;
}

void ReceiverPdu::
multicastRelayHost (const multicastRelayHost_type& x)
{
  this->multicastRelayHost_.set (x);
}

void ReceiverPdu::
multicastRelayHost (const multicastRelayHost_optional& x)
{
  this->multicastRelayHost_ = x;
}

void ReceiverPdu::
multicastRelayHost (::std::auto_ptr< multicastRelayHost_type > x)
{
  this->multicastRelayHost_.set (x);
}

const ReceiverPdu::multicastRelayPort_type& ReceiverPdu::
multicastRelayPort () const
{
  return this->multicastRelayPort_.get ();
}

ReceiverPdu::multicastRelayPort_type& ReceiverPdu::
multicastRelayPort ()
{
  return this->multicastRelayPort_.get ();
}

void ReceiverPdu::
multicastRelayPort (const multicastRelayPort_type& x)
{
  this->multicastRelayPort_.set (x);
}

void ReceiverPdu::
multicastRelayPort (::std::auto_ptr< multicastRelayPort_type > x)
{
  this->multicastRelayPort_.set (x);
}

const ReceiverPdu::multicastRelayPort_type& ReceiverPdu::
multicastRelayPort_default_value ()
{
  return multicastRelayPort_default_value_;
}

const ReceiverPdu::rtpHeaderExpected_type& ReceiverPdu::
rtpHeaderExpected () const
{
  return this->rtpHeaderExpected_.get ();
}

ReceiverPdu::rtpHeaderExpected_type& ReceiverPdu::
rtpHeaderExpected ()
{
  return this->rtpHeaderExpected_.get ();
}

void ReceiverPdu::
rtpHeaderExpected (const rtpHeaderExpected_type& x)
{
  this->rtpHeaderExpected_.set (x);
}

void ReceiverPdu::
rtpHeaderExpected (::std::auto_ptr< rtpHeaderExpected_type > x)
{
  this->rtpHeaderExpected_.set (x);
}

const ReceiverPdu::rtpHeaderExpected_type& ReceiverPdu::
rtpHeaderExpected_default_value ()
{
  return rtpHeaderExpected_default_value_;
}

const ReceiverPdu::radioID_type& ReceiverPdu::
radioID () const
{
  return this->radioID_.get ();
}

ReceiverPdu::radioID_type& ReceiverPdu::
radioID ()
{
  return this->radioID_.get ();
}

void ReceiverPdu::
radioID (const radioID_type& x)
{
  this->radioID_.set (x);
}

void ReceiverPdu::
radioID (::std::auto_ptr< radioID_type > x)
{
  this->radioID_.set (x);
}

const ReceiverPdu::radioID_type& ReceiverPdu::
radioID_default_value ()
{
  return radioID_default_value_;
}

const ReceiverPdu::receivedPower_type& ReceiverPdu::
receivedPower () const
{
  return this->receivedPower_.get ();
}

ReceiverPdu::receivedPower_type& ReceiverPdu::
receivedPower ()
{
  return this->receivedPower_.get ();
}

void ReceiverPdu::
receivedPower (const receivedPower_type& x)
{
  this->receivedPower_.set (x);
}

void ReceiverPdu::
receivedPower (::std::auto_ptr< receivedPower_type > x)
{
  this->receivedPower_.set (x);
}

const ReceiverPdu::receivedPower_type& ReceiverPdu::
receivedPower_default_value ()
{
  return receivedPower_default_value_;
}

const ReceiverPdu::receiverState_type& ReceiverPdu::
receiverState () const
{
  return this->receiverState_.get ();
}

ReceiverPdu::receiverState_type& ReceiverPdu::
receiverState ()
{
  return this->receiverState_.get ();
}

void ReceiverPdu::
receiverState (const receiverState_type& x)
{
  this->receiverState_.set (x);
}

void ReceiverPdu::
receiverState (::std::auto_ptr< receiverState_type > x)
{
  this->receiverState_.set (x);
}

const ReceiverPdu::receiverState_type& ReceiverPdu::
receiverState_default_value ()
{
  return receiverState_default_value_;
}

const ReceiverPdu::transmitterSiteID_type& ReceiverPdu::
transmitterSiteID () const
{
  return this->transmitterSiteID_.get ();
}

ReceiverPdu::transmitterSiteID_type& ReceiverPdu::
transmitterSiteID ()
{
  return this->transmitterSiteID_.get ();
}

void ReceiverPdu::
transmitterSiteID (const transmitterSiteID_type& x)
{
  this->transmitterSiteID_.set (x);
}

void ReceiverPdu::
transmitterSiteID (::std::auto_ptr< transmitterSiteID_type > x)
{
  this->transmitterSiteID_.set (x);
}

const ReceiverPdu::transmitterSiteID_type& ReceiverPdu::
transmitterSiteID_default_value ()
{
  return transmitterSiteID_default_value_;
}

const ReceiverPdu::transmitterApplicationID_type& ReceiverPdu::
transmitterApplicationID () const
{
  return this->transmitterApplicationID_.get ();
}

ReceiverPdu::transmitterApplicationID_type& ReceiverPdu::
transmitterApplicationID ()
{
  return this->transmitterApplicationID_.get ();
}

void ReceiverPdu::
transmitterApplicationID (const transmitterApplicationID_type& x)
{
  this->transmitterApplicationID_.set (x);
}

void ReceiverPdu::
transmitterApplicationID (::std::auto_ptr< transmitterApplicationID_type > x)
{
  this->transmitterApplicationID_.set (x);
}

const ReceiverPdu::transmitterApplicationID_type& ReceiverPdu::
transmitterApplicationID_default_value ()
{
  return transmitterApplicationID_default_value_;
}

const ReceiverPdu::transmitterEntityID_type& ReceiverPdu::
transmitterEntityID () const
{
  return this->transmitterEntityID_.get ();
}

ReceiverPdu::transmitterEntityID_type& ReceiverPdu::
transmitterEntityID ()
{
  return this->transmitterEntityID_.get ();
}

void ReceiverPdu::
transmitterEntityID (const transmitterEntityID_type& x)
{
  this->transmitterEntityID_.set (x);
}

void ReceiverPdu::
transmitterEntityID (::std::auto_ptr< transmitterEntityID_type > x)
{
  this->transmitterEntityID_.set (x);
}

const ReceiverPdu::transmitterEntityID_type& ReceiverPdu::
transmitterEntityID_default_value ()
{
  return transmitterEntityID_default_value_;
}

const ReceiverPdu::transmitterRadioID_type& ReceiverPdu::
transmitterRadioID () const
{
  return this->transmitterRadioID_.get ();
}

ReceiverPdu::transmitterRadioID_type& ReceiverPdu::
transmitterRadioID ()
{
  return this->transmitterRadioID_.get ();
}

void ReceiverPdu::
transmitterRadioID (const transmitterRadioID_type& x)
{
  this->transmitterRadioID_.set (x);
}

void ReceiverPdu::
transmitterRadioID (::std::auto_ptr< transmitterRadioID_type > x)
{
  this->transmitterRadioID_.set (x);
}

const ReceiverPdu::transmitterRadioID_type& ReceiverPdu::
transmitterRadioID_default_value ()
{
  return transmitterRadioID_default_value_;
}


// SignalPdu
// 

const SignalPdu::enabled_type& SignalPdu::
enabled () const
{
  return this->enabled_.get ();
}

SignalPdu::enabled_type& SignalPdu::
enabled ()
{
  return this->enabled_.get ();
}

void SignalPdu::
enabled (const enabled_type& x)
{
  this->enabled_.set (x);
}

void SignalPdu::
enabled (::std::auto_ptr< enabled_type > x)
{
  this->enabled_.set (x);
}

const SignalPdu::enabled_type& SignalPdu::
enabled_default_value ()
{
  return enabled_default_value_;
}

const SignalPdu::whichGeometry_type& SignalPdu::
whichGeometry () const
{
  return this->whichGeometry_.get ();
}

SignalPdu::whichGeometry_type& SignalPdu::
whichGeometry ()
{
  return this->whichGeometry_.get ();
}

void SignalPdu::
whichGeometry (const whichGeometry_type& x)
{
  this->whichGeometry_.set (x);
}

void SignalPdu::
whichGeometry (::std::auto_ptr< whichGeometry_type > x)
{
  this->whichGeometry_.set (x);
}

const SignalPdu::whichGeometry_type& SignalPdu::
whichGeometry_default_value ()
{
  return whichGeometry_default_value_;
}

const SignalPdu::readInterval_type& SignalPdu::
readInterval () const
{
  return this->readInterval_.get ();
}

SignalPdu::readInterval_type& SignalPdu::
readInterval ()
{
  return this->readInterval_.get ();
}

void SignalPdu::
readInterval (const readInterval_type& x)
{
  this->readInterval_.set (x);
}

void SignalPdu::
readInterval (::std::auto_ptr< readInterval_type > x)
{
  this->readInterval_.set (x);
}

const SignalPdu::readInterval_type& SignalPdu::
readInterval_default_value ()
{
  return readInterval_default_value_;
}

const SignalPdu::writeInterval_type& SignalPdu::
writeInterval () const
{
  return this->writeInterval_.get ();
}

SignalPdu::writeInterval_type& SignalPdu::
writeInterval ()
{
  return this->writeInterval_.get ();
}

void SignalPdu::
writeInterval (const writeInterval_type& x)
{
  this->writeInterval_.set (x);
}

void SignalPdu::
writeInterval (::std::auto_ptr< writeInterval_type > x)
{
  this->writeInterval_.set (x);
}

const SignalPdu::writeInterval_type& SignalPdu::
writeInterval_default_value ()
{
  return writeInterval_default_value_;
}

const SignalPdu::networkMode_type& SignalPdu::
networkMode () const
{
  return this->networkMode_.get ();
}

SignalPdu::networkMode_type& SignalPdu::
networkMode ()
{
  return this->networkMode_.get ();
}

void SignalPdu::
networkMode (const networkMode_type& x)
{
  this->networkMode_.set (x);
}

void SignalPdu::
networkMode (::std::auto_ptr< networkMode_type > x)
{
  this->networkMode_.set (x);
}

const SignalPdu::networkMode_type& SignalPdu::
networkMode_default_value ()
{
  return networkMode_default_value_;
}

const SignalPdu::siteID_type& SignalPdu::
siteID () const
{
  return this->siteID_.get ();
}

SignalPdu::siteID_type& SignalPdu::
siteID ()
{
  return this->siteID_.get ();
}

void SignalPdu::
siteID (const siteID_type& x)
{
  this->siteID_.set (x);
}

void SignalPdu::
siteID (::std::auto_ptr< siteID_type > x)
{
  this->siteID_.set (x);
}

const SignalPdu::siteID_type& SignalPdu::
siteID_default_value ()
{
  return siteID_default_value_;
}

const SignalPdu::applicationID_type& SignalPdu::
applicationID () const
{
  return this->applicationID_.get ();
}

SignalPdu::applicationID_type& SignalPdu::
applicationID ()
{
  return this->applicationID_.get ();
}

void SignalPdu::
applicationID (const applicationID_type& x)
{
  this->applicationID_.set (x);
}

void SignalPdu::
applicationID (::std::auto_ptr< applicationID_type > x)
{
  this->applicationID_.set (x);
}

const SignalPdu::applicationID_type& SignalPdu::
applicationID_default_value ()
{
  return applicationID_default_value_;
}

const SignalPdu::entityID_type& SignalPdu::
entityID () const
{
  return this->entityID_.get ();
}

SignalPdu::entityID_type& SignalPdu::
entityID ()
{
  return this->entityID_.get ();
}

void SignalPdu::
entityID (const entityID_type& x)
{
  this->entityID_.set (x);
}

void SignalPdu::
entityID (::std::auto_ptr< entityID_type > x)
{
  this->entityID_.set (x);
}

const SignalPdu::entityID_type& SignalPdu::
entityID_default_value ()
{
  return entityID_default_value_;
}

const SignalPdu::address_type& SignalPdu::
address () const
{
  return this->address_.get ();
}

SignalPdu::address_type& SignalPdu::
address ()
{
  return this->address_.get ();
}

void SignalPdu::
address (const address_type& x)
{
  this->address_.set (x);
}

void SignalPdu::
address (::std::auto_ptr< address_type > x)
{
  this->address_.set (x);
}

const SignalPdu::address_type& SignalPdu::
address_default_value ()
{
  return address_default_value_;
}

const SignalPdu::port_type& SignalPdu::
port () const
{
  return this->port_.get ();
}

SignalPdu::port_type& SignalPdu::
port ()
{
  return this->port_.get ();
}

void SignalPdu::
port (const port_type& x)
{
  this->port_.set (x);
}

void SignalPdu::
port (::std::auto_ptr< port_type > x)
{
  this->port_.set (x);
}

const SignalPdu::port_type& SignalPdu::
port_default_value ()
{
  return port_default_value_;
}

const SignalPdu::multicastRelayHost_optional& SignalPdu::
multicastRelayHost () const
{
  return this->multicastRelayHost_;
}

SignalPdu::multicastRelayHost_optional& SignalPdu::
multicastRelayHost ()
{
  return this->multicastRelayHost_;
}

void SignalPdu::
multicastRelayHost (const multicastRelayHost_type& x)
{
  this->multicastRelayHost_.set (x);
}

void SignalPdu::
multicastRelayHost (const multicastRelayHost_optional& x)
{
  this->multicastRelayHost_ = x;
}

void SignalPdu::
multicastRelayHost (::std::auto_ptr< multicastRelayHost_type > x)
{
  this->multicastRelayHost_.set (x);
}

const SignalPdu::multicastRelayPort_type& SignalPdu::
multicastRelayPort () const
{
  return this->multicastRelayPort_.get ();
}

SignalPdu::multicastRelayPort_type& SignalPdu::
multicastRelayPort ()
{
  return this->multicastRelayPort_.get ();
}

void SignalPdu::
multicastRelayPort (const multicastRelayPort_type& x)
{
  this->multicastRelayPort_.set (x);
}

void SignalPdu::
multicastRelayPort (::std::auto_ptr< multicastRelayPort_type > x)
{
  this->multicastRelayPort_.set (x);
}

const SignalPdu::multicastRelayPort_type& SignalPdu::
multicastRelayPort_default_value ()
{
  return multicastRelayPort_default_value_;
}

const SignalPdu::rtpHeaderExpected_type& SignalPdu::
rtpHeaderExpected () const
{
  return this->rtpHeaderExpected_.get ();
}

SignalPdu::rtpHeaderExpected_type& SignalPdu::
rtpHeaderExpected ()
{
  return this->rtpHeaderExpected_.get ();
}

void SignalPdu::
rtpHeaderExpected (const rtpHeaderExpected_type& x)
{
  this->rtpHeaderExpected_.set (x);
}

void SignalPdu::
rtpHeaderExpected (::std::auto_ptr< rtpHeaderExpected_type > x)
{
  this->rtpHeaderExpected_.set (x);
}

const SignalPdu::rtpHeaderExpected_type& SignalPdu::
rtpHeaderExpected_default_value ()
{
  return rtpHeaderExpected_default_value_;
}

const SignalPdu::radioID_type& SignalPdu::
radioID () const
{
  return this->radioID_.get ();
}

SignalPdu::radioID_type& SignalPdu::
radioID ()
{
  return this->radioID_.get ();
}

void SignalPdu::
radioID (const radioID_type& x)
{
  this->radioID_.set (x);
}

void SignalPdu::
radioID (::std::auto_ptr< radioID_type > x)
{
  this->radioID_.set (x);
}

const SignalPdu::radioID_type& SignalPdu::
radioID_default_value ()
{
  return radioID_default_value_;
}

const SignalPdu::encodingScheme_type& SignalPdu::
encodingScheme () const
{
  return this->encodingScheme_.get ();
}

SignalPdu::encodingScheme_type& SignalPdu::
encodingScheme ()
{
  return this->encodingScheme_.get ();
}

void SignalPdu::
encodingScheme (const encodingScheme_type& x)
{
  this->encodingScheme_.set (x);
}

void SignalPdu::
encodingScheme (::std::auto_ptr< encodingScheme_type > x)
{
  this->encodingScheme_.set (x);
}

const SignalPdu::encodingScheme_type& SignalPdu::
encodingScheme_default_value ()
{
  return encodingScheme_default_value_;
}

const SignalPdu::tdlType_type& SignalPdu::
tdlType () const
{
  return this->tdlType_.get ();
}

SignalPdu::tdlType_type& SignalPdu::
tdlType ()
{
  return this->tdlType_.get ();
}

void SignalPdu::
tdlType (const tdlType_type& x)
{
  this->tdlType_.set (x);
}

void SignalPdu::
tdlType (::std::auto_ptr< tdlType_type > x)
{
  this->tdlType_.set (x);
}

const SignalPdu::tdlType_type& SignalPdu::
tdlType_default_value ()
{
  return tdlType_default_value_;
}

const SignalPdu::sampleRate_type& SignalPdu::
sampleRate () const
{
  return this->sampleRate_.get ();
}

SignalPdu::sampleRate_type& SignalPdu::
sampleRate ()
{
  return this->sampleRate_.get ();
}

void SignalPdu::
sampleRate (const sampleRate_type& x)
{
  this->sampleRate_.set (x);
}

void SignalPdu::
sampleRate (::std::auto_ptr< sampleRate_type > x)
{
  this->sampleRate_.set (x);
}

const SignalPdu::sampleRate_type& SignalPdu::
sampleRate_default_value ()
{
  return sampleRate_default_value_;
}

const SignalPdu::samples_type& SignalPdu::
samples () const
{
  return this->samples_.get ();
}

SignalPdu::samples_type& SignalPdu::
samples ()
{
  return this->samples_.get ();
}

void SignalPdu::
samples (const samples_type& x)
{
  this->samples_.set (x);
}

void SignalPdu::
samples (::std::auto_ptr< samples_type > x)
{
  this->samples_.set (x);
}

const SignalPdu::samples_type& SignalPdu::
samples_default_value ()
{
  return samples_default_value_;
}

const SignalPdu::dataLength_type& SignalPdu::
dataLength () const
{
  return this->dataLength_.get ();
}

SignalPdu::dataLength_type& SignalPdu::
dataLength ()
{
  return this->dataLength_.get ();
}

void SignalPdu::
dataLength (const dataLength_type& x)
{
  this->dataLength_.set (x);
}

void SignalPdu::
dataLength (::std::auto_ptr< dataLength_type > x)
{
  this->dataLength_.set (x);
}

const SignalPdu::dataLength_type& SignalPdu::
dataLength_default_value ()
{
  return dataLength_default_value_;
}

const SignalPdu::data_optional& SignalPdu::
data () const
{
  return this->data_;
}

SignalPdu::data_optional& SignalPdu::
data ()
{
  return this->data_;
}

void SignalPdu::
data (const data_type& x)
{
  this->data_.set (x);
}

void SignalPdu::
data (const data_optional& x)
{
  this->data_ = x;
}

void SignalPdu::
data (::std::auto_ptr< data_type > x)
{
  this->data_.set (x);
}


// TransmitterPdu
// 

const TransmitterPdu::enabled_type& TransmitterPdu::
enabled () const
{
  return this->enabled_.get ();
}

TransmitterPdu::enabled_type& TransmitterPdu::
enabled ()
{
  return this->enabled_.get ();
}

void TransmitterPdu::
enabled (const enabled_type& x)
{
  this->enabled_.set (x);
}

void TransmitterPdu::
enabled (::std::auto_ptr< enabled_type > x)
{
  this->enabled_.set (x);
}

const TransmitterPdu::enabled_type& TransmitterPdu::
enabled_default_value ()
{
  return enabled_default_value_;
}

const TransmitterPdu::whichGeometry_type& TransmitterPdu::
whichGeometry () const
{
  return this->whichGeometry_.get ();
}

TransmitterPdu::whichGeometry_type& TransmitterPdu::
whichGeometry ()
{
  return this->whichGeometry_.get ();
}

void TransmitterPdu::
whichGeometry (const whichGeometry_type& x)
{
  this->whichGeometry_.set (x);
}

void TransmitterPdu::
whichGeometry (::std::auto_ptr< whichGeometry_type > x)
{
  this->whichGeometry_.set (x);
}

const TransmitterPdu::whichGeometry_type& TransmitterPdu::
whichGeometry_default_value ()
{
  return whichGeometry_default_value_;
}

const TransmitterPdu::readInterval_type& TransmitterPdu::
readInterval () const
{
  return this->readInterval_.get ();
}

TransmitterPdu::readInterval_type& TransmitterPdu::
readInterval ()
{
  return this->readInterval_.get ();
}

void TransmitterPdu::
readInterval (const readInterval_type& x)
{
  this->readInterval_.set (x);
}

void TransmitterPdu::
readInterval (::std::auto_ptr< readInterval_type > x)
{
  this->readInterval_.set (x);
}

const TransmitterPdu::readInterval_type& TransmitterPdu::
readInterval_default_value ()
{
  return readInterval_default_value_;
}

const TransmitterPdu::writeInterval_type& TransmitterPdu::
writeInterval () const
{
  return this->writeInterval_.get ();
}

TransmitterPdu::writeInterval_type& TransmitterPdu::
writeInterval ()
{
  return this->writeInterval_.get ();
}

void TransmitterPdu::
writeInterval (const writeInterval_type& x)
{
  this->writeInterval_.set (x);
}

void TransmitterPdu::
writeInterval (::std::auto_ptr< writeInterval_type > x)
{
  this->writeInterval_.set (x);
}

const TransmitterPdu::writeInterval_type& TransmitterPdu::
writeInterval_default_value ()
{
  return writeInterval_default_value_;
}

const TransmitterPdu::networkMode_type& TransmitterPdu::
networkMode () const
{
  return this->networkMode_.get ();
}

TransmitterPdu::networkMode_type& TransmitterPdu::
networkMode ()
{
  return this->networkMode_.get ();
}

void TransmitterPdu::
networkMode (const networkMode_type& x)
{
  this->networkMode_.set (x);
}

void TransmitterPdu::
networkMode (::std::auto_ptr< networkMode_type > x)
{
  this->networkMode_.set (x);
}

const TransmitterPdu::networkMode_type& TransmitterPdu::
networkMode_default_value ()
{
  return networkMode_default_value_;
}

const TransmitterPdu::siteID_type& TransmitterPdu::
siteID () const
{
  return this->siteID_.get ();
}

TransmitterPdu::siteID_type& TransmitterPdu::
siteID ()
{
  return this->siteID_.get ();
}

void TransmitterPdu::
siteID (const siteID_type& x)
{
  this->siteID_.set (x);
}

void TransmitterPdu::
siteID (::std::auto_ptr< siteID_type > x)
{
  this->siteID_.set (x);
}

const TransmitterPdu::siteID_type& TransmitterPdu::
siteID_default_value ()
{
  return siteID_default_value_;
}

const TransmitterPdu::applicationID_type& TransmitterPdu::
applicationID () const
{
  return this->applicationID_.get ();
}

TransmitterPdu::applicationID_type& TransmitterPdu::
applicationID ()
{
  return this->applicationID_.get ();
}

void TransmitterPdu::
applicationID (const applicationID_type& x)
{
  this->applicationID_.set (x);
}

void TransmitterPdu::
applicationID (::std::auto_ptr< applicationID_type > x)
{
  this->applicationID_.set (x);
}

const TransmitterPdu::applicationID_type& TransmitterPdu::
applicationID_default_value ()
{
  return applicationID_default_value_;
}

const TransmitterPdu::entityID_type& TransmitterPdu::
entityID () const
{
  return this->entityID_.get ();
}

TransmitterPdu::entityID_type& TransmitterPdu::
entityID ()
{
  return this->entityID_.get ();
}

void TransmitterPdu::
entityID (const entityID_type& x)
{
  this->entityID_.set (x);
}

void TransmitterPdu::
entityID (::std::auto_ptr< entityID_type > x)
{
  this->entityID_.set (x);
}

const TransmitterPdu::entityID_type& TransmitterPdu::
entityID_default_value ()
{
  return entityID_default_value_;
}

const TransmitterPdu::address_type& TransmitterPdu::
address () const
{
  return this->address_.get ();
}

TransmitterPdu::address_type& TransmitterPdu::
address ()
{
  return this->address_.get ();
}

void TransmitterPdu::
address (const address_type& x)
{
  this->address_.set (x);
}

void TransmitterPdu::
address (::std::auto_ptr< address_type > x)
{
  this->address_.set (x);
}

const TransmitterPdu::address_type& TransmitterPdu::
address_default_value ()
{
  return address_default_value_;
}

const TransmitterPdu::port_type& TransmitterPdu::
port () const
{
  return this->port_.get ();
}

TransmitterPdu::port_type& TransmitterPdu::
port ()
{
  return this->port_.get ();
}

void TransmitterPdu::
port (const port_type& x)
{
  this->port_.set (x);
}

void TransmitterPdu::
port (::std::auto_ptr< port_type > x)
{
  this->port_.set (x);
}

const TransmitterPdu::port_type& TransmitterPdu::
port_default_value ()
{
  return port_default_value_;
}

const TransmitterPdu::multicastRelayHost_optional& TransmitterPdu::
multicastRelayHost () const
{
  return this->multicastRelayHost_;
}

TransmitterPdu::multicastRelayHost_optional& TransmitterPdu::
multicastRelayHost ()
{
  return this->multicastRelayHost_;
}

void TransmitterPdu::
multicastRelayHost (const multicastRelayHost_type& x)
{
  this->multicastRelayHost_.set (x);
}

void TransmitterPdu::
multicastRelayHost (const multicastRelayHost_optional& x)
{
  this->multicastRelayHost_ = x;
}

void TransmitterPdu::
multicastRelayHost (::std::auto_ptr< multicastRelayHost_type > x)
{
  this->multicastRelayHost_.set (x);
}

const TransmitterPdu::multicastRelayPort_type& TransmitterPdu::
multicastRelayPort () const
{
  return this->multicastRelayPort_.get ();
}

TransmitterPdu::multicastRelayPort_type& TransmitterPdu::
multicastRelayPort ()
{
  return this->multicastRelayPort_.get ();
}

void TransmitterPdu::
multicastRelayPort (const multicastRelayPort_type& x)
{
  this->multicastRelayPort_.set (x);
}

void TransmitterPdu::
multicastRelayPort (::std::auto_ptr< multicastRelayPort_type > x)
{
  this->multicastRelayPort_.set (x);
}

const TransmitterPdu::multicastRelayPort_type& TransmitterPdu::
multicastRelayPort_default_value ()
{
  return multicastRelayPort_default_value_;
}

const TransmitterPdu::rtpHeaderExpected_type& TransmitterPdu::
rtpHeaderExpected () const
{
  return this->rtpHeaderExpected_.get ();
}

TransmitterPdu::rtpHeaderExpected_type& TransmitterPdu::
rtpHeaderExpected ()
{
  return this->rtpHeaderExpected_.get ();
}

void TransmitterPdu::
rtpHeaderExpected (const rtpHeaderExpected_type& x)
{
  this->rtpHeaderExpected_.set (x);
}

void TransmitterPdu::
rtpHeaderExpected (::std::auto_ptr< rtpHeaderExpected_type > x)
{
  this->rtpHeaderExpected_.set (x);
}

const TransmitterPdu::rtpHeaderExpected_type& TransmitterPdu::
rtpHeaderExpected_default_value ()
{
  return rtpHeaderExpected_default_value_;
}

const TransmitterPdu::radioID_type& TransmitterPdu::
radioID () const
{
  return this->radioID_.get ();
}

TransmitterPdu::radioID_type& TransmitterPdu::
radioID ()
{
  return this->radioID_.get ();
}

void TransmitterPdu::
radioID (const radioID_type& x)
{
  this->radioID_.set (x);
}

void TransmitterPdu::
radioID (::std::auto_ptr< radioID_type > x)
{
  this->radioID_.set (x);
}

const TransmitterPdu::radioID_type& TransmitterPdu::
radioID_default_value ()
{
  return radioID_default_value_;
}

const TransmitterPdu::antennaLocation_type& TransmitterPdu::
antennaLocation () const
{
  return this->antennaLocation_.get ();
}

TransmitterPdu::antennaLocation_type& TransmitterPdu::
antennaLocation ()
{
  return this->antennaLocation_.get ();
}

void TransmitterPdu::
antennaLocation (const antennaLocation_type& x)
{
  this->antennaLocation_.set (x);
}

void TransmitterPdu::
antennaLocation (::std::auto_ptr< antennaLocation_type > x)
{
  this->antennaLocation_.set (x);
}

const TransmitterPdu::antennaLocation_type& TransmitterPdu::
antennaLocation_default_value ()
{
  return antennaLocation_default_value_;
}

const TransmitterPdu::antennaPatternLength_type& TransmitterPdu::
antennaPatternLength () const
{
  return this->antennaPatternLength_.get ();
}

TransmitterPdu::antennaPatternLength_type& TransmitterPdu::
antennaPatternLength ()
{
  return this->antennaPatternLength_.get ();
}

void TransmitterPdu::
antennaPatternLength (const antennaPatternLength_type& x)
{
  this->antennaPatternLength_.set (x);
}

void TransmitterPdu::
antennaPatternLength (::std::auto_ptr< antennaPatternLength_type > x)
{
  this->antennaPatternLength_.set (x);
}

const TransmitterPdu::antennaPatternLength_type& TransmitterPdu::
antennaPatternLength_default_value ()
{
  return antennaPatternLength_default_value_;
}

const TransmitterPdu::antennaPatternType_type& TransmitterPdu::
antennaPatternType () const
{
  return this->antennaPatternType_.get ();
}

TransmitterPdu::antennaPatternType_type& TransmitterPdu::
antennaPatternType ()
{
  return this->antennaPatternType_.get ();
}

void TransmitterPdu::
antennaPatternType (const antennaPatternType_type& x)
{
  this->antennaPatternType_.set (x);
}

void TransmitterPdu::
antennaPatternType (::std::auto_ptr< antennaPatternType_type > x)
{
  this->antennaPatternType_.set (x);
}

const TransmitterPdu::antennaPatternType_type& TransmitterPdu::
antennaPatternType_default_value ()
{
  return antennaPatternType_default_value_;
}

const TransmitterPdu::cryptoKeyID_type& TransmitterPdu::
cryptoKeyID () const
{
  return this->cryptoKeyID_.get ();
}

TransmitterPdu::cryptoKeyID_type& TransmitterPdu::
cryptoKeyID ()
{
  return this->cryptoKeyID_.get ();
}

void TransmitterPdu::
cryptoKeyID (const cryptoKeyID_type& x)
{
  this->cryptoKeyID_.set (x);
}

void TransmitterPdu::
cryptoKeyID (::std::auto_ptr< cryptoKeyID_type > x)
{
  this->cryptoKeyID_.set (x);
}

const TransmitterPdu::cryptoKeyID_type& TransmitterPdu::
cryptoKeyID_default_value ()
{
  return cryptoKeyID_default_value_;
}

const TransmitterPdu::cryptoSystem_type& TransmitterPdu::
cryptoSystem () const
{
  return this->cryptoSystem_.get ();
}

TransmitterPdu::cryptoSystem_type& TransmitterPdu::
cryptoSystem ()
{
  return this->cryptoSystem_.get ();
}

void TransmitterPdu::
cryptoSystem (const cryptoSystem_type& x)
{
  this->cryptoSystem_.set (x);
}

void TransmitterPdu::
cryptoSystem (::std::auto_ptr< cryptoSystem_type > x)
{
  this->cryptoSystem_.set (x);
}

const TransmitterPdu::cryptoSystem_type& TransmitterPdu::
cryptoSystem_default_value ()
{
  return cryptoSystem_default_value_;
}

const TransmitterPdu::frequency_type& TransmitterPdu::
frequency () const
{
  return this->frequency_.get ();
}

TransmitterPdu::frequency_type& TransmitterPdu::
frequency ()
{
  return this->frequency_.get ();
}

void TransmitterPdu::
frequency (const frequency_type& x)
{
  this->frequency_.set (x);
}

void TransmitterPdu::
frequency (::std::auto_ptr< frequency_type > x)
{
  this->frequency_.set (x);
}

const TransmitterPdu::frequency_type& TransmitterPdu::
frequency_default_value ()
{
  return frequency_default_value_;
}

const TransmitterPdu::inputSource_type& TransmitterPdu::
inputSource () const
{
  return this->inputSource_.get ();
}

TransmitterPdu::inputSource_type& TransmitterPdu::
inputSource ()
{
  return this->inputSource_.get ();
}

void TransmitterPdu::
inputSource (const inputSource_type& x)
{
  this->inputSource_.set (x);
}

void TransmitterPdu::
inputSource (::std::auto_ptr< inputSource_type > x)
{
  this->inputSource_.set (x);
}

const TransmitterPdu::inputSource_type& TransmitterPdu::
inputSource_default_value ()
{
  return inputSource_default_value_;
}

const TransmitterPdu::lengthOfModulationParameters_type& TransmitterPdu::
lengthOfModulationParameters () const
{
  return this->lengthOfModulationParameters_.get ();
}

TransmitterPdu::lengthOfModulationParameters_type& TransmitterPdu::
lengthOfModulationParameters ()
{
  return this->lengthOfModulationParameters_.get ();
}

void TransmitterPdu::
lengthOfModulationParameters (const lengthOfModulationParameters_type& x)
{
  this->lengthOfModulationParameters_.set (x);
}

void TransmitterPdu::
lengthOfModulationParameters (::std::auto_ptr< lengthOfModulationParameters_type > x)
{
  this->lengthOfModulationParameters_.set (x);
}

const TransmitterPdu::lengthOfModulationParameters_type& TransmitterPdu::
lengthOfModulationParameters_default_value ()
{
  return lengthOfModulationParameters_default_value_;
}

const TransmitterPdu::modulationTypeDetail_type& TransmitterPdu::
modulationTypeDetail () const
{
  return this->modulationTypeDetail_.get ();
}

TransmitterPdu::modulationTypeDetail_type& TransmitterPdu::
modulationTypeDetail ()
{
  return this->modulationTypeDetail_.get ();
}

void TransmitterPdu::
modulationTypeDetail (const modulationTypeDetail_type& x)
{
  this->modulationTypeDetail_.set (x);
}

void TransmitterPdu::
modulationTypeDetail (::std::auto_ptr< modulationTypeDetail_type > x)
{
  this->modulationTypeDetail_.set (x);
}

const TransmitterPdu::modulationTypeDetail_type& TransmitterPdu::
modulationTypeDetail_default_value ()
{
  return modulationTypeDetail_default_value_;
}

const TransmitterPdu::modulationTypeMajor_type& TransmitterPdu::
modulationTypeMajor () const
{
  return this->modulationTypeMajor_.get ();
}

TransmitterPdu::modulationTypeMajor_type& TransmitterPdu::
modulationTypeMajor ()
{
  return this->modulationTypeMajor_.get ();
}

void TransmitterPdu::
modulationTypeMajor (const modulationTypeMajor_type& x)
{
  this->modulationTypeMajor_.set (x);
}

void TransmitterPdu::
modulationTypeMajor (::std::auto_ptr< modulationTypeMajor_type > x)
{
  this->modulationTypeMajor_.set (x);
}

const TransmitterPdu::modulationTypeMajor_type& TransmitterPdu::
modulationTypeMajor_default_value ()
{
  return modulationTypeMajor_default_value_;
}

const TransmitterPdu::modulationTypeSpreadSpectrum_type& TransmitterPdu::
modulationTypeSpreadSpectrum () const
{
  return this->modulationTypeSpreadSpectrum_.get ();
}

TransmitterPdu::modulationTypeSpreadSpectrum_type& TransmitterPdu::
modulationTypeSpreadSpectrum ()
{
  return this->modulationTypeSpreadSpectrum_.get ();
}

void TransmitterPdu::
modulationTypeSpreadSpectrum (const modulationTypeSpreadSpectrum_type& x)
{
  this->modulationTypeSpreadSpectrum_.set (x);
}

void TransmitterPdu::
modulationTypeSpreadSpectrum (::std::auto_ptr< modulationTypeSpreadSpectrum_type > x)
{
  this->modulationTypeSpreadSpectrum_.set (x);
}

const TransmitterPdu::modulationTypeSpreadSpectrum_type& TransmitterPdu::
modulationTypeSpreadSpectrum_default_value ()
{
  return modulationTypeSpreadSpectrum_default_value_;
}

const TransmitterPdu::modulationTypeSystem_type& TransmitterPdu::
modulationTypeSystem () const
{
  return this->modulationTypeSystem_.get ();
}

TransmitterPdu::modulationTypeSystem_type& TransmitterPdu::
modulationTypeSystem ()
{
  return this->modulationTypeSystem_.get ();
}

void TransmitterPdu::
modulationTypeSystem (const modulationTypeSystem_type& x)
{
  this->modulationTypeSystem_.set (x);
}

void TransmitterPdu::
modulationTypeSystem (::std::auto_ptr< modulationTypeSystem_type > x)
{
  this->modulationTypeSystem_.set (x);
}

const TransmitterPdu::modulationTypeSystem_type& TransmitterPdu::
modulationTypeSystem_default_value ()
{
  return modulationTypeSystem_default_value_;
}

const TransmitterPdu::power_type& TransmitterPdu::
power () const
{
  return this->power_.get ();
}

TransmitterPdu::power_type& TransmitterPdu::
power ()
{
  return this->power_.get ();
}

void TransmitterPdu::
power (const power_type& x)
{
  this->power_.set (x);
}

void TransmitterPdu::
power (::std::auto_ptr< power_type > x)
{
  this->power_.set (x);
}

const TransmitterPdu::power_type& TransmitterPdu::
power_default_value ()
{
  return power_default_value_;
}

const TransmitterPdu::radioEntityTypeCategory_type& TransmitterPdu::
radioEntityTypeCategory () const
{
  return this->radioEntityTypeCategory_.get ();
}

TransmitterPdu::radioEntityTypeCategory_type& TransmitterPdu::
radioEntityTypeCategory ()
{
  return this->radioEntityTypeCategory_.get ();
}

void TransmitterPdu::
radioEntityTypeCategory (const radioEntityTypeCategory_type& x)
{
  this->radioEntityTypeCategory_.set (x);
}

void TransmitterPdu::
radioEntityTypeCategory (::std::auto_ptr< radioEntityTypeCategory_type > x)
{
  this->radioEntityTypeCategory_.set (x);
}

const TransmitterPdu::radioEntityTypeCategory_type& TransmitterPdu::
radioEntityTypeCategory_default_value ()
{
  return radioEntityTypeCategory_default_value_;
}

const TransmitterPdu::radioEntityTypeCountry_type& TransmitterPdu::
radioEntityTypeCountry () const
{
  return this->radioEntityTypeCountry_.get ();
}

TransmitterPdu::radioEntityTypeCountry_type& TransmitterPdu::
radioEntityTypeCountry ()
{
  return this->radioEntityTypeCountry_.get ();
}

void TransmitterPdu::
radioEntityTypeCountry (const radioEntityTypeCountry_type& x)
{
  this->radioEntityTypeCountry_.set (x);
}

void TransmitterPdu::
radioEntityTypeCountry (::std::auto_ptr< radioEntityTypeCountry_type > x)
{
  this->radioEntityTypeCountry_.set (x);
}

const TransmitterPdu::radioEntityTypeCountry_type& TransmitterPdu::
radioEntityTypeCountry_default_value ()
{
  return radioEntityTypeCountry_default_value_;
}

const TransmitterPdu::radioEntityTypeDomain_type& TransmitterPdu::
radioEntityTypeDomain () const
{
  return this->radioEntityTypeDomain_.get ();
}

TransmitterPdu::radioEntityTypeDomain_type& TransmitterPdu::
radioEntityTypeDomain ()
{
  return this->radioEntityTypeDomain_.get ();
}

void TransmitterPdu::
radioEntityTypeDomain (const radioEntityTypeDomain_type& x)
{
  this->radioEntityTypeDomain_.set (x);
}

void TransmitterPdu::
radioEntityTypeDomain (::std::auto_ptr< radioEntityTypeDomain_type > x)
{
  this->radioEntityTypeDomain_.set (x);
}

const TransmitterPdu::radioEntityTypeDomain_type& TransmitterPdu::
radioEntityTypeDomain_default_value ()
{
  return radioEntityTypeDomain_default_value_;
}

const TransmitterPdu::radioEntityTypeKind_type& TransmitterPdu::
radioEntityTypeKind () const
{
  return this->radioEntityTypeKind_.get ();
}

TransmitterPdu::radioEntityTypeKind_type& TransmitterPdu::
radioEntityTypeKind ()
{
  return this->radioEntityTypeKind_.get ();
}

void TransmitterPdu::
radioEntityTypeKind (const radioEntityTypeKind_type& x)
{
  this->radioEntityTypeKind_.set (x);
}

void TransmitterPdu::
radioEntityTypeKind (::std::auto_ptr< radioEntityTypeKind_type > x)
{
  this->radioEntityTypeKind_.set (x);
}

const TransmitterPdu::radioEntityTypeKind_type& TransmitterPdu::
radioEntityTypeKind_default_value ()
{
  return radioEntityTypeKind_default_value_;
}

const TransmitterPdu::radioEntityTypeNomenclature_type& TransmitterPdu::
radioEntityTypeNomenclature () const
{
  return this->radioEntityTypeNomenclature_.get ();
}

TransmitterPdu::radioEntityTypeNomenclature_type& TransmitterPdu::
radioEntityTypeNomenclature ()
{
  return this->radioEntityTypeNomenclature_.get ();
}

void TransmitterPdu::
radioEntityTypeNomenclature (const radioEntityTypeNomenclature_type& x)
{
  this->radioEntityTypeNomenclature_.set (x);
}

void TransmitterPdu::
radioEntityTypeNomenclature (::std::auto_ptr< radioEntityTypeNomenclature_type > x)
{
  this->radioEntityTypeNomenclature_.set (x);
}

const TransmitterPdu::radioEntityTypeNomenclature_type& TransmitterPdu::
radioEntityTypeNomenclature_default_value ()
{
  return radioEntityTypeNomenclature_default_value_;
}

const TransmitterPdu::radioEntityTypeNomenclatureVersion_type& TransmitterPdu::
radioEntityTypeNomenclatureVersion () const
{
  return this->radioEntityTypeNomenclatureVersion_.get ();
}

TransmitterPdu::radioEntityTypeNomenclatureVersion_type& TransmitterPdu::
radioEntityTypeNomenclatureVersion ()
{
  return this->radioEntityTypeNomenclatureVersion_.get ();
}

void TransmitterPdu::
radioEntityTypeNomenclatureVersion (const radioEntityTypeNomenclatureVersion_type& x)
{
  this->radioEntityTypeNomenclatureVersion_.set (x);
}

void TransmitterPdu::
radioEntityTypeNomenclatureVersion (::std::auto_ptr< radioEntityTypeNomenclatureVersion_type > x)
{
  this->radioEntityTypeNomenclatureVersion_.set (x);
}

const TransmitterPdu::radioEntityTypeNomenclatureVersion_type& TransmitterPdu::
radioEntityTypeNomenclatureVersion_default_value ()
{
  return radioEntityTypeNomenclatureVersion_default_value_;
}

const TransmitterPdu::relativeAntennaLocation_type& TransmitterPdu::
relativeAntennaLocation () const
{
  return this->relativeAntennaLocation_.get ();
}

TransmitterPdu::relativeAntennaLocation_type& TransmitterPdu::
relativeAntennaLocation ()
{
  return this->relativeAntennaLocation_.get ();
}

void TransmitterPdu::
relativeAntennaLocation (const relativeAntennaLocation_type& x)
{
  this->relativeAntennaLocation_.set (x);
}

void TransmitterPdu::
relativeAntennaLocation (::std::auto_ptr< relativeAntennaLocation_type > x)
{
  this->relativeAntennaLocation_.set (x);
}

const TransmitterPdu::relativeAntennaLocation_type& TransmitterPdu::
relativeAntennaLocation_default_value ()
{
  return relativeAntennaLocation_default_value_;
}

const TransmitterPdu::transmitFrequencyBandwidth_type& TransmitterPdu::
transmitFrequencyBandwidth () const
{
  return this->transmitFrequencyBandwidth_.get ();
}

TransmitterPdu::transmitFrequencyBandwidth_type& TransmitterPdu::
transmitFrequencyBandwidth ()
{
  return this->transmitFrequencyBandwidth_.get ();
}

void TransmitterPdu::
transmitFrequencyBandwidth (const transmitFrequencyBandwidth_type& x)
{
  this->transmitFrequencyBandwidth_.set (x);
}

void TransmitterPdu::
transmitFrequencyBandwidth (::std::auto_ptr< transmitFrequencyBandwidth_type > x)
{
  this->transmitFrequencyBandwidth_.set (x);
}

const TransmitterPdu::transmitFrequencyBandwidth_type& TransmitterPdu::
transmitFrequencyBandwidth_default_value ()
{
  return transmitFrequencyBandwidth_default_value_;
}

const TransmitterPdu::transmitState_type& TransmitterPdu::
transmitState () const
{
  return this->transmitState_.get ();
}

TransmitterPdu::transmitState_type& TransmitterPdu::
transmitState ()
{
  return this->transmitState_.get ();
}

void TransmitterPdu::
transmitState (const transmitState_type& x)
{
  this->transmitState_.set (x);
}

void TransmitterPdu::
transmitState (::std::auto_ptr< transmitState_type > x)
{
  this->transmitState_.set (x);
}

const TransmitterPdu::transmitState_type& TransmitterPdu::
transmitState_default_value ()
{
  return transmitState_default_value_;
}


// GeoCoordinate
// 

const GeoCoordinate::GeoOrigin_optional& GeoCoordinate::
GeoOrigin () const
{
  return this->GeoOrigin_;
}

GeoCoordinate::GeoOrigin_optional& GeoCoordinate::
GeoOrigin ()
{
  return this->GeoOrigin_;
}

void GeoCoordinate::
GeoOrigin (const GeoOrigin_type& x)
{
  this->GeoOrigin_.set (x);
}

void GeoCoordinate::
GeoOrigin (const GeoOrigin_optional& x)
{
  this->GeoOrigin_ = x;
}

void GeoCoordinate::
GeoOrigin (::std::auto_ptr< GeoOrigin_type > x)
{
  this->GeoOrigin_.set (x);
}

const GeoCoordinate::geoSystem_type& GeoCoordinate::
geoSystem () const
{
  return this->geoSystem_.get ();
}

GeoCoordinate::geoSystem_type& GeoCoordinate::
geoSystem ()
{
  return this->geoSystem_.get ();
}

void GeoCoordinate::
geoSystem (const geoSystem_type& x)
{
  this->geoSystem_.set (x);
}

void GeoCoordinate::
geoSystem (::std::auto_ptr< geoSystem_type > x)
{
  this->geoSystem_.set (x);
}

const GeoCoordinate::geoSystem_type& GeoCoordinate::
geoSystem_default_value ()
{
  return geoSystem_default_value_;
}

const GeoCoordinate::point_optional& GeoCoordinate::
point () const
{
  return this->point_;
}

GeoCoordinate::point_optional& GeoCoordinate::
point ()
{
  return this->point_;
}

void GeoCoordinate::
point (const point_type& x)
{
  this->point_.set (x);
}

void GeoCoordinate::
point (const point_optional& x)
{
  this->point_ = x;
}

void GeoCoordinate::
point (::std::auto_ptr< point_type > x)
{
  this->point_.set (x);
}

const GeoCoordinate::containerField_type& GeoCoordinate::
containerField () const
{
  return this->containerField_.get ();
}

GeoCoordinate::containerField_type& GeoCoordinate::
containerField ()
{
  return this->containerField_.get ();
}

void GeoCoordinate::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void GeoCoordinate::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const GeoCoordinate::containerField_type& GeoCoordinate::
containerField_default_value ()
{
  return containerField_default_value_;
}


// GeoElevationGrid
// 

const GeoElevationGrid::GeoOrigin_optional& GeoElevationGrid::
GeoOrigin () const
{
  return this->GeoOrigin_;
}

GeoElevationGrid::GeoOrigin_optional& GeoElevationGrid::
GeoOrigin ()
{
  return this->GeoOrigin_;
}

void GeoElevationGrid::
GeoOrigin (const GeoOrigin_type& x)
{
  this->GeoOrigin_.set (x);
}

void GeoElevationGrid::
GeoOrigin (const GeoOrigin_optional& x)
{
  this->GeoOrigin_ = x;
}

void GeoElevationGrid::
GeoOrigin (::std::auto_ptr< GeoOrigin_type > x)
{
  this->GeoOrigin_.set (x);
}

const GeoElevationGrid::Color_optional& GeoElevationGrid::
Color () const
{
  return this->Color_;
}

GeoElevationGrid::Color_optional& GeoElevationGrid::
Color ()
{
  return this->Color_;
}

void GeoElevationGrid::
Color (const Color_type& x)
{
  this->Color_.set (x);
}

void GeoElevationGrid::
Color (const Color_optional& x)
{
  this->Color_ = x;
}

void GeoElevationGrid::
Color (::std::auto_ptr< Color_type > x)
{
  this->Color_.set (x);
}

const GeoElevationGrid::ColorRGBA_optional& GeoElevationGrid::
ColorRGBA () const
{
  return this->ColorRGBA_;
}

GeoElevationGrid::ColorRGBA_optional& GeoElevationGrid::
ColorRGBA ()
{
  return this->ColorRGBA_;
}

void GeoElevationGrid::
ColorRGBA (const ColorRGBA_type& x)
{
  this->ColorRGBA_.set (x);
}

void GeoElevationGrid::
ColorRGBA (const ColorRGBA_optional& x)
{
  this->ColorRGBA_ = x;
}

void GeoElevationGrid::
ColorRGBA (::std::auto_ptr< ColorRGBA_type > x)
{
  this->ColorRGBA_.set (x);
}

const GeoElevationGrid::Normal_optional& GeoElevationGrid::
Normal () const
{
  return this->Normal_;
}

GeoElevationGrid::Normal_optional& GeoElevationGrid::
Normal ()
{
  return this->Normal_;
}

void GeoElevationGrid::
Normal (const Normal_type& x)
{
  this->Normal_.set (x);
}

void GeoElevationGrid::
Normal (const Normal_optional& x)
{
  this->Normal_ = x;
}

void GeoElevationGrid::
Normal (::std::auto_ptr< Normal_type > x)
{
  this->Normal_.set (x);
}

const GeoElevationGrid::TextureCoordinate_optional& GeoElevationGrid::
TextureCoordinate () const
{
  return this->TextureCoordinate_;
}

GeoElevationGrid::TextureCoordinate_optional& GeoElevationGrid::
TextureCoordinate ()
{
  return this->TextureCoordinate_;
}

void GeoElevationGrid::
TextureCoordinate (const TextureCoordinate_type& x)
{
  this->TextureCoordinate_.set (x);
}

void GeoElevationGrid::
TextureCoordinate (const TextureCoordinate_optional& x)
{
  this->TextureCoordinate_ = x;
}

void GeoElevationGrid::
TextureCoordinate (::std::auto_ptr< TextureCoordinate_type > x)
{
  this->TextureCoordinate_.set (x);
}

const GeoElevationGrid::TextureCoordinateGenerator_optional& GeoElevationGrid::
TextureCoordinateGenerator () const
{
  return this->TextureCoordinateGenerator_;
}

GeoElevationGrid::TextureCoordinateGenerator_optional& GeoElevationGrid::
TextureCoordinateGenerator ()
{
  return this->TextureCoordinateGenerator_;
}

void GeoElevationGrid::
TextureCoordinateGenerator (const TextureCoordinateGenerator_type& x)
{
  this->TextureCoordinateGenerator_.set (x);
}

void GeoElevationGrid::
TextureCoordinateGenerator (const TextureCoordinateGenerator_optional& x)
{
  this->TextureCoordinateGenerator_ = x;
}

void GeoElevationGrid::
TextureCoordinateGenerator (::std::auto_ptr< TextureCoordinateGenerator_type > x)
{
  this->TextureCoordinateGenerator_.set (x);
}

const GeoElevationGrid::MultiTextureCoordinate_optional& GeoElevationGrid::
MultiTextureCoordinate () const
{
  return this->MultiTextureCoordinate_;
}

GeoElevationGrid::MultiTextureCoordinate_optional& GeoElevationGrid::
MultiTextureCoordinate ()
{
  return this->MultiTextureCoordinate_;
}

void GeoElevationGrid::
MultiTextureCoordinate (const MultiTextureCoordinate_type& x)
{
  this->MultiTextureCoordinate_.set (x);
}

void GeoElevationGrid::
MultiTextureCoordinate (const MultiTextureCoordinate_optional& x)
{
  this->MultiTextureCoordinate_ = x;
}

void GeoElevationGrid::
MultiTextureCoordinate (::std::auto_ptr< MultiTextureCoordinate_type > x)
{
  this->MultiTextureCoordinate_.set (x);
}

const GeoElevationGrid::NurbsTextureCoordinate_optional& GeoElevationGrid::
NurbsTextureCoordinate () const
{
  return this->NurbsTextureCoordinate_;
}

GeoElevationGrid::NurbsTextureCoordinate_optional& GeoElevationGrid::
NurbsTextureCoordinate ()
{
  return this->NurbsTextureCoordinate_;
}

void GeoElevationGrid::
NurbsTextureCoordinate (const NurbsTextureCoordinate_type& x)
{
  this->NurbsTextureCoordinate_.set (x);
}

void GeoElevationGrid::
NurbsTextureCoordinate (const NurbsTextureCoordinate_optional& x)
{
  this->NurbsTextureCoordinate_ = x;
}

void GeoElevationGrid::
NurbsTextureCoordinate (::std::auto_ptr< NurbsTextureCoordinate_type > x)
{
  this->NurbsTextureCoordinate_.set (x);
}

const GeoElevationGrid::ProtoInstance_sequence& GeoElevationGrid::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

GeoElevationGrid::ProtoInstance_sequence& GeoElevationGrid::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void GeoElevationGrid::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const GeoElevationGrid::FogCoordinate_optional& GeoElevationGrid::
FogCoordinate () const
{
  return this->FogCoordinate_;
}

GeoElevationGrid::FogCoordinate_optional& GeoElevationGrid::
FogCoordinate ()
{
  return this->FogCoordinate_;
}

void GeoElevationGrid::
FogCoordinate (const FogCoordinate_type& x)
{
  this->FogCoordinate_.set (x);
}

void GeoElevationGrid::
FogCoordinate (const FogCoordinate_optional& x)
{
  this->FogCoordinate_ = x;
}

void GeoElevationGrid::
FogCoordinate (::std::auto_ptr< FogCoordinate_type > x)
{
  this->FogCoordinate_.set (x);
}

const GeoElevationGrid::geoSystem_type& GeoElevationGrid::
geoSystem () const
{
  return this->geoSystem_.get ();
}

GeoElevationGrid::geoSystem_type& GeoElevationGrid::
geoSystem ()
{
  return this->geoSystem_.get ();
}

void GeoElevationGrid::
geoSystem (const geoSystem_type& x)
{
  this->geoSystem_.set (x);
}

void GeoElevationGrid::
geoSystem (::std::auto_ptr< geoSystem_type > x)
{
  this->geoSystem_.set (x);
}

const GeoElevationGrid::geoSystem_type& GeoElevationGrid::
geoSystem_default_value ()
{
  return geoSystem_default_value_;
}

const GeoElevationGrid::geoGridOrigin_type& GeoElevationGrid::
geoGridOrigin () const
{
  return this->geoGridOrigin_.get ();
}

GeoElevationGrid::geoGridOrigin_type& GeoElevationGrid::
geoGridOrigin ()
{
  return this->geoGridOrigin_.get ();
}

void GeoElevationGrid::
geoGridOrigin (const geoGridOrigin_type& x)
{
  this->geoGridOrigin_.set (x);
}

void GeoElevationGrid::
geoGridOrigin (::std::auto_ptr< geoGridOrigin_type > x)
{
  this->geoGridOrigin_.set (x);
}

const GeoElevationGrid::geoGridOrigin_type& GeoElevationGrid::
geoGridOrigin_default_value ()
{
  return geoGridOrigin_default_value_;
}

const GeoElevationGrid::height_type& GeoElevationGrid::
height () const
{
  return this->height_.get ();
}

GeoElevationGrid::height_type& GeoElevationGrid::
height ()
{
  return this->height_.get ();
}

void GeoElevationGrid::
height (const height_type& x)
{
  this->height_.set (x);
}

void GeoElevationGrid::
height (::std::auto_ptr< height_type > x)
{
  this->height_.set (x);
}

const GeoElevationGrid::height_type& GeoElevationGrid::
height_default_value ()
{
  return height_default_value_;
}

const GeoElevationGrid::ccw_type& GeoElevationGrid::
ccw () const
{
  return this->ccw_.get ();
}

GeoElevationGrid::ccw_type& GeoElevationGrid::
ccw ()
{
  return this->ccw_.get ();
}

void GeoElevationGrid::
ccw (const ccw_type& x)
{
  this->ccw_.set (x);
}

void GeoElevationGrid::
ccw (::std::auto_ptr< ccw_type > x)
{
  this->ccw_.set (x);
}

const GeoElevationGrid::ccw_type& GeoElevationGrid::
ccw_default_value ()
{
  return ccw_default_value_;
}

const GeoElevationGrid::colorPerVertex_type& GeoElevationGrid::
colorPerVertex () const
{
  return this->colorPerVertex_.get ();
}

GeoElevationGrid::colorPerVertex_type& GeoElevationGrid::
colorPerVertex ()
{
  return this->colorPerVertex_.get ();
}

void GeoElevationGrid::
colorPerVertex (const colorPerVertex_type& x)
{
  this->colorPerVertex_.set (x);
}

void GeoElevationGrid::
colorPerVertex (::std::auto_ptr< colorPerVertex_type > x)
{
  this->colorPerVertex_.set (x);
}

const GeoElevationGrid::colorPerVertex_type& GeoElevationGrid::
colorPerVertex_default_value ()
{
  return colorPerVertex_default_value_;
}

const GeoElevationGrid::creaseAngle_type& GeoElevationGrid::
creaseAngle () const
{
  return this->creaseAngle_.get ();
}

GeoElevationGrid::creaseAngle_type& GeoElevationGrid::
creaseAngle ()
{
  return this->creaseAngle_.get ();
}

void GeoElevationGrid::
creaseAngle (const creaseAngle_type& x)
{
  this->creaseAngle_.set (x);
}

void GeoElevationGrid::
creaseAngle (::std::auto_ptr< creaseAngle_type > x)
{
  this->creaseAngle_.set (x);
}

const GeoElevationGrid::creaseAngle_type& GeoElevationGrid::
creaseAngle_default_value ()
{
  return creaseAngle_default_value_;
}

const GeoElevationGrid::normalPerVertex_type& GeoElevationGrid::
normalPerVertex () const
{
  return this->normalPerVertex_.get ();
}

GeoElevationGrid::normalPerVertex_type& GeoElevationGrid::
normalPerVertex ()
{
  return this->normalPerVertex_.get ();
}

void GeoElevationGrid::
normalPerVertex (const normalPerVertex_type& x)
{
  this->normalPerVertex_.set (x);
}

void GeoElevationGrid::
normalPerVertex (::std::auto_ptr< normalPerVertex_type > x)
{
  this->normalPerVertex_.set (x);
}

const GeoElevationGrid::normalPerVertex_type& GeoElevationGrid::
normalPerVertex_default_value ()
{
  return normalPerVertex_default_value_;
}

const GeoElevationGrid::solid_type& GeoElevationGrid::
solid () const
{
  return this->solid_.get ();
}

GeoElevationGrid::solid_type& GeoElevationGrid::
solid ()
{
  return this->solid_.get ();
}

void GeoElevationGrid::
solid (const solid_type& x)
{
  this->solid_.set (x);
}

void GeoElevationGrid::
solid (::std::auto_ptr< solid_type > x)
{
  this->solid_.set (x);
}

const GeoElevationGrid::solid_type& GeoElevationGrid::
solid_default_value ()
{
  return solid_default_value_;
}

const GeoElevationGrid::xDimension_type& GeoElevationGrid::
xDimension () const
{
  return this->xDimension_.get ();
}

GeoElevationGrid::xDimension_type& GeoElevationGrid::
xDimension ()
{
  return this->xDimension_.get ();
}

void GeoElevationGrid::
xDimension (const xDimension_type& x)
{
  this->xDimension_.set (x);
}

void GeoElevationGrid::
xDimension (::std::auto_ptr< xDimension_type > x)
{
  this->xDimension_.set (x);
}

const GeoElevationGrid::xDimension_type& GeoElevationGrid::
xDimension_default_value ()
{
  return xDimension_default_value_;
}

const GeoElevationGrid::xSpacing_type& GeoElevationGrid::
xSpacing () const
{
  return this->xSpacing_.get ();
}

GeoElevationGrid::xSpacing_type& GeoElevationGrid::
xSpacing ()
{
  return this->xSpacing_.get ();
}

void GeoElevationGrid::
xSpacing (const xSpacing_type& x)
{
  this->xSpacing_.set (x);
}

void GeoElevationGrid::
xSpacing (::std::auto_ptr< xSpacing_type > x)
{
  this->xSpacing_.set (x);
}

const GeoElevationGrid::xSpacing_type& GeoElevationGrid::
xSpacing_default_value ()
{
  return xSpacing_default_value_;
}

const GeoElevationGrid::yScale_type& GeoElevationGrid::
yScale () const
{
  return this->yScale_.get ();
}

GeoElevationGrid::yScale_type& GeoElevationGrid::
yScale ()
{
  return this->yScale_.get ();
}

void GeoElevationGrid::
yScale (const yScale_type& x)
{
  this->yScale_.set (x);
}

void GeoElevationGrid::
yScale (::std::auto_ptr< yScale_type > x)
{
  this->yScale_.set (x);
}

const GeoElevationGrid::yScale_type& GeoElevationGrid::
yScale_default_value ()
{
  return yScale_default_value_;
}

const GeoElevationGrid::zDimension_type& GeoElevationGrid::
zDimension () const
{
  return this->zDimension_.get ();
}

GeoElevationGrid::zDimension_type& GeoElevationGrid::
zDimension ()
{
  return this->zDimension_.get ();
}

void GeoElevationGrid::
zDimension (const zDimension_type& x)
{
  this->zDimension_.set (x);
}

void GeoElevationGrid::
zDimension (::std::auto_ptr< zDimension_type > x)
{
  this->zDimension_.set (x);
}

const GeoElevationGrid::zDimension_type& GeoElevationGrid::
zDimension_default_value ()
{
  return zDimension_default_value_;
}

const GeoElevationGrid::zSpacing_type& GeoElevationGrid::
zSpacing () const
{
  return this->zSpacing_.get ();
}

GeoElevationGrid::zSpacing_type& GeoElevationGrid::
zSpacing ()
{
  return this->zSpacing_.get ();
}

void GeoElevationGrid::
zSpacing (const zSpacing_type& x)
{
  this->zSpacing_.set (x);
}

void GeoElevationGrid::
zSpacing (::std::auto_ptr< zSpacing_type > x)
{
  this->zSpacing_.set (x);
}

const GeoElevationGrid::zSpacing_type& GeoElevationGrid::
zSpacing_default_value ()
{
  return zSpacing_default_value_;
}


// GeoLocation
// 

const GeoLocation::geoSystem_type& GeoLocation::
geoSystem () const
{
  return this->geoSystem_.get ();
}

GeoLocation::geoSystem_type& GeoLocation::
geoSystem ()
{
  return this->geoSystem_.get ();
}

void GeoLocation::
geoSystem (const geoSystem_type& x)
{
  this->geoSystem_.set (x);
}

void GeoLocation::
geoSystem (::std::auto_ptr< geoSystem_type > x)
{
  this->geoSystem_.set (x);
}

const GeoLocation::geoSystem_type& GeoLocation::
geoSystem_default_value ()
{
  return geoSystem_default_value_;
}

const GeoLocation::geoCoords_type& GeoLocation::
geoCoords () const
{
  return this->geoCoords_.get ();
}

GeoLocation::geoCoords_type& GeoLocation::
geoCoords ()
{
  return this->geoCoords_.get ();
}

void GeoLocation::
geoCoords (const geoCoords_type& x)
{
  this->geoCoords_.set (x);
}

void GeoLocation::
geoCoords (::std::auto_ptr< geoCoords_type > x)
{
  this->geoCoords_.set (x);
}

const GeoLocation::geoCoords_type& GeoLocation::
geoCoords_default_value ()
{
  return geoCoords_default_value_;
}


// GeoLOD
// 

const GeoLOD::geoSystem_type& GeoLOD::
geoSystem () const
{
  return this->geoSystem_.get ();
}

GeoLOD::geoSystem_type& GeoLOD::
geoSystem ()
{
  return this->geoSystem_.get ();
}

void GeoLOD::
geoSystem (const geoSystem_type& x)
{
  this->geoSystem_.set (x);
}

void GeoLOD::
geoSystem (::std::auto_ptr< geoSystem_type > x)
{
  this->geoSystem_.set (x);
}

const GeoLOD::geoSystem_type& GeoLOD::
geoSystem_default_value ()
{
  return geoSystem_default_value_;
}

const GeoLOD::rootUrl_optional& GeoLOD::
rootUrl () const
{
  return this->rootUrl_;
}

GeoLOD::rootUrl_optional& GeoLOD::
rootUrl ()
{
  return this->rootUrl_;
}

void GeoLOD::
rootUrl (const rootUrl_type& x)
{
  this->rootUrl_.set (x);
}

void GeoLOD::
rootUrl (const rootUrl_optional& x)
{
  this->rootUrl_ = x;
}

void GeoLOD::
rootUrl (::std::auto_ptr< rootUrl_type > x)
{
  this->rootUrl_.set (x);
}

const GeoLOD::child1Url_optional& GeoLOD::
child1Url () const
{
  return this->child1Url_;
}

GeoLOD::child1Url_optional& GeoLOD::
child1Url ()
{
  return this->child1Url_;
}

void GeoLOD::
child1Url (const child1Url_type& x)
{
  this->child1Url_.set (x);
}

void GeoLOD::
child1Url (const child1Url_optional& x)
{
  this->child1Url_ = x;
}

void GeoLOD::
child1Url (::std::auto_ptr< child1Url_type > x)
{
  this->child1Url_.set (x);
}

const GeoLOD::child2Url_optional& GeoLOD::
child2Url () const
{
  return this->child2Url_;
}

GeoLOD::child2Url_optional& GeoLOD::
child2Url ()
{
  return this->child2Url_;
}

void GeoLOD::
child2Url (const child2Url_type& x)
{
  this->child2Url_.set (x);
}

void GeoLOD::
child2Url (const child2Url_optional& x)
{
  this->child2Url_ = x;
}

void GeoLOD::
child2Url (::std::auto_ptr< child2Url_type > x)
{
  this->child2Url_.set (x);
}

const GeoLOD::child3Url_optional& GeoLOD::
child3Url () const
{
  return this->child3Url_;
}

GeoLOD::child3Url_optional& GeoLOD::
child3Url ()
{
  return this->child3Url_;
}

void GeoLOD::
child3Url (const child3Url_type& x)
{
  this->child3Url_.set (x);
}

void GeoLOD::
child3Url (const child3Url_optional& x)
{
  this->child3Url_ = x;
}

void GeoLOD::
child3Url (::std::auto_ptr< child3Url_type > x)
{
  this->child3Url_.set (x);
}

const GeoLOD::child4Url_optional& GeoLOD::
child4Url () const
{
  return this->child4Url_;
}

GeoLOD::child4Url_optional& GeoLOD::
child4Url ()
{
  return this->child4Url_;
}

void GeoLOD::
child4Url (const child4Url_type& x)
{
  this->child4Url_.set (x);
}

void GeoLOD::
child4Url (const child4Url_optional& x)
{
  this->child4Url_ = x;
}

void GeoLOD::
child4Url (::std::auto_ptr< child4Url_type > x)
{
  this->child4Url_.set (x);
}

const GeoLOD::center_type& GeoLOD::
center () const
{
  return this->center_.get ();
}

GeoLOD::center_type& GeoLOD::
center ()
{
  return this->center_.get ();
}

void GeoLOD::
center (const center_type& x)
{
  this->center_.set (x);
}

void GeoLOD::
center (::std::auto_ptr< center_type > x)
{
  this->center_.set (x);
}

const GeoLOD::center_type& GeoLOD::
center_default_value ()
{
  return center_default_value_;
}

const GeoLOD::range_type& GeoLOD::
range () const
{
  return this->range_.get ();
}

GeoLOD::range_type& GeoLOD::
range ()
{
  return this->range_.get ();
}

void GeoLOD::
range (const range_type& x)
{
  this->range_.set (x);
}

void GeoLOD::
range (::std::auto_ptr< range_type > x)
{
  this->range_.set (x);
}

const GeoLOD::range_type& GeoLOD::
range_default_value ()
{
  return range_default_value_;
}


// GeoMetadata
// 

const GeoMetadata::GeoCoordinate_optional& GeoMetadata::
GeoCoordinate () const
{
  return this->GeoCoordinate_;
}

GeoMetadata::GeoCoordinate_optional& GeoMetadata::
GeoCoordinate ()
{
  return this->GeoCoordinate_;
}

void GeoMetadata::
GeoCoordinate (const GeoCoordinate_type& x)
{
  this->GeoCoordinate_.set (x);
}

void GeoMetadata::
GeoCoordinate (const GeoCoordinate_optional& x)
{
  this->GeoCoordinate_ = x;
}

void GeoMetadata::
GeoCoordinate (::std::auto_ptr< GeoCoordinate_type > x)
{
  this->GeoCoordinate_.set (x);
}

const GeoMetadata::GeoElevationGrid_optional& GeoMetadata::
GeoElevationGrid () const
{
  return this->GeoElevationGrid_;
}

GeoMetadata::GeoElevationGrid_optional& GeoMetadata::
GeoElevationGrid ()
{
  return this->GeoElevationGrid_;
}

void GeoMetadata::
GeoElevationGrid (const GeoElevationGrid_type& x)
{
  this->GeoElevationGrid_.set (x);
}

void GeoMetadata::
GeoElevationGrid (const GeoElevationGrid_optional& x)
{
  this->GeoElevationGrid_ = x;
}

void GeoMetadata::
GeoElevationGrid (::std::auto_ptr< GeoElevationGrid_type > x)
{
  this->GeoElevationGrid_.set (x);
}

const GeoMetadata::GeoLocation_optional& GeoMetadata::
GeoLocation () const
{
  return this->GeoLocation_;
}

GeoMetadata::GeoLocation_optional& GeoMetadata::
GeoLocation ()
{
  return this->GeoLocation_;
}

void GeoMetadata::
GeoLocation (const GeoLocation_type& x)
{
  this->GeoLocation_.set (x);
}

void GeoMetadata::
GeoLocation (const GeoLocation_optional& x)
{
  this->GeoLocation_ = x;
}

void GeoMetadata::
GeoLocation (::std::auto_ptr< GeoLocation_type > x)
{
  this->GeoLocation_.set (x);
}

const GeoMetadata::GeoOrigin_optional& GeoMetadata::
GeoOrigin () const
{
  return this->GeoOrigin_;
}

GeoMetadata::GeoOrigin_optional& GeoMetadata::
GeoOrigin ()
{
  return this->GeoOrigin_;
}

void GeoMetadata::
GeoOrigin (const GeoOrigin_type& x)
{
  this->GeoOrigin_.set (x);
}

void GeoMetadata::
GeoOrigin (const GeoOrigin_optional& x)
{
  this->GeoOrigin_ = x;
}

void GeoMetadata::
GeoOrigin (::std::auto_ptr< GeoOrigin_type > x)
{
  this->GeoOrigin_.set (x);
}

const GeoMetadata::GeoLOD_optional& GeoMetadata::
GeoLOD () const
{
  return this->GeoLOD_;
}

GeoMetadata::GeoLOD_optional& GeoMetadata::
GeoLOD ()
{
  return this->GeoLOD_;
}

void GeoMetadata::
GeoLOD (const GeoLOD_type& x)
{
  this->GeoLOD_.set (x);
}

void GeoMetadata::
GeoLOD (const GeoLOD_optional& x)
{
  this->GeoLOD_ = x;
}

void GeoMetadata::
GeoLOD (::std::auto_ptr< GeoLOD_type > x)
{
  this->GeoLOD_.set (x);
}

const GeoMetadata::GeoPositionInterpolator_optional& GeoMetadata::
GeoPositionInterpolator () const
{
  return this->GeoPositionInterpolator_;
}

GeoMetadata::GeoPositionInterpolator_optional& GeoMetadata::
GeoPositionInterpolator ()
{
  return this->GeoPositionInterpolator_;
}

void GeoMetadata::
GeoPositionInterpolator (const GeoPositionInterpolator_type& x)
{
  this->GeoPositionInterpolator_.set (x);
}

void GeoMetadata::
GeoPositionInterpolator (const GeoPositionInterpolator_optional& x)
{
  this->GeoPositionInterpolator_ = x;
}

void GeoMetadata::
GeoPositionInterpolator (::std::auto_ptr< GeoPositionInterpolator_type > x)
{
  this->GeoPositionInterpolator_.set (x);
}

const GeoMetadata::GeoTouchSensor_optional& GeoMetadata::
GeoTouchSensor () const
{
  return this->GeoTouchSensor_;
}

GeoMetadata::GeoTouchSensor_optional& GeoMetadata::
GeoTouchSensor ()
{
  return this->GeoTouchSensor_;
}

void GeoMetadata::
GeoTouchSensor (const GeoTouchSensor_type& x)
{
  this->GeoTouchSensor_.set (x);
}

void GeoMetadata::
GeoTouchSensor (const GeoTouchSensor_optional& x)
{
  this->GeoTouchSensor_ = x;
}

void GeoMetadata::
GeoTouchSensor (::std::auto_ptr< GeoTouchSensor_type > x)
{
  this->GeoTouchSensor_.set (x);
}

const GeoMetadata::GeoViewpoint_optional& GeoMetadata::
GeoViewpoint () const
{
  return this->GeoViewpoint_;
}

GeoMetadata::GeoViewpoint_optional& GeoMetadata::
GeoViewpoint ()
{
  return this->GeoViewpoint_;
}

void GeoMetadata::
GeoViewpoint (const GeoViewpoint_type& x)
{
  this->GeoViewpoint_.set (x);
}

void GeoMetadata::
GeoViewpoint (const GeoViewpoint_optional& x)
{
  this->GeoViewpoint_ = x;
}

void GeoMetadata::
GeoViewpoint (::std::auto_ptr< GeoViewpoint_type > x)
{
  this->GeoViewpoint_.set (x);
}

const GeoMetadata::ProtoInstance_optional& GeoMetadata::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

GeoMetadata::ProtoInstance_optional& GeoMetadata::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void GeoMetadata::
ProtoInstance (const ProtoInstance_type& x)
{
  this->ProtoInstance_.set (x);
}

void GeoMetadata::
ProtoInstance (const ProtoInstance_optional& x)
{
  this->ProtoInstance_ = x;
}

void GeoMetadata::
ProtoInstance (::std::auto_ptr< ProtoInstance_type > x)
{
  this->ProtoInstance_.set (x);
}

const GeoMetadata::url_optional& GeoMetadata::
url () const
{
  return this->url_;
}

GeoMetadata::url_optional& GeoMetadata::
url ()
{
  return this->url_;
}

void GeoMetadata::
url (const url_type& x)
{
  this->url_.set (x);
}

void GeoMetadata::
url (const url_optional& x)
{
  this->url_ = x;
}

void GeoMetadata::
url (::std::auto_ptr< url_type > x)
{
  this->url_.set (x);
}

const GeoMetadata::data_optional& GeoMetadata::
data () const
{
  return this->data_;
}

GeoMetadata::data_optional& GeoMetadata::
data ()
{
  return this->data_;
}

void GeoMetadata::
data (const data_type& x)
{
  this->data_.set (x);
}

void GeoMetadata::
data (const data_optional& x)
{
  this->data_ = x;
}

void GeoMetadata::
data (::std::auto_ptr< data_type > x)
{
  this->data_.set (x);
}

const GeoMetadata::summary_optional& GeoMetadata::
summary () const
{
  return this->summary_;
}

GeoMetadata::summary_optional& GeoMetadata::
summary ()
{
  return this->summary_;
}

void GeoMetadata::
summary (const summary_type& x)
{
  this->summary_.set (x);
}

void GeoMetadata::
summary (const summary_optional& x)
{
  this->summary_ = x;
}

void GeoMetadata::
summary (::std::auto_ptr< summary_type > x)
{
  this->summary_.set (x);
}


// GeoOrigin
// 

const GeoOrigin::geoSystem_type& GeoOrigin::
geoSystem () const
{
  return this->geoSystem_.get ();
}

GeoOrigin::geoSystem_type& GeoOrigin::
geoSystem ()
{
  return this->geoSystem_.get ();
}

void GeoOrigin::
geoSystem (const geoSystem_type& x)
{
  this->geoSystem_.set (x);
}

void GeoOrigin::
geoSystem (::std::auto_ptr< geoSystem_type > x)
{
  this->geoSystem_.set (x);
}

const GeoOrigin::geoSystem_type& GeoOrigin::
geoSystem_default_value ()
{
  return geoSystem_default_value_;
}

const GeoOrigin::geoCoords_type& GeoOrigin::
geoCoords () const
{
  return this->geoCoords_.get ();
}

GeoOrigin::geoCoords_type& GeoOrigin::
geoCoords ()
{
  return this->geoCoords_.get ();
}

void GeoOrigin::
geoCoords (const geoCoords_type& x)
{
  this->geoCoords_.set (x);
}

void GeoOrigin::
geoCoords (::std::auto_ptr< geoCoords_type > x)
{
  this->geoCoords_.set (x);
}

const GeoOrigin::geoCoords_type& GeoOrigin::
geoCoords_default_value ()
{
  return geoCoords_default_value_;
}

const GeoOrigin::rotateYUp_type& GeoOrigin::
rotateYUp () const
{
  return this->rotateYUp_.get ();
}

GeoOrigin::rotateYUp_type& GeoOrigin::
rotateYUp ()
{
  return this->rotateYUp_.get ();
}

void GeoOrigin::
rotateYUp (const rotateYUp_type& x)
{
  this->rotateYUp_.set (x);
}

void GeoOrigin::
rotateYUp (::std::auto_ptr< rotateYUp_type > x)
{
  this->rotateYUp_.set (x);
}

const GeoOrigin::rotateYUp_type& GeoOrigin::
rotateYUp_default_value ()
{
  return rotateYUp_default_value_;
}

const GeoOrigin::containerField_type& GeoOrigin::
containerField () const
{
  return this->containerField_.get ();
}

GeoOrigin::containerField_type& GeoOrigin::
containerField ()
{
  return this->containerField_.get ();
}

void GeoOrigin::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void GeoOrigin::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const GeoOrigin::containerField_type& GeoOrigin::
containerField_default_value ()
{
  return containerField_default_value_;
}


// GeoPositionInterpolator
// 

const GeoPositionInterpolator::GeoOrigin_optional& GeoPositionInterpolator::
GeoOrigin () const
{
  return this->GeoOrigin_;
}

GeoPositionInterpolator::GeoOrigin_optional& GeoPositionInterpolator::
GeoOrigin ()
{
  return this->GeoOrigin_;
}

void GeoPositionInterpolator::
GeoOrigin (const GeoOrigin_type& x)
{
  this->GeoOrigin_.set (x);
}

void GeoPositionInterpolator::
GeoOrigin (const GeoOrigin_optional& x)
{
  this->GeoOrigin_ = x;
}

void GeoPositionInterpolator::
GeoOrigin (::std::auto_ptr< GeoOrigin_type > x)
{
  this->GeoOrigin_.set (x);
}

const GeoPositionInterpolator::geoSystem_type& GeoPositionInterpolator::
geoSystem () const
{
  return this->geoSystem_.get ();
}

GeoPositionInterpolator::geoSystem_type& GeoPositionInterpolator::
geoSystem ()
{
  return this->geoSystem_.get ();
}

void GeoPositionInterpolator::
geoSystem (const geoSystem_type& x)
{
  this->geoSystem_.set (x);
}

void GeoPositionInterpolator::
geoSystem (::std::auto_ptr< geoSystem_type > x)
{
  this->geoSystem_.set (x);
}

const GeoPositionInterpolator::geoSystem_type& GeoPositionInterpolator::
geoSystem_default_value ()
{
  return geoSystem_default_value_;
}

const GeoPositionInterpolator::keyValue_optional& GeoPositionInterpolator::
keyValue () const
{
  return this->keyValue_;
}

GeoPositionInterpolator::keyValue_optional& GeoPositionInterpolator::
keyValue ()
{
  return this->keyValue_;
}

void GeoPositionInterpolator::
keyValue (const keyValue_type& x)
{
  this->keyValue_.set (x);
}

void GeoPositionInterpolator::
keyValue (const keyValue_optional& x)
{
  this->keyValue_ = x;
}

void GeoPositionInterpolator::
keyValue (::std::auto_ptr< keyValue_type > x)
{
  this->keyValue_.set (x);
}


// GeoTouchSensor
// 

const GeoTouchSensor::GeoOrigin_optional& GeoTouchSensor::
GeoOrigin () const
{
  return this->GeoOrigin_;
}

GeoTouchSensor::GeoOrigin_optional& GeoTouchSensor::
GeoOrigin ()
{
  return this->GeoOrigin_;
}

void GeoTouchSensor::
GeoOrigin (const GeoOrigin_type& x)
{
  this->GeoOrigin_.set (x);
}

void GeoTouchSensor::
GeoOrigin (const GeoOrigin_optional& x)
{
  this->GeoOrigin_ = x;
}

void GeoTouchSensor::
GeoOrigin (::std::auto_ptr< GeoOrigin_type > x)
{
  this->GeoOrigin_.set (x);
}

const GeoTouchSensor::geoSystem_type& GeoTouchSensor::
geoSystem () const
{
  return this->geoSystem_.get ();
}

GeoTouchSensor::geoSystem_type& GeoTouchSensor::
geoSystem ()
{
  return this->geoSystem_.get ();
}

void GeoTouchSensor::
geoSystem (const geoSystem_type& x)
{
  this->geoSystem_.set (x);
}

void GeoTouchSensor::
geoSystem (::std::auto_ptr< geoSystem_type > x)
{
  this->geoSystem_.set (x);
}

const GeoTouchSensor::geoSystem_type& GeoTouchSensor::
geoSystem_default_value ()
{
  return geoSystem_default_value_;
}


// GeoViewpoint
// 

const GeoViewpoint::GeoOrigin_optional& GeoViewpoint::
GeoOrigin () const
{
  return this->GeoOrigin_;
}

GeoViewpoint::GeoOrigin_optional& GeoViewpoint::
GeoOrigin ()
{
  return this->GeoOrigin_;
}

void GeoViewpoint::
GeoOrigin (const GeoOrigin_type& x)
{
  this->GeoOrigin_.set (x);
}

void GeoViewpoint::
GeoOrigin (const GeoOrigin_optional& x)
{
  this->GeoOrigin_ = x;
}

void GeoViewpoint::
GeoOrigin (::std::auto_ptr< GeoOrigin_type > x)
{
  this->GeoOrigin_.set (x);
}

const GeoViewpoint::geoSystem_type& GeoViewpoint::
geoSystem () const
{
  return this->geoSystem_.get ();
}

GeoViewpoint::geoSystem_type& GeoViewpoint::
geoSystem ()
{
  return this->geoSystem_.get ();
}

void GeoViewpoint::
geoSystem (const geoSystem_type& x)
{
  this->geoSystem_.set (x);
}

void GeoViewpoint::
geoSystem (::std::auto_ptr< geoSystem_type > x)
{
  this->geoSystem_.set (x);
}

const GeoViewpoint::geoSystem_type& GeoViewpoint::
geoSystem_default_value ()
{
  return geoSystem_default_value_;
}

const GeoViewpoint::fieldOfView_type& GeoViewpoint::
fieldOfView () const
{
  return this->fieldOfView_.get ();
}

GeoViewpoint::fieldOfView_type& GeoViewpoint::
fieldOfView ()
{
  return this->fieldOfView_.get ();
}

void GeoViewpoint::
fieldOfView (const fieldOfView_type& x)
{
  this->fieldOfView_.set (x);
}

void GeoViewpoint::
fieldOfView (::std::auto_ptr< fieldOfView_type > x)
{
  this->fieldOfView_.set (x);
}

const GeoViewpoint::fieldOfView_type& GeoViewpoint::
fieldOfView_default_value ()
{
  return fieldOfView_default_value_;
}

const GeoViewpoint::jump_type& GeoViewpoint::
jump () const
{
  return this->jump_.get ();
}

GeoViewpoint::jump_type& GeoViewpoint::
jump ()
{
  return this->jump_.get ();
}

void GeoViewpoint::
jump (const jump_type& x)
{
  this->jump_.set (x);
}

void GeoViewpoint::
jump (::std::auto_ptr< jump_type > x)
{
  this->jump_.set (x);
}

const GeoViewpoint::jump_type& GeoViewpoint::
jump_default_value ()
{
  return jump_default_value_;
}

const GeoViewpoint::orientation_type& GeoViewpoint::
orientation () const
{
  return this->orientation_.get ();
}

GeoViewpoint::orientation_type& GeoViewpoint::
orientation ()
{
  return this->orientation_.get ();
}

void GeoViewpoint::
orientation (const orientation_type& x)
{
  this->orientation_.set (x);
}

void GeoViewpoint::
orientation (::std::auto_ptr< orientation_type > x)
{
  this->orientation_.set (x);
}

const GeoViewpoint::orientation_type& GeoViewpoint::
orientation_default_value ()
{
  return orientation_default_value_;
}

const GeoViewpoint::position_type& GeoViewpoint::
position () const
{
  return this->position_.get ();
}

GeoViewpoint::position_type& GeoViewpoint::
position ()
{
  return this->position_.get ();
}

void GeoViewpoint::
position (const position_type& x)
{
  this->position_.set (x);
}

void GeoViewpoint::
position (::std::auto_ptr< position_type > x)
{
  this->position_.set (x);
}

const GeoViewpoint::position_type& GeoViewpoint::
position_default_value ()
{
  return position_default_value_;
}

const GeoViewpoint::description_optional& GeoViewpoint::
description () const
{
  return this->description_;
}

GeoViewpoint::description_optional& GeoViewpoint::
description ()
{
  return this->description_;
}

void GeoViewpoint::
description (const description_type& x)
{
  this->description_.set (x);
}

void GeoViewpoint::
description (const description_optional& x)
{
  this->description_ = x;
}

void GeoViewpoint::
description (::std::auto_ptr< description_type > x)
{
  this->description_.set (x);
}

const GeoViewpoint::headlight_type& GeoViewpoint::
headlight () const
{
  return this->headlight_.get ();
}

GeoViewpoint::headlight_type& GeoViewpoint::
headlight ()
{
  return this->headlight_.get ();
}

void GeoViewpoint::
headlight (const headlight_type& x)
{
  this->headlight_.set (x);
}

void GeoViewpoint::
headlight (::std::auto_ptr< headlight_type > x)
{
  this->headlight_.set (x);
}

const GeoViewpoint::headlight_type& GeoViewpoint::
headlight_default_value ()
{
  return headlight_default_value_;
}

const GeoViewpoint::navType_type& GeoViewpoint::
navType () const
{
  return this->navType_.get ();
}

GeoViewpoint::navType_type& GeoViewpoint::
navType ()
{
  return this->navType_.get ();
}

void GeoViewpoint::
navType (const navType_type& x)
{
  this->navType_.set (x);
}

void GeoViewpoint::
navType (::std::auto_ptr< navType_type > x)
{
  this->navType_.set (x);
}

const GeoViewpoint::navType_type& GeoViewpoint::
navType_default_value ()
{
  return navType_default_value_;
}

const GeoViewpoint::speedFactor_type& GeoViewpoint::
speedFactor () const
{
  return this->speedFactor_.get ();
}

GeoViewpoint::speedFactor_type& GeoViewpoint::
speedFactor ()
{
  return this->speedFactor_.get ();
}

void GeoViewpoint::
speedFactor (const speedFactor_type& x)
{
  this->speedFactor_.set (x);
}

void GeoViewpoint::
speedFactor (::std::auto_ptr< speedFactor_type > x)
{
  this->speedFactor_.set (x);
}

const GeoViewpoint::speedFactor_type& GeoViewpoint::
speedFactor_default_value ()
{
  return speedFactor_default_value_;
}


// HAnimDisplacer
// 

const HAnimDisplacer::name_optional& HAnimDisplacer::
name () const
{
  return this->name_;
}

HAnimDisplacer::name_optional& HAnimDisplacer::
name ()
{
  return this->name_;
}

void HAnimDisplacer::
name (const name_type& x)
{
  this->name_.set (x);
}

void HAnimDisplacer::
name (const name_optional& x)
{
  this->name_ = x;
}

void HAnimDisplacer::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const HAnimDisplacer::coordIndex_optional& HAnimDisplacer::
coordIndex () const
{
  return this->coordIndex_;
}

HAnimDisplacer::coordIndex_optional& HAnimDisplacer::
coordIndex ()
{
  return this->coordIndex_;
}

void HAnimDisplacer::
coordIndex (const coordIndex_type& x)
{
  this->coordIndex_.set (x);
}

void HAnimDisplacer::
coordIndex (const coordIndex_optional& x)
{
  this->coordIndex_ = x;
}

void HAnimDisplacer::
coordIndex (::std::auto_ptr< coordIndex_type > x)
{
  this->coordIndex_.set (x);
}

const HAnimDisplacer::displacements_optional& HAnimDisplacer::
displacements () const
{
  return this->displacements_;
}

HAnimDisplacer::displacements_optional& HAnimDisplacer::
displacements ()
{
  return this->displacements_;
}

void HAnimDisplacer::
displacements (const displacements_type& x)
{
  this->displacements_.set (x);
}

void HAnimDisplacer::
displacements (const displacements_optional& x)
{
  this->displacements_ = x;
}

void HAnimDisplacer::
displacements (::std::auto_ptr< displacements_type > x)
{
  this->displacements_.set (x);
}

const HAnimDisplacer::weight_type& HAnimDisplacer::
weight () const
{
  return this->weight_.get ();
}

HAnimDisplacer::weight_type& HAnimDisplacer::
weight ()
{
  return this->weight_.get ();
}

void HAnimDisplacer::
weight (const weight_type& x)
{
  this->weight_.set (x);
}

void HAnimDisplacer::
weight (::std::auto_ptr< weight_type > x)
{
  this->weight_.set (x);
}

const HAnimDisplacer::weight_type& HAnimDisplacer::
weight_default_value ()
{
  return weight_default_value_;
}

const HAnimDisplacer::containerField_type& HAnimDisplacer::
containerField () const
{
  return this->containerField_.get ();
}

HAnimDisplacer::containerField_type& HAnimDisplacer::
containerField ()
{
  return this->containerField_.get ();
}

void HAnimDisplacer::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void HAnimDisplacer::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const HAnimDisplacer::containerField_type& HAnimDisplacer::
containerField_default_value ()
{
  return containerField_default_value_;
}


// HAnimHumanoid
// 

const HAnimHumanoid::Appearance_sequence& HAnimHumanoid::
Appearance () const
{
  return this->Appearance_;
}

HAnimHumanoid::Appearance_sequence& HAnimHumanoid::
Appearance ()
{
  return this->Appearance_;
}

void HAnimHumanoid::
Appearance (const Appearance_sequence& s)
{
  this->Appearance_ = s;
}

const HAnimHumanoid::Background_sequence& HAnimHumanoid::
Background () const
{
  return this->Background_;
}

HAnimHumanoid::Background_sequence& HAnimHumanoid::
Background ()
{
  return this->Background_;
}

void HAnimHumanoid::
Background (const Background_sequence& s)
{
  this->Background_ = s;
}

const HAnimHumanoid::ColorInterpolator_sequence& HAnimHumanoid::
ColorInterpolator () const
{
  return this->ColorInterpolator_;
}

HAnimHumanoid::ColorInterpolator_sequence& HAnimHumanoid::
ColorInterpolator ()
{
  return this->ColorInterpolator_;
}

void HAnimHumanoid::
ColorInterpolator (const ColorInterpolator_sequence& s)
{
  this->ColorInterpolator_ = s;
}

const HAnimHumanoid::CoordinateInterpolator_sequence& HAnimHumanoid::
CoordinateInterpolator () const
{
  return this->CoordinateInterpolator_;
}

HAnimHumanoid::CoordinateInterpolator_sequence& HAnimHumanoid::
CoordinateInterpolator ()
{
  return this->CoordinateInterpolator_;
}

void HAnimHumanoid::
CoordinateInterpolator (const CoordinateInterpolator_sequence& s)
{
  this->CoordinateInterpolator_ = s;
}

const HAnimHumanoid::DirectionalLight_sequence& HAnimHumanoid::
DirectionalLight () const
{
  return this->DirectionalLight_;
}

HAnimHumanoid::DirectionalLight_sequence& HAnimHumanoid::
DirectionalLight ()
{
  return this->DirectionalLight_;
}

void HAnimHumanoid::
DirectionalLight (const DirectionalLight_sequence& s)
{
  this->DirectionalLight_ = s;
}

const HAnimHumanoid::Group_sequence& HAnimHumanoid::
Group () const
{
  return this->Group_;
}

HAnimHumanoid::Group_sequence& HAnimHumanoid::
Group ()
{
  return this->Group_;
}

void HAnimHumanoid::
Group (const Group_sequence& s)
{
  this->Group_ = s;
}

const HAnimHumanoid::NavigationInfo_sequence& HAnimHumanoid::
NavigationInfo () const
{
  return this->NavigationInfo_;
}

HAnimHumanoid::NavigationInfo_sequence& HAnimHumanoid::
NavigationInfo ()
{
  return this->NavigationInfo_;
}

void HAnimHumanoid::
NavigationInfo (const NavigationInfo_sequence& s)
{
  this->NavigationInfo_ = s;
}

const HAnimHumanoid::NormalInterpolator_sequence& HAnimHumanoid::
NormalInterpolator () const
{
  return this->NormalInterpolator_;
}

HAnimHumanoid::NormalInterpolator_sequence& HAnimHumanoid::
NormalInterpolator ()
{
  return this->NormalInterpolator_;
}

void HAnimHumanoid::
NormalInterpolator (const NormalInterpolator_sequence& s)
{
  this->NormalInterpolator_ = s;
}

const HAnimHumanoid::OrientationInterpolator_sequence& HAnimHumanoid::
OrientationInterpolator () const
{
  return this->OrientationInterpolator_;
}

HAnimHumanoid::OrientationInterpolator_sequence& HAnimHumanoid::
OrientationInterpolator ()
{
  return this->OrientationInterpolator_;
}

void HAnimHumanoid::
OrientationInterpolator (const OrientationInterpolator_sequence& s)
{
  this->OrientationInterpolator_ = s;
}

const HAnimHumanoid::PositionInterpolator_sequence& HAnimHumanoid::
PositionInterpolator () const
{
  return this->PositionInterpolator_;
}

HAnimHumanoid::PositionInterpolator_sequence& HAnimHumanoid::
PositionInterpolator ()
{
  return this->PositionInterpolator_;
}

void HAnimHumanoid::
PositionInterpolator (const PositionInterpolator_sequence& s)
{
  this->PositionInterpolator_ = s;
}

const HAnimHumanoid::ScalarInterpolator_sequence& HAnimHumanoid::
ScalarInterpolator () const
{
  return this->ScalarInterpolator_;
}

HAnimHumanoid::ScalarInterpolator_sequence& HAnimHumanoid::
ScalarInterpolator ()
{
  return this->ScalarInterpolator_;
}

void HAnimHumanoid::
ScalarInterpolator (const ScalarInterpolator_sequence& s)
{
  this->ScalarInterpolator_ = s;
}

const HAnimHumanoid::Shape_sequence& HAnimHumanoid::
Shape () const
{
  return this->Shape_;
}

HAnimHumanoid::Shape_sequence& HAnimHumanoid::
Shape ()
{
  return this->Shape_;
}

void HAnimHumanoid::
Shape (const Shape_sequence& s)
{
  this->Shape_ = s;
}

const HAnimHumanoid::TimeSensor_sequence& HAnimHumanoid::
TimeSensor () const
{
  return this->TimeSensor_;
}

HAnimHumanoid::TimeSensor_sequence& HAnimHumanoid::
TimeSensor ()
{
  return this->TimeSensor_;
}

void HAnimHumanoid::
TimeSensor (const TimeSensor_sequence& s)
{
  this->TimeSensor_ = s;
}

const HAnimHumanoid::Transform_sequence& HAnimHumanoid::
Transform () const
{
  return this->Transform_;
}

HAnimHumanoid::Transform_sequence& HAnimHumanoid::
Transform ()
{
  return this->Transform_;
}

void HAnimHumanoid::
Transform (const Transform_sequence& s)
{
  this->Transform_ = s;
}

const HAnimHumanoid::Viewpoint_sequence& HAnimHumanoid::
Viewpoint () const
{
  return this->Viewpoint_;
}

HAnimHumanoid::Viewpoint_sequence& HAnimHumanoid::
Viewpoint ()
{
  return this->Viewpoint_;
}

void HAnimHumanoid::
Viewpoint (const Viewpoint_sequence& s)
{
  this->Viewpoint_ = s;
}

const HAnimHumanoid::WorldInfo_sequence& HAnimHumanoid::
WorldInfo () const
{
  return this->WorldInfo_;
}

HAnimHumanoid::WorldInfo_sequence& HAnimHumanoid::
WorldInfo ()
{
  return this->WorldInfo_;
}

void HAnimHumanoid::
WorldInfo (const WorldInfo_sequence& s)
{
  this->WorldInfo_ = s;
}

const HAnimHumanoid::Anchor_sequence& HAnimHumanoid::
Anchor () const
{
  return this->Anchor_;
}

HAnimHumanoid::Anchor_sequence& HAnimHumanoid::
Anchor ()
{
  return this->Anchor_;
}

void HAnimHumanoid::
Anchor (const Anchor_sequence& s)
{
  this->Anchor_ = s;
}

const HAnimHumanoid::BooleanFilter_sequence& HAnimHumanoid::
BooleanFilter () const
{
  return this->BooleanFilter_;
}

HAnimHumanoid::BooleanFilter_sequence& HAnimHumanoid::
BooleanFilter ()
{
  return this->BooleanFilter_;
}

void HAnimHumanoid::
BooleanFilter (const BooleanFilter_sequence& s)
{
  this->BooleanFilter_ = s;
}

const HAnimHumanoid::BooleanSequencer_sequence& HAnimHumanoid::
BooleanSequencer () const
{
  return this->BooleanSequencer_;
}

HAnimHumanoid::BooleanSequencer_sequence& HAnimHumanoid::
BooleanSequencer ()
{
  return this->BooleanSequencer_;
}

void HAnimHumanoid::
BooleanSequencer (const BooleanSequencer_sequence& s)
{
  this->BooleanSequencer_ = s;
}

const HAnimHumanoid::BooleanToggle_sequence& HAnimHumanoid::
BooleanToggle () const
{
  return this->BooleanToggle_;
}

HAnimHumanoid::BooleanToggle_sequence& HAnimHumanoid::
BooleanToggle ()
{
  return this->BooleanToggle_;
}

void HAnimHumanoid::
BooleanToggle (const BooleanToggle_sequence& s)
{
  this->BooleanToggle_ = s;
}

const HAnimHumanoid::BooleanTrigger_sequence& HAnimHumanoid::
BooleanTrigger () const
{
  return this->BooleanTrigger_;
}

HAnimHumanoid::BooleanTrigger_sequence& HAnimHumanoid::
BooleanTrigger ()
{
  return this->BooleanTrigger_;
}

void HAnimHumanoid::
BooleanTrigger (const BooleanTrigger_sequence& s)
{
  this->BooleanTrigger_ = s;
}

const HAnimHumanoid::CylinderSensor_sequence& HAnimHumanoid::
CylinderSensor () const
{
  return this->CylinderSensor_;
}

HAnimHumanoid::CylinderSensor_sequence& HAnimHumanoid::
CylinderSensor ()
{
  return this->CylinderSensor_;
}

void HAnimHumanoid::
CylinderSensor (const CylinderSensor_sequence& s)
{
  this->CylinderSensor_ = s;
}

const HAnimHumanoid::Inline_sequence& HAnimHumanoid::
Inline () const
{
  return this->Inline_;
}

HAnimHumanoid::Inline_sequence& HAnimHumanoid::
Inline ()
{
  return this->Inline_;
}

void HAnimHumanoid::
Inline (const Inline_sequence& s)
{
  this->Inline_ = s;
}

const HAnimHumanoid::IntegerSequencer_sequence& HAnimHumanoid::
IntegerSequencer () const
{
  return this->IntegerSequencer_;
}

HAnimHumanoid::IntegerSequencer_sequence& HAnimHumanoid::
IntegerSequencer ()
{
  return this->IntegerSequencer_;
}

void HAnimHumanoid::
IntegerSequencer (const IntegerSequencer_sequence& s)
{
  this->IntegerSequencer_ = s;
}

const HAnimHumanoid::IntegerTrigger_sequence& HAnimHumanoid::
IntegerTrigger () const
{
  return this->IntegerTrigger_;
}

HAnimHumanoid::IntegerTrigger_sequence& HAnimHumanoid::
IntegerTrigger ()
{
  return this->IntegerTrigger_;
}

void HAnimHumanoid::
IntegerTrigger (const IntegerTrigger_sequence& s)
{
  this->IntegerTrigger_ = s;
}

const HAnimHumanoid::KeySensor_sequence& HAnimHumanoid::
KeySensor () const
{
  return this->KeySensor_;
}

HAnimHumanoid::KeySensor_sequence& HAnimHumanoid::
KeySensor ()
{
  return this->KeySensor_;
}

void HAnimHumanoid::
KeySensor (const KeySensor_sequence& s)
{
  this->KeySensor_ = s;
}

const HAnimHumanoid::PlaneSensor_sequence& HAnimHumanoid::
PlaneSensor () const
{
  return this->PlaneSensor_;
}

HAnimHumanoid::PlaneSensor_sequence& HAnimHumanoid::
PlaneSensor ()
{
  return this->PlaneSensor_;
}

void HAnimHumanoid::
PlaneSensor (const PlaneSensor_sequence& s)
{
  this->PlaneSensor_ = s;
}

const HAnimHumanoid::PointLight_sequence& HAnimHumanoid::
PointLight () const
{
  return this->PointLight_;
}

HAnimHumanoid::PointLight_sequence& HAnimHumanoid::
PointLight ()
{
  return this->PointLight_;
}

void HAnimHumanoid::
PointLight (const PointLight_sequence& s)
{
  this->PointLight_ = s;
}

const HAnimHumanoid::ProximitySensor_sequence& HAnimHumanoid::
ProximitySensor () const
{
  return this->ProximitySensor_;
}

HAnimHumanoid::ProximitySensor_sequence& HAnimHumanoid::
ProximitySensor ()
{
  return this->ProximitySensor_;
}

void HAnimHumanoid::
ProximitySensor (const ProximitySensor_sequence& s)
{
  this->ProximitySensor_ = s;
}

const HAnimHumanoid::SphereSensor_sequence& HAnimHumanoid::
SphereSensor () const
{
  return this->SphereSensor_;
}

HAnimHumanoid::SphereSensor_sequence& HAnimHumanoid::
SphereSensor ()
{
  return this->SphereSensor_;
}

void HAnimHumanoid::
SphereSensor (const SphereSensor_sequence& s)
{
  this->SphereSensor_ = s;
}

const HAnimHumanoid::SpotLight_sequence& HAnimHumanoid::
SpotLight () const
{
  return this->SpotLight_;
}

HAnimHumanoid::SpotLight_sequence& HAnimHumanoid::
SpotLight ()
{
  return this->SpotLight_;
}

void HAnimHumanoid::
SpotLight (const SpotLight_sequence& s)
{
  this->SpotLight_ = s;
}

const HAnimHumanoid::StringSensor_sequence& HAnimHumanoid::
StringSensor () const
{
  return this->StringSensor_;
}

HAnimHumanoid::StringSensor_sequence& HAnimHumanoid::
StringSensor ()
{
  return this->StringSensor_;
}

void HAnimHumanoid::
StringSensor (const StringSensor_sequence& s)
{
  this->StringSensor_ = s;
}

const HAnimHumanoid::Switch_sequence& HAnimHumanoid::
Switch () const
{
  return this->Switch_;
}

HAnimHumanoid::Switch_sequence& HAnimHumanoid::
Switch ()
{
  return this->Switch_;
}

void HAnimHumanoid::
Switch (const Switch_sequence& s)
{
  this->Switch_ = s;
}

const HAnimHumanoid::TimeTrigger_sequence& HAnimHumanoid::
TimeTrigger () const
{
  return this->TimeTrigger_;
}

HAnimHumanoid::TimeTrigger_sequence& HAnimHumanoid::
TimeTrigger ()
{
  return this->TimeTrigger_;
}

void HAnimHumanoid::
TimeTrigger (const TimeTrigger_sequence& s)
{
  this->TimeTrigger_ = s;
}

const HAnimHumanoid::TouchSensor_sequence& HAnimHumanoid::
TouchSensor () const
{
  return this->TouchSensor_;
}

HAnimHumanoid::TouchSensor_sequence& HAnimHumanoid::
TouchSensor ()
{
  return this->TouchSensor_;
}

void HAnimHumanoid::
TouchSensor (const TouchSensor_sequence& s)
{
  this->TouchSensor_ = s;
}

const HAnimHumanoid::AudioClip_sequence& HAnimHumanoid::
AudioClip () const
{
  return this->AudioClip_;
}

HAnimHumanoid::AudioClip_sequence& HAnimHumanoid::
AudioClip ()
{
  return this->AudioClip_;
}

void HAnimHumanoid::
AudioClip (const AudioClip_sequence& s)
{
  this->AudioClip_ = s;
}

const HAnimHumanoid::Billboard_sequence& HAnimHumanoid::
Billboard () const
{
  return this->Billboard_;
}

HAnimHumanoid::Billboard_sequence& HAnimHumanoid::
Billboard ()
{
  return this->Billboard_;
}

void HAnimHumanoid::
Billboard (const Billboard_sequence& s)
{
  this->Billboard_ = s;
}

const HAnimHumanoid::Collision_sequence& HAnimHumanoid::
Collision () const
{
  return this->Collision_;
}

HAnimHumanoid::Collision_sequence& HAnimHumanoid::
Collision ()
{
  return this->Collision_;
}

void HAnimHumanoid::
Collision (const Collision_sequence& s)
{
  this->Collision_ = s;
}

const HAnimHumanoid::Fog_sequence& HAnimHumanoid::
Fog () const
{
  return this->Fog_;
}

HAnimHumanoid::Fog_sequence& HAnimHumanoid::
Fog ()
{
  return this->Fog_;
}

void HAnimHumanoid::
Fog (const Fog_sequence& s)
{
  this->Fog_ = s;
}

const HAnimHumanoid::LoadSensor_sequence& HAnimHumanoid::
LoadSensor () const
{
  return this->LoadSensor_;
}

HAnimHumanoid::LoadSensor_sequence& HAnimHumanoid::
LoadSensor ()
{
  return this->LoadSensor_;
}

void HAnimHumanoid::
LoadSensor (const LoadSensor_sequence& s)
{
  this->LoadSensor_ = s;
}

const HAnimHumanoid::LocalFog_sequence& HAnimHumanoid::
LocalFog () const
{
  return this->LocalFog_;
}

HAnimHumanoid::LocalFog_sequence& HAnimHumanoid::
LocalFog ()
{
  return this->LocalFog_;
}

void HAnimHumanoid::
LocalFog (const LocalFog_sequence& s)
{
  this->LocalFog_ = s;
}

const HAnimHumanoid::LOD_sequence& HAnimHumanoid::
LOD () const
{
  return this->LOD_;
}

HAnimHumanoid::LOD_sequence& HAnimHumanoid::
LOD ()
{
  return this->LOD_;
}

void HAnimHumanoid::
LOD (const LOD_sequence& s)
{
  this->LOD_ = s;
}

const HAnimHumanoid::Script_sequence& HAnimHumanoid::
Script () const
{
  return this->Script_;
}

HAnimHumanoid::Script_sequence& HAnimHumanoid::
Script ()
{
  return this->Script_;
}

void HAnimHumanoid::
Script (const Script_sequence& s)
{
  this->Script_ = s;
}

const HAnimHumanoid::Sound_sequence& HAnimHumanoid::
Sound () const
{
  return this->Sound_;
}

HAnimHumanoid::Sound_sequence& HAnimHumanoid::
Sound ()
{
  return this->Sound_;
}

void HAnimHumanoid::
Sound (const Sound_sequence& s)
{
  this->Sound_ = s;
}

const HAnimHumanoid::VisibilitySensor_sequence& HAnimHumanoid::
VisibilitySensor () const
{
  return this->VisibilitySensor_;
}

HAnimHumanoid::VisibilitySensor_sequence& HAnimHumanoid::
VisibilitySensor ()
{
  return this->VisibilitySensor_;
}

void HAnimHumanoid::
VisibilitySensor (const VisibilitySensor_sequence& s)
{
  this->VisibilitySensor_ = s;
}

const HAnimHumanoid::CoordinateInterpolator2D_sequence& HAnimHumanoid::
CoordinateInterpolator2D () const
{
  return this->CoordinateInterpolator2D_;
}

HAnimHumanoid::CoordinateInterpolator2D_sequence& HAnimHumanoid::
CoordinateInterpolator2D ()
{
  return this->CoordinateInterpolator2D_;
}

void HAnimHumanoid::
CoordinateInterpolator2D (const CoordinateInterpolator2D_sequence& s)
{
  this->CoordinateInterpolator2D_ = s;
}

const HAnimHumanoid::PositionInterpolator2D_sequence& HAnimHumanoid::
PositionInterpolator2D () const
{
  return this->PositionInterpolator2D_;
}

HAnimHumanoid::PositionInterpolator2D_sequence& HAnimHumanoid::
PositionInterpolator2D ()
{
  return this->PositionInterpolator2D_;
}

void HAnimHumanoid::
PositionInterpolator2D (const PositionInterpolator2D_sequence& s)
{
  this->PositionInterpolator2D_ = s;
}

const HAnimHumanoid::StaticGroup_sequence& HAnimHumanoid::
StaticGroup () const
{
  return this->StaticGroup_;
}

HAnimHumanoid::StaticGroup_sequence& HAnimHumanoid::
StaticGroup ()
{
  return this->StaticGroup_;
}

void HAnimHumanoid::
StaticGroup (const StaticGroup_sequence& s)
{
  this->StaticGroup_ = s;
}

const HAnimHumanoid::CADAssembly_sequence& HAnimHumanoid::
CADAssembly () const
{
  return this->CADAssembly_;
}

HAnimHumanoid::CADAssembly_sequence& HAnimHumanoid::
CADAssembly ()
{
  return this->CADAssembly_;
}

void HAnimHumanoid::
CADAssembly (const CADAssembly_sequence& s)
{
  this->CADAssembly_ = s;
}

const HAnimHumanoid::CADLayer_sequence& HAnimHumanoid::
CADLayer () const
{
  return this->CADLayer_;
}

HAnimHumanoid::CADLayer_sequence& HAnimHumanoid::
CADLayer ()
{
  return this->CADLayer_;
}

void HAnimHumanoid::
CADLayer (const CADLayer_sequence& s)
{
  this->CADLayer_ = s;
}

const HAnimHumanoid::EspduTransform_sequence& HAnimHumanoid::
EspduTransform () const
{
  return this->EspduTransform_;
}

HAnimHumanoid::EspduTransform_sequence& HAnimHumanoid::
EspduTransform ()
{
  return this->EspduTransform_;
}

void HAnimHumanoid::
EspduTransform (const EspduTransform_sequence& s)
{
  this->EspduTransform_ = s;
}

const HAnimHumanoid::ReceiverPdu_sequence& HAnimHumanoid::
ReceiverPdu () const
{
  return this->ReceiverPdu_;
}

HAnimHumanoid::ReceiverPdu_sequence& HAnimHumanoid::
ReceiverPdu ()
{
  return this->ReceiverPdu_;
}

void HAnimHumanoid::
ReceiverPdu (const ReceiverPdu_sequence& s)
{
  this->ReceiverPdu_ = s;
}

const HAnimHumanoid::SignalPdu_sequence& HAnimHumanoid::
SignalPdu () const
{
  return this->SignalPdu_;
}

HAnimHumanoid::SignalPdu_sequence& HAnimHumanoid::
SignalPdu ()
{
  return this->SignalPdu_;
}

void HAnimHumanoid::
SignalPdu (const SignalPdu_sequence& s)
{
  this->SignalPdu_ = s;
}

const HAnimHumanoid::TransmitterPdu_sequence& HAnimHumanoid::
TransmitterPdu () const
{
  return this->TransmitterPdu_;
}

HAnimHumanoid::TransmitterPdu_sequence& HAnimHumanoid::
TransmitterPdu ()
{
  return this->TransmitterPdu_;
}

void HAnimHumanoid::
TransmitterPdu (const TransmitterPdu_sequence& s)
{
  this->TransmitterPdu_ = s;
}

const HAnimHumanoid::GeoLocation_sequence& HAnimHumanoid::
GeoLocation () const
{
  return this->GeoLocation_;
}

HAnimHumanoid::GeoLocation_sequence& HAnimHumanoid::
GeoLocation ()
{
  return this->GeoLocation_;
}

void HAnimHumanoid::
GeoLocation (const GeoLocation_sequence& s)
{
  this->GeoLocation_ = s;
}

const HAnimHumanoid::GeoLOD_sequence& HAnimHumanoid::
GeoLOD () const
{
  return this->GeoLOD_;
}

HAnimHumanoid::GeoLOD_sequence& HAnimHumanoid::
GeoLOD ()
{
  return this->GeoLOD_;
}

void HAnimHumanoid::
GeoLOD (const GeoLOD_sequence& s)
{
  this->GeoLOD_ = s;
}

const HAnimHumanoid::GeoMetadata_sequence& HAnimHumanoid::
GeoMetadata () const
{
  return this->GeoMetadata_;
}

HAnimHumanoid::GeoMetadata_sequence& HAnimHumanoid::
GeoMetadata ()
{
  return this->GeoMetadata_;
}

void HAnimHumanoid::
GeoMetadata (const GeoMetadata_sequence& s)
{
  this->GeoMetadata_ = s;
}

const HAnimHumanoid::GeoOrigin_sequence& HAnimHumanoid::
GeoOrigin () const
{
  return this->GeoOrigin_;
}

HAnimHumanoid::GeoOrigin_sequence& HAnimHumanoid::
GeoOrigin ()
{
  return this->GeoOrigin_;
}

void HAnimHumanoid::
GeoOrigin (const GeoOrigin_sequence& s)
{
  this->GeoOrigin_ = s;
}

const HAnimHumanoid::GeoPositionInterpolator_sequence& HAnimHumanoid::
GeoPositionInterpolator () const
{
  return this->GeoPositionInterpolator_;
}

HAnimHumanoid::GeoPositionInterpolator_sequence& HAnimHumanoid::
GeoPositionInterpolator ()
{
  return this->GeoPositionInterpolator_;
}

void HAnimHumanoid::
GeoPositionInterpolator (const GeoPositionInterpolator_sequence& s)
{
  this->GeoPositionInterpolator_ = s;
}

const HAnimHumanoid::GeoTouchSensor_sequence& HAnimHumanoid::
GeoTouchSensor () const
{
  return this->GeoTouchSensor_;
}

HAnimHumanoid::GeoTouchSensor_sequence& HAnimHumanoid::
GeoTouchSensor ()
{
  return this->GeoTouchSensor_;
}

void HAnimHumanoid::
GeoTouchSensor (const GeoTouchSensor_sequence& s)
{
  this->GeoTouchSensor_ = s;
}

const HAnimHumanoid::GeoViewpoint_sequence& HAnimHumanoid::
GeoViewpoint () const
{
  return this->GeoViewpoint_;
}

HAnimHumanoid::GeoViewpoint_sequence& HAnimHumanoid::
GeoViewpoint ()
{
  return this->GeoViewpoint_;
}

void HAnimHumanoid::
GeoViewpoint (const GeoViewpoint_sequence& s)
{
  this->GeoViewpoint_ = s;
}

const HAnimHumanoid::HAnimHumanoid1_sequence& HAnimHumanoid::
HAnimHumanoid1 () const
{
  return this->HAnimHumanoid1_;
}

HAnimHumanoid::HAnimHumanoid1_sequence& HAnimHumanoid::
HAnimHumanoid1 ()
{
  return this->HAnimHumanoid1_;
}

void HAnimHumanoid::
HAnimHumanoid1 (const HAnimHumanoid1_sequence& s)
{
  this->HAnimHumanoid1_ = s;
}

const HAnimHumanoid::HAnimJoint_sequence& HAnimHumanoid::
HAnimJoint () const
{
  return this->HAnimJoint_;
}

HAnimHumanoid::HAnimJoint_sequence& HAnimHumanoid::
HAnimJoint ()
{
  return this->HAnimJoint_;
}

void HAnimHumanoid::
HAnimJoint (const HAnimJoint_sequence& s)
{
  this->HAnimJoint_ = s;
}

const HAnimHumanoid::HAnimSegment_sequence& HAnimHumanoid::
HAnimSegment () const
{
  return this->HAnimSegment_;
}

HAnimHumanoid::HAnimSegment_sequence& HAnimHumanoid::
HAnimSegment ()
{
  return this->HAnimSegment_;
}

void HAnimHumanoid::
HAnimSegment (const HAnimSegment_sequence& s)
{
  this->HAnimSegment_ = s;
}

const HAnimHumanoid::HAnimSite_sequence& HAnimHumanoid::
HAnimSite () const
{
  return this->HAnimSite_;
}

HAnimHumanoid::HAnimSite_sequence& HAnimHumanoid::
HAnimSite ()
{
  return this->HAnimSite_;
}

void HAnimHumanoid::
HAnimSite (const HAnimSite_sequence& s)
{
  this->HAnimSite_ = s;
}

const HAnimHumanoid::NurbsOrientationInterpolator_sequence& HAnimHumanoid::
NurbsOrientationInterpolator () const
{
  return this->NurbsOrientationInterpolator_;
}

HAnimHumanoid::NurbsOrientationInterpolator_sequence& HAnimHumanoid::
NurbsOrientationInterpolator ()
{
  return this->NurbsOrientationInterpolator_;
}

void HAnimHumanoid::
NurbsOrientationInterpolator (const NurbsOrientationInterpolator_sequence& s)
{
  this->NurbsOrientationInterpolator_ = s;
}

const HAnimHumanoid::NurbsPositionInterpolator_sequence& HAnimHumanoid::
NurbsPositionInterpolator () const
{
  return this->NurbsPositionInterpolator_;
}

HAnimHumanoid::NurbsPositionInterpolator_sequence& HAnimHumanoid::
NurbsPositionInterpolator ()
{
  return this->NurbsPositionInterpolator_;
}

void HAnimHumanoid::
NurbsPositionInterpolator (const NurbsPositionInterpolator_sequence& s)
{
  this->NurbsPositionInterpolator_ = s;
}

const HAnimHumanoid::NurbsSurfaceInterpolator_sequence& HAnimHumanoid::
NurbsSurfaceInterpolator () const
{
  return this->NurbsSurfaceInterpolator_;
}

HAnimHumanoid::NurbsSurfaceInterpolator_sequence& HAnimHumanoid::
NurbsSurfaceInterpolator ()
{
  return this->NurbsSurfaceInterpolator_;
}

void HAnimHumanoid::
NurbsSurfaceInterpolator (const NurbsSurfaceInterpolator_sequence& s)
{
  this->NurbsSurfaceInterpolator_ = s;
}

const HAnimHumanoid::NurbsSet_sequence& HAnimHumanoid::
NurbsSet () const
{
  return this->NurbsSet_;
}

HAnimHumanoid::NurbsSet_sequence& HAnimHumanoid::
NurbsSet ()
{
  return this->NurbsSet_;
}

void HAnimHumanoid::
NurbsSet (const NurbsSet_sequence& s)
{
  this->NurbsSet_ = s;
}

const HAnimHumanoid::ProtoInstance_sequence& HAnimHumanoid::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

HAnimHumanoid::ProtoInstance_sequence& HAnimHumanoid::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void HAnimHumanoid::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const HAnimHumanoid::Coordinate_sequence& HAnimHumanoid::
Coordinate () const
{
  return this->Coordinate_;
}

HAnimHumanoid::Coordinate_sequence& HAnimHumanoid::
Coordinate ()
{
  return this->Coordinate_;
}

void HAnimHumanoid::
Coordinate (const Coordinate_sequence& s)
{
  this->Coordinate_ = s;
}

const HAnimHumanoid::CoordinateDouble_sequence& HAnimHumanoid::
CoordinateDouble () const
{
  return this->CoordinateDouble_;
}

HAnimHumanoid::CoordinateDouble_sequence& HAnimHumanoid::
CoordinateDouble ()
{
  return this->CoordinateDouble_;
}

void HAnimHumanoid::
CoordinateDouble (const CoordinateDouble_sequence& s)
{
  this->CoordinateDouble_ = s;
}

const HAnimHumanoid::Normal_sequence& HAnimHumanoid::
Normal () const
{
  return this->Normal_;
}

HAnimHumanoid::Normal_sequence& HAnimHumanoid::
Normal ()
{
  return this->Normal_;
}

void HAnimHumanoid::
Normal (const Normal_sequence& s)
{
  this->Normal_ = s;
}

const HAnimHumanoid::name_optional& HAnimHumanoid::
name () const
{
  return this->name_;
}

HAnimHumanoid::name_optional& HAnimHumanoid::
name ()
{
  return this->name_;
}

void HAnimHumanoid::
name (const name_type& x)
{
  this->name_.set (x);
}

void HAnimHumanoid::
name (const name_optional& x)
{
  this->name_ = x;
}

void HAnimHumanoid::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const HAnimHumanoid::center_type& HAnimHumanoid::
center () const
{
  return this->center_.get ();
}

HAnimHumanoid::center_type& HAnimHumanoid::
center ()
{
  return this->center_.get ();
}

void HAnimHumanoid::
center (const center_type& x)
{
  this->center_.set (x);
}

void HAnimHumanoid::
center (::std::auto_ptr< center_type > x)
{
  this->center_.set (x);
}

const HAnimHumanoid::center_type& HAnimHumanoid::
center_default_value ()
{
  return center_default_value_;
}

const HAnimHumanoid::rotation_type& HAnimHumanoid::
rotation () const
{
  return this->rotation_.get ();
}

HAnimHumanoid::rotation_type& HAnimHumanoid::
rotation ()
{
  return this->rotation_.get ();
}

void HAnimHumanoid::
rotation (const rotation_type& x)
{
  this->rotation_.set (x);
}

void HAnimHumanoid::
rotation (::std::auto_ptr< rotation_type > x)
{
  this->rotation_.set (x);
}

const HAnimHumanoid::rotation_type& HAnimHumanoid::
rotation_default_value ()
{
  return rotation_default_value_;
}

const HAnimHumanoid::scale_type& HAnimHumanoid::
scale () const
{
  return this->scale_.get ();
}

HAnimHumanoid::scale_type& HAnimHumanoid::
scale ()
{
  return this->scale_.get ();
}

void HAnimHumanoid::
scale (const scale_type& x)
{
  this->scale_.set (x);
}

void HAnimHumanoid::
scale (::std::auto_ptr< scale_type > x)
{
  this->scale_.set (x);
}

const HAnimHumanoid::scale_type& HAnimHumanoid::
scale_default_value ()
{
  return scale_default_value_;
}

const HAnimHumanoid::scaleOrientation_type& HAnimHumanoid::
scaleOrientation () const
{
  return this->scaleOrientation_.get ();
}

HAnimHumanoid::scaleOrientation_type& HAnimHumanoid::
scaleOrientation ()
{
  return this->scaleOrientation_.get ();
}

void HAnimHumanoid::
scaleOrientation (const scaleOrientation_type& x)
{
  this->scaleOrientation_.set (x);
}

void HAnimHumanoid::
scaleOrientation (::std::auto_ptr< scaleOrientation_type > x)
{
  this->scaleOrientation_.set (x);
}

const HAnimHumanoid::scaleOrientation_type& HAnimHumanoid::
scaleOrientation_default_value ()
{
  return scaleOrientation_default_value_;
}

const HAnimHumanoid::translation_type& HAnimHumanoid::
translation () const
{
  return this->translation_.get ();
}

HAnimHumanoid::translation_type& HAnimHumanoid::
translation ()
{
  return this->translation_.get ();
}

void HAnimHumanoid::
translation (const translation_type& x)
{
  this->translation_.set (x);
}

void HAnimHumanoid::
translation (::std::auto_ptr< translation_type > x)
{
  this->translation_.set (x);
}

const HAnimHumanoid::translation_type& HAnimHumanoid::
translation_default_value ()
{
  return translation_default_value_;
}

const HAnimHumanoid::info_optional& HAnimHumanoid::
info () const
{
  return this->info_;
}

HAnimHumanoid::info_optional& HAnimHumanoid::
info ()
{
  return this->info_;
}

void HAnimHumanoid::
info (const info_type& x)
{
  this->info_.set (x);
}

void HAnimHumanoid::
info (const info_optional& x)
{
  this->info_ = x;
}

void HAnimHumanoid::
info (::std::auto_ptr< info_type > x)
{
  this->info_.set (x);
}

const HAnimHumanoid::version_optional& HAnimHumanoid::
version () const
{
  return this->version_;
}

HAnimHumanoid::version_optional& HAnimHumanoid::
version ()
{
  return this->version_;
}

void HAnimHumanoid::
version (const version_type& x)
{
  this->version_.set (x);
}

void HAnimHumanoid::
version (const version_optional& x)
{
  this->version_ = x;
}

void HAnimHumanoid::
version (::std::auto_ptr< version_type > x)
{
  this->version_.set (x);
}


// HAnimJoint
// 

const HAnimJoint::name_optional& HAnimJoint::
name () const
{
  return this->name_;
}

HAnimJoint::name_optional& HAnimJoint::
name ()
{
  return this->name_;
}

void HAnimJoint::
name (const name_type& x)
{
  this->name_.set (x);
}

void HAnimJoint::
name (const name_optional& x)
{
  this->name_ = x;
}

void HAnimJoint::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const HAnimJoint::center_type& HAnimJoint::
center () const
{
  return this->center_.get ();
}

HAnimJoint::center_type& HAnimJoint::
center ()
{
  return this->center_.get ();
}

void HAnimJoint::
center (const center_type& x)
{
  this->center_.set (x);
}

void HAnimJoint::
center (::std::auto_ptr< center_type > x)
{
  this->center_.set (x);
}

const HAnimJoint::center_type& HAnimJoint::
center_default_value ()
{
  return center_default_value_;
}

const HAnimJoint::rotation_type& HAnimJoint::
rotation () const
{
  return this->rotation_.get ();
}

HAnimJoint::rotation_type& HAnimJoint::
rotation ()
{
  return this->rotation_.get ();
}

void HAnimJoint::
rotation (const rotation_type& x)
{
  this->rotation_.set (x);
}

void HAnimJoint::
rotation (::std::auto_ptr< rotation_type > x)
{
  this->rotation_.set (x);
}

const HAnimJoint::rotation_type& HAnimJoint::
rotation_default_value ()
{
  return rotation_default_value_;
}

const HAnimJoint::scale_type& HAnimJoint::
scale () const
{
  return this->scale_.get ();
}

HAnimJoint::scale_type& HAnimJoint::
scale ()
{
  return this->scale_.get ();
}

void HAnimJoint::
scale (const scale_type& x)
{
  this->scale_.set (x);
}

void HAnimJoint::
scale (::std::auto_ptr< scale_type > x)
{
  this->scale_.set (x);
}

const HAnimJoint::scale_type& HAnimJoint::
scale_default_value ()
{
  return scale_default_value_;
}

const HAnimJoint::scaleOrientation_type& HAnimJoint::
scaleOrientation () const
{
  return this->scaleOrientation_.get ();
}

HAnimJoint::scaleOrientation_type& HAnimJoint::
scaleOrientation ()
{
  return this->scaleOrientation_.get ();
}

void HAnimJoint::
scaleOrientation (const scaleOrientation_type& x)
{
  this->scaleOrientation_.set (x);
}

void HAnimJoint::
scaleOrientation (::std::auto_ptr< scaleOrientation_type > x)
{
  this->scaleOrientation_.set (x);
}

const HAnimJoint::scaleOrientation_type& HAnimJoint::
scaleOrientation_default_value ()
{
  return scaleOrientation_default_value_;
}

const HAnimJoint::translation_type& HAnimJoint::
translation () const
{
  return this->translation_.get ();
}

HAnimJoint::translation_type& HAnimJoint::
translation ()
{
  return this->translation_.get ();
}

void HAnimJoint::
translation (const translation_type& x)
{
  this->translation_.set (x);
}

void HAnimJoint::
translation (::std::auto_ptr< translation_type > x)
{
  this->translation_.set (x);
}

const HAnimJoint::translation_type& HAnimJoint::
translation_default_value ()
{
  return translation_default_value_;
}

const HAnimJoint::skinCoordIndex_optional& HAnimJoint::
skinCoordIndex () const
{
  return this->skinCoordIndex_;
}

HAnimJoint::skinCoordIndex_optional& HAnimJoint::
skinCoordIndex ()
{
  return this->skinCoordIndex_;
}

void HAnimJoint::
skinCoordIndex (const skinCoordIndex_type& x)
{
  this->skinCoordIndex_.set (x);
}

void HAnimJoint::
skinCoordIndex (const skinCoordIndex_optional& x)
{
  this->skinCoordIndex_ = x;
}

void HAnimJoint::
skinCoordIndex (::std::auto_ptr< skinCoordIndex_type > x)
{
  this->skinCoordIndex_.set (x);
}

const HAnimJoint::skinCoordWeight_optional& HAnimJoint::
skinCoordWeight () const
{
  return this->skinCoordWeight_;
}

HAnimJoint::skinCoordWeight_optional& HAnimJoint::
skinCoordWeight ()
{
  return this->skinCoordWeight_;
}

void HAnimJoint::
skinCoordWeight (const skinCoordWeight_type& x)
{
  this->skinCoordWeight_.set (x);
}

void HAnimJoint::
skinCoordWeight (const skinCoordWeight_optional& x)
{
  this->skinCoordWeight_ = x;
}

void HAnimJoint::
skinCoordWeight (::std::auto_ptr< skinCoordWeight_type > x)
{
  this->skinCoordWeight_.set (x);
}

const HAnimJoint::llimit_optional& HAnimJoint::
llimit () const
{
  return this->llimit_;
}

HAnimJoint::llimit_optional& HAnimJoint::
llimit ()
{
  return this->llimit_;
}

void HAnimJoint::
llimit (const llimit_type& x)
{
  this->llimit_.set (x);
}

void HAnimJoint::
llimit (const llimit_optional& x)
{
  this->llimit_ = x;
}

void HAnimJoint::
llimit (::std::auto_ptr< llimit_type > x)
{
  this->llimit_.set (x);
}

const HAnimJoint::ulimit_optional& HAnimJoint::
ulimit () const
{
  return this->ulimit_;
}

HAnimJoint::ulimit_optional& HAnimJoint::
ulimit ()
{
  return this->ulimit_;
}

void HAnimJoint::
ulimit (const ulimit_type& x)
{
  this->ulimit_.set (x);
}

void HAnimJoint::
ulimit (const ulimit_optional& x)
{
  this->ulimit_ = x;
}

void HAnimJoint::
ulimit (::std::auto_ptr< ulimit_type > x)
{
  this->ulimit_.set (x);
}

const HAnimJoint::limitOrientation_type& HAnimJoint::
limitOrientation () const
{
  return this->limitOrientation_.get ();
}

HAnimJoint::limitOrientation_type& HAnimJoint::
limitOrientation ()
{
  return this->limitOrientation_.get ();
}

void HAnimJoint::
limitOrientation (const limitOrientation_type& x)
{
  this->limitOrientation_.set (x);
}

void HAnimJoint::
limitOrientation (::std::auto_ptr< limitOrientation_type > x)
{
  this->limitOrientation_.set (x);
}

const HAnimJoint::limitOrientation_type& HAnimJoint::
limitOrientation_default_value ()
{
  return limitOrientation_default_value_;
}

const HAnimJoint::stiffness_type& HAnimJoint::
stiffness () const
{
  return this->stiffness_.get ();
}

HAnimJoint::stiffness_type& HAnimJoint::
stiffness ()
{
  return this->stiffness_.get ();
}

void HAnimJoint::
stiffness (const stiffness_type& x)
{
  this->stiffness_.set (x);
}

void HAnimJoint::
stiffness (::std::auto_ptr< stiffness_type > x)
{
  this->stiffness_.set (x);
}

const HAnimJoint::stiffness_type& HAnimJoint::
stiffness_default_value ()
{
  return stiffness_default_value_;
}


// HAnimSegment
// 

const HAnimSegment::HAnimDisplacer_sequence& HAnimSegment::
HAnimDisplacer () const
{
  return this->HAnimDisplacer_;
}

HAnimSegment::HAnimDisplacer_sequence& HAnimSegment::
HAnimDisplacer ()
{
  return this->HAnimDisplacer_;
}

void HAnimSegment::
HAnimDisplacer (const HAnimDisplacer_sequence& s)
{
  this->HAnimDisplacer_ = s;
}

const HAnimSegment::name_optional& HAnimSegment::
name () const
{
  return this->name_;
}

HAnimSegment::name_optional& HAnimSegment::
name ()
{
  return this->name_;
}

void HAnimSegment::
name (const name_type& x)
{
  this->name_.set (x);
}

void HAnimSegment::
name (const name_optional& x)
{
  this->name_ = x;
}

void HAnimSegment::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const HAnimSegment::mass_type& HAnimSegment::
mass () const
{
  return this->mass_.get ();
}

HAnimSegment::mass_type& HAnimSegment::
mass ()
{
  return this->mass_.get ();
}

void HAnimSegment::
mass (const mass_type& x)
{
  this->mass_.set (x);
}

void HAnimSegment::
mass (::std::auto_ptr< mass_type > x)
{
  this->mass_.set (x);
}

const HAnimSegment::mass_type& HAnimSegment::
mass_default_value ()
{
  return mass_default_value_;
}

const HAnimSegment::centerOfMass_type& HAnimSegment::
centerOfMass () const
{
  return this->centerOfMass_.get ();
}

HAnimSegment::centerOfMass_type& HAnimSegment::
centerOfMass ()
{
  return this->centerOfMass_.get ();
}

void HAnimSegment::
centerOfMass (const centerOfMass_type& x)
{
  this->centerOfMass_.set (x);
}

void HAnimSegment::
centerOfMass (::std::auto_ptr< centerOfMass_type > x)
{
  this->centerOfMass_.set (x);
}

const HAnimSegment::centerOfMass_type& HAnimSegment::
centerOfMass_default_value ()
{
  return centerOfMass_default_value_;
}

const HAnimSegment::momentsOfInertia_type& HAnimSegment::
momentsOfInertia () const
{
  return this->momentsOfInertia_.get ();
}

HAnimSegment::momentsOfInertia_type& HAnimSegment::
momentsOfInertia ()
{
  return this->momentsOfInertia_.get ();
}

void HAnimSegment::
momentsOfInertia (const momentsOfInertia_type& x)
{
  this->momentsOfInertia_.set (x);
}

void HAnimSegment::
momentsOfInertia (::std::auto_ptr< momentsOfInertia_type > x)
{
  this->momentsOfInertia_.set (x);
}

const HAnimSegment::momentsOfInertia_type& HAnimSegment::
momentsOfInertia_default_value ()
{
  return momentsOfInertia_default_value_;
}


// HAnimSite
// 

const HAnimSite::name_optional& HAnimSite::
name () const
{
  return this->name_;
}

HAnimSite::name_optional& HAnimSite::
name ()
{
  return this->name_;
}

void HAnimSite::
name (const name_type& x)
{
  this->name_.set (x);
}

void HAnimSite::
name (const name_optional& x)
{
  this->name_ = x;
}

void HAnimSite::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const HAnimSite::center_type& HAnimSite::
center () const
{
  return this->center_.get ();
}

HAnimSite::center_type& HAnimSite::
center ()
{
  return this->center_.get ();
}

void HAnimSite::
center (const center_type& x)
{
  this->center_.set (x);
}

void HAnimSite::
center (::std::auto_ptr< center_type > x)
{
  this->center_.set (x);
}

const HAnimSite::center_type& HAnimSite::
center_default_value ()
{
  return center_default_value_;
}

const HAnimSite::rotation_type& HAnimSite::
rotation () const
{
  return this->rotation_.get ();
}

HAnimSite::rotation_type& HAnimSite::
rotation ()
{
  return this->rotation_.get ();
}

void HAnimSite::
rotation (const rotation_type& x)
{
  this->rotation_.set (x);
}

void HAnimSite::
rotation (::std::auto_ptr< rotation_type > x)
{
  this->rotation_.set (x);
}

const HAnimSite::rotation_type& HAnimSite::
rotation_default_value ()
{
  return rotation_default_value_;
}

const HAnimSite::scale_type& HAnimSite::
scale () const
{
  return this->scale_.get ();
}

HAnimSite::scale_type& HAnimSite::
scale ()
{
  return this->scale_.get ();
}

void HAnimSite::
scale (const scale_type& x)
{
  this->scale_.set (x);
}

void HAnimSite::
scale (::std::auto_ptr< scale_type > x)
{
  this->scale_.set (x);
}

const HAnimSite::scale_type& HAnimSite::
scale_default_value ()
{
  return scale_default_value_;
}

const HAnimSite::scaleOrientation_type& HAnimSite::
scaleOrientation () const
{
  return this->scaleOrientation_.get ();
}

HAnimSite::scaleOrientation_type& HAnimSite::
scaleOrientation ()
{
  return this->scaleOrientation_.get ();
}

void HAnimSite::
scaleOrientation (const scaleOrientation_type& x)
{
  this->scaleOrientation_.set (x);
}

void HAnimSite::
scaleOrientation (::std::auto_ptr< scaleOrientation_type > x)
{
  this->scaleOrientation_.set (x);
}

const HAnimSite::scaleOrientation_type& HAnimSite::
scaleOrientation_default_value ()
{
  return scaleOrientation_default_value_;
}

const HAnimSite::translation_type& HAnimSite::
translation () const
{
  return this->translation_.get ();
}

HAnimSite::translation_type& HAnimSite::
translation ()
{
  return this->translation_.get ();
}

void HAnimSite::
translation (const translation_type& x)
{
  this->translation_.set (x);
}

void HAnimSite::
translation (::std::auto_ptr< translation_type > x)
{
  this->translation_.set (x);
}

const HAnimSite::translation_type& HAnimSite::
translation_default_value ()
{
  return translation_default_value_;
}


// Contour2D
// 

const Contour2D::NurbsCurve2D_sequence& Contour2D::
NurbsCurve2D () const
{
  return this->NurbsCurve2D_;
}

Contour2D::NurbsCurve2D_sequence& Contour2D::
NurbsCurve2D ()
{
  return this->NurbsCurve2D_;
}

void Contour2D::
NurbsCurve2D (const NurbsCurve2D_sequence& s)
{
  this->NurbsCurve2D_ = s;
}

const Contour2D::ContourPolyline2D_sequence& Contour2D::
ContourPolyline2D () const
{
  return this->ContourPolyline2D_;
}

Contour2D::ContourPolyline2D_sequence& Contour2D::
ContourPolyline2D ()
{
  return this->ContourPolyline2D_;
}

void Contour2D::
ContourPolyline2D (const ContourPolyline2D_sequence& s)
{
  this->ContourPolyline2D_ = s;
}

const Contour2D::ProtoInstance_sequence& Contour2D::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

Contour2D::ProtoInstance_sequence& Contour2D::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void Contour2D::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const Contour2D::containerField_type& Contour2D::
containerField () const
{
  return this->containerField_.get ();
}

Contour2D::containerField_type& Contour2D::
containerField ()
{
  return this->containerField_.get ();
}

void Contour2D::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void Contour2D::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const Contour2D::containerField_type& Contour2D::
containerField_default_value ()
{
  return containerField_default_value_;
}


// ContourPolyline2D
// 


// NurbsCurve
// 

const NurbsCurve::Coordinate_optional& NurbsCurve::
Coordinate () const
{
  return this->Coordinate_;
}

NurbsCurve::Coordinate_optional& NurbsCurve::
Coordinate ()
{
  return this->Coordinate_;
}

void NurbsCurve::
Coordinate (const Coordinate_type& x)
{
  this->Coordinate_.set (x);
}

void NurbsCurve::
Coordinate (const Coordinate_optional& x)
{
  this->Coordinate_ = x;
}

void NurbsCurve::
Coordinate (::std::auto_ptr< Coordinate_type > x)
{
  this->Coordinate_.set (x);
}

const NurbsCurve::CoordinateDouble_optional& NurbsCurve::
CoordinateDouble () const
{
  return this->CoordinateDouble_;
}

NurbsCurve::CoordinateDouble_optional& NurbsCurve::
CoordinateDouble ()
{
  return this->CoordinateDouble_;
}

void NurbsCurve::
CoordinateDouble (const CoordinateDouble_type& x)
{
  this->CoordinateDouble_.set (x);
}

void NurbsCurve::
CoordinateDouble (const CoordinateDouble_optional& x)
{
  this->CoordinateDouble_ = x;
}

void NurbsCurve::
CoordinateDouble (::std::auto_ptr< CoordinateDouble_type > x)
{
  this->CoordinateDouble_.set (x);
}

const NurbsCurve::ProtoInstance_optional& NurbsCurve::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

NurbsCurve::ProtoInstance_optional& NurbsCurve::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void NurbsCurve::
ProtoInstance (const ProtoInstance_type& x)
{
  this->ProtoInstance_.set (x);
}

void NurbsCurve::
ProtoInstance (const ProtoInstance_optional& x)
{
  this->ProtoInstance_ = x;
}

void NurbsCurve::
ProtoInstance (::std::auto_ptr< ProtoInstance_type > x)
{
  this->ProtoInstance_.set (x);
}

const NurbsCurve::closed_type& NurbsCurve::
closed () const
{
  return this->closed_.get ();
}

NurbsCurve::closed_type& NurbsCurve::
closed ()
{
  return this->closed_.get ();
}

void NurbsCurve::
closed (const closed_type& x)
{
  this->closed_.set (x);
}

void NurbsCurve::
closed (::std::auto_ptr< closed_type > x)
{
  this->closed_.set (x);
}

const NurbsCurve::closed_type& NurbsCurve::
closed_default_value ()
{
  return closed_default_value_;
}

const NurbsCurve::knot_optional& NurbsCurve::
knot () const
{
  return this->knot_;
}

NurbsCurve::knot_optional& NurbsCurve::
knot ()
{
  return this->knot_;
}

void NurbsCurve::
knot (const knot_type& x)
{
  this->knot_.set (x);
}

void NurbsCurve::
knot (const knot_optional& x)
{
  this->knot_ = x;
}

void NurbsCurve::
knot (::std::auto_ptr< knot_type > x)
{
  this->knot_.set (x);
}

const NurbsCurve::order_type& NurbsCurve::
order () const
{
  return this->order_.get ();
}

NurbsCurve::order_type& NurbsCurve::
order ()
{
  return this->order_.get ();
}

void NurbsCurve::
order (const order_type& x)
{
  this->order_.set (x);
}

void NurbsCurve::
order (::std::auto_ptr< order_type > x)
{
  this->order_.set (x);
}

const NurbsCurve::order_type& NurbsCurve::
order_default_value ()
{
  return order_default_value_;
}

const NurbsCurve::tessellation_type& NurbsCurve::
tessellation () const
{
  return this->tessellation_.get ();
}

NurbsCurve::tessellation_type& NurbsCurve::
tessellation ()
{
  return this->tessellation_.get ();
}

void NurbsCurve::
tessellation (const tessellation_type& x)
{
  this->tessellation_.set (x);
}

void NurbsCurve::
tessellation (::std::auto_ptr< tessellation_type > x)
{
  this->tessellation_.set (x);
}

const NurbsCurve::tessellation_type& NurbsCurve::
tessellation_default_value ()
{
  return tessellation_default_value_;
}

const NurbsCurve::weight_optional& NurbsCurve::
weight () const
{
  return this->weight_;
}

NurbsCurve::weight_optional& NurbsCurve::
weight ()
{
  return this->weight_;
}

void NurbsCurve::
weight (const weight_type& x)
{
  this->weight_.set (x);
}

void NurbsCurve::
weight (const weight_optional& x)
{
  this->weight_ = x;
}

void NurbsCurve::
weight (::std::auto_ptr< weight_type > x)
{
  this->weight_.set (x);
}


// NurbsCurve2D
// 

const NurbsCurve2D::closed_type& NurbsCurve2D::
closed () const
{
  return this->closed_.get ();
}

NurbsCurve2D::closed_type& NurbsCurve2D::
closed ()
{
  return this->closed_.get ();
}

void NurbsCurve2D::
closed (const closed_type& x)
{
  this->closed_.set (x);
}

void NurbsCurve2D::
closed (::std::auto_ptr< closed_type > x)
{
  this->closed_.set (x);
}

const NurbsCurve2D::closed_type& NurbsCurve2D::
closed_default_value ()
{
  return closed_default_value_;
}

const NurbsCurve2D::knot_optional& NurbsCurve2D::
knot () const
{
  return this->knot_;
}

NurbsCurve2D::knot_optional& NurbsCurve2D::
knot ()
{
  return this->knot_;
}

void NurbsCurve2D::
knot (const knot_type& x)
{
  this->knot_.set (x);
}

void NurbsCurve2D::
knot (const knot_optional& x)
{
  this->knot_ = x;
}

void NurbsCurve2D::
knot (::std::auto_ptr< knot_type > x)
{
  this->knot_.set (x);
}

const NurbsCurve2D::order_type& NurbsCurve2D::
order () const
{
  return this->order_.get ();
}

NurbsCurve2D::order_type& NurbsCurve2D::
order ()
{
  return this->order_.get ();
}

void NurbsCurve2D::
order (const order_type& x)
{
  this->order_.set (x);
}

void NurbsCurve2D::
order (::std::auto_ptr< order_type > x)
{
  this->order_.set (x);
}

const NurbsCurve2D::order_type& NurbsCurve2D::
order_default_value ()
{
  return order_default_value_;
}

const NurbsCurve2D::tessellation_type& NurbsCurve2D::
tessellation () const
{
  return this->tessellation_.get ();
}

NurbsCurve2D::tessellation_type& NurbsCurve2D::
tessellation ()
{
  return this->tessellation_.get ();
}

void NurbsCurve2D::
tessellation (const tessellation_type& x)
{
  this->tessellation_.set (x);
}

void NurbsCurve2D::
tessellation (::std::auto_ptr< tessellation_type > x)
{
  this->tessellation_.set (x);
}

const NurbsCurve2D::tessellation_type& NurbsCurve2D::
tessellation_default_value ()
{
  return tessellation_default_value_;
}

const NurbsCurve2D::weight_optional& NurbsCurve2D::
weight () const
{
  return this->weight_;
}

NurbsCurve2D::weight_optional& NurbsCurve2D::
weight ()
{
  return this->weight_;
}

void NurbsCurve2D::
weight (const weight_type& x)
{
  this->weight_.set (x);
}

void NurbsCurve2D::
weight (const weight_optional& x)
{
  this->weight_ = x;
}

void NurbsCurve2D::
weight (::std::auto_ptr< weight_type > x)
{
  this->weight_.set (x);
}


// NurbsOrientationInterpolator
// 

const NurbsOrientationInterpolator::Coordinate_optional& NurbsOrientationInterpolator::
Coordinate () const
{
  return this->Coordinate_;
}

NurbsOrientationInterpolator::Coordinate_optional& NurbsOrientationInterpolator::
Coordinate ()
{
  return this->Coordinate_;
}

void NurbsOrientationInterpolator::
Coordinate (const Coordinate_type& x)
{
  this->Coordinate_.set (x);
}

void NurbsOrientationInterpolator::
Coordinate (const Coordinate_optional& x)
{
  this->Coordinate_ = x;
}

void NurbsOrientationInterpolator::
Coordinate (::std::auto_ptr< Coordinate_type > x)
{
  this->Coordinate_.set (x);
}

const NurbsOrientationInterpolator::CoordinateDouble_optional& NurbsOrientationInterpolator::
CoordinateDouble () const
{
  return this->CoordinateDouble_;
}

NurbsOrientationInterpolator::CoordinateDouble_optional& NurbsOrientationInterpolator::
CoordinateDouble ()
{
  return this->CoordinateDouble_;
}

void NurbsOrientationInterpolator::
CoordinateDouble (const CoordinateDouble_type& x)
{
  this->CoordinateDouble_.set (x);
}

void NurbsOrientationInterpolator::
CoordinateDouble (const CoordinateDouble_optional& x)
{
  this->CoordinateDouble_ = x;
}

void NurbsOrientationInterpolator::
CoordinateDouble (::std::auto_ptr< CoordinateDouble_type > x)
{
  this->CoordinateDouble_.set (x);
}

const NurbsOrientationInterpolator::ProtoInstance_optional& NurbsOrientationInterpolator::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

NurbsOrientationInterpolator::ProtoInstance_optional& NurbsOrientationInterpolator::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void NurbsOrientationInterpolator::
ProtoInstance (const ProtoInstance_type& x)
{
  this->ProtoInstance_.set (x);
}

void NurbsOrientationInterpolator::
ProtoInstance (const ProtoInstance_optional& x)
{
  this->ProtoInstance_ = x;
}

void NurbsOrientationInterpolator::
ProtoInstance (::std::auto_ptr< ProtoInstance_type > x)
{
  this->ProtoInstance_.set (x);
}

const NurbsOrientationInterpolator::knot_optional& NurbsOrientationInterpolator::
knot () const
{
  return this->knot_;
}

NurbsOrientationInterpolator::knot_optional& NurbsOrientationInterpolator::
knot ()
{
  return this->knot_;
}

void NurbsOrientationInterpolator::
knot (const knot_type& x)
{
  this->knot_.set (x);
}

void NurbsOrientationInterpolator::
knot (const knot_optional& x)
{
  this->knot_ = x;
}

void NurbsOrientationInterpolator::
knot (::std::auto_ptr< knot_type > x)
{
  this->knot_.set (x);
}

const NurbsOrientationInterpolator::order_type& NurbsOrientationInterpolator::
order () const
{
  return this->order_.get ();
}

NurbsOrientationInterpolator::order_type& NurbsOrientationInterpolator::
order ()
{
  return this->order_.get ();
}

void NurbsOrientationInterpolator::
order (const order_type& x)
{
  this->order_.set (x);
}

void NurbsOrientationInterpolator::
order (::std::auto_ptr< order_type > x)
{
  this->order_.set (x);
}

const NurbsOrientationInterpolator::order_type& NurbsOrientationInterpolator::
order_default_value ()
{
  return order_default_value_;
}

const NurbsOrientationInterpolator::weight_optional& NurbsOrientationInterpolator::
weight () const
{
  return this->weight_;
}

NurbsOrientationInterpolator::weight_optional& NurbsOrientationInterpolator::
weight ()
{
  return this->weight_;
}

void NurbsOrientationInterpolator::
weight (const weight_type& x)
{
  this->weight_.set (x);
}

void NurbsOrientationInterpolator::
weight (const weight_optional& x)
{
  this->weight_ = x;
}

void NurbsOrientationInterpolator::
weight (::std::auto_ptr< weight_type > x)
{
  this->weight_.set (x);
}


// NurbsPatchSurface
// 

const NurbsPatchSurface::Coordinate_sequence& NurbsPatchSurface::
Coordinate () const
{
  return this->Coordinate_;
}

NurbsPatchSurface::Coordinate_sequence& NurbsPatchSurface::
Coordinate ()
{
  return this->Coordinate_;
}

void NurbsPatchSurface::
Coordinate (const Coordinate_sequence& s)
{
  this->Coordinate_ = s;
}

const NurbsPatchSurface::CoordinateDouble_sequence& NurbsPatchSurface::
CoordinateDouble () const
{
  return this->CoordinateDouble_;
}

NurbsPatchSurface::CoordinateDouble_sequence& NurbsPatchSurface::
CoordinateDouble ()
{
  return this->CoordinateDouble_;
}

void NurbsPatchSurface::
CoordinateDouble (const CoordinateDouble_sequence& s)
{
  this->CoordinateDouble_ = s;
}

const NurbsPatchSurface::TextureCoordinate_sequence& NurbsPatchSurface::
TextureCoordinate () const
{
  return this->TextureCoordinate_;
}

NurbsPatchSurface::TextureCoordinate_sequence& NurbsPatchSurface::
TextureCoordinate ()
{
  return this->TextureCoordinate_;
}

void NurbsPatchSurface::
TextureCoordinate (const TextureCoordinate_sequence& s)
{
  this->TextureCoordinate_ = s;
}

const NurbsPatchSurface::TextureCoordinateGenerator_sequence& NurbsPatchSurface::
TextureCoordinateGenerator () const
{
  return this->TextureCoordinateGenerator_;
}

NurbsPatchSurface::TextureCoordinateGenerator_sequence& NurbsPatchSurface::
TextureCoordinateGenerator ()
{
  return this->TextureCoordinateGenerator_;
}

void NurbsPatchSurface::
TextureCoordinateGenerator (const TextureCoordinateGenerator_sequence& s)
{
  this->TextureCoordinateGenerator_ = s;
}

const NurbsPatchSurface::NurbsTextureCoordinate_sequence& NurbsPatchSurface::
NurbsTextureCoordinate () const
{
  return this->NurbsTextureCoordinate_;
}

NurbsPatchSurface::NurbsTextureCoordinate_sequence& NurbsPatchSurface::
NurbsTextureCoordinate ()
{
  return this->NurbsTextureCoordinate_;
}

void NurbsPatchSurface::
NurbsTextureCoordinate (const NurbsTextureCoordinate_sequence& s)
{
  this->NurbsTextureCoordinate_ = s;
}

const NurbsPatchSurface::ProtoInstance_sequence& NurbsPatchSurface::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

NurbsPatchSurface::ProtoInstance_sequence& NurbsPatchSurface::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void NurbsPatchSurface::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}


// NurbsPositionInterpolator
// 

const NurbsPositionInterpolator::Coordinate_optional& NurbsPositionInterpolator::
Coordinate () const
{
  return this->Coordinate_;
}

NurbsPositionInterpolator::Coordinate_optional& NurbsPositionInterpolator::
Coordinate ()
{
  return this->Coordinate_;
}

void NurbsPositionInterpolator::
Coordinate (const Coordinate_type& x)
{
  this->Coordinate_.set (x);
}

void NurbsPositionInterpolator::
Coordinate (const Coordinate_optional& x)
{
  this->Coordinate_ = x;
}

void NurbsPositionInterpolator::
Coordinate (::std::auto_ptr< Coordinate_type > x)
{
  this->Coordinate_.set (x);
}

const NurbsPositionInterpolator::CoordinateDouble_optional& NurbsPositionInterpolator::
CoordinateDouble () const
{
  return this->CoordinateDouble_;
}

NurbsPositionInterpolator::CoordinateDouble_optional& NurbsPositionInterpolator::
CoordinateDouble ()
{
  return this->CoordinateDouble_;
}

void NurbsPositionInterpolator::
CoordinateDouble (const CoordinateDouble_type& x)
{
  this->CoordinateDouble_.set (x);
}

void NurbsPositionInterpolator::
CoordinateDouble (const CoordinateDouble_optional& x)
{
  this->CoordinateDouble_ = x;
}

void NurbsPositionInterpolator::
CoordinateDouble (::std::auto_ptr< CoordinateDouble_type > x)
{
  this->CoordinateDouble_.set (x);
}

const NurbsPositionInterpolator::ProtoInstance_optional& NurbsPositionInterpolator::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

NurbsPositionInterpolator::ProtoInstance_optional& NurbsPositionInterpolator::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void NurbsPositionInterpolator::
ProtoInstance (const ProtoInstance_type& x)
{
  this->ProtoInstance_.set (x);
}

void NurbsPositionInterpolator::
ProtoInstance (const ProtoInstance_optional& x)
{
  this->ProtoInstance_ = x;
}

void NurbsPositionInterpolator::
ProtoInstance (::std::auto_ptr< ProtoInstance_type > x)
{
  this->ProtoInstance_.set (x);
}

const NurbsPositionInterpolator::knot_optional& NurbsPositionInterpolator::
knot () const
{
  return this->knot_;
}

NurbsPositionInterpolator::knot_optional& NurbsPositionInterpolator::
knot ()
{
  return this->knot_;
}

void NurbsPositionInterpolator::
knot (const knot_type& x)
{
  this->knot_.set (x);
}

void NurbsPositionInterpolator::
knot (const knot_optional& x)
{
  this->knot_ = x;
}

void NurbsPositionInterpolator::
knot (::std::auto_ptr< knot_type > x)
{
  this->knot_.set (x);
}

const NurbsPositionInterpolator::order_type& NurbsPositionInterpolator::
order () const
{
  return this->order_.get ();
}

NurbsPositionInterpolator::order_type& NurbsPositionInterpolator::
order ()
{
  return this->order_.get ();
}

void NurbsPositionInterpolator::
order (const order_type& x)
{
  this->order_.set (x);
}

void NurbsPositionInterpolator::
order (::std::auto_ptr< order_type > x)
{
  this->order_.set (x);
}

const NurbsPositionInterpolator::order_type& NurbsPositionInterpolator::
order_default_value ()
{
  return order_default_value_;
}

const NurbsPositionInterpolator::weight_optional& NurbsPositionInterpolator::
weight () const
{
  return this->weight_;
}

NurbsPositionInterpolator::weight_optional& NurbsPositionInterpolator::
weight ()
{
  return this->weight_;
}

void NurbsPositionInterpolator::
weight (const weight_type& x)
{
  this->weight_.set (x);
}

void NurbsPositionInterpolator::
weight (const weight_optional& x)
{
  this->weight_ = x;
}

void NurbsPositionInterpolator::
weight (::std::auto_ptr< weight_type > x)
{
  this->weight_.set (x);
}


// NurbsSet
// 

const NurbsSet::NurbsPatchSurface_sequence& NurbsSet::
NurbsPatchSurface () const
{
  return this->NurbsPatchSurface_;
}

NurbsSet::NurbsPatchSurface_sequence& NurbsSet::
NurbsPatchSurface ()
{
  return this->NurbsPatchSurface_;
}

void NurbsSet::
NurbsPatchSurface (const NurbsPatchSurface_sequence& s)
{
  this->NurbsPatchSurface_ = s;
}

const NurbsSet::NurbsSweptSurface_sequence& NurbsSet::
NurbsSweptSurface () const
{
  return this->NurbsSweptSurface_;
}

NurbsSet::NurbsSweptSurface_sequence& NurbsSet::
NurbsSweptSurface ()
{
  return this->NurbsSweptSurface_;
}

void NurbsSet::
NurbsSweptSurface (const NurbsSweptSurface_sequence& s)
{
  this->NurbsSweptSurface_ = s;
}

const NurbsSet::NurbsSwungSurface_sequence& NurbsSet::
NurbsSwungSurface () const
{
  return this->NurbsSwungSurface_;
}

NurbsSet::NurbsSwungSurface_sequence& NurbsSet::
NurbsSwungSurface ()
{
  return this->NurbsSwungSurface_;
}

void NurbsSet::
NurbsSwungSurface (const NurbsSwungSurface_sequence& s)
{
  this->NurbsSwungSurface_ = s;
}

const NurbsSet::NurbsTrimmedSurface_sequence& NurbsSet::
NurbsTrimmedSurface () const
{
  return this->NurbsTrimmedSurface_;
}

NurbsSet::NurbsTrimmedSurface_sequence& NurbsSet::
NurbsTrimmedSurface ()
{
  return this->NurbsTrimmedSurface_;
}

void NurbsSet::
NurbsTrimmedSurface (const NurbsTrimmedSurface_sequence& s)
{
  this->NurbsTrimmedSurface_ = s;
}

const NurbsSet::ProtoInstance_sequence& NurbsSet::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

NurbsSet::ProtoInstance_sequence& NurbsSet::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void NurbsSet::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const NurbsSet::tessellationScale_type& NurbsSet::
tessellationScale () const
{
  return this->tessellationScale_.get ();
}

NurbsSet::tessellationScale_type& NurbsSet::
tessellationScale ()
{
  return this->tessellationScale_.get ();
}

void NurbsSet::
tessellationScale (const tessellationScale_type& x)
{
  this->tessellationScale_.set (x);
}

void NurbsSet::
tessellationScale (::std::auto_ptr< tessellationScale_type > x)
{
  this->tessellationScale_.set (x);
}

const NurbsSet::tessellationScale_type& NurbsSet::
tessellationScale_default_value ()
{
  return tessellationScale_default_value_;
}

const NurbsSet::bboxCenter_type& NurbsSet::
bboxCenter () const
{
  return this->bboxCenter_.get ();
}

NurbsSet::bboxCenter_type& NurbsSet::
bboxCenter ()
{
  return this->bboxCenter_.get ();
}

void NurbsSet::
bboxCenter (const bboxCenter_type& x)
{
  this->bboxCenter_.set (x);
}

void NurbsSet::
bboxCenter (::std::auto_ptr< bboxCenter_type > x)
{
  this->bboxCenter_.set (x);
}

const NurbsSet::bboxCenter_type& NurbsSet::
bboxCenter_default_value ()
{
  return bboxCenter_default_value_;
}

const NurbsSet::bboxSize_type& NurbsSet::
bboxSize () const
{
  return this->bboxSize_.get ();
}

NurbsSet::bboxSize_type& NurbsSet::
bboxSize ()
{
  return this->bboxSize_.get ();
}

void NurbsSet::
bboxSize (const bboxSize_type& x)
{
  this->bboxSize_.set (x);
}

void NurbsSet::
bboxSize (::std::auto_ptr< bboxSize_type > x)
{
  this->bboxSize_.set (x);
}

const NurbsSet::bboxSize_type& NurbsSet::
bboxSize_default_value ()
{
  return bboxSize_default_value_;
}


// NurbsSurfaceInterpolator
// 

const NurbsSurfaceInterpolator::Coordinate_optional& NurbsSurfaceInterpolator::
Coordinate () const
{
  return this->Coordinate_;
}

NurbsSurfaceInterpolator::Coordinate_optional& NurbsSurfaceInterpolator::
Coordinate ()
{
  return this->Coordinate_;
}

void NurbsSurfaceInterpolator::
Coordinate (const Coordinate_type& x)
{
  this->Coordinate_.set (x);
}

void NurbsSurfaceInterpolator::
Coordinate (const Coordinate_optional& x)
{
  this->Coordinate_ = x;
}

void NurbsSurfaceInterpolator::
Coordinate (::std::auto_ptr< Coordinate_type > x)
{
  this->Coordinate_.set (x);
}

const NurbsSurfaceInterpolator::CoordinateDouble_optional& NurbsSurfaceInterpolator::
CoordinateDouble () const
{
  return this->CoordinateDouble_;
}

NurbsSurfaceInterpolator::CoordinateDouble_optional& NurbsSurfaceInterpolator::
CoordinateDouble ()
{
  return this->CoordinateDouble_;
}

void NurbsSurfaceInterpolator::
CoordinateDouble (const CoordinateDouble_type& x)
{
  this->CoordinateDouble_.set (x);
}

void NurbsSurfaceInterpolator::
CoordinateDouble (const CoordinateDouble_optional& x)
{
  this->CoordinateDouble_ = x;
}

void NurbsSurfaceInterpolator::
CoordinateDouble (::std::auto_ptr< CoordinateDouble_type > x)
{
  this->CoordinateDouble_.set (x);
}

const NurbsSurfaceInterpolator::ProtoInstance_optional& NurbsSurfaceInterpolator::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

NurbsSurfaceInterpolator::ProtoInstance_optional& NurbsSurfaceInterpolator::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void NurbsSurfaceInterpolator::
ProtoInstance (const ProtoInstance_type& x)
{
  this->ProtoInstance_.set (x);
}

void NurbsSurfaceInterpolator::
ProtoInstance (const ProtoInstance_optional& x)
{
  this->ProtoInstance_ = x;
}

void NurbsSurfaceInterpolator::
ProtoInstance (::std::auto_ptr< ProtoInstance_type > x)
{
  this->ProtoInstance_.set (x);
}

const NurbsSurfaceInterpolator::uDimension_type& NurbsSurfaceInterpolator::
uDimension () const
{
  return this->uDimension_.get ();
}

NurbsSurfaceInterpolator::uDimension_type& NurbsSurfaceInterpolator::
uDimension ()
{
  return this->uDimension_.get ();
}

void NurbsSurfaceInterpolator::
uDimension (const uDimension_type& x)
{
  this->uDimension_.set (x);
}

void NurbsSurfaceInterpolator::
uDimension (::std::auto_ptr< uDimension_type > x)
{
  this->uDimension_.set (x);
}

const NurbsSurfaceInterpolator::uDimension_type& NurbsSurfaceInterpolator::
uDimension_default_value ()
{
  return uDimension_default_value_;
}

const NurbsSurfaceInterpolator::vDimension_type& NurbsSurfaceInterpolator::
vDimension () const
{
  return this->vDimension_.get ();
}

NurbsSurfaceInterpolator::vDimension_type& NurbsSurfaceInterpolator::
vDimension ()
{
  return this->vDimension_.get ();
}

void NurbsSurfaceInterpolator::
vDimension (const vDimension_type& x)
{
  this->vDimension_.set (x);
}

void NurbsSurfaceInterpolator::
vDimension (::std::auto_ptr< vDimension_type > x)
{
  this->vDimension_.set (x);
}

const NurbsSurfaceInterpolator::vDimension_type& NurbsSurfaceInterpolator::
vDimension_default_value ()
{
  return vDimension_default_value_;
}

const NurbsSurfaceInterpolator::uKnot_optional& NurbsSurfaceInterpolator::
uKnot () const
{
  return this->uKnot_;
}

NurbsSurfaceInterpolator::uKnot_optional& NurbsSurfaceInterpolator::
uKnot ()
{
  return this->uKnot_;
}

void NurbsSurfaceInterpolator::
uKnot (const uKnot_type& x)
{
  this->uKnot_.set (x);
}

void NurbsSurfaceInterpolator::
uKnot (const uKnot_optional& x)
{
  this->uKnot_ = x;
}

void NurbsSurfaceInterpolator::
uKnot (::std::auto_ptr< uKnot_type > x)
{
  this->uKnot_.set (x);
}

const NurbsSurfaceInterpolator::vKnot_optional& NurbsSurfaceInterpolator::
vKnot () const
{
  return this->vKnot_;
}

NurbsSurfaceInterpolator::vKnot_optional& NurbsSurfaceInterpolator::
vKnot ()
{
  return this->vKnot_;
}

void NurbsSurfaceInterpolator::
vKnot (const vKnot_type& x)
{
  this->vKnot_.set (x);
}

void NurbsSurfaceInterpolator::
vKnot (const vKnot_optional& x)
{
  this->vKnot_ = x;
}

void NurbsSurfaceInterpolator::
vKnot (::std::auto_ptr< vKnot_type > x)
{
  this->vKnot_.set (x);
}

const NurbsSurfaceInterpolator::uOrder_type& NurbsSurfaceInterpolator::
uOrder () const
{
  return this->uOrder_.get ();
}

NurbsSurfaceInterpolator::uOrder_type& NurbsSurfaceInterpolator::
uOrder ()
{
  return this->uOrder_.get ();
}

void NurbsSurfaceInterpolator::
uOrder (const uOrder_type& x)
{
  this->uOrder_.set (x);
}

void NurbsSurfaceInterpolator::
uOrder (::std::auto_ptr< uOrder_type > x)
{
  this->uOrder_.set (x);
}

const NurbsSurfaceInterpolator::uOrder_type& NurbsSurfaceInterpolator::
uOrder_default_value ()
{
  return uOrder_default_value_;
}

const NurbsSurfaceInterpolator::vOrder_type& NurbsSurfaceInterpolator::
vOrder () const
{
  return this->vOrder_.get ();
}

NurbsSurfaceInterpolator::vOrder_type& NurbsSurfaceInterpolator::
vOrder ()
{
  return this->vOrder_.get ();
}

void NurbsSurfaceInterpolator::
vOrder (const vOrder_type& x)
{
  this->vOrder_.set (x);
}

void NurbsSurfaceInterpolator::
vOrder (::std::auto_ptr< vOrder_type > x)
{
  this->vOrder_.set (x);
}

const NurbsSurfaceInterpolator::vOrder_type& NurbsSurfaceInterpolator::
vOrder_default_value ()
{
  return vOrder_default_value_;
}

const NurbsSurfaceInterpolator::weight_optional& NurbsSurfaceInterpolator::
weight () const
{
  return this->weight_;
}

NurbsSurfaceInterpolator::weight_optional& NurbsSurfaceInterpolator::
weight ()
{
  return this->weight_;
}

void NurbsSurfaceInterpolator::
weight (const weight_type& x)
{
  this->weight_.set (x);
}

void NurbsSurfaceInterpolator::
weight (const weight_optional& x)
{
  this->weight_ = x;
}

void NurbsSurfaceInterpolator::
weight (::std::auto_ptr< weight_type > x)
{
  this->weight_.set (x);
}


// NurbsSweptSurface
// 

const NurbsSweptSurface::ContourPolyline2D_sequence& NurbsSweptSurface::
ContourPolyline2D () const
{
  return this->ContourPolyline2D_;
}

NurbsSweptSurface::ContourPolyline2D_sequence& NurbsSweptSurface::
ContourPolyline2D ()
{
  return this->ContourPolyline2D_;
}

void NurbsSweptSurface::
ContourPolyline2D (const ContourPolyline2D_sequence& s)
{
  this->ContourPolyline2D_ = s;
}

const NurbsSweptSurface::NurbsCurve2D_sequence& NurbsSweptSurface::
NurbsCurve2D () const
{
  return this->NurbsCurve2D_;
}

NurbsSweptSurface::NurbsCurve2D_sequence& NurbsSweptSurface::
NurbsCurve2D ()
{
  return this->NurbsCurve2D_;
}

void NurbsSweptSurface::
NurbsCurve2D (const NurbsCurve2D_sequence& s)
{
  this->NurbsCurve2D_ = s;
}

const NurbsSweptSurface::NurbsCurve_sequence& NurbsSweptSurface::
NurbsCurve () const
{
  return this->NurbsCurve_;
}

NurbsSweptSurface::NurbsCurve_sequence& NurbsSweptSurface::
NurbsCurve ()
{
  return this->NurbsCurve_;
}

void NurbsSweptSurface::
NurbsCurve (const NurbsCurve_sequence& s)
{
  this->NurbsCurve_ = s;
}

const NurbsSweptSurface::ProtoInstance_sequence& NurbsSweptSurface::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

NurbsSweptSurface::ProtoInstance_sequence& NurbsSweptSurface::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void NurbsSweptSurface::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const NurbsSweptSurface::ccw_type& NurbsSweptSurface::
ccw () const
{
  return this->ccw_.get ();
}

NurbsSweptSurface::ccw_type& NurbsSweptSurface::
ccw ()
{
  return this->ccw_.get ();
}

void NurbsSweptSurface::
ccw (const ccw_type& x)
{
  this->ccw_.set (x);
}

void NurbsSweptSurface::
ccw (::std::auto_ptr< ccw_type > x)
{
  this->ccw_.set (x);
}

const NurbsSweptSurface::ccw_type& NurbsSweptSurface::
ccw_default_value ()
{
  return ccw_default_value_;
}

const NurbsSweptSurface::solid_type& NurbsSweptSurface::
solid () const
{
  return this->solid_.get ();
}

NurbsSweptSurface::solid_type& NurbsSweptSurface::
solid ()
{
  return this->solid_.get ();
}

void NurbsSweptSurface::
solid (const solid_type& x)
{
  this->solid_.set (x);
}

void NurbsSweptSurface::
solid (::std::auto_ptr< solid_type > x)
{
  this->solid_.set (x);
}

const NurbsSweptSurface::solid_type& NurbsSweptSurface::
solid_default_value ()
{
  return solid_default_value_;
}


// NurbsSwungSurface
// 

const NurbsSwungSurface::ContourPolyline2D_sequence& NurbsSwungSurface::
ContourPolyline2D () const
{
  return this->ContourPolyline2D_;
}

NurbsSwungSurface::ContourPolyline2D_sequence& NurbsSwungSurface::
ContourPolyline2D ()
{
  return this->ContourPolyline2D_;
}

void NurbsSwungSurface::
ContourPolyline2D (const ContourPolyline2D_sequence& s)
{
  this->ContourPolyline2D_ = s;
}

const NurbsSwungSurface::NurbsCurve2D_sequence& NurbsSwungSurface::
NurbsCurve2D () const
{
  return this->NurbsCurve2D_;
}

NurbsSwungSurface::NurbsCurve2D_sequence& NurbsSwungSurface::
NurbsCurve2D ()
{
  return this->NurbsCurve2D_;
}

void NurbsSwungSurface::
NurbsCurve2D (const NurbsCurve2D_sequence& s)
{
  this->NurbsCurve2D_ = s;
}

const NurbsSwungSurface::ProtoInstance_sequence& NurbsSwungSurface::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

NurbsSwungSurface::ProtoInstance_sequence& NurbsSwungSurface::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void NurbsSwungSurface::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}

const NurbsSwungSurface::ccw_type& NurbsSwungSurface::
ccw () const
{
  return this->ccw_.get ();
}

NurbsSwungSurface::ccw_type& NurbsSwungSurface::
ccw ()
{
  return this->ccw_.get ();
}

void NurbsSwungSurface::
ccw (const ccw_type& x)
{
  this->ccw_.set (x);
}

void NurbsSwungSurface::
ccw (::std::auto_ptr< ccw_type > x)
{
  this->ccw_.set (x);
}

const NurbsSwungSurface::ccw_type& NurbsSwungSurface::
ccw_default_value ()
{
  return ccw_default_value_;
}

const NurbsSwungSurface::solid_type& NurbsSwungSurface::
solid () const
{
  return this->solid_.get ();
}

NurbsSwungSurface::solid_type& NurbsSwungSurface::
solid ()
{
  return this->solid_.get ();
}

void NurbsSwungSurface::
solid (const solid_type& x)
{
  this->solid_.set (x);
}

void NurbsSwungSurface::
solid (::std::auto_ptr< solid_type > x)
{
  this->solid_.set (x);
}

const NurbsSwungSurface::solid_type& NurbsSwungSurface::
solid_default_value ()
{
  return solid_default_value_;
}


// NurbsTextureCoordinate
// 

const NurbsTextureCoordinate::controlPoint_optional& NurbsTextureCoordinate::
controlPoint () const
{
  return this->controlPoint_;
}

NurbsTextureCoordinate::controlPoint_optional& NurbsTextureCoordinate::
controlPoint ()
{
  return this->controlPoint_;
}

void NurbsTextureCoordinate::
controlPoint (const controlPoint_type& x)
{
  this->controlPoint_.set (x);
}

void NurbsTextureCoordinate::
controlPoint (const controlPoint_optional& x)
{
  this->controlPoint_ = x;
}

void NurbsTextureCoordinate::
controlPoint (::std::auto_ptr< controlPoint_type > x)
{
  this->controlPoint_.set (x);
}

const NurbsTextureCoordinate::uDimension_type& NurbsTextureCoordinate::
uDimension () const
{
  return this->uDimension_.get ();
}

NurbsTextureCoordinate::uDimension_type& NurbsTextureCoordinate::
uDimension ()
{
  return this->uDimension_.get ();
}

void NurbsTextureCoordinate::
uDimension (const uDimension_type& x)
{
  this->uDimension_.set (x);
}

void NurbsTextureCoordinate::
uDimension (::std::auto_ptr< uDimension_type > x)
{
  this->uDimension_.set (x);
}

const NurbsTextureCoordinate::uDimension_type& NurbsTextureCoordinate::
uDimension_default_value ()
{
  return uDimension_default_value_;
}

const NurbsTextureCoordinate::vDimension_type& NurbsTextureCoordinate::
vDimension () const
{
  return this->vDimension_.get ();
}

NurbsTextureCoordinate::vDimension_type& NurbsTextureCoordinate::
vDimension ()
{
  return this->vDimension_.get ();
}

void NurbsTextureCoordinate::
vDimension (const vDimension_type& x)
{
  this->vDimension_.set (x);
}

void NurbsTextureCoordinate::
vDimension (::std::auto_ptr< vDimension_type > x)
{
  this->vDimension_.set (x);
}

const NurbsTextureCoordinate::vDimension_type& NurbsTextureCoordinate::
vDimension_default_value ()
{
  return vDimension_default_value_;
}

const NurbsTextureCoordinate::uKnot_optional& NurbsTextureCoordinate::
uKnot () const
{
  return this->uKnot_;
}

NurbsTextureCoordinate::uKnot_optional& NurbsTextureCoordinate::
uKnot ()
{
  return this->uKnot_;
}

void NurbsTextureCoordinate::
uKnot (const uKnot_type& x)
{
  this->uKnot_.set (x);
}

void NurbsTextureCoordinate::
uKnot (const uKnot_optional& x)
{
  this->uKnot_ = x;
}

void NurbsTextureCoordinate::
uKnot (::std::auto_ptr< uKnot_type > x)
{
  this->uKnot_.set (x);
}

const NurbsTextureCoordinate::vKnot_optional& NurbsTextureCoordinate::
vKnot () const
{
  return this->vKnot_;
}

NurbsTextureCoordinate::vKnot_optional& NurbsTextureCoordinate::
vKnot ()
{
  return this->vKnot_;
}

void NurbsTextureCoordinate::
vKnot (const vKnot_type& x)
{
  this->vKnot_.set (x);
}

void NurbsTextureCoordinate::
vKnot (const vKnot_optional& x)
{
  this->vKnot_ = x;
}

void NurbsTextureCoordinate::
vKnot (::std::auto_ptr< vKnot_type > x)
{
  this->vKnot_.set (x);
}

const NurbsTextureCoordinate::uOrder_type& NurbsTextureCoordinate::
uOrder () const
{
  return this->uOrder_.get ();
}

NurbsTextureCoordinate::uOrder_type& NurbsTextureCoordinate::
uOrder ()
{
  return this->uOrder_.get ();
}

void NurbsTextureCoordinate::
uOrder (const uOrder_type& x)
{
  this->uOrder_.set (x);
}

void NurbsTextureCoordinate::
uOrder (::std::auto_ptr< uOrder_type > x)
{
  this->uOrder_.set (x);
}

const NurbsTextureCoordinate::uOrder_type& NurbsTextureCoordinate::
uOrder_default_value ()
{
  return uOrder_default_value_;
}

const NurbsTextureCoordinate::vOrder_type& NurbsTextureCoordinate::
vOrder () const
{
  return this->vOrder_.get ();
}

NurbsTextureCoordinate::vOrder_type& NurbsTextureCoordinate::
vOrder ()
{
  return this->vOrder_.get ();
}

void NurbsTextureCoordinate::
vOrder (const vOrder_type& x)
{
  this->vOrder_.set (x);
}

void NurbsTextureCoordinate::
vOrder (::std::auto_ptr< vOrder_type > x)
{
  this->vOrder_.set (x);
}

const NurbsTextureCoordinate::vOrder_type& NurbsTextureCoordinate::
vOrder_default_value ()
{
  return vOrder_default_value_;
}

const NurbsTextureCoordinate::weight_optional& NurbsTextureCoordinate::
weight () const
{
  return this->weight_;
}

NurbsTextureCoordinate::weight_optional& NurbsTextureCoordinate::
weight ()
{
  return this->weight_;
}

void NurbsTextureCoordinate::
weight (const weight_type& x)
{
  this->weight_.set (x);
}

void NurbsTextureCoordinate::
weight (const weight_optional& x)
{
  this->weight_ = x;
}

void NurbsTextureCoordinate::
weight (::std::auto_ptr< weight_type > x)
{
  this->weight_.set (x);
}


// NurbsTrimmedSurface
// 

const NurbsTrimmedSurface::Contour2D_sequence& NurbsTrimmedSurface::
Contour2D () const
{
  return this->Contour2D_;
}

NurbsTrimmedSurface::Contour2D_sequence& NurbsTrimmedSurface::
Contour2D ()
{
  return this->Contour2D_;
}

void NurbsTrimmedSurface::
Contour2D (const Contour2D_sequence& s)
{
  this->Contour2D_ = s;
}

const NurbsTrimmedSurface::Coordinate_sequence& NurbsTrimmedSurface::
Coordinate () const
{
  return this->Coordinate_;
}

NurbsTrimmedSurface::Coordinate_sequence& NurbsTrimmedSurface::
Coordinate ()
{
  return this->Coordinate_;
}

void NurbsTrimmedSurface::
Coordinate (const Coordinate_sequence& s)
{
  this->Coordinate_ = s;
}

const NurbsTrimmedSurface::CoordinateDouble_sequence& NurbsTrimmedSurface::
CoordinateDouble () const
{
  return this->CoordinateDouble_;
}

NurbsTrimmedSurface::CoordinateDouble_sequence& NurbsTrimmedSurface::
CoordinateDouble ()
{
  return this->CoordinateDouble_;
}

void NurbsTrimmedSurface::
CoordinateDouble (const CoordinateDouble_sequence& s)
{
  this->CoordinateDouble_ = s;
}

const NurbsTrimmedSurface::TextureCoordinate_sequence& NurbsTrimmedSurface::
TextureCoordinate () const
{
  return this->TextureCoordinate_;
}

NurbsTrimmedSurface::TextureCoordinate_sequence& NurbsTrimmedSurface::
TextureCoordinate ()
{
  return this->TextureCoordinate_;
}

void NurbsTrimmedSurface::
TextureCoordinate (const TextureCoordinate_sequence& s)
{
  this->TextureCoordinate_ = s;
}

const NurbsTrimmedSurface::TextureCoordinateGenerator_sequence& NurbsTrimmedSurface::
TextureCoordinateGenerator () const
{
  return this->TextureCoordinateGenerator_;
}

NurbsTrimmedSurface::TextureCoordinateGenerator_sequence& NurbsTrimmedSurface::
TextureCoordinateGenerator ()
{
  return this->TextureCoordinateGenerator_;
}

void NurbsTrimmedSurface::
TextureCoordinateGenerator (const TextureCoordinateGenerator_sequence& s)
{
  this->TextureCoordinateGenerator_ = s;
}

const NurbsTrimmedSurface::NurbsTextureCoordinate_sequence& NurbsTrimmedSurface::
NurbsTextureCoordinate () const
{
  return this->NurbsTextureCoordinate_;
}

NurbsTrimmedSurface::NurbsTextureCoordinate_sequence& NurbsTrimmedSurface::
NurbsTextureCoordinate ()
{
  return this->NurbsTextureCoordinate_;
}

void NurbsTrimmedSurface::
NurbsTextureCoordinate (const NurbsTextureCoordinate_sequence& s)
{
  this->NurbsTextureCoordinate_ = s;
}

const NurbsTrimmedSurface::ProtoInstance_sequence& NurbsTrimmedSurface::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

NurbsTrimmedSurface::ProtoInstance_sequence& NurbsTrimmedSurface::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void NurbsTrimmedSurface::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}


// CADAssembly
// 

const CADAssembly::CADPart_sequence& CADAssembly::
CADPart () const
{
  return this->CADPart_;
}

CADAssembly::CADPart_sequence& CADAssembly::
CADPart ()
{
  return this->CADPart_;
}

void CADAssembly::
CADPart (const CADPart_sequence& s)
{
  this->CADPart_ = s;
}

const CADAssembly::name_optional& CADAssembly::
name () const
{
  return this->name_;
}

CADAssembly::name_optional& CADAssembly::
name ()
{
  return this->name_;
}

void CADAssembly::
name (const name_type& x)
{
  this->name_.set (x);
}

void CADAssembly::
name (const name_optional& x)
{
  this->name_ = x;
}

void CADAssembly::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}


// CADFace
// 

const CADFace::Shape_optional& CADFace::
Shape () const
{
  return this->Shape_;
}

CADFace::Shape_optional& CADFace::
Shape ()
{
  return this->Shape_;
}

void CADFace::
Shape (const Shape_type& x)
{
  this->Shape_.set (x);
}

void CADFace::
Shape (const Shape_optional& x)
{
  this->Shape_ = x;
}

void CADFace::
Shape (::std::auto_ptr< Shape_type > x)
{
  this->Shape_.set (x);
}

const CADFace::LOD_optional& CADFace::
LOD () const
{
  return this->LOD_;
}

CADFace::LOD_optional& CADFace::
LOD ()
{
  return this->LOD_;
}

void CADFace::
LOD (const LOD_type& x)
{
  this->LOD_.set (x);
}

void CADFace::
LOD (const LOD_optional& x)
{
  this->LOD_ = x;
}

void CADFace::
LOD (::std::auto_ptr< LOD_type > x)
{
  this->LOD_.set (x);
}

const CADFace::ProtoInstance_optional& CADFace::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

CADFace::ProtoInstance_optional& CADFace::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void CADFace::
ProtoInstance (const ProtoInstance_type& x)
{
  this->ProtoInstance_.set (x);
}

void CADFace::
ProtoInstance (const ProtoInstance_optional& x)
{
  this->ProtoInstance_ = x;
}

void CADFace::
ProtoInstance (::std::auto_ptr< ProtoInstance_type > x)
{
  this->ProtoInstance_.set (x);
}

const CADFace::bboxCenter_type& CADFace::
bboxCenter () const
{
  return this->bboxCenter_.get ();
}

CADFace::bboxCenter_type& CADFace::
bboxCenter ()
{
  return this->bboxCenter_.get ();
}

void CADFace::
bboxCenter (const bboxCenter_type& x)
{
  this->bboxCenter_.set (x);
}

void CADFace::
bboxCenter (::std::auto_ptr< bboxCenter_type > x)
{
  this->bboxCenter_.set (x);
}

const CADFace::bboxCenter_type& CADFace::
bboxCenter_default_value ()
{
  return bboxCenter_default_value_;
}

const CADFace::bboxSize_type& CADFace::
bboxSize () const
{
  return this->bboxSize_.get ();
}

CADFace::bboxSize_type& CADFace::
bboxSize ()
{
  return this->bboxSize_.get ();
}

void CADFace::
bboxSize (const bboxSize_type& x)
{
  this->bboxSize_.set (x);
}

void CADFace::
bboxSize (::std::auto_ptr< bboxSize_type > x)
{
  this->bboxSize_.set (x);
}

const CADFace::bboxSize_type& CADFace::
bboxSize_default_value ()
{
  return bboxSize_default_value_;
}

const CADFace::name_optional& CADFace::
name () const
{
  return this->name_;
}

CADFace::name_optional& CADFace::
name ()
{
  return this->name_;
}

void CADFace::
name (const name_type& x)
{
  this->name_.set (x);
}

void CADFace::
name (const name_optional& x)
{
  this->name_ = x;
}

void CADFace::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}


// CADLayer
// 

const CADLayer::name_optional& CADLayer::
name () const
{
  return this->name_;
}

CADLayer::name_optional& CADLayer::
name ()
{
  return this->name_;
}

void CADLayer::
name (const name_type& x)
{
  this->name_.set (x);
}

void CADLayer::
name (const name_optional& x)
{
  this->name_ = x;
}

void CADLayer::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}

const CADLayer::visible_optional& CADLayer::
visible () const
{
  return this->visible_;
}

CADLayer::visible_optional& CADLayer::
visible ()
{
  return this->visible_;
}

void CADLayer::
visible (const visible_type& x)
{
  this->visible_.set (x);
}

void CADLayer::
visible (const visible_optional& x)
{
  this->visible_ = x;
}

void CADLayer::
visible (::std::auto_ptr< visible_type > x)
{
  this->visible_.set (x);
}


// CADPart
// 

const CADPart::CADFace_sequence& CADPart::
CADFace () const
{
  return this->CADFace_;
}

CADPart::CADFace_sequence& CADPart::
CADFace ()
{
  return this->CADFace_;
}

void CADPart::
CADFace (const CADFace_sequence& s)
{
  this->CADFace_ = s;
}

const CADPart::name_optional& CADPart::
name () const
{
  return this->name_;
}

CADPart::name_optional& CADPart::
name ()
{
  return this->name_;
}

void CADPart::
name (const name_type& x)
{
  this->name_.set (x);
}

void CADPart::
name (const name_optional& x)
{
  this->name_ = x;
}

void CADPart::
name (::std::auto_ptr< name_type > x)
{
  this->name_.set (x);
}


// IndexedQuadSet
// 

const IndexedQuadSet::index_optional& IndexedQuadSet::
index () const
{
  return this->index_;
}

IndexedQuadSet::index_optional& IndexedQuadSet::
index ()
{
  return this->index_;
}

void IndexedQuadSet::
index (const index_type& x)
{
  this->index_.set (x);
}

void IndexedQuadSet::
index (const index_optional& x)
{
  this->index_ = x;
}

void IndexedQuadSet::
index (::std::auto_ptr< index_type > x)
{
  this->index_.set (x);
}


// QuadSet
// 


// ComposedShader
// 

const ComposedShader::field_sequence& ComposedShader::
field () const
{
  return this->field_;
}

ComposedShader::field_sequence& ComposedShader::
field ()
{
  return this->field_;
}

void ComposedShader::
field (const field_sequence& s)
{
  this->field_ = s;
}

const ComposedShader::ShaderPart_sequence& ComposedShader::
ShaderPart () const
{
  return this->ShaderPart_;
}

ComposedShader::ShaderPart_sequence& ComposedShader::
ShaderPart ()
{
  return this->ShaderPart_;
}

void ComposedShader::
ShaderPart (const ShaderPart_sequence& s)
{
  this->ShaderPart_ = s;
}


// FloatVertexAttribute
// 

const FloatVertexAttribute::value_optional& FloatVertexAttribute::
value () const
{
  return this->value_;
}

FloatVertexAttribute::value_optional& FloatVertexAttribute::
value ()
{
  return this->value_;
}

void FloatVertexAttribute::
value (const value_type& x)
{
  this->value_.set (x);
}

void FloatVertexAttribute::
value (const value_optional& x)
{
  this->value_ = x;
}

void FloatVertexAttribute::
value (::std::auto_ptr< value_type > x)
{
  this->value_.set (x);
}

const FloatVertexAttribute::numComponents_type& FloatVertexAttribute::
numComponents () const
{
  return this->numComponents_.get ();
}

FloatVertexAttribute::numComponents_type& FloatVertexAttribute::
numComponents ()
{
  return this->numComponents_.get ();
}

void FloatVertexAttribute::
numComponents (const numComponents_type& x)
{
  this->numComponents_.set (x);
}

void FloatVertexAttribute::
numComponents (::std::auto_ptr< numComponents_type > x)
{
  this->numComponents_.set (x);
}

const FloatVertexAttribute::numComponents_type& FloatVertexAttribute::
numComponents_default_value ()
{
  return numComponents_default_value_;
}


// Matrix3VertexAttribute
// 

const Matrix3VertexAttribute::value_optional& Matrix3VertexAttribute::
value () const
{
  return this->value_;
}

Matrix3VertexAttribute::value_optional& Matrix3VertexAttribute::
value ()
{
  return this->value_;
}

void Matrix3VertexAttribute::
value (const value_type& x)
{
  this->value_.set (x);
}

void Matrix3VertexAttribute::
value (const value_optional& x)
{
  this->value_ = x;
}

void Matrix3VertexAttribute::
value (::std::auto_ptr< value_type > x)
{
  this->value_.set (x);
}


// Matrix4VertexAttribute
// 

const Matrix4VertexAttribute::value_optional& Matrix4VertexAttribute::
value () const
{
  return this->value_;
}

Matrix4VertexAttribute::value_optional& Matrix4VertexAttribute::
value ()
{
  return this->value_;
}

void Matrix4VertexAttribute::
value (const value_type& x)
{
  this->value_.set (x);
}

void Matrix4VertexAttribute::
value (const value_optional& x)
{
  this->value_ = x;
}

void Matrix4VertexAttribute::
value (::std::auto_ptr< value_type > x)
{
  this->value_.set (x);
}


// PackagedShader
// 

const PackagedShader::field_sequence& PackagedShader::
field () const
{
  return this->field_;
}

PackagedShader::field_sequence& PackagedShader::
field ()
{
  return this->field_;
}

void PackagedShader::
field (const field_sequence& s)
{
  this->field_ = s;
}

const PackagedShader::url_optional& PackagedShader::
url () const
{
  return this->url_;
}

PackagedShader::url_optional& PackagedShader::
url ()
{
  return this->url_;
}

void PackagedShader::
url (const url_type& x)
{
  this->url_.set (x);
}

void PackagedShader::
url (const url_optional& x)
{
  this->url_ = x;
}

void PackagedShader::
url (::std::auto_ptr< url_type > x)
{
  this->url_.set (x);
}


// ProgramShader
// 

const ProgramShader::ShaderProgram_sequence& ProgramShader::
ShaderProgram () const
{
  return this->ShaderProgram_;
}

ProgramShader::ShaderProgram_sequence& ProgramShader::
ShaderProgram ()
{
  return this->ShaderProgram_;
}

void ProgramShader::
ShaderProgram (const ShaderProgram_sequence& s)
{
  this->ShaderProgram_ = s;
}


// ShaderPart
// 

const ShaderPart::containerField_type& ShaderPart::
containerField () const
{
  return this->containerField_.get ();
}

ShaderPart::containerField_type& ShaderPart::
containerField ()
{
  return this->containerField_.get ();
}

void ShaderPart::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void ShaderPart::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const ShaderPart::containerField_type& ShaderPart::
containerField_default_value ()
{
  return containerField_default_value_;
}

const ShaderPart::url_optional& ShaderPart::
url () const
{
  return this->url_;
}

ShaderPart::url_optional& ShaderPart::
url ()
{
  return this->url_;
}

void ShaderPart::
url (const url_type& x)
{
  this->url_.set (x);
}

void ShaderPart::
url (const url_optional& x)
{
  this->url_ = x;
}

void ShaderPart::
url (::std::auto_ptr< url_type > x)
{
  this->url_.set (x);
}

const ShaderPart::type_optional& ShaderPart::
type () const
{
  return this->type_;
}

ShaderPart::type_optional& ShaderPart::
type ()
{
  return this->type_;
}

void ShaderPart::
type (const type_type& x)
{
  this->type_.set (x);
}

void ShaderPart::
type (const type_optional& x)
{
  this->type_ = x;
}

void ShaderPart::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}


// ShaderProgram
// 

const ShaderProgram::field_sequence& ShaderProgram::
field () const
{
  return this->field_;
}

ShaderProgram::field_sequence& ShaderProgram::
field ()
{
  return this->field_;
}

void ShaderProgram::
field (const field_sequence& s)
{
  this->field_ = s;
}

const ShaderProgram::containerField_type& ShaderProgram::
containerField () const
{
  return this->containerField_.get ();
}

ShaderProgram::containerField_type& ShaderProgram::
containerField ()
{
  return this->containerField_.get ();
}

void ShaderProgram::
containerField (const containerField_type& x)
{
  this->containerField_.set (x);
}

void ShaderProgram::
containerField (::std::auto_ptr< containerField_type > x)
{
  this->containerField_.set (x);
}

const ShaderProgram::containerField_type& ShaderProgram::
containerField_default_value ()
{
  return containerField_default_value_;
}

const ShaderProgram::url_optional& ShaderProgram::
url () const
{
  return this->url_;
}

ShaderProgram::url_optional& ShaderProgram::
url ()
{
  return this->url_;
}

void ShaderProgram::
url (const url_type& x)
{
  this->url_.set (x);
}

void ShaderProgram::
url (const url_optional& x)
{
  this->url_ = x;
}

void ShaderProgram::
url (::std::auto_ptr< url_type > x)
{
  this->url_.set (x);
}

const ShaderProgram::type_optional& ShaderProgram::
type () const
{
  return this->type_;
}

ShaderProgram::type_optional& ShaderProgram::
type ()
{
  return this->type_;
}

void ShaderProgram::
type (const type_type& x)
{
  this->type_.set (x);
}

void ShaderProgram::
type (const type_optional& x)
{
  this->type_ = x;
}

void ShaderProgram::
type (::std::auto_ptr< type_type > x)
{
  this->type_.set (x);
}


// ComposedCubeMapTexture
// 

const ComposedCubeMapTexture::ImageTexture_sequence& ComposedCubeMapTexture::
ImageTexture () const
{
  return this->ImageTexture_;
}

ComposedCubeMapTexture::ImageTexture_sequence& ComposedCubeMapTexture::
ImageTexture ()
{
  return this->ImageTexture_;
}

void ComposedCubeMapTexture::
ImageTexture (const ImageTexture_sequence& s)
{
  this->ImageTexture_ = s;
}

const ComposedCubeMapTexture::PixelTexture_sequence& ComposedCubeMapTexture::
PixelTexture () const
{
  return this->PixelTexture_;
}

ComposedCubeMapTexture::PixelTexture_sequence& ComposedCubeMapTexture::
PixelTexture ()
{
  return this->PixelTexture_;
}

void ComposedCubeMapTexture::
PixelTexture (const PixelTexture_sequence& s)
{
  this->PixelTexture_ = s;
}

const ComposedCubeMapTexture::MovieTexture_sequence& ComposedCubeMapTexture::
MovieTexture () const
{
  return this->MovieTexture_;
}

ComposedCubeMapTexture::MovieTexture_sequence& ComposedCubeMapTexture::
MovieTexture ()
{
  return this->MovieTexture_;
}

void ComposedCubeMapTexture::
MovieTexture (const MovieTexture_sequence& s)
{
  this->MovieTexture_ = s;
}

const ComposedCubeMapTexture::ProtoInstance_sequence& ComposedCubeMapTexture::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

ComposedCubeMapTexture::ProtoInstance_sequence& ComposedCubeMapTexture::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void ComposedCubeMapTexture::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}


// GeneratedCubeMapTexture
// 

const GeneratedCubeMapTexture::update_type& GeneratedCubeMapTexture::
update () const
{
  return this->update_.get ();
}

GeneratedCubeMapTexture::update_type& GeneratedCubeMapTexture::
update ()
{
  return this->update_.get ();
}

void GeneratedCubeMapTexture::
update (const update_type& x)
{
  this->update_.set (x);
}

void GeneratedCubeMapTexture::
update (::std::auto_ptr< update_type > x)
{
  this->update_.set (x);
}

const GeneratedCubeMapTexture::update_type& GeneratedCubeMapTexture::
update_default_value ()
{
  return update_default_value_;
}

const GeneratedCubeMapTexture::size_type& GeneratedCubeMapTexture::
size () const
{
  return this->size_.get ();
}

GeneratedCubeMapTexture::size_type& GeneratedCubeMapTexture::
size ()
{
  return this->size_.get ();
}

void GeneratedCubeMapTexture::
size (const size_type& x)
{
  this->size_.set (x);
}

void GeneratedCubeMapTexture::
size (::std::auto_ptr< size_type > x)
{
  this->size_.set (x);
}

const GeneratedCubeMapTexture::size_type& GeneratedCubeMapTexture::
size_default_value ()
{
  return size_default_value_;
}


// ImageCubeMapTexture
// 

const ImageCubeMapTexture::url_optional& ImageCubeMapTexture::
url () const
{
  return this->url_;
}

ImageCubeMapTexture::url_optional& ImageCubeMapTexture::
url ()
{
  return this->url_;
}

void ImageCubeMapTexture::
url (const url_type& x)
{
  this->url_.set (x);
}

void ImageCubeMapTexture::
url (const url_optional& x)
{
  this->url_ = x;
}

void ImageCubeMapTexture::
url (::std::auto_ptr< url_type > x)
{
  this->url_.set (x);
}


// ComposedTexture3D
// 

const ComposedTexture3D::ImageTexture_sequence& ComposedTexture3D::
ImageTexture () const
{
  return this->ImageTexture_;
}

ComposedTexture3D::ImageTexture_sequence& ComposedTexture3D::
ImageTexture ()
{
  return this->ImageTexture_;
}

void ComposedTexture3D::
ImageTexture (const ImageTexture_sequence& s)
{
  this->ImageTexture_ = s;
}

const ComposedTexture3D::PixelTexture_sequence& ComposedTexture3D::
PixelTexture () const
{
  return this->PixelTexture_;
}

ComposedTexture3D::PixelTexture_sequence& ComposedTexture3D::
PixelTexture ()
{
  return this->PixelTexture_;
}

void ComposedTexture3D::
PixelTexture (const PixelTexture_sequence& s)
{
  this->PixelTexture_ = s;
}

const ComposedTexture3D::MovieTexture_sequence& ComposedTexture3D::
MovieTexture () const
{
  return this->MovieTexture_;
}

ComposedTexture3D::MovieTexture_sequence& ComposedTexture3D::
MovieTexture ()
{
  return this->MovieTexture_;
}

void ComposedTexture3D::
MovieTexture (const MovieTexture_sequence& s)
{
  this->MovieTexture_ = s;
}

const ComposedTexture3D::ProtoInstance_sequence& ComposedTexture3D::
ProtoInstance () const
{
  return this->ProtoInstance_;
}

ComposedTexture3D::ProtoInstance_sequence& ComposedTexture3D::
ProtoInstance ()
{
  return this->ProtoInstance_;
}

void ComposedTexture3D::
ProtoInstance (const ProtoInstance_sequence& s)
{
  this->ProtoInstance_ = s;
}


// ImageTexture3D
// 

const ImageTexture3D::url_optional& ImageTexture3D::
url () const
{
  return this->url_;
}

ImageTexture3D::url_optional& ImageTexture3D::
url ()
{
  return this->url_;
}

void ImageTexture3D::
url (const url_type& x)
{
  this->url_.set (x);
}

void ImageTexture3D::
url (const url_optional& x)
{
  this->url_ = x;
}

void ImageTexture3D::
url (::std::auto_ptr< url_type > x)
{
  this->url_.set (x);
}


// PixelTexture3D
// 

const PixelTexture3D::image_type& PixelTexture3D::
image () const
{
  return this->image_.get ();
}

PixelTexture3D::image_type& PixelTexture3D::
image ()
{
  return this->image_.get ();
}

void PixelTexture3D::
image (const image_type& x)
{
  this->image_.set (x);
}

void PixelTexture3D::
image (::std::auto_ptr< image_type > x)
{
  this->image_.set (x);
}

const PixelTexture3D::image_type& PixelTexture3D::
image_default_value ()
{
  return image_default_value_;
}


// TextureCoordinate3D
// 

const TextureCoordinate3D::point_optional& TextureCoordinate3D::
point () const
{
  return this->point_;
}

TextureCoordinate3D::point_optional& TextureCoordinate3D::
point ()
{
  return this->point_;
}

void TextureCoordinate3D::
point (const point_type& x)
{
  this->point_.set (x);
}

void TextureCoordinate3D::
point (const point_optional& x)
{
  this->point_ = x;
}

void TextureCoordinate3D::
point (::std::auto_ptr< point_type > x)
{
  this->point_.set (x);
}


// TextureCoordinate4D
// 

const TextureCoordinate4D::point_optional& TextureCoordinate4D::
point () const
{
  return this->point_;
}

TextureCoordinate4D::point_optional& TextureCoordinate4D::
point ()
{
  return this->point_;
}

void TextureCoordinate4D::
point (const point_type& x)
{
  this->point_.set (x);
}

void TextureCoordinate4D::
point (const point_optional& x)
{
  this->point_ = x;
}

void TextureCoordinate4D::
point (::std::auto_ptr< point_type > x)
{
  this->point_.set (x);
}


// TextureMatrixTransform
// 

const TextureMatrixTransform::matrix_type& TextureMatrixTransform::
matrix () const
{
  return this->matrix_.get ();
}

TextureMatrixTransform::matrix_type& TextureMatrixTransform::
matrix ()
{
  return this->matrix_.get ();
}

void TextureMatrixTransform::
matrix (const matrix_type& x)
{
  this->matrix_.set (x);
}

void TextureMatrixTransform::
matrix (::std::auto_ptr< matrix_type > x)
{
  this->matrix_.set (x);
}

const TextureMatrixTransform::matrix_type& TextureMatrixTransform::
matrix_default_value ()
{
  return matrix_default_value_;
}


// TextureTransform3D
// 

const TextureTransform3D::center_type& TextureTransform3D::
center () const
{
  return this->center_.get ();
}

TextureTransform3D::center_type& TextureTransform3D::
center ()
{
  return this->center_.get ();
}

void TextureTransform3D::
center (const center_type& x)
{
  this->center_.set (x);
}

void TextureTransform3D::
center (::std::auto_ptr< center_type > x)
{
  this->center_.set (x);
}

const TextureTransform3D::center_type& TextureTransform3D::
center_default_value ()
{
  return center_default_value_;
}

const TextureTransform3D::rotation_type& TextureTransform3D::
rotation () const
{
  return this->rotation_.get ();
}

TextureTransform3D::rotation_type& TextureTransform3D::
rotation ()
{
  return this->rotation_.get ();
}

void TextureTransform3D::
rotation (const rotation_type& x)
{
  this->rotation_.set (x);
}

void TextureTransform3D::
rotation (::std::auto_ptr< rotation_type > x)
{
  this->rotation_.set (x);
}

const TextureTransform3D::rotation_type& TextureTransform3D::
rotation_default_value ()
{
  return rotation_default_value_;
}

const TextureTransform3D::scale_type& TextureTransform3D::
scale () const
{
  return this->scale_.get ();
}

TextureTransform3D::scale_type& TextureTransform3D::
scale ()
{
  return this->scale_.get ();
}

void TextureTransform3D::
scale (const scale_type& x)
{
  this->scale_.set (x);
}

void TextureTransform3D::
scale (::std::auto_ptr< scale_type > x)
{
  this->scale_.set (x);
}

const TextureTransform3D::scale_type& TextureTransform3D::
scale_default_value ()
{
  return scale_default_value_;
}

const TextureTransform3D::translation_type& TextureTransform3D::
translation () const
{
  return this->translation_.get ();
}

TextureTransform3D::translation_type& TextureTransform3D::
translation ()
{
  return this->translation_.get ();
}

void TextureTransform3D::
translation (const translation_type& x)
{
  this->translation_.set (x);
}

void TextureTransform3D::
translation (::std::auto_ptr< translation_type > x)
{
  this->translation_.set (x);
}

const TextureTransform3D::translation_type& TextureTransform3D::
translation_default_value ()
{
  return translation_default_value_;
}


// radius
// 


// radius1
// 


// radius2
// 


// bottomRadius
// 


// height
// 


// height1
// 


// radius3
// 


// innerRadius
// 


// outerRadius
// 


// creaseAngle
// 


// xSpacing
// 


// zSpacing
// 


// creaseAngle1
// 


// creaseAngle2
// 


// ambientIntensity1
// 


// shininess
// 


// transparency
// 


// radius4
// 


// radius5
// 


// beamWidth
// 


// radius6
// 


// maxExtent
// 


// creaseAngle3
// 


// xSpacing1
// 


// yScale
// 


// zSpacing1
// 


// numComponents
// 


// update
// 

update::
update (value v)
: SFString (
  ::xml_schema::string (_xsd_update_literals_[v]))
{
}

update::
update (const char* v)
: ::SFString (v)
{
}

update::
update (const ::std::string& v)
: ::SFString (v)
{
}

update::
update (const ::SFString& v)
: ::SFString (v)
{
}

update::
update (const update& v,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SFString (v, f, c)
{
}

update& update::
operator= (value v)
{
  static_cast< ::SFString& > (*this) = 
  SFString (
    ::xml_schema::string (_xsd_update_literals_[v]));

  return *this;
}


// size
// 


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// SFVec3f
//

SFVec3f::
SFVec3f ()
: ::xml_schema::string ()
{
}

SFVec3f::
SFVec3f (const char* string)
: ::xml_schema::string (string)
{
}

SFVec3f::
SFVec3f (const ::std::string& string)
: ::xml_schema::string (string)
{
}

SFVec3f::
SFVec3f (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

SFVec3f::
SFVec3f (const SFVec3f& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

SFVec3f::
SFVec3f (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

SFVec3f::
SFVec3f (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

SFVec3f::
SFVec3f (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

SFVec3f* SFVec3f::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFVec3f (*this, f, c);
}

SFVec3f::
~SFVec3f ()
{
}

// BoundingBoxSize
//

BoundingBoxSize::
BoundingBoxSize ()
: ::SFVec3f ()
{
}

BoundingBoxSize::
BoundingBoxSize (const char* string)
: ::SFVec3f (string)
{
}

BoundingBoxSize::
BoundingBoxSize (const ::std::string& string)
: ::SFVec3f (string)
{
}

BoundingBoxSize::
BoundingBoxSize (const ::xml_schema::string& string)
: ::SFVec3f (string)
{
}

BoundingBoxSize::
BoundingBoxSize (const BoundingBoxSize& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::SFVec3f (x, f, c)
{
}

BoundingBoxSize::
BoundingBoxSize (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::SFVec3f (e, f, c)
{
}

BoundingBoxSize::
BoundingBoxSize (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::SFVec3f (a, f, c)
{
}

BoundingBoxSize::
BoundingBoxSize (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::SFVec3f (s, e, f, c)
{
}

BoundingBoxSize* BoundingBoxSize::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new BoundingBoxSize (*this, f, c);
}

BoundingBoxSize::
~BoundingBoxSize ()
{
}

// SFBool
//

SFBool::
SFBool (const ::xml_schema::boolean& boolean)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (boolean)
{
}

SFBool::
SFBool (const SFBool& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (x, f, c)
{
}

SFBool::
SFBool (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (e, f, c)
{
}

SFBool::
SFBool (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (a, f, c)
{
}

SFBool::
SFBool (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::boolean, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

SFBool* SFBool::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFBool (*this, f, c);
}

SFBool::
~SFBool ()
{
}

// MFBool
//

MFBool::
MFBool (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::simple_type (e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::boolean, char > (e, f, c)
{
}

MFBool::
MFBool (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::simple_type (a, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::boolean, char > (a, f, c)
{
}

MFBool::
MFBool (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::simple_type (s, e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::boolean, char > (s, e, f, c)
{
}

MFBool* MFBool::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFBool (*this, f, c);
}

MFBool::
~MFBool ()
{
}

// SFColor
//

SFColor::
SFColor ()
: ::xml_schema::string ()
{
}

SFColor::
SFColor (const char* string)
: ::xml_schema::string (string)
{
}

SFColor::
SFColor (const ::std::string& string)
: ::xml_schema::string (string)
{
}

SFColor::
SFColor (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

SFColor::
SFColor (const SFColor& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

SFColor::
SFColor (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

SFColor::
SFColor (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

SFColor::
SFColor (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

SFColor* SFColor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFColor (*this, f, c);
}

SFColor::
~SFColor ()
{
}

// MFColor
//

MFColor::
MFColor ()
: ::xml_schema::string ()
{
}

MFColor::
MFColor (const char* string)
: ::xml_schema::string (string)
{
}

MFColor::
MFColor (const ::std::string& string)
: ::xml_schema::string (string)
{
}

MFColor::
MFColor (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

MFColor::
MFColor (const MFColor& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

MFColor::
MFColor (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

MFColor::
MFColor (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

MFColor::
MFColor (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

MFColor* MFColor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFColor (*this, f, c);
}

MFColor::
~MFColor ()
{
}

// SFColorRGBA
//

SFColorRGBA::
SFColorRGBA ()
: ::xml_schema::string ()
{
}

SFColorRGBA::
SFColorRGBA (const char* string)
: ::xml_schema::string (string)
{
}

SFColorRGBA::
SFColorRGBA (const ::std::string& string)
: ::xml_schema::string (string)
{
}

SFColorRGBA::
SFColorRGBA (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

SFColorRGBA::
SFColorRGBA (const SFColorRGBA& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

SFColorRGBA::
SFColorRGBA (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

SFColorRGBA::
SFColorRGBA (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

SFColorRGBA::
SFColorRGBA (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

SFColorRGBA* SFColorRGBA::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFColorRGBA (*this, f, c);
}

SFColorRGBA::
~SFColorRGBA ()
{
}

// MFColorRGBA
//

MFColorRGBA::
MFColorRGBA ()
: ::xml_schema::string ()
{
}

MFColorRGBA::
MFColorRGBA (const char* string)
: ::xml_schema::string (string)
{
}

MFColorRGBA::
MFColorRGBA (const ::std::string& string)
: ::xml_schema::string (string)
{
}

MFColorRGBA::
MFColorRGBA (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

MFColorRGBA::
MFColorRGBA (const MFColorRGBA& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

MFColorRGBA::
MFColorRGBA (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

MFColorRGBA::
MFColorRGBA (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

MFColorRGBA::
MFColorRGBA (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

MFColorRGBA* MFColorRGBA::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFColorRGBA (*this, f, c);
}

MFColorRGBA::
~MFColorRGBA ()
{
}

// SFDouble
//

SFDouble::
SFDouble (const ::xml_schema::double_& double_)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type > (double_)
{
}

SFDouble::
SFDouble (const SFDouble& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type > (x, f, c)
{
}

SFDouble::
SFDouble (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type > (e, f, c)
{
}

SFDouble::
SFDouble (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type > (a, f, c)
{
}

SFDouble::
SFDouble (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::double_, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

SFDouble* SFDouble::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFDouble (*this, f, c);
}

SFDouble::
~SFDouble ()
{
}

// MFDouble
//

MFDouble::
MFDouble ()
: ::xml_schema::string ()
{
}

MFDouble::
MFDouble (const char* string)
: ::xml_schema::string (string)
{
}

MFDouble::
MFDouble (const ::std::string& string)
: ::xml_schema::string (string)
{
}

MFDouble::
MFDouble (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

MFDouble::
MFDouble (const MFDouble& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

MFDouble::
MFDouble (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

MFDouble::
MFDouble (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

MFDouble::
MFDouble (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

MFDouble* MFDouble::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFDouble (*this, f, c);
}

MFDouble::
~MFDouble ()
{
}

// SFFloat
//

SFFloat::
SFFloat (const ::xml_schema::float_& float_)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (float_)
{
}

SFFloat::
SFFloat (const SFFloat& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (x, f, c)
{
}

SFFloat::
SFFloat (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (e, f, c)
{
}

SFFloat::
SFFloat (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (a, f, c)
{
}

SFFloat::
SFFloat (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::float_, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

SFFloat* SFFloat::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFFloat (*this, f, c);
}

SFFloat::
~SFFloat ()
{
}

// MFFloat
//

MFFloat::
MFFloat ()
: ::xml_schema::string ()
{
}

MFFloat::
MFFloat (const char* string)
: ::xml_schema::string (string)
{
}

MFFloat::
MFFloat (const ::std::string& string)
: ::xml_schema::string (string)
{
}

MFFloat::
MFFloat (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

MFFloat::
MFFloat (const MFFloat& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

MFFloat::
MFFloat (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

MFFloat::
MFFloat (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

MFFloat::
MFFloat (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

MFFloat* MFFloat::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFFloat (*this, f, c);
}

MFFloat::
~MFFloat ()
{
}

// SFImage
//

SFImage::
SFImage ()
: ::xml_schema::string ()
{
}

SFImage::
SFImage (const char* string)
: ::xml_schema::string (string)
{
}

SFImage::
SFImage (const ::std::string& string)
: ::xml_schema::string (string)
{
}

SFImage::
SFImage (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

SFImage::
SFImage (const SFImage& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

SFImage::
SFImage (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

SFImage::
SFImage (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

SFImage::
SFImage (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

SFImage* SFImage::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFImage (*this, f, c);
}

SFImage::
~SFImage ()
{
}

// MFImage
//

MFImage::
MFImage ()
: ::xml_schema::string ()
{
}

MFImage::
MFImage (const char* string)
: ::xml_schema::string (string)
{
}

MFImage::
MFImage (const ::std::string& string)
: ::xml_schema::string (string)
{
}

MFImage::
MFImage (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

MFImage::
MFImage (const MFImage& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

MFImage::
MFImage (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

MFImage::
MFImage (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

MFImage::
MFImage (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

MFImage* MFImage::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFImage (*this, f, c);
}

MFImage::
~MFImage ()
{
}

// SFInt32
//

SFInt32::
SFInt32 (const ::xml_schema::integer& integer)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (integer)
{
}

SFInt32::
SFInt32 (const SFInt32& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (x, f, c)
{
}

SFInt32::
SFInt32 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (e, f, c)
{
}

SFInt32::
SFInt32 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (a, f, c)
{
}

SFInt32::
SFInt32 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::integer, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

SFInt32* SFInt32::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFInt32 (*this, f, c);
}

SFInt32::
~SFInt32 ()
{
}

// MFInt32
//

MFInt32::
MFInt32 ()
: ::xml_schema::string ()
{
}

MFInt32::
MFInt32 (const char* string)
: ::xml_schema::string (string)
{
}

MFInt32::
MFInt32 (const ::std::string& string)
: ::xml_schema::string (string)
{
}

MFInt32::
MFInt32 (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

MFInt32::
MFInt32 (const MFInt32& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

MFInt32::
MFInt32 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

MFInt32::
MFInt32 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

MFInt32::
MFInt32 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

MFInt32* MFInt32::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFInt32 (*this, f, c);
}

MFInt32::
~MFInt32 ()
{
}

// SFRotation
//

SFRotation::
SFRotation ()
: ::xml_schema::string ()
{
}

SFRotation::
SFRotation (const char* string)
: ::xml_schema::string (string)
{
}

SFRotation::
SFRotation (const ::std::string& string)
: ::xml_schema::string (string)
{
}

SFRotation::
SFRotation (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

SFRotation::
SFRotation (const SFRotation& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

SFRotation::
SFRotation (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

SFRotation::
SFRotation (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

SFRotation::
SFRotation (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

SFRotation* SFRotation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFRotation (*this, f, c);
}

SFRotation::
~SFRotation ()
{
}

// MFRotation
//

MFRotation::
MFRotation ()
: ::xml_schema::string ()
{
}

MFRotation::
MFRotation (const char* string)
: ::xml_schema::string (string)
{
}

MFRotation::
MFRotation (const ::std::string& string)
: ::xml_schema::string (string)
{
}

MFRotation::
MFRotation (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

MFRotation::
MFRotation (const MFRotation& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

MFRotation::
MFRotation (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

MFRotation::
MFRotation (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

MFRotation::
MFRotation (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

MFRotation* MFRotation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFRotation (*this, f, c);
}

MFRotation::
~MFRotation ()
{
}

// SFString
//

SFString::
SFString ()
: ::xml_schema::string ()
{
}

SFString::
SFString (const char* string)
: ::xml_schema::string (string)
{
}

SFString::
SFString (const ::std::string& string)
: ::xml_schema::string (string)
{
}

SFString::
SFString (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

SFString::
SFString (const SFString& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

SFString::
SFString (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

SFString::
SFString (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

SFString::
SFString (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

SFString* SFString::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFString (*this, f, c);
}

SFString::
~SFString ()
{
}

// MFString
//

MFString::
MFString (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::simple_type (e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (e, f, c)
{
}

MFString::
MFString (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::simple_type (a, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (a, f, c)
{
}

MFString::
MFString (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::simple_type (s, e, f, c),
  ::xsd::cxx::tree::list< ::xml_schema::string, char > (s, e, f, c)
{
}

MFString* MFString::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFString (*this, f, c);
}

MFString::
~MFString ()
{
}

// SFTime
//

SFTime::
SFTime ()
: ::xml_schema::string ()
{
}

SFTime::
SFTime (const char* string)
: ::xml_schema::string (string)
{
}

SFTime::
SFTime (const ::std::string& string)
: ::xml_schema::string (string)
{
}

SFTime::
SFTime (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

SFTime::
SFTime (const SFTime& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

SFTime::
SFTime (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

SFTime::
SFTime (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

SFTime::
SFTime (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

SFTime* SFTime::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFTime (*this, f, c);
}

SFTime::
~SFTime ()
{
}

// MFTime
//

MFTime::
MFTime ()
: ::xml_schema::string ()
{
}

MFTime::
MFTime (const char* string)
: ::xml_schema::string (string)
{
}

MFTime::
MFTime (const ::std::string& string)
: ::xml_schema::string (string)
{
}

MFTime::
MFTime (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

MFTime::
MFTime (const MFTime& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

MFTime::
MFTime (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

MFTime::
MFTime (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

MFTime::
MFTime (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

MFTime* MFTime::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFTime (*this, f, c);
}

MFTime::
~MFTime ()
{
}

// SFVec2f
//

SFVec2f::
SFVec2f ()
: ::xml_schema::string ()
{
}

SFVec2f::
SFVec2f (const char* string)
: ::xml_schema::string (string)
{
}

SFVec2f::
SFVec2f (const ::std::string& string)
: ::xml_schema::string (string)
{
}

SFVec2f::
SFVec2f (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

SFVec2f::
SFVec2f (const SFVec2f& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

SFVec2f::
SFVec2f (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

SFVec2f::
SFVec2f (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

SFVec2f::
SFVec2f (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

SFVec2f* SFVec2f::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFVec2f (*this, f, c);
}

SFVec2f::
~SFVec2f ()
{
}

// MFVec2f
//

MFVec2f::
MFVec2f ()
: ::xml_schema::string ()
{
}

MFVec2f::
MFVec2f (const char* string)
: ::xml_schema::string (string)
{
}

MFVec2f::
MFVec2f (const ::std::string& string)
: ::xml_schema::string (string)
{
}

MFVec2f::
MFVec2f (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

MFVec2f::
MFVec2f (const MFVec2f& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

MFVec2f::
MFVec2f (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

MFVec2f::
MFVec2f (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

MFVec2f::
MFVec2f (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

MFVec2f* MFVec2f::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFVec2f (*this, f, c);
}

MFVec2f::
~MFVec2f ()
{
}

// SFVec2d
//

SFVec2d::
SFVec2d ()
: ::xml_schema::string ()
{
}

SFVec2d::
SFVec2d (const char* string)
: ::xml_schema::string (string)
{
}

SFVec2d::
SFVec2d (const ::std::string& string)
: ::xml_schema::string (string)
{
}

SFVec2d::
SFVec2d (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

SFVec2d::
SFVec2d (const SFVec2d& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

SFVec2d::
SFVec2d (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

SFVec2d::
SFVec2d (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

SFVec2d::
SFVec2d (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

SFVec2d* SFVec2d::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFVec2d (*this, f, c);
}

SFVec2d::
~SFVec2d ()
{
}

// MFVec2d
//

MFVec2d::
MFVec2d ()
: ::xml_schema::string ()
{
}

MFVec2d::
MFVec2d (const char* string)
: ::xml_schema::string (string)
{
}

MFVec2d::
MFVec2d (const ::std::string& string)
: ::xml_schema::string (string)
{
}

MFVec2d::
MFVec2d (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

MFVec2d::
MFVec2d (const MFVec2d& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

MFVec2d::
MFVec2d (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

MFVec2d::
MFVec2d (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

MFVec2d::
MFVec2d (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

MFVec2d* MFVec2d::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFVec2d (*this, f, c);
}

MFVec2d::
~MFVec2d ()
{
}

// MFVec3f
//

MFVec3f::
MFVec3f ()
: ::xml_schema::string ()
{
}

MFVec3f::
MFVec3f (const char* string)
: ::xml_schema::string (string)
{
}

MFVec3f::
MFVec3f (const ::std::string& string)
: ::xml_schema::string (string)
{
}

MFVec3f::
MFVec3f (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

MFVec3f::
MFVec3f (const MFVec3f& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

MFVec3f::
MFVec3f (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

MFVec3f::
MFVec3f (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

MFVec3f::
MFVec3f (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

MFVec3f* MFVec3f::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFVec3f (*this, f, c);
}

MFVec3f::
~MFVec3f ()
{
}

// SFVec3d
//

SFVec3d::
SFVec3d ()
: ::xml_schema::string ()
{
}

SFVec3d::
SFVec3d (const char* string)
: ::xml_schema::string (string)
{
}

SFVec3d::
SFVec3d (const ::std::string& string)
: ::xml_schema::string (string)
{
}

SFVec3d::
SFVec3d (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

SFVec3d::
SFVec3d (const SFVec3d& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

SFVec3d::
SFVec3d (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

SFVec3d::
SFVec3d (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

SFVec3d::
SFVec3d (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

SFVec3d* SFVec3d::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFVec3d (*this, f, c);
}

SFVec3d::
~SFVec3d ()
{
}

// MFVec3d
//

MFVec3d::
MFVec3d ()
: ::xml_schema::string ()
{
}

MFVec3d::
MFVec3d (const char* string)
: ::xml_schema::string (string)
{
}

MFVec3d::
MFVec3d (const ::std::string& string)
: ::xml_schema::string (string)
{
}

MFVec3d::
MFVec3d (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

MFVec3d::
MFVec3d (const MFVec3d& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

MFVec3d::
MFVec3d (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

MFVec3d::
MFVec3d (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

MFVec3d::
MFVec3d (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

MFVec3d* MFVec3d::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFVec3d (*this, f, c);
}

MFVec3d::
~MFVec3d ()
{
}

// SFVec4f
//

SFVec4f::
SFVec4f ()
: ::xml_schema::string ()
{
}

SFVec4f::
SFVec4f (const char* string)
: ::xml_schema::string (string)
{
}

SFVec4f::
SFVec4f (const ::std::string& string)
: ::xml_schema::string (string)
{
}

SFVec4f::
SFVec4f (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

SFVec4f::
SFVec4f (const SFVec4f& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

SFVec4f::
SFVec4f (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

SFVec4f::
SFVec4f (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

SFVec4f::
SFVec4f (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

SFVec4f* SFVec4f::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFVec4f (*this, f, c);
}

SFVec4f::
~SFVec4f ()
{
}

// MFVec4f
//

MFVec4f::
MFVec4f ()
: ::xml_schema::string ()
{
}

MFVec4f::
MFVec4f (const char* string)
: ::xml_schema::string (string)
{
}

MFVec4f::
MFVec4f (const ::std::string& string)
: ::xml_schema::string (string)
{
}

MFVec4f::
MFVec4f (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

MFVec4f::
MFVec4f (const MFVec4f& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

MFVec4f::
MFVec4f (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

MFVec4f::
MFVec4f (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

MFVec4f::
MFVec4f (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

MFVec4f* MFVec4f::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFVec4f (*this, f, c);
}

MFVec4f::
~MFVec4f ()
{
}

// SFVec4d
//

SFVec4d::
SFVec4d ()
: ::xml_schema::string ()
{
}

SFVec4d::
SFVec4d (const char* string)
: ::xml_schema::string (string)
{
}

SFVec4d::
SFVec4d (const ::std::string& string)
: ::xml_schema::string (string)
{
}

SFVec4d::
SFVec4d (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

SFVec4d::
SFVec4d (const SFVec4d& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

SFVec4d::
SFVec4d (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

SFVec4d::
SFVec4d (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

SFVec4d::
SFVec4d (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

SFVec4d* SFVec4d::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFVec4d (*this, f, c);
}

SFVec4d::
~SFVec4d ()
{
}

// MFVec4d
//

MFVec4d::
MFVec4d ()
: ::xml_schema::string ()
{
}

MFVec4d::
MFVec4d (const char* string)
: ::xml_schema::string (string)
{
}

MFVec4d::
MFVec4d (const ::std::string& string)
: ::xml_schema::string (string)
{
}

MFVec4d::
MFVec4d (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

MFVec4d::
MFVec4d (const MFVec4d& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

MFVec4d::
MFVec4d (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

MFVec4d::
MFVec4d (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

MFVec4d::
MFVec4d (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

MFVec4d* MFVec4d::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFVec4d (*this, f, c);
}

MFVec4d::
~MFVec4d ()
{
}

// SFMatrix3f
//

SFMatrix3f::
SFMatrix3f ()
: ::xml_schema::string ()
{
}

SFMatrix3f::
SFMatrix3f (const char* string)
: ::xml_schema::string (string)
{
}

SFMatrix3f::
SFMatrix3f (const ::std::string& string)
: ::xml_schema::string (string)
{
}

SFMatrix3f::
SFMatrix3f (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

SFMatrix3f::
SFMatrix3f (const SFMatrix3f& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

SFMatrix3f::
SFMatrix3f (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

SFMatrix3f::
SFMatrix3f (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

SFMatrix3f::
SFMatrix3f (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

SFMatrix3f* SFMatrix3f::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFMatrix3f (*this, f, c);
}

SFMatrix3f::
~SFMatrix3f ()
{
}

// MFMatrix3f
//

MFMatrix3f::
MFMatrix3f ()
: ::xml_schema::string ()
{
}

MFMatrix3f::
MFMatrix3f (const char* string)
: ::xml_schema::string (string)
{
}

MFMatrix3f::
MFMatrix3f (const ::std::string& string)
: ::xml_schema::string (string)
{
}

MFMatrix3f::
MFMatrix3f (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

MFMatrix3f::
MFMatrix3f (const MFMatrix3f& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

MFMatrix3f::
MFMatrix3f (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

MFMatrix3f::
MFMatrix3f (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

MFMatrix3f::
MFMatrix3f (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

MFMatrix3f* MFMatrix3f::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFMatrix3f (*this, f, c);
}

MFMatrix3f::
~MFMatrix3f ()
{
}

// SFMatrix3d
//

SFMatrix3d::
SFMatrix3d ()
: ::xml_schema::string ()
{
}

SFMatrix3d::
SFMatrix3d (const char* string)
: ::xml_schema::string (string)
{
}

SFMatrix3d::
SFMatrix3d (const ::std::string& string)
: ::xml_schema::string (string)
{
}

SFMatrix3d::
SFMatrix3d (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

SFMatrix3d::
SFMatrix3d (const SFMatrix3d& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

SFMatrix3d::
SFMatrix3d (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

SFMatrix3d::
SFMatrix3d (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

SFMatrix3d::
SFMatrix3d (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

SFMatrix3d* SFMatrix3d::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFMatrix3d (*this, f, c);
}

SFMatrix3d::
~SFMatrix3d ()
{
}

// MFMatrix3d
//

MFMatrix3d::
MFMatrix3d ()
: ::xml_schema::string ()
{
}

MFMatrix3d::
MFMatrix3d (const char* string)
: ::xml_schema::string (string)
{
}

MFMatrix3d::
MFMatrix3d (const ::std::string& string)
: ::xml_schema::string (string)
{
}

MFMatrix3d::
MFMatrix3d (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

MFMatrix3d::
MFMatrix3d (const MFMatrix3d& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

MFMatrix3d::
MFMatrix3d (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

MFMatrix3d::
MFMatrix3d (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

MFMatrix3d::
MFMatrix3d (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

MFMatrix3d* MFMatrix3d::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFMatrix3d (*this, f, c);
}

MFMatrix3d::
~MFMatrix3d ()
{
}

// SFMatrix4f
//

SFMatrix4f::
SFMatrix4f ()
: ::xml_schema::string ()
{
}

SFMatrix4f::
SFMatrix4f (const char* string)
: ::xml_schema::string (string)
{
}

SFMatrix4f::
SFMatrix4f (const ::std::string& string)
: ::xml_schema::string (string)
{
}

SFMatrix4f::
SFMatrix4f (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

SFMatrix4f::
SFMatrix4f (const SFMatrix4f& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

SFMatrix4f::
SFMatrix4f (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

SFMatrix4f::
SFMatrix4f (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

SFMatrix4f::
SFMatrix4f (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

SFMatrix4f* SFMatrix4f::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFMatrix4f (*this, f, c);
}

SFMatrix4f::
~SFMatrix4f ()
{
}

// MFMatrix4f
//

MFMatrix4f::
MFMatrix4f ()
: ::xml_schema::string ()
{
}

MFMatrix4f::
MFMatrix4f (const char* string)
: ::xml_schema::string (string)
{
}

MFMatrix4f::
MFMatrix4f (const ::std::string& string)
: ::xml_schema::string (string)
{
}

MFMatrix4f::
MFMatrix4f (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

MFMatrix4f::
MFMatrix4f (const MFMatrix4f& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

MFMatrix4f::
MFMatrix4f (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

MFMatrix4f::
MFMatrix4f (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

MFMatrix4f::
MFMatrix4f (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

MFMatrix4f* MFMatrix4f::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFMatrix4f (*this, f, c);
}

MFMatrix4f::
~MFMatrix4f ()
{
}

// SFMatrix4d
//

SFMatrix4d::
SFMatrix4d ()
: ::xml_schema::string ()
{
}

SFMatrix4d::
SFMatrix4d (const char* string)
: ::xml_schema::string (string)
{
}

SFMatrix4d::
SFMatrix4d (const ::std::string& string)
: ::xml_schema::string (string)
{
}

SFMatrix4d::
SFMatrix4d (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

SFMatrix4d::
SFMatrix4d (const SFMatrix4d& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

SFMatrix4d::
SFMatrix4d (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

SFMatrix4d::
SFMatrix4d (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

SFMatrix4d::
SFMatrix4d (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

SFMatrix4d* SFMatrix4d::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SFMatrix4d (*this, f, c);
}

SFMatrix4d::
~SFMatrix4d ()
{
}

// MFMatrix4d
//

MFMatrix4d::
MFMatrix4d ()
: ::xml_schema::string ()
{
}

MFMatrix4d::
MFMatrix4d (const char* string)
: ::xml_schema::string (string)
{
}

MFMatrix4d::
MFMatrix4d (const ::std::string& string)
: ::xml_schema::string (string)
{
}

MFMatrix4d::
MFMatrix4d (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

MFMatrix4d::
MFMatrix4d (const MFMatrix4d& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

MFMatrix4d::
MFMatrix4d (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

MFMatrix4d::
MFMatrix4d (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

MFMatrix4d::
MFMatrix4d (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

MFMatrix4d* MFMatrix4d::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MFMatrix4d (*this, f, c);
}

MFMatrix4d::
~MFMatrix4d ()
{
}

// accessTypeNames
//

accessTypeNames::
accessTypeNames (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_accessTypeNames_convert ();
}

accessTypeNames::
accessTypeNames (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_accessTypeNames_convert ();
}

accessTypeNames::
accessTypeNames (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_accessTypeNames_convert ();
}

accessTypeNames* accessTypeNames::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new accessTypeNames (*this, f, c);
}

accessTypeNames::value accessTypeNames::
_xsd_accessTypeNames_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_accessTypeNames_literals_);
  const value* i (::std::lower_bound (
                    _xsd_accessTypeNames_indexes_,
                    _xsd_accessTypeNames_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_accessTypeNames_indexes_ + 4 || _xsd_accessTypeNames_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const accessTypeNames::
_xsd_accessTypeNames_literals_[4] =
{
  "initializeOnly",
  "inputOnly",
  "outputOnly",
  "inputOutput"
};

const accessTypeNames::value accessTypeNames::
_xsd_accessTypeNames_indexes_[4] =
{
  ::accessTypeNames::initializeOnly,
  ::accessTypeNames::inputOnly,
  ::accessTypeNames::inputOutput,
  ::accessTypeNames::outputOnly
};

// ArcClose2dTypeValues
//

ArcClose2dTypeValues::
ArcClose2dTypeValues (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::token (e, f, c)
{
  _xsd_ArcClose2dTypeValues_convert ();
}

ArcClose2dTypeValues::
ArcClose2dTypeValues (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::token (a, f, c)
{
  _xsd_ArcClose2dTypeValues_convert ();
}

ArcClose2dTypeValues::
ArcClose2dTypeValues (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::token (s, e, f, c)
{
  _xsd_ArcClose2dTypeValues_convert ();
}

ArcClose2dTypeValues* ArcClose2dTypeValues::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ArcClose2dTypeValues (*this, f, c);
}

ArcClose2dTypeValues::value ArcClose2dTypeValues::
_xsd_ArcClose2dTypeValues_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ArcClose2dTypeValues_literals_);
  const value* i (::std::lower_bound (
                    _xsd_ArcClose2dTypeValues_indexes_,
                    _xsd_ArcClose2dTypeValues_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_ArcClose2dTypeValues_indexes_ + 2 || _xsd_ArcClose2dTypeValues_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ArcClose2dTypeValues::
_xsd_ArcClose2dTypeValues_literals_[2] =
{
  "PIE",
  "CHORD"
};

const ArcClose2dTypeValues::value ArcClose2dTypeValues::
_xsd_ArcClose2dTypeValues_indexes_[2] =
{
  ::ArcClose2dTypeValues::CHORD,
  ::ArcClose2dTypeValues::PIE
};

// componentNames
//

componentNames::
componentNames (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_componentNames_convert ();
}

componentNames::
componentNames (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_componentNames_convert ();
}

componentNames::
componentNames (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_componentNames_convert ();
}

componentNames* componentNames::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new componentNames (*this, f, c);
}

componentNames::value componentNames::
_xsd_componentNames_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_componentNames_literals_);
  const value* i (::std::lower_bound (
                    _xsd_componentNames_indexes_,
                    _xsd_componentNames_indexes_ + 28,
                    *this,
                    c));

  if (i == _xsd_componentNames_indexes_ + 28 || _xsd_componentNames_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const componentNames::
_xsd_componentNames_literals_[28] =
{
  "Core",
  "CADGeometry",
  "CubeMapTexturing",
  "DIS",
  "EnvironmentalEffects",
  "EnvironmentalSensor",
  "EventUtilities",
  "Geometry2D",
  "Geometry3D",
  "Geospatial",
  "Grouping",
  "H-Anim",
  "Interpolation",
  "KeyDeviceSensor",
  "Lighting",
  "Navigation",
  "Networking",
  "NURBS",
  "PointingDeviceSensor",
  "Rendering",
  "Scripting",
  "Shaders",
  "Shape",
  "Sound",
  "Text",
  "Texturing",
  "Texturing3D",
  "Time"
};

const componentNames::value componentNames::
_xsd_componentNames_indexes_[28] =
{
  ::componentNames::CADGeometry,
  ::componentNames::Core,
  ::componentNames::CubeMapTexturing,
  ::componentNames::DIS,
  ::componentNames::EnvironmentalEffects,
  ::componentNames::EnvironmentalSensor,
  ::componentNames::EventUtilities,
  ::componentNames::Geometry2D,
  ::componentNames::Geometry3D,
  ::componentNames::Geospatial,
  ::componentNames::Grouping,
  ::componentNames::H_Anim,
  ::componentNames::Interpolation,
  ::componentNames::KeyDeviceSensor,
  ::componentNames::Lighting,
  ::componentNames::NURBS,
  ::componentNames::Navigation,
  ::componentNames::Networking,
  ::componentNames::PointingDeviceSensor,
  ::componentNames::Rendering,
  ::componentNames::Scripting,
  ::componentNames::Shaders,
  ::componentNames::Shape,
  ::componentNames::Sound,
  ::componentNames::Text,
  ::componentNames::Texturing,
  ::componentNames::Texturing3D,
  ::componentNames::Time
};

// fieldTypeName
//

fieldTypeName::
fieldTypeName (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_fieldTypeName_convert ();
}

fieldTypeName::
fieldTypeName (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_fieldTypeName_convert ();
}

fieldTypeName::
fieldTypeName (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_fieldTypeName_convert ();
}

fieldTypeName* fieldTypeName::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new fieldTypeName (*this, f, c);
}

fieldTypeName::value fieldTypeName::
_xsd_fieldTypeName_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_fieldTypeName_literals_);
  const value* i (::std::lower_bound (
                    _xsd_fieldTypeName_indexes_,
                    _xsd_fieldTypeName_indexes_ + 30,
                    *this,
                    c));

  if (i == _xsd_fieldTypeName_indexes_ + 30 || _xsd_fieldTypeName_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const fieldTypeName::
_xsd_fieldTypeName_literals_[30] =
{
  "SFBool",
  "MFBool",
  "SFColor",
  "MFColor",
  "SFColorRGBA",
  "MFColorRGBA",
  "SFDouble",
  "MFDouble",
  "SFFloat",
  "MFFloat",
  "SFImage",
  "MFImage",
  "SFInt32",
  "SFNode",
  "MFNode",
  "MFInt32",
  "SFRotation",
  "MFRotation",
  "SFString",
  "MFString",
  "SFTime",
  "MFTime",
  "SFVec2d",
  "MFVec2d",
  "SFVec2f",
  "MFVec2f",
  "SFVec3d",
  "MFVec3d",
  "SFVec3f",
  "MFVec3f"
};

const fieldTypeName::value fieldTypeName::
_xsd_fieldTypeName_indexes_[30] =
{
  ::fieldTypeName::MFBool,
  ::fieldTypeName::MFColor,
  ::fieldTypeName::MFColorRGBA,
  ::fieldTypeName::MFDouble,
  ::fieldTypeName::MFFloat,
  ::fieldTypeName::MFImage,
  ::fieldTypeName::MFInt32,
  ::fieldTypeName::MFNode,
  ::fieldTypeName::MFRotation,
  ::fieldTypeName::MFString,
  ::fieldTypeName::MFTime,
  ::fieldTypeName::MFVec2d,
  ::fieldTypeName::MFVec2f,
  ::fieldTypeName::MFVec3d,
  ::fieldTypeName::MFVec3f,
  ::fieldTypeName::SFBool,
  ::fieldTypeName::SFColor,
  ::fieldTypeName::SFColorRGBA,
  ::fieldTypeName::SFDouble,
  ::fieldTypeName::SFFloat,
  ::fieldTypeName::SFImage,
  ::fieldTypeName::SFInt32,
  ::fieldTypeName::SFNode,
  ::fieldTypeName::SFRotation,
  ::fieldTypeName::SFString,
  ::fieldTypeName::SFTime,
  ::fieldTypeName::SFVec2d,
  ::fieldTypeName::SFVec2f,
  ::fieldTypeName::SFVec3d,
  ::fieldTypeName::SFVec3f
};

// fontStyleValues
//

fontStyleValues::
fontStyleValues (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::token (e, f, c)
{
  _xsd_fontStyleValues_convert ();
}

fontStyleValues::
fontStyleValues (const ::xercesc::DOMAttr& a,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::token (a, f, c)
{
  _xsd_fontStyleValues_convert ();
}

fontStyleValues::
fontStyleValues (const ::std::string& s,
                 const ::xercesc::DOMElement* e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::token (s, e, f, c)
{
  _xsd_fontStyleValues_convert ();
}

fontStyleValues* fontStyleValues::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new fontStyleValues (*this, f, c);
}

fontStyleValues::value fontStyleValues::
_xsd_fontStyleValues_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_fontStyleValues_literals_);
  const value* i (::std::lower_bound (
                    _xsd_fontStyleValues_indexes_,
                    _xsd_fontStyleValues_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_fontStyleValues_indexes_ + 4 || _xsd_fontStyleValues_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const fontStyleValues::
_xsd_fontStyleValues_literals_[4] =
{
  "PLAIN",
  "BOLD",
  "ITALIC",
  "BOLDITALIC"
};

const fontStyleValues::value fontStyleValues::
_xsd_fontStyleValues_indexes_[4] =
{
  ::fontStyleValues::BOLD,
  ::fontStyleValues::BOLDITALIC,
  ::fontStyleValues::ITALIC,
  ::fontStyleValues::PLAIN
};

// fogTypeValues
//

fogTypeValues::
fogTypeValues (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::token (e, f, c)
{
  _xsd_fogTypeValues_convert ();
}

fogTypeValues::
fogTypeValues (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::token (a, f, c)
{
  _xsd_fogTypeValues_convert ();
}

fogTypeValues::
fogTypeValues (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::token (s, e, f, c)
{
  _xsd_fogTypeValues_convert ();
}

fogTypeValues* fogTypeValues::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new fogTypeValues (*this, f, c);
}

fogTypeValues::value fogTypeValues::
_xsd_fogTypeValues_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_fogTypeValues_literals_);
  const value* i (::std::lower_bound (
                    _xsd_fogTypeValues_indexes_,
                    _xsd_fogTypeValues_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_fogTypeValues_indexes_ + 2 || _xsd_fogTypeValues_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const fogTypeValues::
_xsd_fogTypeValues_literals_[2] =
{
  "LINEAR",
  "EXPONENTIAL"
};

const fogTypeValues::value fogTypeValues::
_xsd_fogTypeValues_indexes_[2] =
{
  ::fogTypeValues::EXPONENTIAL,
  ::fogTypeValues::LINEAR
};

// shaderPartTypeValues
//

shaderPartTypeValues::
shaderPartTypeValues (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::token (e, f, c)
{
  _xsd_shaderPartTypeValues_convert ();
}

shaderPartTypeValues::
shaderPartTypeValues (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::token (a, f, c)
{
  _xsd_shaderPartTypeValues_convert ();
}

shaderPartTypeValues::
shaderPartTypeValues (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::token (s, e, f, c)
{
  _xsd_shaderPartTypeValues_convert ();
}

shaderPartTypeValues* shaderPartTypeValues::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new shaderPartTypeValues (*this, f, c);
}

shaderPartTypeValues::value shaderPartTypeValues::
_xsd_shaderPartTypeValues_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_shaderPartTypeValues_literals_);
  const value* i (::std::lower_bound (
                    _xsd_shaderPartTypeValues_indexes_,
                    _xsd_shaderPartTypeValues_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_shaderPartTypeValues_indexes_ + 2 || _xsd_shaderPartTypeValues_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const shaderPartTypeValues::
_xsd_shaderPartTypeValues_literals_[2] =
{
  "VERTEX",
  "FRAGMENT"
};

const shaderPartTypeValues::value shaderPartTypeValues::
_xsd_shaderPartTypeValues_indexes_[2] =
{
  ::shaderPartTypeValues::FRAGMENT,
  ::shaderPartTypeValues::VERTEX
};

// metaDirectionValues
//

metaDirectionValues::
metaDirectionValues (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_metaDirectionValues_convert ();
}

metaDirectionValues::
metaDirectionValues (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_metaDirectionValues_convert ();
}

metaDirectionValues::
metaDirectionValues (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_metaDirectionValues_convert ();
}

metaDirectionValues* metaDirectionValues::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new metaDirectionValues (*this, f, c);
}

metaDirectionValues::value metaDirectionValues::
_xsd_metaDirectionValues_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_metaDirectionValues_literals_);
  const value* i (::std::lower_bound (
                    _xsd_metaDirectionValues_indexes_,
                    _xsd_metaDirectionValues_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_metaDirectionValues_indexes_ + 2 || _xsd_metaDirectionValues_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const metaDirectionValues::
_xsd_metaDirectionValues_literals_[2] =
{
  "rtl",
  "ltr"
};

const metaDirectionValues::value metaDirectionValues::
_xsd_metaDirectionValues_indexes_[2] =
{
  ::metaDirectionValues::ltr,
  ::metaDirectionValues::rtl
};

// networkModeValues
//

networkModeValues::
networkModeValues (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::token (e, f, c)
{
  _xsd_networkModeValues_convert ();
}

networkModeValues::
networkModeValues (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::token (a, f, c)
{
  _xsd_networkModeValues_convert ();
}

networkModeValues::
networkModeValues (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::token (s, e, f, c)
{
  _xsd_networkModeValues_convert ();
}

networkModeValues* networkModeValues::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new networkModeValues (*this, f, c);
}

networkModeValues::value networkModeValues::
_xsd_networkModeValues_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_networkModeValues_literals_);
  const value* i (::std::lower_bound (
                    _xsd_networkModeValues_indexes_,
                    _xsd_networkModeValues_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_networkModeValues_indexes_ + 3 || _xsd_networkModeValues_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const networkModeValues::
_xsd_networkModeValues_literals_[3] =
{
  "standAlone",
  "networkReader",
  "networkWriter"
};

const networkModeValues::value networkModeValues::
_xsd_networkModeValues_indexes_[3] =
{
  ::networkModeValues::networkReader,
  ::networkModeValues::networkWriter,
  ::networkModeValues::standAlone
};

// profileNames
//

profileNames::
profileNames (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_profileNames_convert ();
}

profileNames::
profileNames (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_profileNames_convert ();
}

profileNames::
profileNames (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_profileNames_convert ();
}

profileNames* profileNames::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new profileNames (*this, f, c);
}

profileNames::value profileNames::
_xsd_profileNames_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_profileNames_literals_);
  const value* i (::std::lower_bound (
                    _xsd_profileNames_indexes_,
                    _xsd_profileNames_indexes_ + 7,
                    *this,
                    c));

  if (i == _xsd_profileNames_indexes_ + 7 || _xsd_profileNames_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const profileNames::
_xsd_profileNames_literals_[7] =
{
  "Core",
  "Interchange",
  "CADInterchange",
  "Interactive",
  "Immersive",
  "MPEG4Interactive",
  "Full"
};

const profileNames::value profileNames::
_xsd_profileNames_indexes_[7] =
{
  ::profileNames::CADInterchange,
  ::profileNames::Core,
  ::profileNames::Full,
  ::profileNames::Immersive,
  ::profileNames::Interactive,
  ::profileNames::Interchange,
  ::profileNames::MPEG4Interactive
};

// x3dVersion
//

x3dVersion::
x3dVersion (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_x3dVersion_convert ();
}

x3dVersion::
x3dVersion (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_x3dVersion_convert ();
}

x3dVersion::
x3dVersion (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_x3dVersion_convert ();
}

x3dVersion* x3dVersion::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new x3dVersion (*this, f, c);
}

x3dVersion::value x3dVersion::
_xsd_x3dVersion_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_x3dVersion_literals_);
  const value* i (::std::lower_bound (
                    _xsd_x3dVersion_indexes_,
                    _xsd_x3dVersion_indexes_ + 2,
                    *this,
                    c));

  if (i == _xsd_x3dVersion_indexes_ + 2 || _xsd_x3dVersion_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const x3dVersion::
_xsd_x3dVersion_literals_[2] =
{
  "3.0",
  "3.1"
};

const x3dVersion::value x3dVersion::
_xsd_x3dVersion_indexes_[2] =
{
  ::x3dVersion::cxx_3_0,
  ::x3dVersion::cxx_3_1
};

// initializeOnlyAccessTypes
//

initializeOnlyAccessTypes::
initializeOnlyAccessTypes (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_initializeOnlyAccessTypes_convert ();
}

initializeOnlyAccessTypes::
initializeOnlyAccessTypes (const ::xercesc::DOMAttr& a,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_initializeOnlyAccessTypes_convert ();
}

initializeOnlyAccessTypes::
initializeOnlyAccessTypes (const ::std::string& s,
                           const ::xercesc::DOMElement* e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_initializeOnlyAccessTypes_convert ();
}

initializeOnlyAccessTypes* initializeOnlyAccessTypes::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new initializeOnlyAccessTypes (*this, f, c);
}

initializeOnlyAccessTypes::value initializeOnlyAccessTypes::
_xsd_initializeOnlyAccessTypes_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_initializeOnlyAccessTypes_literals_);
  const value* i (::std::lower_bound (
                    _xsd_initializeOnlyAccessTypes_indexes_,
                    _xsd_initializeOnlyAccessTypes_indexes_ + 76,
                    *this,
                    c));

  if (i == _xsd_initializeOnlyAccessTypes_indexes_ + 76 || _xsd_initializeOnlyAccessTypes_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const initializeOnlyAccessTypes::
_xsd_initializeOnlyAccessTypes_literals_[76] =
{
  "bboxCenter",
  "bboxSize",
  "beginCap",
  "bottom",
  "bottomRadius",
  "ccw",
  "child1Url",
  "child2Url",
  "child3Url",
  "child4Url",
  "closed",
  "closureType",
  "colorIndex",
  "colorPerVertex",
  "convex",
  "coordIndex",
  "creaseAngle",
  "crossSection",
  "directOutput",
  "endCap",
  "endAngle",
  "forceTransitions",
  "geoGridOrigin",
  "geoSystem",
  "height",
  "horizontal",
  "index",
  "info",
  "innerRadius",
  "justify",
  "knot",
  "language",
  "leftToRight",
  "lineSegments",
  "mustEvaluate",
  "name",
  "normalIndex",
  "normalPerVertex",
  "numComponents",
  "order",
  "outerRadius",
  "orientation",
  "radius",
  "range",
  "repeatR",
  "repeatS",
  "repeatT",
  "rootUrl",
  "rotateYUp",
  "rtpHeaderExpected",
  "side",
  "size",
  "solid",
  "spacing",
  "spatialize",
  "speedFactor",
  "spine",
  "startAngle",
  "style",
  "texCoordIndex",
  "title",
  "top",
  "topToBottom",
  "type",
  "uClosed",
  "uDimension",
  "uKnot",
  "uOrder",
  "vClosed",
  "vDimension",
  "vKnot",
  "vOrder",
  "xDimension",
  "xSpacing",
  "zDimension",
  "zSpacing"
};

const initializeOnlyAccessTypes::value initializeOnlyAccessTypes::
_xsd_initializeOnlyAccessTypes_indexes_[76] =
{
  ::initializeOnlyAccessTypes::bboxCenter,
  ::initializeOnlyAccessTypes::bboxSize,
  ::initializeOnlyAccessTypes::beginCap,
  ::initializeOnlyAccessTypes::bottom,
  ::initializeOnlyAccessTypes::bottomRadius,
  ::initializeOnlyAccessTypes::ccw,
  ::initializeOnlyAccessTypes::child1Url,
  ::initializeOnlyAccessTypes::child2Url,
  ::initializeOnlyAccessTypes::child3Url,
  ::initializeOnlyAccessTypes::child4Url,
  ::initializeOnlyAccessTypes::closed,
  ::initializeOnlyAccessTypes::closureType,
  ::initializeOnlyAccessTypes::colorIndex,
  ::initializeOnlyAccessTypes::colorPerVertex,
  ::initializeOnlyAccessTypes::convex,
  ::initializeOnlyAccessTypes::coordIndex,
  ::initializeOnlyAccessTypes::creaseAngle,
  ::initializeOnlyAccessTypes::crossSection,
  ::initializeOnlyAccessTypes::directOutput,
  ::initializeOnlyAccessTypes::endAngle,
  ::initializeOnlyAccessTypes::endCap,
  ::initializeOnlyAccessTypes::forceTransitions,
  ::initializeOnlyAccessTypes::geoGridOrigin,
  ::initializeOnlyAccessTypes::geoSystem,
  ::initializeOnlyAccessTypes::height,
  ::initializeOnlyAccessTypes::horizontal,
  ::initializeOnlyAccessTypes::index,
  ::initializeOnlyAccessTypes::info,
  ::initializeOnlyAccessTypes::innerRadius,
  ::initializeOnlyAccessTypes::justify,
  ::initializeOnlyAccessTypes::knot,
  ::initializeOnlyAccessTypes::language,
  ::initializeOnlyAccessTypes::leftToRight,
  ::initializeOnlyAccessTypes::lineSegments,
  ::initializeOnlyAccessTypes::mustEvaluate,
  ::initializeOnlyAccessTypes::name,
  ::initializeOnlyAccessTypes::normalIndex,
  ::initializeOnlyAccessTypes::normalPerVertex,
  ::initializeOnlyAccessTypes::numComponents,
  ::initializeOnlyAccessTypes::order,
  ::initializeOnlyAccessTypes::orientation,
  ::initializeOnlyAccessTypes::outerRadius,
  ::initializeOnlyAccessTypes::radius,
  ::initializeOnlyAccessTypes::range,
  ::initializeOnlyAccessTypes::repeatR,
  ::initializeOnlyAccessTypes::repeatS,
  ::initializeOnlyAccessTypes::repeatT,
  ::initializeOnlyAccessTypes::rootUrl,
  ::initializeOnlyAccessTypes::rotateYUp,
  ::initializeOnlyAccessTypes::rtpHeaderExpected,
  ::initializeOnlyAccessTypes::side,
  ::initializeOnlyAccessTypes::size,
  ::initializeOnlyAccessTypes::solid,
  ::initializeOnlyAccessTypes::spacing,
  ::initializeOnlyAccessTypes::spatialize,
  ::initializeOnlyAccessTypes::speedFactor,
  ::initializeOnlyAccessTypes::spine,
  ::initializeOnlyAccessTypes::startAngle,
  ::initializeOnlyAccessTypes::style,
  ::initializeOnlyAccessTypes::texCoordIndex,
  ::initializeOnlyAccessTypes::title,
  ::initializeOnlyAccessTypes::top,
  ::initializeOnlyAccessTypes::topToBottom,
  ::initializeOnlyAccessTypes::type,
  ::initializeOnlyAccessTypes::uClosed,
  ::initializeOnlyAccessTypes::uDimension,
  ::initializeOnlyAccessTypes::uKnot,
  ::initializeOnlyAccessTypes::uOrder,
  ::initializeOnlyAccessTypes::vClosed,
  ::initializeOnlyAccessTypes::vDimension,
  ::initializeOnlyAccessTypes::vKnot,
  ::initializeOnlyAccessTypes::vOrder,
  ::initializeOnlyAccessTypes::xDimension,
  ::initializeOnlyAccessTypes::xSpacing,
  ::initializeOnlyAccessTypes::zDimension,
  ::initializeOnlyAccessTypes::zSpacing
};

// inputOnlyAccessTypes
//

inputOnlyAccessTypes::
inputOnlyAccessTypes (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_inputOnlyAccessTypes_convert ();
}

inputOnlyAccessTypes::
inputOnlyAccessTypes (const ::xercesc::DOMAttr& a,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_inputOnlyAccessTypes_convert ();
}

inputOnlyAccessTypes::
inputOnlyAccessTypes (const ::std::string& s,
                      const ::xercesc::DOMElement* e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_inputOnlyAccessTypes_convert ();
}

inputOnlyAccessTypes* inputOnlyAccessTypes::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new inputOnlyAccessTypes (*this, f, c);
}

inputOnlyAccessTypes::value inputOnlyAccessTypes::
_xsd_inputOnlyAccessTypes_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_inputOnlyAccessTypes_literals_);
  const value* i (::std::lower_bound (
                    _xsd_inputOnlyAccessTypes_indexes_,
                    _xsd_inputOnlyAccessTypes_indexes_ + 24,
                    *this,
                    c));

  if (i == _xsd_inputOnlyAccessTypes_indexes_ + 24 || _xsd_inputOnlyAccessTypes_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const inputOnlyAccessTypes::
_xsd_inputOnlyAccessTypes_literals_[24] =
{
  "activate",
  "set_articulationParameterValue0",
  "set_articulationParameterValue1",
  "set_articulationParameterValue2",
  "set_articulationParameterValue3",
  "set_articulationParameterValue4",
  "set_articulationParameterValue5",
  "set_articulationParameterValue6",
  "set_articulationParameterValue7",
  "set_boolean",
  "set_bind",
  "set_colorIndex",
  "set_coordIndex",
  "set_crossSection",
  "set_fraction",
  "set_height",
  "set_index",
  "set_normalIndex",
  "set_orientation",
  "set_position",
  "set_scale",
  "set_spine",
  "set_texCoordIndex",
  "set_triggerTime"
};

const inputOnlyAccessTypes::value inputOnlyAccessTypes::
_xsd_inputOnlyAccessTypes_indexes_[24] =
{
  ::inputOnlyAccessTypes::activate,
  ::inputOnlyAccessTypes::set_articulationParameterValue0,
  ::inputOnlyAccessTypes::set_articulationParameterValue1,
  ::inputOnlyAccessTypes::set_articulationParameterValue2,
  ::inputOnlyAccessTypes::set_articulationParameterValue3,
  ::inputOnlyAccessTypes::set_articulationParameterValue4,
  ::inputOnlyAccessTypes::set_articulationParameterValue5,
  ::inputOnlyAccessTypes::set_articulationParameterValue6,
  ::inputOnlyAccessTypes::set_articulationParameterValue7,
  ::inputOnlyAccessTypes::set_bind,
  ::inputOnlyAccessTypes::set_boolean,
  ::inputOnlyAccessTypes::set_colorIndex,
  ::inputOnlyAccessTypes::set_coordIndex,
  ::inputOnlyAccessTypes::set_crossSection,
  ::inputOnlyAccessTypes::set_fraction,
  ::inputOnlyAccessTypes::set_height,
  ::inputOnlyAccessTypes::set_index,
  ::inputOnlyAccessTypes::set_normalIndex,
  ::inputOnlyAccessTypes::set_orientation,
  ::inputOnlyAccessTypes::set_position,
  ::inputOnlyAccessTypes::set_scale,
  ::inputOnlyAccessTypes::set_spine,
  ::inputOnlyAccessTypes::set_texCoordIndex,
  ::inputOnlyAccessTypes::set_triggerTime
};

// outputOnlyAccessTypes
//

outputOnlyAccessTypes::
outputOnlyAccessTypes (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_outputOnlyAccessTypes_convert ();
}

outputOnlyAccessTypes::
outputOnlyAccessTypes (const ::xercesc::DOMAttr& a,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_outputOnlyAccessTypes_convert ();
}

outputOnlyAccessTypes::
outputOnlyAccessTypes (const ::std::string& s,
                       const ::xercesc::DOMElement* e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_outputOnlyAccessTypes_convert ();
}

outputOnlyAccessTypes* outputOnlyAccessTypes::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new outputOnlyAccessTypes (*this, f, c);
}

outputOnlyAccessTypes::value outputOnlyAccessTypes::
_xsd_outputOnlyAccessTypes_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_outputOnlyAccessTypes_literals_);
  const value* i (::std::lower_bound (
                    _xsd_outputOnlyAccessTypes_indexes_,
                    _xsd_outputOnlyAccessTypes_indexes_ + 70,
                    *this,
                    c));

  if (i == _xsd_outputOnlyAccessTypes_indexes_ + 70 || _xsd_outputOnlyAccessTypes_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const outputOnlyAccessTypes::
_xsd_outputOnlyAccessTypes_literals_[70] =
{
  "actionKeyPress",
  "actionKeyRelease",
  "altKey",
  "articulationParameterValue0_changed",
  "articulationParameterValue1_changed",
  "articulationParameterValue2_changed",
  "articulationParameterValue3_changed",
  "articulationParameterValue4_changed",
  "articulationParameterValue5_changed",
  "articulationParameterValue6_changed",
  "articulationParameterValue7_changed",
  "bindTime",
  "centerOfRotation_changed",
  "collideTime",
  "controlKey",
  "cycleTime",
  "detonateTime",
  "duration_changed",
  "elapsedTime",
  "enteredText",
  "enterTime",
  "exitTime",
  "finalText",
  "firedTime",
  "fraction_changed",
  "geovalue_changed",
  "hitGeoCoord_changed",
  "hitNormal_changed",
  "hitPoint_changed",
  "hitTexCoord_changed",
  "inputFalse",
  "inputNegate",
  "inputTrue",
  "isActive",
  "isBound",
  "isCollided",
  "isDetonated",
  "isLoaded",
  "isOver",
  "isPaused",
  "isNetworkReader",
  "isNetworkWriter",
  "isRtpHeaderHeard",
  "isSelected",
  "isStandAlone",
  "isValid",
  "keyPress",
  "keyRelease",
  "level_changed",
  "lineBounds",
  "loadTime",
  "next",
  "normal_changed",
  "orientation_changed",
  "position_changed",
  "previous",
  "progress",
  "rotation_changed",
  "shiftKey",
  "textBounds",
  "time",
  "timestamp",
  "touchTime",
  "trackPoint_changed",
  "transitionComplete",
  "translation_changed",
  "triggerTime",
  "triggerTrue",
  "triggerValue",
  "value_changed"
};

const outputOnlyAccessTypes::value outputOnlyAccessTypes::
_xsd_outputOnlyAccessTypes_indexes_[70] =
{
  ::outputOnlyAccessTypes::actionKeyPress,
  ::outputOnlyAccessTypes::actionKeyRelease,
  ::outputOnlyAccessTypes::altKey,
  ::outputOnlyAccessTypes::articulationParameterValue0_changed,
  ::outputOnlyAccessTypes::articulationParameterValue1_changed,
  ::outputOnlyAccessTypes::articulationParameterValue2_changed,
  ::outputOnlyAccessTypes::articulationParameterValue3_changed,
  ::outputOnlyAccessTypes::articulationParameterValue4_changed,
  ::outputOnlyAccessTypes::articulationParameterValue5_changed,
  ::outputOnlyAccessTypes::articulationParameterValue6_changed,
  ::outputOnlyAccessTypes::articulationParameterValue7_changed,
  ::outputOnlyAccessTypes::bindTime,
  ::outputOnlyAccessTypes::centerOfRotation_changed,
  ::outputOnlyAccessTypes::collideTime,
  ::outputOnlyAccessTypes::controlKey,
  ::outputOnlyAccessTypes::cycleTime,
  ::outputOnlyAccessTypes::detonateTime,
  ::outputOnlyAccessTypes::duration_changed,
  ::outputOnlyAccessTypes::elapsedTime,
  ::outputOnlyAccessTypes::enterTime,
  ::outputOnlyAccessTypes::enteredText,
  ::outputOnlyAccessTypes::exitTime,
  ::outputOnlyAccessTypes::finalText,
  ::outputOnlyAccessTypes::firedTime,
  ::outputOnlyAccessTypes::fraction_changed,
  ::outputOnlyAccessTypes::geovalue_changed,
  ::outputOnlyAccessTypes::hitGeoCoord_changed,
  ::outputOnlyAccessTypes::hitNormal_changed,
  ::outputOnlyAccessTypes::hitPoint_changed,
  ::outputOnlyAccessTypes::hitTexCoord_changed,
  ::outputOnlyAccessTypes::inputFalse,
  ::outputOnlyAccessTypes::inputNegate,
  ::outputOnlyAccessTypes::inputTrue,
  ::outputOnlyAccessTypes::isActive,
  ::outputOnlyAccessTypes::isBound,
  ::outputOnlyAccessTypes::isCollided,
  ::outputOnlyAccessTypes::isDetonated,
  ::outputOnlyAccessTypes::isLoaded,
  ::outputOnlyAccessTypes::isNetworkReader,
  ::outputOnlyAccessTypes::isNetworkWriter,
  ::outputOnlyAccessTypes::isOver,
  ::outputOnlyAccessTypes::isPaused,
  ::outputOnlyAccessTypes::isRtpHeaderHeard,
  ::outputOnlyAccessTypes::isSelected,
  ::outputOnlyAccessTypes::isStandAlone,
  ::outputOnlyAccessTypes::isValid,
  ::outputOnlyAccessTypes::keyPress,
  ::outputOnlyAccessTypes::keyRelease,
  ::outputOnlyAccessTypes::level_changed,
  ::outputOnlyAccessTypes::lineBounds,
  ::outputOnlyAccessTypes::loadTime,
  ::outputOnlyAccessTypes::next,
  ::outputOnlyAccessTypes::normal_changed,
  ::outputOnlyAccessTypes::orientation_changed,
  ::outputOnlyAccessTypes::position_changed,
  ::outputOnlyAccessTypes::previous,
  ::outputOnlyAccessTypes::progress,
  ::outputOnlyAccessTypes::rotation_changed,
  ::outputOnlyAccessTypes::shiftKey,
  ::outputOnlyAccessTypes::textBounds,
  ::outputOnlyAccessTypes::time,
  ::outputOnlyAccessTypes::timestamp,
  ::outputOnlyAccessTypes::touchTime,
  ::outputOnlyAccessTypes::trackPoint_changed,
  ::outputOnlyAccessTypes::transitionComplete,
  ::outputOnlyAccessTypes::translation_changed,
  ::outputOnlyAccessTypes::triggerTime,
  ::outputOnlyAccessTypes::triggerTrue,
  ::outputOnlyAccessTypes::triggerValue,
  ::outputOnlyAccessTypes::value_changed
};

// inputOutputAccessTypes
//

inputOutputAccessTypes::
inputOutputAccessTypes (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_inputOutputAccessTypes_convert ();
}

inputOutputAccessTypes::
inputOutputAccessTypes (const ::xercesc::DOMAttr& a,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_inputOutputAccessTypes_convert ();
}

inputOutputAccessTypes::
inputOutputAccessTypes (const ::std::string& s,
                        const ::xercesc::DOMElement* e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_inputOutputAccessTypes_convert ();
}

inputOutputAccessTypes* inputOutputAccessTypes::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new inputOutputAccessTypes (*this, f, c);
}

inputOutputAccessTypes::value1 inputOutputAccessTypes::
_xsd_inputOutputAccessTypes_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_inputOutputAccessTypes_literals_);
  const value1* i (::std::lower_bound (
                     _xsd_inputOutputAccessTypes_indexes_,
                     _xsd_inputOutputAccessTypes_indexes_ + 213,
                     *this,
                     c));

  if (i == _xsd_inputOutputAccessTypes_indexes_ + 213 || _xsd_inputOutputAccessTypes_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const inputOutputAccessTypes::
_xsd_inputOutputAccessTypes_literals_[213] =
{
  "address",
  "alpha",
  "ambientIntensity",
  "antennaLocation",
  "applicationID",
  "applied",
  "antennaPatternType",
  "antennaPatternLength",
  "articulationParameterArray",
  "articulationParameterChangeIndicatorArray",
  "articulationParameterCount",
  "articulationParameterDesignatorArray",
  "articulationParameterIdPartAttachedToArray",
  "articulationParameterTypeArray",
  "attenuation",
  "autoOffset",
  "avatarSize",
  "axisOfRotation",
  "backUrl",
  "bottomUrl",
  "beamWidth",
  "bottomUrl",
  "center",
  "centerOfMass",
  "centerOfRotation",
  "collisionType",
  "color",
  "controlPoint",
  "cryptoSystem",
  "cryptoKeyID",
  "cutOffAngle",
  "cycleInterval",
  "data",
  "dataLength",
  "deadReckoning",
  "deletionAllowed",
  "depth",
  "description",
  "detonationLocation",
  "detonationRelativeLocation",
  "detonationResult",
  "diffuseColor",
  "direction",
  "diskAngle",
  "displacements",
  "emissiveColor",
  "enabled",
  "encodingScheme",
  "entityID",
  "entityKind",
  "entityDomain",
  "entityCountry",
  "entityCategory",
  "entitySubCategory",
  "entitySpecific",
  "entityExtra",
  "eventApplicationID",
  "eventEntityID",
  "eventNumber",
  "eventSiteID",
  "family",
  "fanCount",
  "fieldOfView",
  "filled",
  "fired1",
  "fired2",
  "fireMissionIndex",
  "firingRange",
  "firingRate",
  "fogType",
  "forceID",
  "frequency",
  "frontUrl",
  "function",
  "fuse",
  "geoCoords",
  "global",
  "groundAngle",
  "groundColor",
  "hatchColor",
  "hatched",
  "hatchStyle",
  "headlight",
  "image",
  "info",
  "inputSource",
  "integerKey",
  "intensity",
  "key",
  "jump",
  "keyValue",
  "leftUrl",
  "length",
  "lengthOfModulationParameters",
  "limitOrientation",
  "linearAcceleration",
  "linearVelocity",
  "linetype",
  "linewidthScaleFactor",
  "llimit",
  "load",
  "location",
  "loop",
  "marking",
  "mass",
  "maxAngle",
  "matrix",
  "maxBack",
  "maxExtent",
  "maxFront",
  "maxPosition",
  "minAngle",
  "minBack",
  "minFront",
  "minPosition",
  "mode",
  "modulationTypeSpreadSpectrum",
  "modulationTypeMajor",
  "modulationTypeDetail",
  "modulationTypeSystem",
  "momentsOfInertia",
  "multicastRelayHost",
  "multicastRelayPort",
  "munitionEndPoint",
  "munitionStartPoint",
  "munitionApplicationID",
  "munitionEntityID",
  "munitionSiteID",
  "munitionQuantity",
  "name",
  "navType",
  "networkMode",
  "offset",
  "on",
  "pauseTime",
  "parameter",
  "pitch",
  "point",
  "port",
  "position",
  "power",
  "priority",
  "radioID",
  "radioEntityTypeKind",
  "radioEntityTypeDomain",
  "radioEntityTypeCountry",
  "radioEntityTypeCategory",
  "radioEntityTypeNomenclature",
  "radioEntityTypeNomenclatureVersion",
  "readInterval",
  "receivedPower",
  "receiverState",
  "reference",
  "relativeAntennaLocation",
  "resumeTime",
  "rightUrl",
  "rotation",
  "sampleRate",
  "samples",
  "scale",
  "scaleOrientation",
  "shininess",
  "siteID",
  "skinCoordIndex",
  "skinCoordWeight",
  "skyColor",
  "skyAngle",
  "source",
  "specularColor",
  "speed",
  "startTime",
  "stiffness",
  "stopTime",
  "string",
  "stripCount",
  "summary",
  "tdlType",
  "tessellation",
  "tessellationScale",
  "timeOut",
  "toggle",
  "topUrl",
  "transitionTime",
  "transitionType",
  "translation",
  "transmitFrequencyBandwidth",
  "transmitState",
  "transmitterApplicationID",
  "transmitterEntityID",
  "transmitterRadioID",
  "transmitterSiteID",
  "transparent",
  "transparency",
  "type",
  "ulimit",
  "update",
  "url",
  "uTessellation",
  "value",
  "version",
  "vector",
  "vertexCount",
  "vertices",
  "visibilityLimit",
  "visibilityRange",
  "visible",
  "vTessellation",
  "warhead",
  "weight",
  "whichChoice",
  "whichGeometry",
  "writeInterval",
  "yScale"
};

const inputOutputAccessTypes::value1 inputOutputAccessTypes::
_xsd_inputOutputAccessTypes_indexes_[213] =
{
  ::inputOutputAccessTypes::address,
  ::inputOutputAccessTypes::alpha,
  ::inputOutputAccessTypes::ambientIntensity,
  ::inputOutputAccessTypes::antennaLocation,
  ::inputOutputAccessTypes::antennaPatternLength,
  ::inputOutputAccessTypes::antennaPatternType,
  ::inputOutputAccessTypes::applicationID,
  ::inputOutputAccessTypes::applied,
  ::inputOutputAccessTypes::articulationParameterArray,
  ::inputOutputAccessTypes::articulationParameterChangeIndicatorArray,
  ::inputOutputAccessTypes::articulationParameterCount,
  ::inputOutputAccessTypes::articulationParameterDesignatorArray,
  ::inputOutputAccessTypes::articulationParameterIdPartAttachedToArray,
  ::inputOutputAccessTypes::articulationParameterTypeArray,
  ::inputOutputAccessTypes::attenuation,
  ::inputOutputAccessTypes::autoOffset,
  ::inputOutputAccessTypes::avatarSize,
  ::inputOutputAccessTypes::axisOfRotation,
  ::inputOutputAccessTypes::backUrl,
  ::inputOutputAccessTypes::beamWidth,
  ::inputOutputAccessTypes::bottomUrl,
  ::inputOutputAccessTypes::bottomUrl1,
  ::inputOutputAccessTypes::center,
  ::inputOutputAccessTypes::centerOfMass,
  ::inputOutputAccessTypes::centerOfRotation,
  ::inputOutputAccessTypes::collisionType,
  ::inputOutputAccessTypes::color,
  ::inputOutputAccessTypes::controlPoint,
  ::inputOutputAccessTypes::cryptoKeyID,
  ::inputOutputAccessTypes::cryptoSystem,
  ::inputOutputAccessTypes::cutOffAngle,
  ::inputOutputAccessTypes::cycleInterval,
  ::inputOutputAccessTypes::data,
  ::inputOutputAccessTypes::dataLength,
  ::inputOutputAccessTypes::deadReckoning,
  ::inputOutputAccessTypes::deletionAllowed,
  ::inputOutputAccessTypes::depth,
  ::inputOutputAccessTypes::description,
  ::inputOutputAccessTypes::detonationLocation,
  ::inputOutputAccessTypes::detonationRelativeLocation,
  ::inputOutputAccessTypes::detonationResult,
  ::inputOutputAccessTypes::diffuseColor,
  ::inputOutputAccessTypes::direction,
  ::inputOutputAccessTypes::diskAngle,
  ::inputOutputAccessTypes::displacements,
  ::inputOutputAccessTypes::emissiveColor,
  ::inputOutputAccessTypes::enabled,
  ::inputOutputAccessTypes::encodingScheme,
  ::inputOutputAccessTypes::entityCategory,
  ::inputOutputAccessTypes::entityCountry,
  ::inputOutputAccessTypes::entityDomain,
  ::inputOutputAccessTypes::entityExtra,
  ::inputOutputAccessTypes::entityID,
  ::inputOutputAccessTypes::entityKind,
  ::inputOutputAccessTypes::entitySpecific,
  ::inputOutputAccessTypes::entitySubCategory,
  ::inputOutputAccessTypes::eventApplicationID,
  ::inputOutputAccessTypes::eventEntityID,
  ::inputOutputAccessTypes::eventNumber,
  ::inputOutputAccessTypes::eventSiteID,
  ::inputOutputAccessTypes::family,
  ::inputOutputAccessTypes::fanCount,
  ::inputOutputAccessTypes::fieldOfView,
  ::inputOutputAccessTypes::filled,
  ::inputOutputAccessTypes::fireMissionIndex,
  ::inputOutputAccessTypes::fired1,
  ::inputOutputAccessTypes::fired2,
  ::inputOutputAccessTypes::firingRange,
  ::inputOutputAccessTypes::firingRate,
  ::inputOutputAccessTypes::fogType,
  ::inputOutputAccessTypes::forceID,
  ::inputOutputAccessTypes::frequency,
  ::inputOutputAccessTypes::frontUrl,
  ::inputOutputAccessTypes::function,
  ::inputOutputAccessTypes::fuse,
  ::inputOutputAccessTypes::geoCoords,
  ::inputOutputAccessTypes::global,
  ::inputOutputAccessTypes::groundAngle,
  ::inputOutputAccessTypes::groundColor,
  ::inputOutputAccessTypes::hatchColor,
  ::inputOutputAccessTypes::hatchStyle,
  ::inputOutputAccessTypes::hatched,
  ::inputOutputAccessTypes::headlight,
  ::inputOutputAccessTypes::image,
  ::inputOutputAccessTypes::info,
  ::inputOutputAccessTypes::inputSource,
  ::inputOutputAccessTypes::integerKey,
  ::inputOutputAccessTypes::intensity,
  ::inputOutputAccessTypes::jump,
  ::inputOutputAccessTypes::key,
  ::inputOutputAccessTypes::keyValue,
  ::inputOutputAccessTypes::leftUrl,
  ::inputOutputAccessTypes::length,
  ::inputOutputAccessTypes::lengthOfModulationParameters,
  ::inputOutputAccessTypes::limitOrientation,
  ::inputOutputAccessTypes::linearAcceleration,
  ::inputOutputAccessTypes::linearVelocity,
  ::inputOutputAccessTypes::linetype,
  ::inputOutputAccessTypes::linewidthScaleFactor,
  ::inputOutputAccessTypes::llimit,
  ::inputOutputAccessTypes::load,
  ::inputOutputAccessTypes::location,
  ::inputOutputAccessTypes::loop,
  ::inputOutputAccessTypes::marking,
  ::inputOutputAccessTypes::mass,
  ::inputOutputAccessTypes::matrix,
  ::inputOutputAccessTypes::maxAngle,
  ::inputOutputAccessTypes::maxBack,
  ::inputOutputAccessTypes::maxExtent,
  ::inputOutputAccessTypes::maxFront,
  ::inputOutputAccessTypes::maxPosition,
  ::inputOutputAccessTypes::minAngle,
  ::inputOutputAccessTypes::minBack,
  ::inputOutputAccessTypes::minFront,
  ::inputOutputAccessTypes::minPosition,
  ::inputOutputAccessTypes::mode,
  ::inputOutputAccessTypes::modulationTypeDetail,
  ::inputOutputAccessTypes::modulationTypeMajor,
  ::inputOutputAccessTypes::modulationTypeSpreadSpectrum,
  ::inputOutputAccessTypes::modulationTypeSystem,
  ::inputOutputAccessTypes::momentsOfInertia,
  ::inputOutputAccessTypes::multicastRelayHost,
  ::inputOutputAccessTypes::multicastRelayPort,
  ::inputOutputAccessTypes::munitionApplicationID,
  ::inputOutputAccessTypes::munitionEndPoint,
  ::inputOutputAccessTypes::munitionEntityID,
  ::inputOutputAccessTypes::munitionQuantity,
  ::inputOutputAccessTypes::munitionSiteID,
  ::inputOutputAccessTypes::munitionStartPoint,
  ::inputOutputAccessTypes::name,
  ::inputOutputAccessTypes::navType,
  ::inputOutputAccessTypes::networkMode,
  ::inputOutputAccessTypes::offset,
  ::inputOutputAccessTypes::on,
  ::inputOutputAccessTypes::parameter,
  ::inputOutputAccessTypes::pauseTime,
  ::inputOutputAccessTypes::pitch,
  ::inputOutputAccessTypes::point,
  ::inputOutputAccessTypes::port,
  ::inputOutputAccessTypes::position,
  ::inputOutputAccessTypes::power,
  ::inputOutputAccessTypes::priority,
  ::inputOutputAccessTypes::radioEntityTypeCategory,
  ::inputOutputAccessTypes::radioEntityTypeCountry,
  ::inputOutputAccessTypes::radioEntityTypeDomain,
  ::inputOutputAccessTypes::radioEntityTypeKind,
  ::inputOutputAccessTypes::radioEntityTypeNomenclature,
  ::inputOutputAccessTypes::radioEntityTypeNomenclatureVersion,
  ::inputOutputAccessTypes::radioID,
  ::inputOutputAccessTypes::readInterval,
  ::inputOutputAccessTypes::receivedPower,
  ::inputOutputAccessTypes::receiverState,
  ::inputOutputAccessTypes::reference,
  ::inputOutputAccessTypes::relativeAntennaLocation,
  ::inputOutputAccessTypes::resumeTime,
  ::inputOutputAccessTypes::rightUrl,
  ::inputOutputAccessTypes::rotation,
  ::inputOutputAccessTypes::sampleRate,
  ::inputOutputAccessTypes::samples,
  ::inputOutputAccessTypes::scale,
  ::inputOutputAccessTypes::scaleOrientation,
  ::inputOutputAccessTypes::shininess,
  ::inputOutputAccessTypes::siteID,
  ::inputOutputAccessTypes::skinCoordIndex,
  ::inputOutputAccessTypes::skinCoordWeight,
  ::inputOutputAccessTypes::skyAngle,
  ::inputOutputAccessTypes::skyColor,
  ::inputOutputAccessTypes::source,
  ::inputOutputAccessTypes::specularColor,
  ::inputOutputAccessTypes::speed,
  ::inputOutputAccessTypes::startTime,
  ::inputOutputAccessTypes::stiffness,
  ::inputOutputAccessTypes::stopTime,
  ::inputOutputAccessTypes::string,
  ::inputOutputAccessTypes::stripCount,
  ::inputOutputAccessTypes::summary,
  ::inputOutputAccessTypes::tdlType,
  ::inputOutputAccessTypes::tessellation,
  ::inputOutputAccessTypes::tessellationScale,
  ::inputOutputAccessTypes::timeOut,
  ::inputOutputAccessTypes::toggle,
  ::inputOutputAccessTypes::topUrl,
  ::inputOutputAccessTypes::transitionTime,
  ::inputOutputAccessTypes::transitionType,
  ::inputOutputAccessTypes::translation,
  ::inputOutputAccessTypes::transmitFrequencyBandwidth,
  ::inputOutputAccessTypes::transmitState,
  ::inputOutputAccessTypes::transmitterApplicationID,
  ::inputOutputAccessTypes::transmitterEntityID,
  ::inputOutputAccessTypes::transmitterRadioID,
  ::inputOutputAccessTypes::transmitterSiteID,
  ::inputOutputAccessTypes::transparency,
  ::inputOutputAccessTypes::transparent,
  ::inputOutputAccessTypes::type,
  ::inputOutputAccessTypes::uTessellation,
  ::inputOutputAccessTypes::ulimit,
  ::inputOutputAccessTypes::update,
  ::inputOutputAccessTypes::url,
  ::inputOutputAccessTypes::vTessellation,
  ::inputOutputAccessTypes::value,
  ::inputOutputAccessTypes::vector,
  ::inputOutputAccessTypes::version,
  ::inputOutputAccessTypes::vertexCount,
  ::inputOutputAccessTypes::vertices,
  ::inputOutputAccessTypes::visibilityLimit,
  ::inputOutputAccessTypes::visibilityRange,
  ::inputOutputAccessTypes::visible,
  ::inputOutputAccessTypes::warhead,
  ::inputOutputAccessTypes::weight,
  ::inputOutputAccessTypes::whichChoice,
  ::inputOutputAccessTypes::whichGeometry,
  ::inputOutputAccessTypes::writeInterval,
  ::inputOutputAccessTypes::yScale
};

// X3DNode
//

X3DNode::
X3DNode ()
: ::xml_schema::type (),
  IS_ (::xml_schema::flags (), this),
  MetadataDouble_ (::xml_schema::flags (), this),
  MetadataFloat_ (::xml_schema::flags (), this),
  MetadataInteger_ (::xml_schema::flags (), this),
  MetadataSet_ (::xml_schema::flags (), this),
  MetadataString_ (::xml_schema::flags (), this),
  DEF_ (::xml_schema::flags (), this),
  USE_ (::xml_schema::flags (), this),
  class__ (::xml_schema::flags (), this)
{
}

X3DNode::
X3DNode (const X3DNode& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  IS_ (x.IS_, f, this),
  MetadataDouble_ (x.MetadataDouble_, f, this),
  MetadataFloat_ (x.MetadataFloat_, f, this),
  MetadataInteger_ (x.MetadataInteger_, f, this),
  MetadataSet_ (x.MetadataSet_, f, this),
  MetadataString_ (x.MetadataString_, f, this),
  DEF_ (x.DEF_, f, this),
  USE_ (x.USE_, f, this),
  class__ (x.class__, f, this)
{
}

X3DNode::
X3DNode (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  IS_ (f, this),
  MetadataDouble_ (f, this),
  MetadataFloat_ (f, this),
  MetadataInteger_ (f, this),
  MetadataSet_ (f, this),
  MetadataString_ (f, this),
  DEF_ (f, this),
  USE_ (f, this),
  class__ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // IS
    //
    if (n.name () == "IS" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IS_type > r (
        IS_traits::create (i, f, this));

      if (!this->IS ())
      {
        this->IS (r);
        continue;
      }
    }

    // MetadataDouble
    //
    if (n.name () == "MetadataDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataDouble_type > r (
        MetadataDouble_traits::create (i, f, this));

      if (!this->MetadataDouble ())
      {
        this->MetadataDouble (r);
        continue;
      }
    }

    // MetadataFloat
    //
    if (n.name () == "MetadataFloat" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataFloat_type > r (
        MetadataFloat_traits::create (i, f, this));

      if (!this->MetadataFloat ())
      {
        this->MetadataFloat (r);
        continue;
      }
    }

    // MetadataInteger
    //
    if (n.name () == "MetadataInteger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataInteger_type > r (
        MetadataInteger_traits::create (i, f, this));

      if (!this->MetadataInteger ())
      {
        this->MetadataInteger (r);
        continue;
      }
    }

    // MetadataSet
    //
    if (n.name () == "MetadataSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataSet_type > r (
        MetadataSet_traits::create (i, f, this));

      if (!this->MetadataSet ())
      {
        this->MetadataSet (r);
        continue;
      }
    }

    // MetadataString
    //
    if (n.name () == "MetadataString" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataString_type > r (
        MetadataString_traits::create (i, f, this));

      if (!this->MetadataString ())
      {
        this->MetadataString (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "DEF" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DEF_type > r (
        DEF_traits::create (i, f, this));

      this->DEF (r);
      continue;
    }

    if (n.name () == "USE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< USE_type > r (
        USE_traits::create (i, f, this));

      this->USE (r);
      continue;
    }

    if (n.name () == "class" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< class_type > r (
        class_traits::create (i, f, this));

      this->class_ (r);
      continue;
    }
  }
}

X3DNode* X3DNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DNode (*this, f, c);
}

X3DNode::
~X3DNode ()
{
}

// X3DAppearanceNode
//

const X3DAppearanceNode::containerField_type X3DAppearanceNode::containerField_default_value_ (
  ::std::string ("appearance"), 0, 0, 0);

X3DAppearanceNode::
X3DAppearanceNode ()
: ::X3DNode (),
  FillProperties_ (::xml_schema::flags (), this),
  LineProperties_ (::xml_schema::flags (), this),
  Material_ (::xml_schema::flags (), this),
  ComposedShader_ (::xml_schema::flags (), this),
  PackagedShader_ (::xml_schema::flags (), this),
  ProgramShader_ (::xml_schema::flags (), this),
  ComposedCubeMapTexture_ (::xml_schema::flags (), this),
  ImageTexture_ (::xml_schema::flags (), this),
  MovieTexture_ (::xml_schema::flags (), this),
  MultiTexture_ (::xml_schema::flags (), this),
  PixelTexture_ (::xml_schema::flags (), this),
  GeneratedCubeMapTexture_ (::xml_schema::flags (), this),
  ImageCubeMapTexture_ (::xml_schema::flags (), this),
  MultiTextureTransform_ (::xml_schema::flags (), this),
  TextureTransform_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

X3DAppearanceNode::
X3DAppearanceNode (const X3DAppearanceNode& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DNode (x, f, c),
  FillProperties_ (x.FillProperties_, f, this),
  LineProperties_ (x.LineProperties_, f, this),
  Material_ (x.Material_, f, this),
  ComposedShader_ (x.ComposedShader_, f, this),
  PackagedShader_ (x.PackagedShader_, f, this),
  ProgramShader_ (x.ProgramShader_, f, this),
  ComposedCubeMapTexture_ (x.ComposedCubeMapTexture_, f, this),
  ImageTexture_ (x.ImageTexture_, f, this),
  MovieTexture_ (x.MovieTexture_, f, this),
  MultiTexture_ (x.MultiTexture_, f, this),
  PixelTexture_ (x.PixelTexture_, f, this),
  GeneratedCubeMapTexture_ (x.GeneratedCubeMapTexture_, f, this),
  ImageCubeMapTexture_ (x.ImageCubeMapTexture_, f, this),
  MultiTextureTransform_ (x.MultiTextureTransform_, f, this),
  TextureTransform_ (x.TextureTransform_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  containerField_ (x.containerField_, f, this)
{
}

X3DAppearanceNode::
X3DAppearanceNode (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DNode (e, f | ::xml_schema::flags::base, c),
  FillProperties_ (f, this),
  LineProperties_ (f, this),
  Material_ (f, this),
  ComposedShader_ (f, this),
  PackagedShader_ (f, this),
  ProgramShader_ (f, this),
  ComposedCubeMapTexture_ (f, this),
  ImageTexture_ (f, this),
  MovieTexture_ (f, this),
  MultiTexture_ (f, this),
  PixelTexture_ (f, this),
  GeneratedCubeMapTexture_ (f, this),
  ImageCubeMapTexture_ (f, this),
  MultiTextureTransform_ (f, this),
  TextureTransform_ (f, this),
  ProtoInstance_ (f, this),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DAppearanceNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // FillProperties
    //
    if (n.name () == "FillProperties" && n.namespace_ () == "")
    {
      ::std::auto_ptr< FillProperties_type > r (
        FillProperties_traits::create (i, f, this));

      this->FillProperties ().push_back (r);
      continue;
    }

    // LineProperties
    //
    if (n.name () == "LineProperties" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LineProperties_type > r (
        LineProperties_traits::create (i, f, this));

      this->LineProperties ().push_back (r);
      continue;
    }

    // Material
    //
    if (n.name () == "Material" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Material_type > r (
        Material_traits::create (i, f, this));

      this->Material ().push_back (r);
      continue;
    }

    // ComposedShader
    //
    if (n.name () == "ComposedShader" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ComposedShader_type > r (
        ComposedShader_traits::create (i, f, this));

      this->ComposedShader ().push_back (r);
      continue;
    }

    // PackagedShader
    //
    if (n.name () == "PackagedShader" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PackagedShader_type > r (
        PackagedShader_traits::create (i, f, this));

      this->PackagedShader ().push_back (r);
      continue;
    }

    // ProgramShader
    //
    if (n.name () == "ProgramShader" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProgramShader_type > r (
        ProgramShader_traits::create (i, f, this));

      this->ProgramShader ().push_back (r);
      continue;
    }

    // ComposedCubeMapTexture
    //
    if (n.name () == "ComposedCubeMapTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ComposedCubeMapTexture_type > r (
        ComposedCubeMapTexture_traits::create (i, f, this));

      this->ComposedCubeMapTexture ().push_back (r);
      continue;
    }

    // ImageTexture
    //
    if (n.name () == "ImageTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ImageTexture_type > r (
        ImageTexture_traits::create (i, f, this));

      this->ImageTexture ().push_back (r);
      continue;
    }

    // MovieTexture
    //
    if (n.name () == "MovieTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MovieTexture_type > r (
        MovieTexture_traits::create (i, f, this));

      this->MovieTexture ().push_back (r);
      continue;
    }

    // MultiTexture
    //
    if (n.name () == "MultiTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MultiTexture_type > r (
        MultiTexture_traits::create (i, f, this));

      this->MultiTexture ().push_back (r);
      continue;
    }

    // PixelTexture
    //
    if (n.name () == "PixelTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PixelTexture_type > r (
        PixelTexture_traits::create (i, f, this));

      this->PixelTexture ().push_back (r);
      continue;
    }

    // GeneratedCubeMapTexture
    //
    if (n.name () == "GeneratedCubeMapTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeneratedCubeMapTexture_type > r (
        GeneratedCubeMapTexture_traits::create (i, f, this));

      this->GeneratedCubeMapTexture ().push_back (r);
      continue;
    }

    // ImageCubeMapTexture
    //
    if (n.name () == "ImageCubeMapTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ImageCubeMapTexture_type > r (
        ImageCubeMapTexture_traits::create (i, f, this));

      this->ImageCubeMapTexture ().push_back (r);
      continue;
    }

    // MultiTextureTransform
    //
    if (n.name () == "MultiTextureTransform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MultiTextureTransform_type > r (
        MultiTextureTransform_traits::create (i, f, this));

      this->MultiTextureTransform ().push_back (r);
      continue;
    }

    // TextureTransform
    //
    if (n.name () == "TextureTransform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureTransform_type > r (
        TextureTransform_traits::create (i, f, this));

      this->TextureTransform ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("appearance"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

X3DAppearanceNode* X3DAppearanceNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DAppearanceNode (*this, f, c);
}

X3DAppearanceNode::
~X3DAppearanceNode ()
{
}

// X3DAppearanceChildNode
//

X3DAppearanceChildNode::
X3DAppearanceChildNode ()
: ::X3DNode ()
{
}

X3DAppearanceChildNode::
X3DAppearanceChildNode (const X3DAppearanceChildNode& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DNode (x, f, c)
{
}

X3DAppearanceChildNode::
X3DAppearanceChildNode (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DNode (e, f, c)
{
}

X3DAppearanceChildNode* X3DAppearanceChildNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DAppearanceChildNode (*this, f, c);
}

X3DAppearanceChildNode::
~X3DAppearanceChildNode ()
{
}

// X3DChildNode
//

const X3DChildNode::containerField_type X3DChildNode::containerField_default_value_ (
  ::std::string ("children"), 0, 0, 0);

X3DChildNode::
X3DChildNode ()
: ::X3DNode (),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

X3DChildNode::
X3DChildNode (const X3DChildNode& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DNode (x, f, c),
  containerField_ (x.containerField_, f, this)
{
}

X3DChildNode::
X3DChildNode (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DNode (e, f | ::xml_schema::flags::base, c),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DChildNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("children"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

X3DChildNode* X3DChildNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DChildNode (*this, f, c);
}

X3DChildNode::
~X3DChildNode ()
{
}

// X3DBindableNode
//

X3DBindableNode::
X3DBindableNode ()
: ::X3DChildNode ()
{
}

X3DBindableNode::
X3DBindableNode (const X3DBindableNode& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::X3DChildNode (x, f, c)
{
}

X3DBindableNode::
X3DBindableNode (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::X3DChildNode (e, f, c)
{
}

X3DBindableNode* X3DBindableNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DBindableNode (*this, f, c);
}

X3DBindableNode::
~X3DBindableNode ()
{
}

// X3DBackgroundNode
//

const X3DBackgroundNode::skyColor_type X3DBackgroundNode::skyColor_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

X3DBackgroundNode::
X3DBackgroundNode ()
: ::X3DBindableNode (),
  groundAngle_ (::xml_schema::flags (), this),
  groundColor_ (::xml_schema::flags (), this),
  skyAngle_ (::xml_schema::flags (), this),
  skyColor_ (skyColor_default_value (), ::xml_schema::flags (), this)
{
}

X3DBackgroundNode::
X3DBackgroundNode (const X3DBackgroundNode& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DBindableNode (x, f, c),
  groundAngle_ (x.groundAngle_, f, this),
  groundColor_ (x.groundColor_, f, this),
  skyAngle_ (x.skyAngle_, f, this),
  skyColor_ (x.skyColor_, f, this)
{
}

X3DBackgroundNode::
X3DBackgroundNode (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DBindableNode (e, f | ::xml_schema::flags::base, c),
  groundAngle_ (f, this),
  groundColor_ (f, this),
  skyAngle_ (f, this),
  skyColor_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DBackgroundNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DBindableNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "groundAngle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< groundAngle_type > r (
        groundAngle_traits::create (i, f, this));

      this->groundAngle (r);
      continue;
    }

    if (n.name () == "groundColor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< groundColor_type > r (
        groundColor_traits::create (i, f, this));

      this->groundColor (r);
      continue;
    }

    if (n.name () == "skyAngle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< skyAngle_type > r (
        skyAngle_traits::create (i, f, this));

      this->skyAngle (r);
      continue;
    }

    if (n.name () == "skyColor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< skyColor_type > r (
        skyColor_traits::create (i, f, this));

      this->skyColor (r);
      continue;
    }
  }

  if (!skyColor_.present ())
  {
    ::std::auto_ptr< skyColor_type > r (
      skyColor_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->skyColor (r);
  }
}

X3DBackgroundNode* X3DBackgroundNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DBackgroundNode (*this, f, c);
}

X3DBackgroundNode::
~X3DBackgroundNode ()
{
}

// X3DBoundedObject
//

const X3DBoundedObject::bboxCenter_type X3DBoundedObject::bboxCenter_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const X3DBoundedObject::bboxSize_type X3DBoundedObject::bboxSize_default_value_ (
  ::std::string ("-1 -1 -1"), 0, 0, 0);

X3DBoundedObject::
X3DBoundedObject ()
: ::xml_schema::type (),
  bboxCenter_ (bboxCenter_default_value (), ::xml_schema::flags (), this),
  bboxSize_ (bboxSize_default_value (), ::xml_schema::flags (), this)
{
}

X3DBoundedObject::
X3DBoundedObject (const X3DBoundedObject& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  bboxCenter_ (x.bboxCenter_, f, this),
  bboxSize_ (x.bboxSize_, f, this)
{
}

X3DBoundedObject::
X3DBoundedObject (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  bboxCenter_ (f, this),
  bboxSize_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DBoundedObject::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "bboxCenter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bboxCenter_type > r (
        bboxCenter_traits::create (i, f, this));

      this->bboxCenter (r);
      continue;
    }

    if (n.name () == "bboxSize" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bboxSize_type > r (
        bboxSize_traits::create (i, f, this));

      this->bboxSize (r);
      continue;
    }
  }

  if (!bboxCenter_.present ())
  {
    ::std::auto_ptr< bboxCenter_type > r (
      bboxCenter_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->bboxCenter (r);
  }

  if (!bboxSize_.present ())
  {
    ::std::auto_ptr< bboxSize_type > r (
      bboxSize_traits::create (
        ::std::string ("-1 -1 -1"),
        &p.element (), f, this));

    this->bboxSize (r);
  }
}

X3DBoundedObject* X3DBoundedObject::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DBoundedObject (*this, f, c);
}

X3DBoundedObject::
~X3DBoundedObject ()
{
}

// X3DGeometricPropertyNode
//

X3DGeometricPropertyNode::
X3DGeometricPropertyNode ()
: ::X3DNode ()
{
}

X3DGeometricPropertyNode::
X3DGeometricPropertyNode (const X3DGeometricPropertyNode& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::X3DNode (x, f, c)
{
}

X3DGeometricPropertyNode::
X3DGeometricPropertyNode (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::X3DNode (e, f, c)
{
}

X3DGeometricPropertyNode* X3DGeometricPropertyNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DGeometricPropertyNode (*this, f, c);
}

X3DGeometricPropertyNode::
~X3DGeometricPropertyNode ()
{
}

// X3DColorNode
//

const X3DColorNode::containerField_type X3DColorNode::containerField_default_value_ (
  ::std::string ("color"), 0, 0, 0);

X3DColorNode::
X3DColorNode ()
: ::X3DGeometricPropertyNode (),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

X3DColorNode::
X3DColorNode (const X3DColorNode& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DGeometricPropertyNode (x, f, c),
  containerField_ (x.containerField_, f, this)
{
}

X3DColorNode::
X3DColorNode (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DGeometricPropertyNode (e, f | ::xml_schema::flags::base, c),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DColorNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometricPropertyNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("color"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

X3DColorNode* X3DColorNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DColorNode (*this, f, c);
}

X3DColorNode::
~X3DColorNode ()
{
}

// X3DGeometryNode
//

const X3DGeometryNode::containerField_type X3DGeometryNode::containerField_default_value_ (
  ::std::string ("geometry"), 0, 0, 0);

X3DGeometryNode::
X3DGeometryNode ()
: ::X3DNode (),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

X3DGeometryNode::
X3DGeometryNode (const X3DGeometryNode& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::X3DNode (x, f, c),
  containerField_ (x.containerField_, f, this)
{
}

X3DGeometryNode::
X3DGeometryNode (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::X3DNode (e, f | ::xml_schema::flags::base, c),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DGeometryNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("geometry"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

X3DGeometryNode* X3DGeometryNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DGeometryNode (*this, f, c);
}

X3DGeometryNode::
~X3DGeometryNode ()
{
}

// X3DComposedGeometryNode
//

const X3DComposedGeometryNode::ccw_type X3DComposedGeometryNode::ccw_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const X3DComposedGeometryNode::colorPerVertex_type X3DComposedGeometryNode::colorPerVertex_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const X3DComposedGeometryNode::normalPerVertex_type X3DComposedGeometryNode::normalPerVertex_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const X3DComposedGeometryNode::solid_type X3DComposedGeometryNode::solid_default_value_ (
  ::std::string ("true"), 0, 0, 0);

X3DComposedGeometryNode::
X3DComposedGeometryNode ()
: ::X3DGeometryNode (),
  FloatVertexAttribute_ (::xml_schema::flags (), this),
  Matrix3VertexAttribute_ (::xml_schema::flags (), this),
  Matrix4VertexAttribute_ (::xml_schema::flags (), this),
  Color_ (::xml_schema::flags (), this),
  ColorRGBA_ (::xml_schema::flags (), this),
  Coordinate_ (::xml_schema::flags (), this),
  CoordinateDouble_ (::xml_schema::flags (), this),
  GeoCoordinate_ (::xml_schema::flags (), this),
  FogCoordinate_ (::xml_schema::flags (), this),
  Normal_ (::xml_schema::flags (), this),
  TextureCoordinate_ (::xml_schema::flags (), this),
  TextureCoordinate3D_ (::xml_schema::flags (), this),
  TextureCoordinate4D_ (::xml_schema::flags (), this),
  TextureCoordinateGenerator_ (::xml_schema::flags (), this),
  MultiTextureCoordinate_ (::xml_schema::flags (), this),
  NurbsTextureCoordinate_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  ccw_ (ccw_default_value (), ::xml_schema::flags (), this),
  colorPerVertex_ (colorPerVertex_default_value (), ::xml_schema::flags (), this),
  normalPerVertex_ (normalPerVertex_default_value (), ::xml_schema::flags (), this),
  solid_ (solid_default_value (), ::xml_schema::flags (), this)
{
}

X3DComposedGeometryNode::
X3DComposedGeometryNode (const X3DComposedGeometryNode& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  FloatVertexAttribute_ (x.FloatVertexAttribute_, f, this),
  Matrix3VertexAttribute_ (x.Matrix3VertexAttribute_, f, this),
  Matrix4VertexAttribute_ (x.Matrix4VertexAttribute_, f, this),
  Color_ (x.Color_, f, this),
  ColorRGBA_ (x.ColorRGBA_, f, this),
  Coordinate_ (x.Coordinate_, f, this),
  CoordinateDouble_ (x.CoordinateDouble_, f, this),
  GeoCoordinate_ (x.GeoCoordinate_, f, this),
  FogCoordinate_ (x.FogCoordinate_, f, this),
  Normal_ (x.Normal_, f, this),
  TextureCoordinate_ (x.TextureCoordinate_, f, this),
  TextureCoordinate3D_ (x.TextureCoordinate3D_, f, this),
  TextureCoordinate4D_ (x.TextureCoordinate4D_, f, this),
  TextureCoordinateGenerator_ (x.TextureCoordinateGenerator_, f, this),
  MultiTextureCoordinate_ (x.MultiTextureCoordinate_, f, this),
  NurbsTextureCoordinate_ (x.NurbsTextureCoordinate_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  ccw_ (x.ccw_, f, this),
  colorPerVertex_ (x.colorPerVertex_, f, this),
  normalPerVertex_ (x.normalPerVertex_, f, this),
  solid_ (x.solid_, f, this)
{
}

X3DComposedGeometryNode::
X3DComposedGeometryNode (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  FloatVertexAttribute_ (f, this),
  Matrix3VertexAttribute_ (f, this),
  Matrix4VertexAttribute_ (f, this),
  Color_ (f, this),
  ColorRGBA_ (f, this),
  Coordinate_ (f, this),
  CoordinateDouble_ (f, this),
  GeoCoordinate_ (f, this),
  FogCoordinate_ (f, this),
  Normal_ (f, this),
  TextureCoordinate_ (f, this),
  TextureCoordinate3D_ (f, this),
  TextureCoordinate4D_ (f, this),
  TextureCoordinateGenerator_ (f, this),
  MultiTextureCoordinate_ (f, this),
  NurbsTextureCoordinate_ (f, this),
  ProtoInstance_ (f, this),
  ccw_ (f, this),
  colorPerVertex_ (f, this),
  normalPerVertex_ (f, this),
  solid_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DComposedGeometryNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // FloatVertexAttribute
    //
    if (n.name () == "FloatVertexAttribute" && n.namespace_ () == "")
    {
      ::std::auto_ptr< FloatVertexAttribute_type > r (
        FloatVertexAttribute_traits::create (i, f, this));

      this->FloatVertexAttribute ().push_back (r);
      continue;
    }

    // Matrix3VertexAttribute
    //
    if (n.name () == "Matrix3VertexAttribute" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Matrix3VertexAttribute_type > r (
        Matrix3VertexAttribute_traits::create (i, f, this));

      this->Matrix3VertexAttribute ().push_back (r);
      continue;
    }

    // Matrix4VertexAttribute
    //
    if (n.name () == "Matrix4VertexAttribute" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Matrix4VertexAttribute_type > r (
        Matrix4VertexAttribute_traits::create (i, f, this));

      this->Matrix4VertexAttribute ().push_back (r);
      continue;
    }

    // Color
    //
    if (n.name () == "Color" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Color_type > r (
        Color_traits::create (i, f, this));

      this->Color ().push_back (r);
      continue;
    }

    // ColorRGBA
    //
    if (n.name () == "ColorRGBA" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ColorRGBA_type > r (
        ColorRGBA_traits::create (i, f, this));

      this->ColorRGBA ().push_back (r);
      continue;
    }

    // Coordinate
    //
    if (n.name () == "Coordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Coordinate_type > r (
        Coordinate_traits::create (i, f, this));

      this->Coordinate ().push_back (r);
      continue;
    }

    // CoordinateDouble
    //
    if (n.name () == "CoordinateDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateDouble_type > r (
        CoordinateDouble_traits::create (i, f, this));

      this->CoordinateDouble ().push_back (r);
      continue;
    }

    // GeoCoordinate
    //
    if (n.name () == "GeoCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoCoordinate_type > r (
        GeoCoordinate_traits::create (i, f, this));

      this->GeoCoordinate ().push_back (r);
      continue;
    }

    // FogCoordinate
    //
    if (n.name () == "FogCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< FogCoordinate_type > r (
        FogCoordinate_traits::create (i, f, this));

      this->FogCoordinate ().push_back (r);
      continue;
    }

    // Normal
    //
    if (n.name () == "Normal" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Normal_type > r (
        Normal_traits::create (i, f, this));

      this->Normal ().push_back (r);
      continue;
    }

    // TextureCoordinate
    //
    if (n.name () == "TextureCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureCoordinate_type > r (
        TextureCoordinate_traits::create (i, f, this));

      this->TextureCoordinate ().push_back (r);
      continue;
    }

    // TextureCoordinate3D
    //
    if (n.name () == "TextureCoordinate3D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureCoordinate3D_type > r (
        TextureCoordinate3D_traits::create (i, f, this));

      this->TextureCoordinate3D ().push_back (r);
      continue;
    }

    // TextureCoordinate4D
    //
    if (n.name () == "TextureCoordinate4D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureCoordinate4D_type > r (
        TextureCoordinate4D_traits::create (i, f, this));

      this->TextureCoordinate4D ().push_back (r);
      continue;
    }

    // TextureCoordinateGenerator
    //
    if (n.name () == "TextureCoordinateGenerator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureCoordinateGenerator_type > r (
        TextureCoordinateGenerator_traits::create (i, f, this));

      this->TextureCoordinateGenerator ().push_back (r);
      continue;
    }

    // MultiTextureCoordinate
    //
    if (n.name () == "MultiTextureCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MultiTextureCoordinate_type > r (
        MultiTextureCoordinate_traits::create (i, f, this));

      this->MultiTextureCoordinate ().push_back (r);
      continue;
    }

    // NurbsTextureCoordinate
    //
    if (n.name () == "NurbsTextureCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsTextureCoordinate_type > r (
        NurbsTextureCoordinate_traits::create (i, f, this));

      this->NurbsTextureCoordinate ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "ccw" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ccw_type > r (
        ccw_traits::create (i, f, this));

      this->ccw (r);
      continue;
    }

    if (n.name () == "colorPerVertex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< colorPerVertex_type > r (
        colorPerVertex_traits::create (i, f, this));

      this->colorPerVertex (r);
      continue;
    }

    if (n.name () == "normalPerVertex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< normalPerVertex_type > r (
        normalPerVertex_traits::create (i, f, this));

      this->normalPerVertex (r);
      continue;
    }

    if (n.name () == "solid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< solid_type > r (
        solid_traits::create (i, f, this));

      this->solid (r);
      continue;
    }
  }

  if (!ccw_.present ())
  {
    ::std::auto_ptr< ccw_type > r (
      ccw_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->ccw (r);
  }

  if (!colorPerVertex_.present ())
  {
    ::std::auto_ptr< colorPerVertex_type > r (
      colorPerVertex_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->colorPerVertex (r);
  }

  if (!normalPerVertex_.present ())
  {
    ::std::auto_ptr< normalPerVertex_type > r (
      normalPerVertex_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->normalPerVertex (r);
  }

  if (!solid_.present ())
  {
    ::std::auto_ptr< solid_type > r (
      solid_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->solid (r);
  }
}

X3DComposedGeometryNode* X3DComposedGeometryNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DComposedGeometryNode (*this, f, c);
}

X3DComposedGeometryNode::
~X3DComposedGeometryNode ()
{
}

// X3DCoordinateNode
//

X3DCoordinateNode::
X3DCoordinateNode ()
: ::X3DGeometricPropertyNode ()
{
}

X3DCoordinateNode::
X3DCoordinateNode (const X3DCoordinateNode& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DGeometricPropertyNode (x, f, c)
{
}

X3DCoordinateNode::
X3DCoordinateNode (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DGeometricPropertyNode (e, f, c)
{
}

X3DCoordinateNode* X3DCoordinateNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DCoordinateNode (*this, f, c);
}

X3DCoordinateNode::
~X3DCoordinateNode ()
{
}

// X3DSensorNode
//

const X3DSensorNode::enabled_type X3DSensorNode::enabled_default_value_ (
  ::std::string ("true"), 0, 0, 0);

X3DSensorNode::
X3DSensorNode ()
: ::X3DChildNode (),
  enabled_ (enabled_default_value (), ::xml_schema::flags (), this)
{
}

X3DSensorNode::
X3DSensorNode (const X3DSensorNode& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DChildNode (x, f, c),
  enabled_ (x.enabled_, f, this)
{
}

X3DSensorNode::
X3DSensorNode (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DChildNode (e, f | ::xml_schema::flags::base, c),
  enabled_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DSensorNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DChildNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "enabled" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< enabled_type > r (
        enabled_traits::create (i, f, this));

      this->enabled (r);
      continue;
    }
  }

  if (!enabled_.present ())
  {
    ::std::auto_ptr< enabled_type > r (
      enabled_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->enabled (r);
  }
}

X3DSensorNode* X3DSensorNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DSensorNode (*this, f, c);
}

X3DSensorNode::
~X3DSensorNode ()
{
}

// X3DPointingDeviceSensorNode
//

X3DPointingDeviceSensorNode::
X3DPointingDeviceSensorNode ()
: ::X3DSensorNode (),
  description_ (::xml_schema::flags (), this)
{
}

X3DPointingDeviceSensorNode::
X3DPointingDeviceSensorNode (const X3DPointingDeviceSensorNode& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::X3DSensorNode (x, f, c),
  description_ (x.description_, f, this)
{
}

X3DPointingDeviceSensorNode::
X3DPointingDeviceSensorNode (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::X3DSensorNode (e, f | ::xml_schema::flags::base, c),
  description_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DPointingDeviceSensorNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DSensorNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "description" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< description_type > r (
        description_traits::create (i, f, this));

      this->description (r);
      continue;
    }
  }
}

X3DPointingDeviceSensorNode* X3DPointingDeviceSensorNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DPointingDeviceSensorNode (*this, f, c);
}

X3DPointingDeviceSensorNode::
~X3DPointingDeviceSensorNode ()
{
}

// X3DDragSensorNode
//

const X3DDragSensorNode::autoOffset_type X3DDragSensorNode::autoOffset_default_value_ (
  ::std::string ("true"), 0, 0, 0);

X3DDragSensorNode::
X3DDragSensorNode ()
: ::X3DPointingDeviceSensorNode (),
  autoOffset_ (autoOffset_default_value (), ::xml_schema::flags (), this)
{
}

X3DDragSensorNode::
X3DDragSensorNode (const X3DDragSensorNode& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DPointingDeviceSensorNode (x, f, c),
  autoOffset_ (x.autoOffset_, f, this)
{
}

X3DDragSensorNode::
X3DDragSensorNode (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DPointingDeviceSensorNode (e, f | ::xml_schema::flags::base, c),
  autoOffset_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DDragSensorNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DPointingDeviceSensorNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "autoOffset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< autoOffset_type > r (
        autoOffset_traits::create (i, f, this));

      this->autoOffset (r);
      continue;
    }
  }

  if (!autoOffset_.present ())
  {
    ::std::auto_ptr< autoOffset_type > r (
      autoOffset_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->autoOffset (r);
  }
}

X3DDragSensorNode* X3DDragSensorNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DDragSensorNode (*this, f, c);
}

X3DDragSensorNode::
~X3DDragSensorNode ()
{
}

// X3DEnvironmentalSensorNode
//

const X3DEnvironmentalSensorNode::center_type X3DEnvironmentalSensorNode::center_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const X3DEnvironmentalSensorNode::size_type X3DEnvironmentalSensorNode::size_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

X3DEnvironmentalSensorNode::
X3DEnvironmentalSensorNode ()
: ::X3DSensorNode (),
  center_ (center_default_value (), ::xml_schema::flags (), this),
  size_ (size_default_value (), ::xml_schema::flags (), this)
{
}

X3DEnvironmentalSensorNode::
X3DEnvironmentalSensorNode (const X3DEnvironmentalSensorNode& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::X3DSensorNode (x, f, c),
  center_ (x.center_, f, this),
  size_ (x.size_, f, this)
{
}

X3DEnvironmentalSensorNode::
X3DEnvironmentalSensorNode (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::X3DSensorNode (e, f | ::xml_schema::flags::base, c),
  center_ (f, this),
  size_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DEnvironmentalSensorNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DSensorNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "center" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< center_type > r (
        center_traits::create (i, f, this));

      this->center (r);
      continue;
    }

    if (n.name () == "size" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< size_type > r (
        size_traits::create (i, f, this));

      this->size (r);
      continue;
    }
  }

  if (!center_.present ())
  {
    ::std::auto_ptr< center_type > r (
      center_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->center (r);
  }

  if (!size_.present ())
  {
    ::std::auto_ptr< size_type > r (
      size_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->size (r);
  }
}

X3DEnvironmentalSensorNode* X3DEnvironmentalSensorNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DEnvironmentalSensorNode (*this, f, c);
}

X3DEnvironmentalSensorNode::
~X3DEnvironmentalSensorNode ()
{
}

// X3DEnvironmentTextureNode
//

const X3DEnvironmentTextureNode::containerField_type X3DEnvironmentTextureNode::containerField_default_value_ (
  ::std::string ("texture"), 0, 0, 0);

X3DEnvironmentTextureNode::
X3DEnvironmentTextureNode ()
: ::X3DAppearanceChildNode (),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

X3DEnvironmentTextureNode::
X3DEnvironmentTextureNode (const X3DEnvironmentTextureNode& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::X3DAppearanceChildNode (x, f, c),
  containerField_ (x.containerField_, f, this)
{
}

X3DEnvironmentTextureNode::
X3DEnvironmentTextureNode (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::X3DAppearanceChildNode (e, f | ::xml_schema::flags::base, c),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DEnvironmentTextureNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DAppearanceChildNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("texture"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

X3DEnvironmentTextureNode* X3DEnvironmentTextureNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DEnvironmentTextureNode (*this, f, c);
}

X3DEnvironmentTextureNode::
~X3DEnvironmentTextureNode ()
{
}

// X3DField
//

X3DField::
X3DField ()
: ::xml_schema::type ()
{
}

X3DField::
X3DField (const X3DField& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (x, f, c)
{
}

X3DField::
X3DField (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (e, f, c)
{
}

X3DField::
X3DField (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (a, f, c)
{
}

X3DField::
X3DField (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::xml_schema::type (s, e, f, c)
{
}

X3DField* X3DField::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DField (*this, f, c);
}

X3DField::
~X3DField ()
{
}

// X3DFogObject
//

const X3DFogObject::color_type X3DFogObject::color_default_value_ (
  ::std::string ("1 1 1"), 0, 0, 0);

const X3DFogObject::fogType_type X3DFogObject::fogType_default_value_ (
  ::std::string ("LINEAR"), 0, 0, 0);

const X3DFogObject::visibilityRange_type X3DFogObject::visibilityRange_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const X3DFogObject::containerField_type X3DFogObject::containerField_default_value_ (
  ::std::string ("fontStyle"), 0, 0, 0);

X3DFogObject::
X3DFogObject ()
: ::X3DNode (),
  color_ (color_default_value (), ::xml_schema::flags (), this),
  fogType_ (fogType_default_value (), ::xml_schema::flags (), this),
  visibilityRange_ (visibilityRange_default_value (), ::xml_schema::flags (), this),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

X3DFogObject::
X3DFogObject (const X3DFogObject& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DNode (x, f, c),
  color_ (x.color_, f, this),
  fogType_ (x.fogType_, f, this),
  visibilityRange_ (x.visibilityRange_, f, this),
  containerField_ (x.containerField_, f, this)
{
}

X3DFogObject::
X3DFogObject (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DNode (e, f | ::xml_schema::flags::base, c),
  color_ (f, this),
  fogType_ (f, this),
  visibilityRange_ (f, this),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DFogObject::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< color_type > r (
        color_traits::create (i, f, this));

      this->color (r);
      continue;
    }

    if (n.name () == "fogType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< fogType_type > r (
        fogType_traits::create (i, f, this));

      this->fogType (r);
      continue;
    }

    if (n.name () == "visibilityRange" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< visibilityRange_type > r (
        visibilityRange_traits::create (i, f, this));

      this->visibilityRange (r);
      continue;
    }

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!color_.present ())
  {
    ::std::auto_ptr< color_type > r (
      color_traits::create (
        ::std::string ("1 1 1"),
        &p.element (), f, this));

    this->color (r);
  }

  if (!fogType_.present ())
  {
    ::std::auto_ptr< fogType_type > r (
      fogType_traits::create (
        ::std::string ("LINEAR"),
        &p.element (), f, this));

    this->fogType (r);
  }

  if (!visibilityRange_.present ())
  {
    ::std::auto_ptr< visibilityRange_type > r (
      visibilityRange_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->visibilityRange (r);
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("fontStyle"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

X3DFogObject* X3DFogObject::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DFogObject (*this, f, c);
}

X3DFogObject::
~X3DFogObject ()
{
}

// X3DFontStyleNode
//

const X3DFontStyleNode::containerField_type X3DFontStyleNode::containerField_default_value_ (
  ::std::string ("fontStyle"), 0, 0, 0);

X3DFontStyleNode::
X3DFontStyleNode ()
: ::X3DNode (),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

X3DFontStyleNode::
X3DFontStyleNode (const X3DFontStyleNode& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DNode (x, f, c),
  containerField_ (x.containerField_, f, this)
{
}

X3DFontStyleNode::
X3DFontStyleNode (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DNode (e, f | ::xml_schema::flags::base, c),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DFontStyleNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("fontStyle"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

X3DFontStyleNode* X3DFontStyleNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DFontStyleNode (*this, f, c);
}

X3DFontStyleNode::
~X3DFontStyleNode ()
{
}

// X3DGroupingNode
//

const X3DGroupingNode::bboxCenter_type X3DGroupingNode::bboxCenter_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const X3DGroupingNode::bboxSize_type X3DGroupingNode::bboxSize_default_value_ (
  ::std::string ("-1 -1 -1"), 0, 0, 0);

X3DGroupingNode::
X3DGroupingNode ()
: ::X3DChildNode (),
  Appearance_ (::xml_schema::flags (), this),
  Background_ (::xml_schema::flags (), this),
  ColorInterpolator_ (::xml_schema::flags (), this),
  CoordinateInterpolator_ (::xml_schema::flags (), this),
  DirectionalLight_ (::xml_schema::flags (), this),
  Group_ (::xml_schema::flags (), this),
  NavigationInfo_ (::xml_schema::flags (), this),
  NormalInterpolator_ (::xml_schema::flags (), this),
  OrientationInterpolator_ (::xml_schema::flags (), this),
  PositionInterpolator_ (::xml_schema::flags (), this),
  ScalarInterpolator_ (::xml_schema::flags (), this),
  Shape_ (::xml_schema::flags (), this),
  TimeSensor_ (::xml_schema::flags (), this),
  Transform_ (::xml_schema::flags (), this),
  Viewpoint_ (::xml_schema::flags (), this),
  WorldInfo_ (::xml_schema::flags (), this),
  Anchor_ (::xml_schema::flags (), this),
  BooleanFilter_ (::xml_schema::flags (), this),
  BooleanSequencer_ (::xml_schema::flags (), this),
  BooleanToggle_ (::xml_schema::flags (), this),
  BooleanTrigger_ (::xml_schema::flags (), this),
  CylinderSensor_ (::xml_schema::flags (), this),
  Inline_ (::xml_schema::flags (), this),
  IntegerSequencer_ (::xml_schema::flags (), this),
  IntegerTrigger_ (::xml_schema::flags (), this),
  KeySensor_ (::xml_schema::flags (), this),
  PlaneSensor_ (::xml_schema::flags (), this),
  PointLight_ (::xml_schema::flags (), this),
  ProximitySensor_ (::xml_schema::flags (), this),
  SphereSensor_ (::xml_schema::flags (), this),
  SpotLight_ (::xml_schema::flags (), this),
  StringSensor_ (::xml_schema::flags (), this),
  Switch_ (::xml_schema::flags (), this),
  TimeTrigger_ (::xml_schema::flags (), this),
  TouchSensor_ (::xml_schema::flags (), this),
  AudioClip_ (::xml_schema::flags (), this),
  Billboard_ (::xml_schema::flags (), this),
  Collision_ (::xml_schema::flags (), this),
  Fog_ (::xml_schema::flags (), this),
  LoadSensor_ (::xml_schema::flags (), this),
  LocalFog_ (::xml_schema::flags (), this),
  LOD_ (::xml_schema::flags (), this),
  Script_ (::xml_schema::flags (), this),
  Sound_ (::xml_schema::flags (), this),
  VisibilitySensor_ (::xml_schema::flags (), this),
  CoordinateInterpolator2D_ (::xml_schema::flags (), this),
  PositionInterpolator2D_ (::xml_schema::flags (), this),
  StaticGroup_ (::xml_schema::flags (), this),
  CADAssembly_ (::xml_schema::flags (), this),
  CADLayer_ (::xml_schema::flags (), this),
  EspduTransform_ (::xml_schema::flags (), this),
  ReceiverPdu_ (::xml_schema::flags (), this),
  SignalPdu_ (::xml_schema::flags (), this),
  TransmitterPdu_ (::xml_schema::flags (), this),
  GeoLocation_ (::xml_schema::flags (), this),
  GeoLOD_ (::xml_schema::flags (), this),
  GeoMetadata_ (::xml_schema::flags (), this),
  GeoOrigin_ (::xml_schema::flags (), this),
  GeoPositionInterpolator_ (::xml_schema::flags (), this),
  GeoTouchSensor_ (::xml_schema::flags (), this),
  GeoViewpoint_ (::xml_schema::flags (), this),
  HAnimHumanoid_ (::xml_schema::flags (), this),
  HAnimJoint_ (::xml_schema::flags (), this),
  HAnimSegment_ (::xml_schema::flags (), this),
  HAnimSite_ (::xml_schema::flags (), this),
  NurbsOrientationInterpolator_ (::xml_schema::flags (), this),
  NurbsPositionInterpolator_ (::xml_schema::flags (), this),
  NurbsSurfaceInterpolator_ (::xml_schema::flags (), this),
  NurbsSet_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  ROUTE_ (::xml_schema::flags (), this),
  ExternProtoDeclare_ (::xml_schema::flags (), this),
  ProtoDeclare_ (::xml_schema::flags (), this),
  IMPORT_ (::xml_schema::flags (), this),
  EXPORT_ (::xml_schema::flags (), this),
  bboxCenter_ (bboxCenter_default_value (), ::xml_schema::flags (), this),
  bboxSize_ (bboxSize_default_value (), ::xml_schema::flags (), this)
{
}

X3DGroupingNode::
X3DGroupingNode (const X3DGroupingNode& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::X3DChildNode (x, f, c),
  Appearance_ (x.Appearance_, f, this),
  Background_ (x.Background_, f, this),
  ColorInterpolator_ (x.ColorInterpolator_, f, this),
  CoordinateInterpolator_ (x.CoordinateInterpolator_, f, this),
  DirectionalLight_ (x.DirectionalLight_, f, this),
  Group_ (x.Group_, f, this),
  NavigationInfo_ (x.NavigationInfo_, f, this),
  NormalInterpolator_ (x.NormalInterpolator_, f, this),
  OrientationInterpolator_ (x.OrientationInterpolator_, f, this),
  PositionInterpolator_ (x.PositionInterpolator_, f, this),
  ScalarInterpolator_ (x.ScalarInterpolator_, f, this),
  Shape_ (x.Shape_, f, this),
  TimeSensor_ (x.TimeSensor_, f, this),
  Transform_ (x.Transform_, f, this),
  Viewpoint_ (x.Viewpoint_, f, this),
  WorldInfo_ (x.WorldInfo_, f, this),
  Anchor_ (x.Anchor_, f, this),
  BooleanFilter_ (x.BooleanFilter_, f, this),
  BooleanSequencer_ (x.BooleanSequencer_, f, this),
  BooleanToggle_ (x.BooleanToggle_, f, this),
  BooleanTrigger_ (x.BooleanTrigger_, f, this),
  CylinderSensor_ (x.CylinderSensor_, f, this),
  Inline_ (x.Inline_, f, this),
  IntegerSequencer_ (x.IntegerSequencer_, f, this),
  IntegerTrigger_ (x.IntegerTrigger_, f, this),
  KeySensor_ (x.KeySensor_, f, this),
  PlaneSensor_ (x.PlaneSensor_, f, this),
  PointLight_ (x.PointLight_, f, this),
  ProximitySensor_ (x.ProximitySensor_, f, this),
  SphereSensor_ (x.SphereSensor_, f, this),
  SpotLight_ (x.SpotLight_, f, this),
  StringSensor_ (x.StringSensor_, f, this),
  Switch_ (x.Switch_, f, this),
  TimeTrigger_ (x.TimeTrigger_, f, this),
  TouchSensor_ (x.TouchSensor_, f, this),
  AudioClip_ (x.AudioClip_, f, this),
  Billboard_ (x.Billboard_, f, this),
  Collision_ (x.Collision_, f, this),
  Fog_ (x.Fog_, f, this),
  LoadSensor_ (x.LoadSensor_, f, this),
  LocalFog_ (x.LocalFog_, f, this),
  LOD_ (x.LOD_, f, this),
  Script_ (x.Script_, f, this),
  Sound_ (x.Sound_, f, this),
  VisibilitySensor_ (x.VisibilitySensor_, f, this),
  CoordinateInterpolator2D_ (x.CoordinateInterpolator2D_, f, this),
  PositionInterpolator2D_ (x.PositionInterpolator2D_, f, this),
  StaticGroup_ (x.StaticGroup_, f, this),
  CADAssembly_ (x.CADAssembly_, f, this),
  CADLayer_ (x.CADLayer_, f, this),
  EspduTransform_ (x.EspduTransform_, f, this),
  ReceiverPdu_ (x.ReceiverPdu_, f, this),
  SignalPdu_ (x.SignalPdu_, f, this),
  TransmitterPdu_ (x.TransmitterPdu_, f, this),
  GeoLocation_ (x.GeoLocation_, f, this),
  GeoLOD_ (x.GeoLOD_, f, this),
  GeoMetadata_ (x.GeoMetadata_, f, this),
  GeoOrigin_ (x.GeoOrigin_, f, this),
  GeoPositionInterpolator_ (x.GeoPositionInterpolator_, f, this),
  GeoTouchSensor_ (x.GeoTouchSensor_, f, this),
  GeoViewpoint_ (x.GeoViewpoint_, f, this),
  HAnimHumanoid_ (x.HAnimHumanoid_, f, this),
  HAnimJoint_ (x.HAnimJoint_, f, this),
  HAnimSegment_ (x.HAnimSegment_, f, this),
  HAnimSite_ (x.HAnimSite_, f, this),
  NurbsOrientationInterpolator_ (x.NurbsOrientationInterpolator_, f, this),
  NurbsPositionInterpolator_ (x.NurbsPositionInterpolator_, f, this),
  NurbsSurfaceInterpolator_ (x.NurbsSurfaceInterpolator_, f, this),
  NurbsSet_ (x.NurbsSet_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  ROUTE_ (x.ROUTE_, f, this),
  ExternProtoDeclare_ (x.ExternProtoDeclare_, f, this),
  ProtoDeclare_ (x.ProtoDeclare_, f, this),
  IMPORT_ (x.IMPORT_, f, this),
  EXPORT_ (x.EXPORT_, f, this),
  bboxCenter_ (x.bboxCenter_, f, this),
  bboxSize_ (x.bboxSize_, f, this)
{
}

X3DGroupingNode::
X3DGroupingNode (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::X3DChildNode (e, f | ::xml_schema::flags::base, c),
  Appearance_ (f, this),
  Background_ (f, this),
  ColorInterpolator_ (f, this),
  CoordinateInterpolator_ (f, this),
  DirectionalLight_ (f, this),
  Group_ (f, this),
  NavigationInfo_ (f, this),
  NormalInterpolator_ (f, this),
  OrientationInterpolator_ (f, this),
  PositionInterpolator_ (f, this),
  ScalarInterpolator_ (f, this),
  Shape_ (f, this),
  TimeSensor_ (f, this),
  Transform_ (f, this),
  Viewpoint_ (f, this),
  WorldInfo_ (f, this),
  Anchor_ (f, this),
  BooleanFilter_ (f, this),
  BooleanSequencer_ (f, this),
  BooleanToggle_ (f, this),
  BooleanTrigger_ (f, this),
  CylinderSensor_ (f, this),
  Inline_ (f, this),
  IntegerSequencer_ (f, this),
  IntegerTrigger_ (f, this),
  KeySensor_ (f, this),
  PlaneSensor_ (f, this),
  PointLight_ (f, this),
  ProximitySensor_ (f, this),
  SphereSensor_ (f, this),
  SpotLight_ (f, this),
  StringSensor_ (f, this),
  Switch_ (f, this),
  TimeTrigger_ (f, this),
  TouchSensor_ (f, this),
  AudioClip_ (f, this),
  Billboard_ (f, this),
  Collision_ (f, this),
  Fog_ (f, this),
  LoadSensor_ (f, this),
  LocalFog_ (f, this),
  LOD_ (f, this),
  Script_ (f, this),
  Sound_ (f, this),
  VisibilitySensor_ (f, this),
  CoordinateInterpolator2D_ (f, this),
  PositionInterpolator2D_ (f, this),
  StaticGroup_ (f, this),
  CADAssembly_ (f, this),
  CADLayer_ (f, this),
  EspduTransform_ (f, this),
  ReceiverPdu_ (f, this),
  SignalPdu_ (f, this),
  TransmitterPdu_ (f, this),
  GeoLocation_ (f, this),
  GeoLOD_ (f, this),
  GeoMetadata_ (f, this),
  GeoOrigin_ (f, this),
  GeoPositionInterpolator_ (f, this),
  GeoTouchSensor_ (f, this),
  GeoViewpoint_ (f, this),
  HAnimHumanoid_ (f, this),
  HAnimJoint_ (f, this),
  HAnimSegment_ (f, this),
  HAnimSite_ (f, this),
  NurbsOrientationInterpolator_ (f, this),
  NurbsPositionInterpolator_ (f, this),
  NurbsSurfaceInterpolator_ (f, this),
  NurbsSet_ (f, this),
  ProtoInstance_ (f, this),
  ROUTE_ (f, this),
  ExternProtoDeclare_ (f, this),
  ProtoDeclare_ (f, this),
  IMPORT_ (f, this),
  EXPORT_ (f, this),
  bboxCenter_ (f, this),
  bboxSize_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DGroupingNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DChildNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Appearance
    //
    if (n.name () == "Appearance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Appearance_type > r (
        Appearance_traits::create (i, f, this));

      this->Appearance ().push_back (r);
      continue;
    }

    // Background
    //
    if (n.name () == "Background" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Background_type > r (
        Background_traits::create (i, f, this));

      this->Background ().push_back (r);
      continue;
    }

    // ColorInterpolator
    //
    if (n.name () == "ColorInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ColorInterpolator_type > r (
        ColorInterpolator_traits::create (i, f, this));

      this->ColorInterpolator ().push_back (r);
      continue;
    }

    // CoordinateInterpolator
    //
    if (n.name () == "CoordinateInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateInterpolator_type > r (
        CoordinateInterpolator_traits::create (i, f, this));

      this->CoordinateInterpolator ().push_back (r);
      continue;
    }

    // DirectionalLight
    //
    if (n.name () == "DirectionalLight" && n.namespace_ () == "")
    {
      ::std::auto_ptr< DirectionalLight_type > r (
        DirectionalLight_traits::create (i, f, this));

      this->DirectionalLight ().push_back (r);
      continue;
    }

    // Group
    //
    if (n.name () == "Group" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Group_type > r (
        Group_traits::create (i, f, this));

      this->Group ().push_back (r);
      continue;
    }

    // NavigationInfo
    //
    if (n.name () == "NavigationInfo" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NavigationInfo_type > r (
        NavigationInfo_traits::create (i, f, this));

      this->NavigationInfo ().push_back (r);
      continue;
    }

    // NormalInterpolator
    //
    if (n.name () == "NormalInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NormalInterpolator_type > r (
        NormalInterpolator_traits::create (i, f, this));

      this->NormalInterpolator ().push_back (r);
      continue;
    }

    // OrientationInterpolator
    //
    if (n.name () == "OrientationInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< OrientationInterpolator_type > r (
        OrientationInterpolator_traits::create (i, f, this));

      this->OrientationInterpolator ().push_back (r);
      continue;
    }

    // PositionInterpolator
    //
    if (n.name () == "PositionInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PositionInterpolator_type > r (
        PositionInterpolator_traits::create (i, f, this));

      this->PositionInterpolator ().push_back (r);
      continue;
    }

    // ScalarInterpolator
    //
    if (n.name () == "ScalarInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ScalarInterpolator_type > r (
        ScalarInterpolator_traits::create (i, f, this));

      this->ScalarInterpolator ().push_back (r);
      continue;
    }

    // Shape
    //
    if (n.name () == "Shape" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Shape_type > r (
        Shape_traits::create (i, f, this));

      this->Shape ().push_back (r);
      continue;
    }

    // TimeSensor
    //
    if (n.name () == "TimeSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TimeSensor_type > r (
        TimeSensor_traits::create (i, f, this));

      this->TimeSensor ().push_back (r);
      continue;
    }

    // Transform
    //
    if (n.name () == "Transform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Transform_type > r (
        Transform_traits::create (i, f, this));

      this->Transform ().push_back (r);
      continue;
    }

    // Viewpoint
    //
    if (n.name () == "Viewpoint" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Viewpoint_type > r (
        Viewpoint_traits::create (i, f, this));

      this->Viewpoint ().push_back (r);
      continue;
    }

    // WorldInfo
    //
    if (n.name () == "WorldInfo" && n.namespace_ () == "")
    {
      ::std::auto_ptr< WorldInfo_type > r (
        WorldInfo_traits::create (i, f, this));

      this->WorldInfo ().push_back (r);
      continue;
    }

    // Anchor
    //
    if (n.name () == "Anchor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Anchor_type > r (
        Anchor_traits::create (i, f, this));

      this->Anchor ().push_back (r);
      continue;
    }

    // BooleanFilter
    //
    if (n.name () == "BooleanFilter" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanFilter_type > r (
        BooleanFilter_traits::create (i, f, this));

      this->BooleanFilter ().push_back (r);
      continue;
    }

    // BooleanSequencer
    //
    if (n.name () == "BooleanSequencer" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanSequencer_type > r (
        BooleanSequencer_traits::create (i, f, this));

      this->BooleanSequencer ().push_back (r);
      continue;
    }

    // BooleanToggle
    //
    if (n.name () == "BooleanToggle" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanToggle_type > r (
        BooleanToggle_traits::create (i, f, this));

      this->BooleanToggle ().push_back (r);
      continue;
    }

    // BooleanTrigger
    //
    if (n.name () == "BooleanTrigger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanTrigger_type > r (
        BooleanTrigger_traits::create (i, f, this));

      this->BooleanTrigger ().push_back (r);
      continue;
    }

    // CylinderSensor
    //
    if (n.name () == "CylinderSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CylinderSensor_type > r (
        CylinderSensor_traits::create (i, f, this));

      this->CylinderSensor ().push_back (r);
      continue;
    }

    // Inline
    //
    if (n.name () == "Inline" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Inline_type > r (
        Inline_traits::create (i, f, this));

      this->Inline ().push_back (r);
      continue;
    }

    // IntegerSequencer
    //
    if (n.name () == "IntegerSequencer" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IntegerSequencer_type > r (
        IntegerSequencer_traits::create (i, f, this));

      this->IntegerSequencer ().push_back (r);
      continue;
    }

    // IntegerTrigger
    //
    if (n.name () == "IntegerTrigger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IntegerTrigger_type > r (
        IntegerTrigger_traits::create (i, f, this));

      this->IntegerTrigger ().push_back (r);
      continue;
    }

    // KeySensor
    //
    if (n.name () == "KeySensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< KeySensor_type > r (
        KeySensor_traits::create (i, f, this));

      this->KeySensor ().push_back (r);
      continue;
    }

    // PlaneSensor
    //
    if (n.name () == "PlaneSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PlaneSensor_type > r (
        PlaneSensor_traits::create (i, f, this));

      this->PlaneSensor ().push_back (r);
      continue;
    }

    // PointLight
    //
    if (n.name () == "PointLight" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PointLight_type > r (
        PointLight_traits::create (i, f, this));

      this->PointLight ().push_back (r);
      continue;
    }

    // ProximitySensor
    //
    if (n.name () == "ProximitySensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProximitySensor_type > r (
        ProximitySensor_traits::create (i, f, this));

      this->ProximitySensor ().push_back (r);
      continue;
    }

    // SphereSensor
    //
    if (n.name () == "SphereSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< SphereSensor_type > r (
        SphereSensor_traits::create (i, f, this));

      this->SphereSensor ().push_back (r);
      continue;
    }

    // SpotLight
    //
    if (n.name () == "SpotLight" && n.namespace_ () == "")
    {
      ::std::auto_ptr< SpotLight_type > r (
        SpotLight_traits::create (i, f, this));

      this->SpotLight ().push_back (r);
      continue;
    }

    // StringSensor
    //
    if (n.name () == "StringSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< StringSensor_type > r (
        StringSensor_traits::create (i, f, this));

      this->StringSensor ().push_back (r);
      continue;
    }

    // Switch
    //
    if (n.name () == "Switch" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Switch_type > r (
        Switch_traits::create (i, f, this));

      this->Switch ().push_back (r);
      continue;
    }

    // TimeTrigger
    //
    if (n.name () == "TimeTrigger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TimeTrigger_type > r (
        TimeTrigger_traits::create (i, f, this));

      this->TimeTrigger ().push_back (r);
      continue;
    }

    // TouchSensor
    //
    if (n.name () == "TouchSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TouchSensor_type > r (
        TouchSensor_traits::create (i, f, this));

      this->TouchSensor ().push_back (r);
      continue;
    }

    // AudioClip
    //
    if (n.name () == "AudioClip" && n.namespace_ () == "")
    {
      ::std::auto_ptr< AudioClip_type > r (
        AudioClip_traits::create (i, f, this));

      this->AudioClip ().push_back (r);
      continue;
    }

    // Billboard
    //
    if (n.name () == "Billboard" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Billboard_type > r (
        Billboard_traits::create (i, f, this));

      this->Billboard ().push_back (r);
      continue;
    }

    // Collision
    //
    if (n.name () == "Collision" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Collision_type > r (
        Collision_traits::create (i, f, this));

      this->Collision ().push_back (r);
      continue;
    }

    // Fog
    //
    if (n.name () == "Fog" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Fog_type > r (
        Fog_traits::create (i, f, this));

      this->Fog ().push_back (r);
      continue;
    }

    // LoadSensor
    //
    if (n.name () == "LoadSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LoadSensor_type > r (
        LoadSensor_traits::create (i, f, this));

      this->LoadSensor ().push_back (r);
      continue;
    }

    // LocalFog
    //
    if (n.name () == "LocalFog" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LocalFog_type > r (
        LocalFog_traits::create (i, f, this));

      this->LocalFog ().push_back (r);
      continue;
    }

    // LOD
    //
    if (n.name () == "LOD" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LOD_type > r (
        LOD_traits::create (i, f, this));

      this->LOD ().push_back (r);
      continue;
    }

    // Script
    //
    if (n.name () == "Script" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Script_type > r (
        Script_traits::create (i, f, this));

      this->Script ().push_back (r);
      continue;
    }

    // Sound
    //
    if (n.name () == "Sound" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Sound_type > r (
        Sound_traits::create (i, f, this));

      this->Sound ().push_back (r);
      continue;
    }

    // VisibilitySensor
    //
    if (n.name () == "VisibilitySensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< VisibilitySensor_type > r (
        VisibilitySensor_traits::create (i, f, this));

      this->VisibilitySensor ().push_back (r);
      continue;
    }

    // CoordinateInterpolator2D
    //
    if (n.name () == "CoordinateInterpolator2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateInterpolator2D_type > r (
        CoordinateInterpolator2D_traits::create (i, f, this));

      this->CoordinateInterpolator2D ().push_back (r);
      continue;
    }

    // PositionInterpolator2D
    //
    if (n.name () == "PositionInterpolator2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PositionInterpolator2D_type > r (
        PositionInterpolator2D_traits::create (i, f, this));

      this->PositionInterpolator2D ().push_back (r);
      continue;
    }

    // StaticGroup
    //
    if (n.name () == "StaticGroup" && n.namespace_ () == "")
    {
      ::std::auto_ptr< StaticGroup_type > r (
        StaticGroup_traits::create (i, f, this));

      this->StaticGroup ().push_back (r);
      continue;
    }

    // CADAssembly
    //
    if (n.name () == "CADAssembly" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CADAssembly_type > r (
        CADAssembly_traits::create (i, f, this));

      this->CADAssembly ().push_back (r);
      continue;
    }

    // CADLayer
    //
    if (n.name () == "CADLayer" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CADLayer_type > r (
        CADLayer_traits::create (i, f, this));

      this->CADLayer ().push_back (r);
      continue;
    }

    // EspduTransform
    //
    if (n.name () == "EspduTransform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< EspduTransform_type > r (
        EspduTransform_traits::create (i, f, this));

      this->EspduTransform ().push_back (r);
      continue;
    }

    // ReceiverPdu
    //
    if (n.name () == "ReceiverPdu" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ReceiverPdu_type > r (
        ReceiverPdu_traits::create (i, f, this));

      this->ReceiverPdu ().push_back (r);
      continue;
    }

    // SignalPdu
    //
    if (n.name () == "SignalPdu" && n.namespace_ () == "")
    {
      ::std::auto_ptr< SignalPdu_type > r (
        SignalPdu_traits::create (i, f, this));

      this->SignalPdu ().push_back (r);
      continue;
    }

    // TransmitterPdu
    //
    if (n.name () == "TransmitterPdu" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TransmitterPdu_type > r (
        TransmitterPdu_traits::create (i, f, this));

      this->TransmitterPdu ().push_back (r);
      continue;
    }

    // GeoLocation
    //
    if (n.name () == "GeoLocation" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoLocation_type > r (
        GeoLocation_traits::create (i, f, this));

      this->GeoLocation ().push_back (r);
      continue;
    }

    // GeoLOD
    //
    if (n.name () == "GeoLOD" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoLOD_type > r (
        GeoLOD_traits::create (i, f, this));

      this->GeoLOD ().push_back (r);
      continue;
    }

    // GeoMetadata
    //
    if (n.name () == "GeoMetadata" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoMetadata_type > r (
        GeoMetadata_traits::create (i, f, this));

      this->GeoMetadata ().push_back (r);
      continue;
    }

    // GeoOrigin
    //
    if (n.name () == "GeoOrigin" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoOrigin_type > r (
        GeoOrigin_traits::create (i, f, this));

      this->GeoOrigin ().push_back (r);
      continue;
    }

    // GeoPositionInterpolator
    //
    if (n.name () == "GeoPositionInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoPositionInterpolator_type > r (
        GeoPositionInterpolator_traits::create (i, f, this));

      this->GeoPositionInterpolator ().push_back (r);
      continue;
    }

    // GeoTouchSensor
    //
    if (n.name () == "GeoTouchSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoTouchSensor_type > r (
        GeoTouchSensor_traits::create (i, f, this));

      this->GeoTouchSensor ().push_back (r);
      continue;
    }

    // GeoViewpoint
    //
    if (n.name () == "GeoViewpoint" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoViewpoint_type > r (
        GeoViewpoint_traits::create (i, f, this));

      this->GeoViewpoint ().push_back (r);
      continue;
    }

    // HAnimHumanoid
    //
    if (n.name () == "HAnimHumanoid" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimHumanoid_type > r (
        HAnimHumanoid_traits::create (i, f, this));

      this->HAnimHumanoid ().push_back (r);
      continue;
    }

    // HAnimJoint
    //
    if (n.name () == "HAnimJoint" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimJoint_type > r (
        HAnimJoint_traits::create (i, f, this));

      this->HAnimJoint ().push_back (r);
      continue;
    }

    // HAnimSegment
    //
    if (n.name () == "HAnimSegment" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimSegment_type > r (
        HAnimSegment_traits::create (i, f, this));

      this->HAnimSegment ().push_back (r);
      continue;
    }

    // HAnimSite
    //
    if (n.name () == "HAnimSite" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimSite_type > r (
        HAnimSite_traits::create (i, f, this));

      this->HAnimSite ().push_back (r);
      continue;
    }

    // NurbsOrientationInterpolator
    //
    if (n.name () == "NurbsOrientationInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsOrientationInterpolator_type > r (
        NurbsOrientationInterpolator_traits::create (i, f, this));

      this->NurbsOrientationInterpolator ().push_back (r);
      continue;
    }

    // NurbsPositionInterpolator
    //
    if (n.name () == "NurbsPositionInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsPositionInterpolator_type > r (
        NurbsPositionInterpolator_traits::create (i, f, this));

      this->NurbsPositionInterpolator ().push_back (r);
      continue;
    }

    // NurbsSurfaceInterpolator
    //
    if (n.name () == "NurbsSurfaceInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSurfaceInterpolator_type > r (
        NurbsSurfaceInterpolator_traits::create (i, f, this));

      this->NurbsSurfaceInterpolator ().push_back (r);
      continue;
    }

    // NurbsSet
    //
    if (n.name () == "NurbsSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSet_type > r (
        NurbsSet_traits::create (i, f, this));

      this->NurbsSet ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    // ROUTE
    //
    if (n.name () == "ROUTE" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ROUTE_type > r (
        ROUTE_traits::create (i, f, this));

      this->ROUTE ().push_back (r);
      continue;
    }

    // ExternProtoDeclare
    //
    if (n.name () == "ExternProtoDeclare" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ExternProtoDeclare_type > r (
        ExternProtoDeclare_traits::create (i, f, this));

      this->ExternProtoDeclare ().push_back (r);
      continue;
    }

    // ProtoDeclare
    //
    if (n.name () == "ProtoDeclare" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoDeclare_type > r (
        ProtoDeclare_traits::create (i, f, this));

      this->ProtoDeclare ().push_back (r);
      continue;
    }

    // IMPORT
    //
    if (n.name () == "IMPORT" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IMPORT_type > r (
        IMPORT_traits::create (i, f, this));

      this->IMPORT ().push_back (r);
      continue;
    }

    // EXPORT
    //
    if (n.name () == "EXPORT" && n.namespace_ () == "")
    {
      ::std::auto_ptr< EXPORT_type > r (
        EXPORT_traits::create (i, f, this));

      this->EXPORT ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "bboxCenter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bboxCenter_type > r (
        bboxCenter_traits::create (i, f, this));

      this->bboxCenter (r);
      continue;
    }

    if (n.name () == "bboxSize" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bboxSize_type > r (
        bboxSize_traits::create (i, f, this));

      this->bboxSize (r);
      continue;
    }
  }

  if (!bboxCenter_.present ())
  {
    ::std::auto_ptr< bboxCenter_type > r (
      bboxCenter_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->bboxCenter (r);
  }

  if (!bboxSize_.present ())
  {
    ::std::auto_ptr< bboxSize_type > r (
      bboxSize_traits::create (
        ::std::string ("-1 -1 -1"),
        &p.element (), f, this));

    this->bboxSize (r);
  }
}

X3DGroupingNode* X3DGroupingNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DGroupingNode (*this, f, c);
}

X3DGroupingNode::
~X3DGroupingNode ()
{
}

// X3DHumanoidNode
//

X3DHumanoidNode::
X3DHumanoidNode ()
: ::X3DChildNode ()
{
}

X3DHumanoidNode::
X3DHumanoidNode (const X3DHumanoidNode& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::X3DChildNode (x, f, c)
{
}

X3DHumanoidNode::
X3DHumanoidNode (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::X3DChildNode (e, f, c)
{
}

X3DHumanoidNode* X3DHumanoidNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DHumanoidNode (*this, f, c);
}

X3DHumanoidNode::
~X3DHumanoidNode ()
{
}

// X3DInfoNode
//

X3DInfoNode::
X3DInfoNode ()
: ::X3DChildNode ()
{
}

X3DInfoNode::
X3DInfoNode (const X3DInfoNode& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DChildNode (x, f, c)
{
}

X3DInfoNode::
X3DInfoNode (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DChildNode (e, f, c)
{
}

X3DInfoNode* X3DInfoNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DInfoNode (*this, f, c);
}

X3DInfoNode::
~X3DInfoNode ()
{
}

// X3DInterpolatorNode
//

X3DInterpolatorNode::
X3DInterpolatorNode ()
: ::X3DChildNode (),
  key_ (::xml_schema::flags (), this)
{
}

X3DInterpolatorNode::
X3DInterpolatorNode (const X3DInterpolatorNode& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::X3DChildNode (x, f, c),
  key_ (x.key_, f, this)
{
}

X3DInterpolatorNode::
X3DInterpolatorNode (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::X3DChildNode (e, f | ::xml_schema::flags::base, c),
  key_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DInterpolatorNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DChildNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "key" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< key_type > r (
        key_traits::create (i, f, this));

      this->key (r);
      continue;
    }
  }
}

X3DInterpolatorNode* X3DInterpolatorNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DInterpolatorNode (*this, f, c);
}

X3DInterpolatorNode::
~X3DInterpolatorNode ()
{
}

// X3DKeyDeviceSensorNode
//

X3DKeyDeviceSensorNode::
X3DKeyDeviceSensorNode ()
: ::X3DSensorNode ()
{
}

X3DKeyDeviceSensorNode::
X3DKeyDeviceSensorNode (const X3DKeyDeviceSensorNode& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DSensorNode (x, f, c)
{
}

X3DKeyDeviceSensorNode::
X3DKeyDeviceSensorNode (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DSensorNode (e, f, c)
{
}

X3DKeyDeviceSensorNode* X3DKeyDeviceSensorNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DKeyDeviceSensorNode (*this, f, c);
}

X3DKeyDeviceSensorNode::
~X3DKeyDeviceSensorNode ()
{
}

// X3DLightNode
//

const X3DLightNode::ambientIntensity_type X3DLightNode::ambientIntensity_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const X3DLightNode::color_type X3DLightNode::color_default_value_ (
  ::std::string ("1 1 1"), 0, 0, 0);

const X3DLightNode::intensity_type X3DLightNode::intensity_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const X3DLightNode::on_type X3DLightNode::on_default_value_ (
  ::std::string ("true"), 0, 0, 0);

X3DLightNode::
X3DLightNode ()
: ::X3DChildNode (),
  ambientIntensity_ (ambientIntensity_default_value (), ::xml_schema::flags (), this),
  color_ (color_default_value (), ::xml_schema::flags (), this),
  intensity_ (intensity_default_value (), ::xml_schema::flags (), this),
  on_ (on_default_value (), ::xml_schema::flags (), this)
{
}

X3DLightNode::
X3DLightNode (const X3DLightNode& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DChildNode (x, f, c),
  ambientIntensity_ (x.ambientIntensity_, f, this),
  color_ (x.color_, f, this),
  intensity_ (x.intensity_, f, this),
  on_ (x.on_, f, this)
{
}

X3DLightNode::
X3DLightNode (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DChildNode (e, f | ::xml_schema::flags::base, c),
  ambientIntensity_ (f, this),
  color_ (f, this),
  intensity_ (f, this),
  on_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DLightNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DChildNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "ambientIntensity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ambientIntensity_type > r (
        ambientIntensity_traits::create (i, f, this));

      this->ambientIntensity (r);
      continue;
    }

    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< color_type > r (
        color_traits::create (i, f, this));

      this->color (r);
      continue;
    }

    if (n.name () == "intensity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< intensity_type > r (
        intensity_traits::create (i, f, this));

      this->intensity (r);
      continue;
    }

    if (n.name () == "on" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< on_type > r (
        on_traits::create (i, f, this));

      this->on (r);
      continue;
    }
  }

  if (!ambientIntensity_.present ())
  {
    ::std::auto_ptr< ambientIntensity_type > r (
      ambientIntensity_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->ambientIntensity (r);
  }

  if (!color_.present ())
  {
    ::std::auto_ptr< color_type > r (
      color_traits::create (
        ::std::string ("1 1 1"),
        &p.element (), f, this));

    this->color (r);
  }

  if (!intensity_.present ())
  {
    ::std::auto_ptr< intensity_type > r (
      intensity_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->intensity (r);
  }

  if (!on_.present ())
  {
    ::std::auto_ptr< on_type > r (
      on_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->on (r);
  }
}

X3DLightNode* X3DLightNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DLightNode (*this, f, c);
}

X3DLightNode::
~X3DLightNode ()
{
}

// X3DMaterialNode
//

const X3DMaterialNode::containerField_type X3DMaterialNode::containerField_default_value_ (
  ::std::string ("material"), 0, 0, 0);

X3DMaterialNode::
X3DMaterialNode ()
: ::X3DAppearanceChildNode (),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

X3DMaterialNode::
X3DMaterialNode (const X3DMaterialNode& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::X3DAppearanceChildNode (x, f, c),
  containerField_ (x.containerField_, f, this)
{
}

X3DMaterialNode::
X3DMaterialNode (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::X3DAppearanceChildNode (e, f | ::xml_schema::flags::base, c),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DMaterialNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DAppearanceChildNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("material"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

X3DMaterialNode* X3DMaterialNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DMaterialNode (*this, f, c);
}

X3DMaterialNode::
~X3DMaterialNode ()
{
}

// X3DMetadataObject
//

const X3DMetadataObject::containerField_type X3DMetadataObject::containerField_default_value_ (
  ::std::string ("metadata"), 0, 0, 0);

X3DMetadataObject::
X3DMetadataObject ()
: ::X3DNode (),
  name_ (::xml_schema::flags (), this),
  reference_ (::xml_schema::flags (), this),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

X3DMetadataObject::
X3DMetadataObject (const X3DMetadataObject& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DNode (x, f, c),
  name_ (x.name_, f, this),
  reference_ (x.reference_, f, this),
  containerField_ (x.containerField_, f, this)
{
}

X3DMetadataObject::
X3DMetadataObject (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DNode (e, f | ::xml_schema::flags::base, c),
  name_ (f, this),
  reference_ (f, this),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DMetadataObject::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name (r);
      continue;
    }

    if (n.name () == "reference" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< reference_type > r (
        reference_traits::create (i, f, this));

      this->reference (r);
      continue;
    }

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("metadata"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

X3DMetadataObject* X3DMetadataObject::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DMetadataObject (*this, f, c);
}

X3DMetadataObject::
~X3DMetadataObject ()
{
}

// X3DNetworkSensorNode
//

X3DNetworkSensorNode::
X3DNetworkSensorNode ()
: ::X3DSensorNode (),
  Anchor_ (::xml_schema::flags (), this),
  AudioClip_ (::xml_schema::flags (), this),
  GeoMetadata_ (::xml_schema::flags (), this),
  ImageCubeMapTexture_ (::xml_schema::flags (), this),
  ImageTexture_ (::xml_schema::flags (), this),
  ImageTexture3D_ (::xml_schema::flags (), this),
  Inline_ (::xml_schema::flags (), this),
  MovieTexture_ (::xml_schema::flags (), this),
  PackagedShader_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  Script_ (::xml_schema::flags (), this),
  ShaderPart_ (::xml_schema::flags (), this),
  ShaderProgram_ (::xml_schema::flags (), this)
{
}

X3DNetworkSensorNode::
X3DNetworkSensorNode (const X3DNetworkSensorNode& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::X3DSensorNode (x, f, c),
  Anchor_ (x.Anchor_, f, this),
  AudioClip_ (x.AudioClip_, f, this),
  GeoMetadata_ (x.GeoMetadata_, f, this),
  ImageCubeMapTexture_ (x.ImageCubeMapTexture_, f, this),
  ImageTexture_ (x.ImageTexture_, f, this),
  ImageTexture3D_ (x.ImageTexture3D_, f, this),
  Inline_ (x.Inline_, f, this),
  MovieTexture_ (x.MovieTexture_, f, this),
  PackagedShader_ (x.PackagedShader_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  Script_ (x.Script_, f, this),
  ShaderPart_ (x.ShaderPart_, f, this),
  ShaderProgram_ (x.ShaderProgram_, f, this)
{
}

X3DNetworkSensorNode::
X3DNetworkSensorNode (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::X3DSensorNode (e, f | ::xml_schema::flags::base, c),
  Anchor_ (f, this),
  AudioClip_ (f, this),
  GeoMetadata_ (f, this),
  ImageCubeMapTexture_ (f, this),
  ImageTexture_ (f, this),
  ImageTexture3D_ (f, this),
  Inline_ (f, this),
  MovieTexture_ (f, this),
  PackagedShader_ (f, this),
  ProtoInstance_ (f, this),
  Script_ (f, this),
  ShaderPart_ (f, this),
  ShaderProgram_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DNetworkSensorNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DSensorNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Anchor
    //
    if (n.name () == "Anchor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Anchor_type > r (
        Anchor_traits::create (i, f, this));

      this->Anchor ().push_back (r);
      continue;
    }

    // AudioClip
    //
    if (n.name () == "AudioClip" && n.namespace_ () == "")
    {
      ::std::auto_ptr< AudioClip_type > r (
        AudioClip_traits::create (i, f, this));

      this->AudioClip ().push_back (r);
      continue;
    }

    // GeoMetadata
    //
    if (n.name () == "GeoMetadata" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoMetadata_type > r (
        GeoMetadata_traits::create (i, f, this));

      this->GeoMetadata ().push_back (r);
      continue;
    }

    // ImageCubeMapTexture
    //
    if (n.name () == "ImageCubeMapTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ImageCubeMapTexture_type > r (
        ImageCubeMapTexture_traits::create (i, f, this));

      this->ImageCubeMapTexture ().push_back (r);
      continue;
    }

    // ImageTexture
    //
    if (n.name () == "ImageTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ImageTexture_type > r (
        ImageTexture_traits::create (i, f, this));

      this->ImageTexture ().push_back (r);
      continue;
    }

    // ImageTexture3D
    //
    if (n.name () == "ImageTexture3D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ImageTexture3D_type > r (
        ImageTexture3D_traits::create (i, f, this));

      this->ImageTexture3D ().push_back (r);
      continue;
    }

    // Inline
    //
    if (n.name () == "Inline" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Inline_type > r (
        Inline_traits::create (i, f, this));

      this->Inline ().push_back (r);
      continue;
    }

    // MovieTexture
    //
    if (n.name () == "MovieTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MovieTexture_type > r (
        MovieTexture_traits::create (i, f, this));

      this->MovieTexture ().push_back (r);
      continue;
    }

    // PackagedShader
    //
    if (n.name () == "PackagedShader" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PackagedShader_type > r (
        PackagedShader_traits::create (i, f, this));

      this->PackagedShader ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    // Script
    //
    if (n.name () == "Script" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Script_type > r (
        Script_traits::create (i, f, this));

      this->Script ().push_back (r);
      continue;
    }

    // ShaderPart
    //
    if (n.name () == "ShaderPart" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ShaderPart_type > r (
        ShaderPart_traits::create (i, f, this));

      this->ShaderPart ().push_back (r);
      continue;
    }

    // ShaderProgram
    //
    if (n.name () == "ShaderProgram" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ShaderProgram_type > r (
        ShaderProgram_traits::create (i, f, this));

      this->ShaderProgram ().push_back (r);
      continue;
    }

    break;
  }
}

X3DNetworkSensorNode* X3DNetworkSensorNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DNetworkSensorNode (*this, f, c);
}

X3DNetworkSensorNode::
~X3DNetworkSensorNode ()
{
}

// X3DNormalNode
//

const X3DNormalNode::containerField_type X3DNormalNode::containerField_default_value_ (
  ::std::string ("normal"), 0, 0, 0);

X3DNormalNode::
X3DNormalNode ()
: ::X3DGeometricPropertyNode (),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

X3DNormalNode::
X3DNormalNode (const X3DNormalNode& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DGeometricPropertyNode (x, f, c),
  containerField_ (x.containerField_, f, this)
{
}

X3DNormalNode::
X3DNormalNode (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DGeometricPropertyNode (e, f | ::xml_schema::flags::base, c),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DNormalNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometricPropertyNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("normal"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

X3DNormalNode* X3DNormalNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DNormalNode (*this, f, c);
}

X3DNormalNode::
~X3DNormalNode ()
{
}

// X3DNurbsControlCurveNode
//

X3DNurbsControlCurveNode::
X3DNurbsControlCurveNode ()
: ::X3DGeometryNode (),
  controlPoint_ (::xml_schema::flags (), this)
{
}

X3DNurbsControlCurveNode::
X3DNurbsControlCurveNode (const X3DNurbsControlCurveNode& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  controlPoint_ (x.controlPoint_, f, this)
{
}

X3DNurbsControlCurveNode::
X3DNurbsControlCurveNode (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  controlPoint_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DNurbsControlCurveNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "controlPoint" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< controlPoint_type > r (
        controlPoint_traits::create (i, f, this));

      this->controlPoint (r);
      continue;
    }
  }
}

X3DNurbsControlCurveNode* X3DNurbsControlCurveNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DNurbsControlCurveNode (*this, f, c);
}

X3DNurbsControlCurveNode::
~X3DNurbsControlCurveNode ()
{
}

// X3DParametricGeometryNode
//

X3DParametricGeometryNode::
X3DParametricGeometryNode ()
: ::X3DGeometryNode ()
{
}

X3DParametricGeometryNode::
X3DParametricGeometryNode (const X3DParametricGeometryNode& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c)
{
}

X3DParametricGeometryNode::
X3DParametricGeometryNode (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::X3DGeometryNode (e, f, c)
{
}

X3DParametricGeometryNode* X3DParametricGeometryNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DParametricGeometryNode (*this, f, c);
}

X3DParametricGeometryNode::
~X3DParametricGeometryNode ()
{
}

// X3DNurbsSurfaceGeometryNode
//

const X3DNurbsSurfaceGeometryNode::uClosed_type X3DNurbsSurfaceGeometryNode::uClosed_default_value_ (
  ::std::string ("false"), 0, 0, 0);

const X3DNurbsSurfaceGeometryNode::vClosed_type X3DNurbsSurfaceGeometryNode::vClosed_default_value_ (
  ::std::string ("false"), 0, 0, 0);

const X3DNurbsSurfaceGeometryNode::uDimension_type X3DNurbsSurfaceGeometryNode::uDimension_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const X3DNurbsSurfaceGeometryNode::vDimension_type X3DNurbsSurfaceGeometryNode::vDimension_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const X3DNurbsSurfaceGeometryNode::uOrder_type X3DNurbsSurfaceGeometryNode::uOrder_default_value_ (
  ::std::string ("3"), 0, 0, 0);

const X3DNurbsSurfaceGeometryNode::vOrder_type X3DNurbsSurfaceGeometryNode::vOrder_default_value_ (
  ::std::string ("3"), 0, 0, 0);

const X3DNurbsSurfaceGeometryNode::uTessellation_type X3DNurbsSurfaceGeometryNode::uTessellation_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const X3DNurbsSurfaceGeometryNode::vTessellation_type X3DNurbsSurfaceGeometryNode::vTessellation_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const X3DNurbsSurfaceGeometryNode::solid_type X3DNurbsSurfaceGeometryNode::solid_default_value_ (
  ::std::string ("true"), 0, 0, 0);

X3DNurbsSurfaceGeometryNode::
X3DNurbsSurfaceGeometryNode ()
: ::X3DParametricGeometryNode (),
  uClosed_ (uClosed_default_value (), ::xml_schema::flags (), this),
  vClosed_ (vClosed_default_value (), ::xml_schema::flags (), this),
  uDimension_ (uDimension_default_value (), ::xml_schema::flags (), this),
  vDimension_ (vDimension_default_value (), ::xml_schema::flags (), this),
  uKnot_ (::xml_schema::flags (), this),
  vKnot_ (::xml_schema::flags (), this),
  uOrder_ (uOrder_default_value (), ::xml_schema::flags (), this),
  vOrder_ (vOrder_default_value (), ::xml_schema::flags (), this),
  uTessellation_ (uTessellation_default_value (), ::xml_schema::flags (), this),
  vTessellation_ (vTessellation_default_value (), ::xml_schema::flags (), this),
  weight_ (::xml_schema::flags (), this),
  solid_ (solid_default_value (), ::xml_schema::flags (), this)
{
}

X3DNurbsSurfaceGeometryNode::
X3DNurbsSurfaceGeometryNode (const X3DNurbsSurfaceGeometryNode& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::X3DParametricGeometryNode (x, f, c),
  uClosed_ (x.uClosed_, f, this),
  vClosed_ (x.vClosed_, f, this),
  uDimension_ (x.uDimension_, f, this),
  vDimension_ (x.vDimension_, f, this),
  uKnot_ (x.uKnot_, f, this),
  vKnot_ (x.vKnot_, f, this),
  uOrder_ (x.uOrder_, f, this),
  vOrder_ (x.vOrder_, f, this),
  uTessellation_ (x.uTessellation_, f, this),
  vTessellation_ (x.vTessellation_, f, this),
  weight_ (x.weight_, f, this),
  solid_ (x.solid_, f, this)
{
}

X3DNurbsSurfaceGeometryNode::
X3DNurbsSurfaceGeometryNode (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::X3DParametricGeometryNode (e, f | ::xml_schema::flags::base, c),
  uClosed_ (f, this),
  vClosed_ (f, this),
  uDimension_ (f, this),
  vDimension_ (f, this),
  uKnot_ (f, this),
  vKnot_ (f, this),
  uOrder_ (f, this),
  vOrder_ (f, this),
  uTessellation_ (f, this),
  vTessellation_ (f, this),
  weight_ (f, this),
  solid_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DNurbsSurfaceGeometryNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DParametricGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "uClosed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< uClosed_type > r (
        uClosed_traits::create (i, f, this));

      this->uClosed (r);
      continue;
    }

    if (n.name () == "vClosed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vClosed_type > r (
        vClosed_traits::create (i, f, this));

      this->vClosed (r);
      continue;
    }

    if (n.name () == "uDimension" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< uDimension_type > r (
        uDimension_traits::create (i, f, this));

      this->uDimension (r);
      continue;
    }

    if (n.name () == "vDimension" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vDimension_type > r (
        vDimension_traits::create (i, f, this));

      this->vDimension (r);
      continue;
    }

    if (n.name () == "uKnot" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< uKnot_type > r (
        uKnot_traits::create (i, f, this));

      this->uKnot (r);
      continue;
    }

    if (n.name () == "vKnot" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vKnot_type > r (
        vKnot_traits::create (i, f, this));

      this->vKnot (r);
      continue;
    }

    if (n.name () == "uOrder" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< uOrder_type > r (
        uOrder_traits::create (i, f, this));

      this->uOrder (r);
      continue;
    }

    if (n.name () == "vOrder" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vOrder_type > r (
        vOrder_traits::create (i, f, this));

      this->vOrder (r);
      continue;
    }

    if (n.name () == "uTessellation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< uTessellation_type > r (
        uTessellation_traits::create (i, f, this));

      this->uTessellation (r);
      continue;
    }

    if (n.name () == "vTessellation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vTessellation_type > r (
        vTessellation_traits::create (i, f, this));

      this->vTessellation (r);
      continue;
    }

    if (n.name () == "weight" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< weight_type > r (
        weight_traits::create (i, f, this));

      this->weight (r);
      continue;
    }

    if (n.name () == "solid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< solid_type > r (
        solid_traits::create (i, f, this));

      this->solid (r);
      continue;
    }
  }

  if (!uClosed_.present ())
  {
    ::std::auto_ptr< uClosed_type > r (
      uClosed_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->uClosed (r);
  }

  if (!vClosed_.present ())
  {
    ::std::auto_ptr< vClosed_type > r (
      vClosed_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->vClosed (r);
  }

  if (!uDimension_.present ())
  {
    ::std::auto_ptr< uDimension_type > r (
      uDimension_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->uDimension (r);
  }

  if (!vDimension_.present ())
  {
    ::std::auto_ptr< vDimension_type > r (
      vDimension_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->vDimension (r);
  }

  if (!uOrder_.present ())
  {
    ::std::auto_ptr< uOrder_type > r (
      uOrder_traits::create (
        ::std::string ("3"),
        &p.element (), f, this));

    this->uOrder (r);
  }

  if (!vOrder_.present ())
  {
    ::std::auto_ptr< vOrder_type > r (
      vOrder_traits::create (
        ::std::string ("3"),
        &p.element (), f, this));

    this->vOrder (r);
  }

  if (!uTessellation_.present ())
  {
    ::std::auto_ptr< uTessellation_type > r (
      uTessellation_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->uTessellation (r);
  }

  if (!vTessellation_.present ())
  {
    ::std::auto_ptr< vTessellation_type > r (
      vTessellation_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->vTessellation (r);
  }

  if (!solid_.present ())
  {
    ::std::auto_ptr< solid_type > r (
      solid_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->solid (r);
  }
}

X3DNurbsSurfaceGeometryNode* X3DNurbsSurfaceGeometryNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DNurbsSurfaceGeometryNode (*this, f, c);
}

X3DNurbsSurfaceGeometryNode::
~X3DNurbsSurfaceGeometryNode ()
{
}

// X3DProductStructureChildNode
//

X3DProductStructureChildNode::
X3DProductStructureChildNode ()
: ::X3DChildNode ()
{
}

X3DProductStructureChildNode::
X3DProductStructureChildNode (const X3DProductStructureChildNode& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::X3DChildNode (x, f, c)
{
}

X3DProductStructureChildNode::
X3DProductStructureChildNode (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::X3DChildNode (e, f, c)
{
}

X3DProductStructureChildNode* X3DProductStructureChildNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DProductStructureChildNode (*this, f, c);
}

X3DProductStructureChildNode::
~X3DProductStructureChildNode ()
{
}

// X3DProgrammableShaderObject
//

X3DProgrammableShaderObject::
X3DProgrammableShaderObject ()
: ::xml_schema::type ()
{
}

X3DProgrammableShaderObject::
X3DProgrammableShaderObject (const X3DProgrammableShaderObject& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c)
{
}

X3DProgrammableShaderObject::
X3DProgrammableShaderObject (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (e, f, c)
{
}

X3DProgrammableShaderObject::
X3DProgrammableShaderObject (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (a, f, c)
{
}

X3DProgrammableShaderObject::
X3DProgrammableShaderObject (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (s, e, f, c)
{
}

X3DProgrammableShaderObject* X3DProgrammableShaderObject::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DProgrammableShaderObject (*this, f, c);
}

X3DProgrammableShaderObject::
~X3DProgrammableShaderObject ()
{
}

// X3DPrototypeInstanceNode
//

X3DPrototypeInstanceNode::
X3DPrototypeInstanceNode ()
: ::X3DNode ()
{
}

X3DPrototypeInstanceNode::
X3DPrototypeInstanceNode (const X3DPrototypeInstanceNode& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::X3DNode (x, f, c)
{
}

X3DPrototypeInstanceNode::
X3DPrototypeInstanceNode (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::X3DNode (e, f, c)
{
}

X3DPrototypeInstanceNode* X3DPrototypeInstanceNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DPrototypeInstanceNode (*this, f, c);
}

X3DPrototypeInstanceNode::
~X3DPrototypeInstanceNode ()
{
}

// X3DScriptNode
//

const X3DScriptNode::containerField_type X3DScriptNode::containerField_default_value_ (
  ::std::string ("children"), 0, 0, 0);

X3DScriptNode::
X3DScriptNode ()
: ::xml_schema::type (),
  MetadataDouble_ (::xml_schema::flags (), this),
  MetadataFloat_ (::xml_schema::flags (), this),
  MetadataInteger_ (::xml_schema::flags (), this),
  MetadataSet_ (::xml_schema::flags (), this),
  MetadataString_ (::xml_schema::flags (), this),
  field_ (::xml_schema::flags (), this),
  IS_ (::xml_schema::flags (), this),
  DEF_ (::xml_schema::flags (), this),
  USE_ (::xml_schema::flags (), this),
  class__ (::xml_schema::flags (), this),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

X3DScriptNode::
X3DScriptNode (const X3DScriptNode& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  MetadataDouble_ (x.MetadataDouble_, f, this),
  MetadataFloat_ (x.MetadataFloat_, f, this),
  MetadataInteger_ (x.MetadataInteger_, f, this),
  MetadataSet_ (x.MetadataSet_, f, this),
  MetadataString_ (x.MetadataString_, f, this),
  field_ (x.field_, f, this),
  IS_ (x.IS_, f, this),
  DEF_ (x.DEF_, f, this),
  USE_ (x.USE_, f, this),
  class__ (x.class__, f, this),
  containerField_ (x.containerField_, f, this)
{
}

X3DScriptNode::
X3DScriptNode (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  MetadataDouble_ (f, this),
  MetadataFloat_ (f, this),
  MetadataInteger_ (f, this),
  MetadataSet_ (f, this),
  MetadataString_ (f, this),
  field_ (f, this),
  IS_ (f, this),
  DEF_ (f, this),
  USE_ (f, this),
  class__ (f, this),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DScriptNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // MetadataDouble
    //
    if (n.name () == "MetadataDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataDouble_type > r (
        MetadataDouble_traits::create (i, f, this));

      if (!this->MetadataDouble ())
      {
        this->MetadataDouble (r);
        continue;
      }
    }

    // MetadataFloat
    //
    if (n.name () == "MetadataFloat" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataFloat_type > r (
        MetadataFloat_traits::create (i, f, this));

      if (!this->MetadataFloat ())
      {
        this->MetadataFloat (r);
        continue;
      }
    }

    // MetadataInteger
    //
    if (n.name () == "MetadataInteger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataInteger_type > r (
        MetadataInteger_traits::create (i, f, this));

      if (!this->MetadataInteger ())
      {
        this->MetadataInteger (r);
        continue;
      }
    }

    // MetadataSet
    //
    if (n.name () == "MetadataSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataSet_type > r (
        MetadataSet_traits::create (i, f, this));

      if (!this->MetadataSet ())
      {
        this->MetadataSet (r);
        continue;
      }
    }

    // MetadataString
    //
    if (n.name () == "MetadataString" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataString_type > r (
        MetadataString_traits::create (i, f, this));

      if (!this->MetadataString ())
      {
        this->MetadataString (r);
        continue;
      }
    }

    // field
    //
    if (n.name () == "field" && n.namespace_ () == "")
    {
      ::std::auto_ptr< field_type > r (
        field_traits::create (i, f, this));

      this->field ().push_back (r);
      continue;
    }

    // IS
    //
    if (n.name () == "IS" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IS_type > r (
        IS_traits::create (i, f, this));

      if (!this->IS ())
      {
        this->IS (r);
        continue;
      }
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "DEF" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DEF_type > r (
        DEF_traits::create (i, f, this));

      this->DEF (r);
      continue;
    }

    if (n.name () == "USE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< USE_type > r (
        USE_traits::create (i, f, this));

      this->USE (r);
      continue;
    }

    if (n.name () == "class" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< class_type > r (
        class_traits::create (i, f, this));

      this->class_ (r);
      continue;
    }

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("children"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

X3DScriptNode* X3DScriptNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DScriptNode (*this, f, c);
}

X3DScriptNode::
~X3DScriptNode ()
{
}

// X3DSequencerNode
//

X3DSequencerNode::
X3DSequencerNode ()
: ::X3DChildNode (),
  key_ (::xml_schema::flags (), this)
{
}

X3DSequencerNode::
X3DSequencerNode (const X3DSequencerNode& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DChildNode (x, f, c),
  key_ (x.key_, f, this)
{
}

X3DSequencerNode::
X3DSequencerNode (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DChildNode (e, f | ::xml_schema::flags::base, c),
  key_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DSequencerNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DChildNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "key" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< key_type > r (
        key_traits::create (i, f, this));

      this->key (r);
      continue;
    }
  }
}

X3DSequencerNode* X3DSequencerNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DSequencerNode (*this, f, c);
}

X3DSequencerNode::
~X3DSequencerNode ()
{
}

// X3DShaderNode
//

const X3DShaderNode::containerField_type X3DShaderNode::containerField_default_value_ (
  ::std::string ("shaders"), 0, 0, 0);

X3DShaderNode::
X3DShaderNode ()
: ::X3DAppearanceChildNode (),
  language_ (::xml_schema::flags (), this),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

X3DShaderNode::
X3DShaderNode (const X3DShaderNode& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DAppearanceChildNode (x, f, c),
  language_ (x.language_, f, this),
  containerField_ (x.containerField_, f, this)
{
}

X3DShaderNode::
X3DShaderNode (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DAppearanceChildNode (e, f | ::xml_schema::flags::base, c),
  language_ (f, this),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DShaderNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DAppearanceChildNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "language" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< language_type > r (
        language_traits::create (i, f, this));

      this->language (r);
      continue;
    }

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("shaders"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

X3DShaderNode* X3DShaderNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DShaderNode (*this, f, c);
}

X3DShaderNode::
~X3DShaderNode ()
{
}

// X3DShapeNode
//

const X3DShapeNode::bboxCenter_type X3DShapeNode::bboxCenter_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const X3DShapeNode::bboxSize_type X3DShapeNode::bboxSize_default_value_ (
  ::std::string ("-1 -1 -1"), 0, 0, 0);

X3DShapeNode::
X3DShapeNode ()
: ::X3DChildNode (),
  Appearance_ (::xml_schema::flags (), this),
  Box_ (::xml_schema::flags (), this),
  Cone_ (::xml_schema::flags (), this),
  Cylinder_ (::xml_schema::flags (), this),
  IndexedFaceSet_ (::xml_schema::flags (), this),
  IndexedLineSet_ (::xml_schema::flags (), this),
  IndexedTriangleFanSet_ (::xml_schema::flags (), this),
  IndexedTriangleSet_ (::xml_schema::flags (), this),
  IndexedTriangleStripSet_ (::xml_schema::flags (), this),
  LineSet_ (::xml_schema::flags (), this),
  PointSet_ (::xml_schema::flags (), this),
  Sphere_ (::xml_schema::flags (), this),
  TriangleFanSet_ (::xml_schema::flags (), this),
  TriangleSet_ (::xml_schema::flags (), this),
  TriangleStripSet_ (::xml_schema::flags (), this),
  ElevationGrid_ (::xml_schema::flags (), this),
  Polyline2D_ (::xml_schema::flags (), this),
  Polypoint2D_ (::xml_schema::flags (), this),
  Rectangle2D_ (::xml_schema::flags (), this),
  TriangleSet2D_ (::xml_schema::flags (), this),
  Extrusion_ (::xml_schema::flags (), this),
  Text_ (::xml_schema::flags (), this),
  Arc2D_ (::xml_schema::flags (), this),
  ArcClose2D_ (::xml_schema::flags (), this),
  Circle2D_ (::xml_schema::flags (), this),
  Disk2D_ (::xml_schema::flags (), this),
  QuadSet_ (::xml_schema::flags (), this),
  IndexedQuadSet_ (::xml_schema::flags (), this),
  GeoElevationGrid_ (::xml_schema::flags (), this),
  NurbsCurve_ (::xml_schema::flags (), this),
  NurbsCurve2D_ (::xml_schema::flags (), this),
  NurbsPatchSurface_ (::xml_schema::flags (), this),
  NurbsSweptSurface_ (::xml_schema::flags (), this),
  NurbsSwungSurface_ (::xml_schema::flags (), this),
  NurbsTrimmedSurface_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  bboxCenter_ (bboxCenter_default_value (), ::xml_schema::flags (), this),
  bboxSize_ (bboxSize_default_value (), ::xml_schema::flags (), this)
{
}

X3DShapeNode::
X3DShapeNode (const X3DShapeNode& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DChildNode (x, f, c),
  Appearance_ (x.Appearance_, f, this),
  Box_ (x.Box_, f, this),
  Cone_ (x.Cone_, f, this),
  Cylinder_ (x.Cylinder_, f, this),
  IndexedFaceSet_ (x.IndexedFaceSet_, f, this),
  IndexedLineSet_ (x.IndexedLineSet_, f, this),
  IndexedTriangleFanSet_ (x.IndexedTriangleFanSet_, f, this),
  IndexedTriangleSet_ (x.IndexedTriangleSet_, f, this),
  IndexedTriangleStripSet_ (x.IndexedTriangleStripSet_, f, this),
  LineSet_ (x.LineSet_, f, this),
  PointSet_ (x.PointSet_, f, this),
  Sphere_ (x.Sphere_, f, this),
  TriangleFanSet_ (x.TriangleFanSet_, f, this),
  TriangleSet_ (x.TriangleSet_, f, this),
  TriangleStripSet_ (x.TriangleStripSet_, f, this),
  ElevationGrid_ (x.ElevationGrid_, f, this),
  Polyline2D_ (x.Polyline2D_, f, this),
  Polypoint2D_ (x.Polypoint2D_, f, this),
  Rectangle2D_ (x.Rectangle2D_, f, this),
  TriangleSet2D_ (x.TriangleSet2D_, f, this),
  Extrusion_ (x.Extrusion_, f, this),
  Text_ (x.Text_, f, this),
  Arc2D_ (x.Arc2D_, f, this),
  ArcClose2D_ (x.ArcClose2D_, f, this),
  Circle2D_ (x.Circle2D_, f, this),
  Disk2D_ (x.Disk2D_, f, this),
  QuadSet_ (x.QuadSet_, f, this),
  IndexedQuadSet_ (x.IndexedQuadSet_, f, this),
  GeoElevationGrid_ (x.GeoElevationGrid_, f, this),
  NurbsCurve_ (x.NurbsCurve_, f, this),
  NurbsCurve2D_ (x.NurbsCurve2D_, f, this),
  NurbsPatchSurface_ (x.NurbsPatchSurface_, f, this),
  NurbsSweptSurface_ (x.NurbsSweptSurface_, f, this),
  NurbsSwungSurface_ (x.NurbsSwungSurface_, f, this),
  NurbsTrimmedSurface_ (x.NurbsTrimmedSurface_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  bboxCenter_ (x.bboxCenter_, f, this),
  bboxSize_ (x.bboxSize_, f, this)
{
}

X3DShapeNode::
X3DShapeNode (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DChildNode (e, f | ::xml_schema::flags::base, c),
  Appearance_ (f, this),
  Box_ (f, this),
  Cone_ (f, this),
  Cylinder_ (f, this),
  IndexedFaceSet_ (f, this),
  IndexedLineSet_ (f, this),
  IndexedTriangleFanSet_ (f, this),
  IndexedTriangleSet_ (f, this),
  IndexedTriangleStripSet_ (f, this),
  LineSet_ (f, this),
  PointSet_ (f, this),
  Sphere_ (f, this),
  TriangleFanSet_ (f, this),
  TriangleSet_ (f, this),
  TriangleStripSet_ (f, this),
  ElevationGrid_ (f, this),
  Polyline2D_ (f, this),
  Polypoint2D_ (f, this),
  Rectangle2D_ (f, this),
  TriangleSet2D_ (f, this),
  Extrusion_ (f, this),
  Text_ (f, this),
  Arc2D_ (f, this),
  ArcClose2D_ (f, this),
  Circle2D_ (f, this),
  Disk2D_ (f, this),
  QuadSet_ (f, this),
  IndexedQuadSet_ (f, this),
  GeoElevationGrid_ (f, this),
  NurbsCurve_ (f, this),
  NurbsCurve2D_ (f, this),
  NurbsPatchSurface_ (f, this),
  NurbsSweptSurface_ (f, this),
  NurbsSwungSurface_ (f, this),
  NurbsTrimmedSurface_ (f, this),
  ProtoInstance_ (f, this),
  bboxCenter_ (f, this),
  bboxSize_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DShapeNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DChildNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Appearance
    //
    if (n.name () == "Appearance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Appearance_type > r (
        Appearance_traits::create (i, f, this));

      if (!this->Appearance ())
      {
        this->Appearance (r);
        continue;
      }
    }

    // Box
    //
    if (n.name () == "Box" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Box_type > r (
        Box_traits::create (i, f, this));

      if (!this->Box ())
      {
        this->Box (r);
        continue;
      }
    }

    // Cone
    //
    if (n.name () == "Cone" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Cone_type > r (
        Cone_traits::create (i, f, this));

      if (!this->Cone ())
      {
        this->Cone (r);
        continue;
      }
    }

    // Cylinder
    //
    if (n.name () == "Cylinder" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Cylinder_type > r (
        Cylinder_traits::create (i, f, this));

      if (!this->Cylinder ())
      {
        this->Cylinder (r);
        continue;
      }
    }

    // IndexedFaceSet
    //
    if (n.name () == "IndexedFaceSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedFaceSet_type > r (
        IndexedFaceSet_traits::create (i, f, this));

      if (!this->IndexedFaceSet ())
      {
        this->IndexedFaceSet (r);
        continue;
      }
    }

    // IndexedLineSet
    //
    if (n.name () == "IndexedLineSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedLineSet_type > r (
        IndexedLineSet_traits::create (i, f, this));

      if (!this->IndexedLineSet ())
      {
        this->IndexedLineSet (r);
        continue;
      }
    }

    // IndexedTriangleFanSet
    //
    if (n.name () == "IndexedTriangleFanSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedTriangleFanSet_type > r (
        IndexedTriangleFanSet_traits::create (i, f, this));

      if (!this->IndexedTriangleFanSet ())
      {
        this->IndexedTriangleFanSet (r);
        continue;
      }
    }

    // IndexedTriangleSet
    //
    if (n.name () == "IndexedTriangleSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedTriangleSet_type > r (
        IndexedTriangleSet_traits::create (i, f, this));

      if (!this->IndexedTriangleSet ())
      {
        this->IndexedTriangleSet (r);
        continue;
      }
    }

    // IndexedTriangleStripSet
    //
    if (n.name () == "IndexedTriangleStripSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedTriangleStripSet_type > r (
        IndexedTriangleStripSet_traits::create (i, f, this));

      if (!this->IndexedTriangleStripSet ())
      {
        this->IndexedTriangleStripSet (r);
        continue;
      }
    }

    // LineSet
    //
    if (n.name () == "LineSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LineSet_type > r (
        LineSet_traits::create (i, f, this));

      if (!this->LineSet ())
      {
        this->LineSet (r);
        continue;
      }
    }

    // PointSet
    //
    if (n.name () == "PointSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PointSet_type > r (
        PointSet_traits::create (i, f, this));

      if (!this->PointSet ())
      {
        this->PointSet (r);
        continue;
      }
    }

    // Sphere
    //
    if (n.name () == "Sphere" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Sphere_type > r (
        Sphere_traits::create (i, f, this));

      if (!this->Sphere ())
      {
        this->Sphere (r);
        continue;
      }
    }

    // TriangleFanSet
    //
    if (n.name () == "TriangleFanSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TriangleFanSet_type > r (
        TriangleFanSet_traits::create (i, f, this));

      if (!this->TriangleFanSet ())
      {
        this->TriangleFanSet (r);
        continue;
      }
    }

    // TriangleSet
    //
    if (n.name () == "TriangleSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TriangleSet_type > r (
        TriangleSet_traits::create (i, f, this));

      if (!this->TriangleSet ())
      {
        this->TriangleSet (r);
        continue;
      }
    }

    // TriangleStripSet
    //
    if (n.name () == "TriangleStripSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TriangleStripSet_type > r (
        TriangleStripSet_traits::create (i, f, this));

      if (!this->TriangleStripSet ())
      {
        this->TriangleStripSet (r);
        continue;
      }
    }

    // ElevationGrid
    //
    if (n.name () == "ElevationGrid" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ElevationGrid_type > r (
        ElevationGrid_traits::create (i, f, this));

      if (!this->ElevationGrid ())
      {
        this->ElevationGrid (r);
        continue;
      }
    }

    // Polyline2D
    //
    if (n.name () == "Polyline2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Polyline2D_type > r (
        Polyline2D_traits::create (i, f, this));

      if (!this->Polyline2D ())
      {
        this->Polyline2D (r);
        continue;
      }
    }

    // Polypoint2D
    //
    if (n.name () == "Polypoint2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Polypoint2D_type > r (
        Polypoint2D_traits::create (i, f, this));

      if (!this->Polypoint2D ())
      {
        this->Polypoint2D (r);
        continue;
      }
    }

    // Rectangle2D
    //
    if (n.name () == "Rectangle2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Rectangle2D_type > r (
        Rectangle2D_traits::create (i, f, this));

      if (!this->Rectangle2D ())
      {
        this->Rectangle2D (r);
        continue;
      }
    }

    // TriangleSet2D
    //
    if (n.name () == "TriangleSet2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TriangleSet2D_type > r (
        TriangleSet2D_traits::create (i, f, this));

      if (!this->TriangleSet2D ())
      {
        this->TriangleSet2D (r);
        continue;
      }
    }

    // Extrusion
    //
    if (n.name () == "Extrusion" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Extrusion_type > r (
        Extrusion_traits::create (i, f, this));

      if (!this->Extrusion ())
      {
        this->Extrusion (r);
        continue;
      }
    }

    // Text
    //
    if (n.name () == "Text" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Text_type > r (
        Text_traits::create (i, f, this));

      if (!this->Text ())
      {
        this->Text (r);
        continue;
      }
    }

    // Arc2D
    //
    if (n.name () == "Arc2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Arc2D_type > r (
        Arc2D_traits::create (i, f, this));

      if (!this->Arc2D ())
      {
        this->Arc2D (r);
        continue;
      }
    }

    // ArcClose2D
    //
    if (n.name () == "ArcClose2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ArcClose2D_type > r (
        ArcClose2D_traits::create (i, f, this));

      if (!this->ArcClose2D ())
      {
        this->ArcClose2D (r);
        continue;
      }
    }

    // Circle2D
    //
    if (n.name () == "Circle2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Circle2D_type > r (
        Circle2D_traits::create (i, f, this));

      if (!this->Circle2D ())
      {
        this->Circle2D (r);
        continue;
      }
    }

    // Disk2D
    //
    if (n.name () == "Disk2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Disk2D_type > r (
        Disk2D_traits::create (i, f, this));

      if (!this->Disk2D ())
      {
        this->Disk2D (r);
        continue;
      }
    }

    // QuadSet
    //
    if (n.name () == "QuadSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< QuadSet_type > r (
        QuadSet_traits::create (i, f, this));

      if (!this->QuadSet ())
      {
        this->QuadSet (r);
        continue;
      }
    }

    // IndexedQuadSet
    //
    if (n.name () == "IndexedQuadSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedQuadSet_type > r (
        IndexedQuadSet_traits::create (i, f, this));

      if (!this->IndexedQuadSet ())
      {
        this->IndexedQuadSet (r);
        continue;
      }
    }

    // GeoElevationGrid
    //
    if (n.name () == "GeoElevationGrid" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoElevationGrid_type > r (
        GeoElevationGrid_traits::create (i, f, this));

      if (!this->GeoElevationGrid ())
      {
        this->GeoElevationGrid (r);
        continue;
      }
    }

    // NurbsCurve
    //
    if (n.name () == "NurbsCurve" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsCurve_type > r (
        NurbsCurve_traits::create (i, f, this));

      if (!this->NurbsCurve ())
      {
        this->NurbsCurve (r);
        continue;
      }
    }

    // NurbsCurve2D
    //
    if (n.name () == "NurbsCurve2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsCurve2D_type > r (
        NurbsCurve2D_traits::create (i, f, this));

      if (!this->NurbsCurve2D ())
      {
        this->NurbsCurve2D (r);
        continue;
      }
    }

    // NurbsPatchSurface
    //
    if (n.name () == "NurbsPatchSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsPatchSurface_type > r (
        NurbsPatchSurface_traits::create (i, f, this));

      if (!this->NurbsPatchSurface ())
      {
        this->NurbsPatchSurface (r);
        continue;
      }
    }

    // NurbsSweptSurface
    //
    if (n.name () == "NurbsSweptSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSweptSurface_type > r (
        NurbsSweptSurface_traits::create (i, f, this));

      if (!this->NurbsSweptSurface ())
      {
        this->NurbsSweptSurface (r);
        continue;
      }
    }

    // NurbsSwungSurface
    //
    if (n.name () == "NurbsSwungSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSwungSurface_type > r (
        NurbsSwungSurface_traits::create (i, f, this));

      if (!this->NurbsSwungSurface ())
      {
        this->NurbsSwungSurface (r);
        continue;
      }
    }

    // NurbsTrimmedSurface
    //
    if (n.name () == "NurbsTrimmedSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsTrimmedSurface_type > r (
        NurbsTrimmedSurface_traits::create (i, f, this));

      if (!this->NurbsTrimmedSurface ())
      {
        this->NurbsTrimmedSurface (r);
        continue;
      }
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "bboxCenter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bboxCenter_type > r (
        bboxCenter_traits::create (i, f, this));

      this->bboxCenter (r);
      continue;
    }

    if (n.name () == "bboxSize" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bboxSize_type > r (
        bboxSize_traits::create (i, f, this));

      this->bboxSize (r);
      continue;
    }
  }

  if (!bboxCenter_.present ())
  {
    ::std::auto_ptr< bboxCenter_type > r (
      bboxCenter_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->bboxCenter (r);
  }

  if (!bboxSize_.present ())
  {
    ::std::auto_ptr< bboxSize_type > r (
      bboxSize_traits::create (
        ::std::string ("-1 -1 -1"),
        &p.element (), f, this));

    this->bboxSize (r);
  }
}

X3DShapeNode* X3DShapeNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DShapeNode (*this, f, c);
}

X3DShapeNode::
~X3DShapeNode ()
{
}

// X3DSoundNode
//

X3DSoundNode::
X3DSoundNode ()
: ::X3DChildNode (),
  AudioClip_ (::xml_schema::flags (), this),
  MovieTexture_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this)
{
}

X3DSoundNode::
X3DSoundNode (const X3DSoundNode& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DChildNode (x, f, c),
  AudioClip_ (x.AudioClip_, f, this),
  MovieTexture_ (x.MovieTexture_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this)
{
}

X3DSoundNode::
X3DSoundNode (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DChildNode (e, f | ::xml_schema::flags::base, c),
  AudioClip_ (f, this),
  MovieTexture_ (f, this),
  ProtoInstance_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DSoundNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DChildNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AudioClip
    //
    if (n.name () == "AudioClip" && n.namespace_ () == "")
    {
      ::std::auto_ptr< AudioClip_type > r (
        AudioClip_traits::create (i, f, this));

      if (!this->AudioClip ())
      {
        this->AudioClip (r);
        continue;
      }
    }

    // MovieTexture
    //
    if (n.name () == "MovieTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MovieTexture_type > r (
        MovieTexture_traits::create (i, f, this));

      if (!this->MovieTexture ())
      {
        this->MovieTexture (r);
        continue;
      }
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      if (!this->ProtoInstance ())
      {
        this->ProtoInstance (r);
        continue;
      }
    }

    break;
  }
}

X3DSoundNode* X3DSoundNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DSoundNode (*this, f, c);
}

X3DSoundNode::
~X3DSoundNode ()
{
}

// X3DTimeDependentNode
//

const X3DTimeDependentNode::loop_type X3DTimeDependentNode::loop_default_value_ (
  ::std::string ("false"), 0, 0, 0);

const X3DTimeDependentNode::pauseTime_type X3DTimeDependentNode::pauseTime_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const X3DTimeDependentNode::resumeTime_type X3DTimeDependentNode::resumeTime_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const X3DTimeDependentNode::startTime_type X3DTimeDependentNode::startTime_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const X3DTimeDependentNode::stopTime_type X3DTimeDependentNode::stopTime_default_value_ (
  ::std::string ("0"), 0, 0, 0);

X3DTimeDependentNode::
X3DTimeDependentNode ()
: ::X3DChildNode (),
  loop_ (loop_default_value (), ::xml_schema::flags (), this),
  pauseTime_ (pauseTime_default_value (), ::xml_schema::flags (), this),
  resumeTime_ (resumeTime_default_value (), ::xml_schema::flags (), this),
  startTime_ (startTime_default_value (), ::xml_schema::flags (), this),
  stopTime_ (stopTime_default_value (), ::xml_schema::flags (), this)
{
}

X3DTimeDependentNode::
X3DTimeDependentNode (const X3DTimeDependentNode& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::X3DChildNode (x, f, c),
  loop_ (x.loop_, f, this),
  pauseTime_ (x.pauseTime_, f, this),
  resumeTime_ (x.resumeTime_, f, this),
  startTime_ (x.startTime_, f, this),
  stopTime_ (x.stopTime_, f, this)
{
}

X3DTimeDependentNode::
X3DTimeDependentNode (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::X3DChildNode (e, f | ::xml_schema::flags::base, c),
  loop_ (f, this),
  pauseTime_ (f, this),
  resumeTime_ (f, this),
  startTime_ (f, this),
  stopTime_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DTimeDependentNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DChildNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "loop" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< loop_type > r (
        loop_traits::create (i, f, this));

      this->loop (r);
      continue;
    }

    if (n.name () == "pauseTime" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< pauseTime_type > r (
        pauseTime_traits::create (i, f, this));

      this->pauseTime (r);
      continue;
    }

    if (n.name () == "resumeTime" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< resumeTime_type > r (
        resumeTime_traits::create (i, f, this));

      this->resumeTime (r);
      continue;
    }

    if (n.name () == "startTime" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< startTime_type > r (
        startTime_traits::create (i, f, this));

      this->startTime (r);
      continue;
    }

    if (n.name () == "stopTime" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< stopTime_type > r (
        stopTime_traits::create (i, f, this));

      this->stopTime (r);
      continue;
    }
  }

  if (!loop_.present ())
  {
    ::std::auto_ptr< loop_type > r (
      loop_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->loop (r);
  }

  if (!pauseTime_.present ())
  {
    ::std::auto_ptr< pauseTime_type > r (
      pauseTime_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->pauseTime (r);
  }

  if (!resumeTime_.present ())
  {
    ::std::auto_ptr< resumeTime_type > r (
      resumeTime_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->resumeTime (r);
  }

  if (!startTime_.present ())
  {
    ::std::auto_ptr< startTime_type > r (
      startTime_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->startTime (r);
  }

  if (!stopTime_.present ())
  {
    ::std::auto_ptr< stopTime_type > r (
      stopTime_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->stopTime (r);
  }
}

X3DTimeDependentNode* X3DTimeDependentNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DTimeDependentNode (*this, f, c);
}

X3DTimeDependentNode::
~X3DTimeDependentNode ()
{
}

// X3DSoundSourceNode
//

const X3DSoundSourceNode::pitch_type X3DSoundSourceNode::pitch_default_value_ (
  ::std::string ("1.0"), 0, 0, 0);

X3DSoundSourceNode::
X3DSoundSourceNode ()
: ::X3DTimeDependentNode (),
  pitch_ (pitch_default_value (), ::xml_schema::flags (), this)
{
}

X3DSoundSourceNode::
X3DSoundSourceNode (const X3DSoundSourceNode& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::X3DTimeDependentNode (x, f, c),
  pitch_ (x.pitch_, f, this)
{
}

X3DSoundSourceNode::
X3DSoundSourceNode (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::X3DTimeDependentNode (e, f | ::xml_schema::flags::base, c),
  pitch_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DSoundSourceNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTimeDependentNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "pitch" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< pitch_type > r (
        pitch_traits::create (i, f, this));

      this->pitch (r);
      continue;
    }
  }

  if (!pitch_.present ())
  {
    ::std::auto_ptr< pitch_type > r (
      pitch_traits::create (
        ::std::string ("1.0"),
        &p.element (), f, this));

    this->pitch (r);
  }
}

X3DSoundSourceNode* X3DSoundSourceNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DSoundSourceNode (*this, f, c);
}

X3DSoundSourceNode::
~X3DSoundSourceNode ()
{
}

// X3DTextureNode
//

const X3DTextureNode::containerField_type X3DTextureNode::containerField_default_value_ (
  ::std::string ("texture"), 0, 0, 0);

X3DTextureNode::
X3DTextureNode ()
: ::X3DAppearanceChildNode (),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

X3DTextureNode::
X3DTextureNode (const X3DTextureNode& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DAppearanceChildNode (x, f, c),
  containerField_ (x.containerField_, f, this)
{
}

X3DTextureNode::
X3DTextureNode (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DAppearanceChildNode (e, f | ::xml_schema::flags::base, c),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DTextureNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DAppearanceChildNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("texture"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

X3DTextureNode* X3DTextureNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DTextureNode (*this, f, c);
}

X3DTextureNode::
~X3DTextureNode ()
{
}

// X3DTexture2DNode
//

const X3DTexture2DNode::repeatS_type X3DTexture2DNode::repeatS_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const X3DTexture2DNode::repeatT_type X3DTexture2DNode::repeatT_default_value_ (
  ::std::string ("true"), 0, 0, 0);

X3DTexture2DNode::
X3DTexture2DNode ()
: ::X3DTextureNode (),
  repeatS_ (repeatS_default_value (), ::xml_schema::flags (), this),
  repeatT_ (repeatT_default_value (), ::xml_schema::flags (), this)
{
}

X3DTexture2DNode::
X3DTexture2DNode (const X3DTexture2DNode& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DTextureNode (x, f, c),
  repeatS_ (x.repeatS_, f, this),
  repeatT_ (x.repeatT_, f, this)
{
}

X3DTexture2DNode::
X3DTexture2DNode (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DTextureNode (e, f | ::xml_schema::flags::base, c),
  repeatS_ (f, this),
  repeatT_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DTexture2DNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTextureNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "repeatS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< repeatS_type > r (
        repeatS_traits::create (i, f, this));

      this->repeatS (r);
      continue;
    }

    if (n.name () == "repeatT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< repeatT_type > r (
        repeatT_traits::create (i, f, this));

      this->repeatT (r);
      continue;
    }
  }

  if (!repeatS_.present ())
  {
    ::std::auto_ptr< repeatS_type > r (
      repeatS_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->repeatS (r);
  }

  if (!repeatT_.present ())
  {
    ::std::auto_ptr< repeatT_type > r (
      repeatT_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->repeatT (r);
  }
}

X3DTexture2DNode* X3DTexture2DNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DTexture2DNode (*this, f, c);
}

X3DTexture2DNode::
~X3DTexture2DNode ()
{
}

// X3DTexture3DNode
//

const X3DTexture3DNode::repeatS_type X3DTexture3DNode::repeatS_default_value_ (
  ::std::string ("false"), 0, 0, 0);

const X3DTexture3DNode::repeatT_type X3DTexture3DNode::repeatT_default_value_ (
  ::std::string ("false"), 0, 0, 0);

const X3DTexture3DNode::repeatR_type X3DTexture3DNode::repeatR_default_value_ (
  ::std::string ("false"), 0, 0, 0);

X3DTexture3DNode::
X3DTexture3DNode ()
: ::X3DTextureNode (),
  repeatS_ (repeatS_default_value (), ::xml_schema::flags (), this),
  repeatT_ (repeatT_default_value (), ::xml_schema::flags (), this),
  repeatR_ (repeatR_default_value (), ::xml_schema::flags (), this)
{
}

X3DTexture3DNode::
X3DTexture3DNode (const X3DTexture3DNode& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DTextureNode (x, f, c),
  repeatS_ (x.repeatS_, f, this),
  repeatT_ (x.repeatT_, f, this),
  repeatR_ (x.repeatR_, f, this)
{
}

X3DTexture3DNode::
X3DTexture3DNode (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DTextureNode (e, f | ::xml_schema::flags::base, c),
  repeatS_ (f, this),
  repeatT_ (f, this),
  repeatR_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DTexture3DNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTextureNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "repeatS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< repeatS_type > r (
        repeatS_traits::create (i, f, this));

      this->repeatS (r);
      continue;
    }

    if (n.name () == "repeatT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< repeatT_type > r (
        repeatT_traits::create (i, f, this));

      this->repeatT (r);
      continue;
    }

    if (n.name () == "repeatR" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< repeatR_type > r (
        repeatR_traits::create (i, f, this));

      this->repeatR (r);
      continue;
    }
  }

  if (!repeatS_.present ())
  {
    ::std::auto_ptr< repeatS_type > r (
      repeatS_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->repeatS (r);
  }

  if (!repeatT_.present ())
  {
    ::std::auto_ptr< repeatT_type > r (
      repeatT_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->repeatT (r);
  }

  if (!repeatR_.present ())
  {
    ::std::auto_ptr< repeatR_type > r (
      repeatR_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->repeatR (r);
  }
}

X3DTexture3DNode* X3DTexture3DNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DTexture3DNode (*this, f, c);
}

X3DTexture3DNode::
~X3DTexture3DNode ()
{
}

// X3DTextureCoordinateNode
//

const X3DTextureCoordinateNode::containerField_type X3DTextureCoordinateNode::containerField_default_value_ (
  ::std::string ("texCoord"), 0, 0, 0);

X3DTextureCoordinateNode::
X3DTextureCoordinateNode ()
: ::X3DGeometricPropertyNode (),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

X3DTextureCoordinateNode::
X3DTextureCoordinateNode (const X3DTextureCoordinateNode& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::X3DGeometricPropertyNode (x, f, c),
  containerField_ (x.containerField_, f, this)
{
}

X3DTextureCoordinateNode::
X3DTextureCoordinateNode (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::X3DGeometricPropertyNode (e, f | ::xml_schema::flags::base, c),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DTextureCoordinateNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometricPropertyNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("texCoord"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

X3DTextureCoordinateNode* X3DTextureCoordinateNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DTextureCoordinateNode (*this, f, c);
}

X3DTextureCoordinateNode::
~X3DTextureCoordinateNode ()
{
}

// X3DTextureTransformNode
//

const X3DTextureTransformNode::containerField_type X3DTextureTransformNode::containerField_default_value_ (
  ::std::string ("textureTransform"), 0, 0, 0);

X3DTextureTransformNode::
X3DTextureTransformNode ()
: ::X3DAppearanceChildNode (),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

X3DTextureTransformNode::
X3DTextureTransformNode (const X3DTextureTransformNode& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::X3DAppearanceChildNode (x, f, c),
  containerField_ (x.containerField_, f, this)
{
}

X3DTextureTransformNode::
X3DTextureTransformNode (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::X3DAppearanceChildNode (e, f | ::xml_schema::flags::base, c),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DTextureTransformNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DAppearanceChildNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("textureTransform"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

X3DTextureTransformNode* X3DTextureTransformNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DTextureTransformNode (*this, f, c);
}

X3DTextureTransformNode::
~X3DTextureTransformNode ()
{
}

// X3DTextureTransform2DNode
//

const X3DTextureTransform2DNode::center_type X3DTextureTransform2DNode::center_default_value_ (
  ::std::string ("0 0"), 0, 0, 0);

const X3DTextureTransform2DNode::rotation_type X3DTextureTransform2DNode::rotation_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const X3DTextureTransform2DNode::scale_type X3DTextureTransform2DNode::scale_default_value_ (
  ::std::string ("1 1"), 0, 0, 0);

const X3DTextureTransform2DNode::translation_type X3DTextureTransform2DNode::translation_default_value_ (
  ::std::string ("0 0"), 0, 0, 0);

X3DTextureTransform2DNode::
X3DTextureTransform2DNode ()
: ::X3DTextureTransformNode (),
  center_ (center_default_value (), ::xml_schema::flags (), this),
  rotation_ (rotation_default_value (), ::xml_schema::flags (), this),
  scale_ (scale_default_value (), ::xml_schema::flags (), this),
  translation_ (translation_default_value (), ::xml_schema::flags (), this)
{
}

X3DTextureTransform2DNode::
X3DTextureTransform2DNode (const X3DTextureTransform2DNode& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::X3DTextureTransformNode (x, f, c),
  center_ (x.center_, f, this),
  rotation_ (x.rotation_, f, this),
  scale_ (x.scale_, f, this),
  translation_ (x.translation_, f, this)
{
}

X3DTextureTransform2DNode::
X3DTextureTransform2DNode (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::X3DTextureTransformNode (e, f | ::xml_schema::flags::base, c),
  center_ (f, this),
  rotation_ (f, this),
  scale_ (f, this),
  translation_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DTextureTransform2DNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTextureTransformNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "center" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< center_type > r (
        center_traits::create (i, f, this));

      this->center (r);
      continue;
    }

    if (n.name () == "rotation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rotation_type > r (
        rotation_traits::create (i, f, this));

      this->rotation (r);
      continue;
    }

    if (n.name () == "scale" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< scale_type > r (
        scale_traits::create (i, f, this));

      this->scale (r);
      continue;
    }

    if (n.name () == "translation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< translation_type > r (
        translation_traits::create (i, f, this));

      this->translation (r);
      continue;
    }
  }

  if (!center_.present ())
  {
    ::std::auto_ptr< center_type > r (
      center_traits::create (
        ::std::string ("0 0"),
        &p.element (), f, this));

    this->center (r);
  }

  if (!rotation_.present ())
  {
    ::std::auto_ptr< rotation_type > r (
      rotation_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->rotation (r);
  }

  if (!scale_.present ())
  {
    ::std::auto_ptr< scale_type > r (
      scale_traits::create (
        ::std::string ("1 1"),
        &p.element (), f, this));

    this->scale (r);
  }

  if (!translation_.present ())
  {
    ::std::auto_ptr< translation_type > r (
      translation_traits::create (
        ::std::string ("0 0"),
        &p.element (), f, this));

    this->translation (r);
  }
}

X3DTextureTransform2DNode* X3DTextureTransform2DNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DTextureTransform2DNode (*this, f, c);
}

X3DTextureTransform2DNode::
~X3DTextureTransform2DNode ()
{
}

// X3DTouchSensorNode
//

X3DTouchSensorNode::
X3DTouchSensorNode ()
: ::X3DPointingDeviceSensorNode ()
{
}

X3DTouchSensorNode::
X3DTouchSensorNode (const X3DTouchSensorNode& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::X3DPointingDeviceSensorNode (x, f, c)
{
}

X3DTouchSensorNode::
X3DTouchSensorNode (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::X3DPointingDeviceSensorNode (e, f, c)
{
}

X3DTouchSensorNode* X3DTouchSensorNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DTouchSensorNode (*this, f, c);
}

X3DTouchSensorNode::
~X3DTouchSensorNode ()
{
}

// X3DTriggerNode
//

X3DTriggerNode::
X3DTriggerNode ()
: ::X3DChildNode ()
{
}

X3DTriggerNode::
X3DTriggerNode (const X3DTriggerNode& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DChildNode (x, f, c)
{
}

X3DTriggerNode::
X3DTriggerNode (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DChildNode (e, f, c)
{
}

X3DTriggerNode* X3DTriggerNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DTriggerNode (*this, f, c);
}

X3DTriggerNode::
~X3DTriggerNode ()
{
}

// X3DUrlObject
//

X3DUrlObject::
X3DUrlObject ()
: ::xml_schema::type (),
  url_ (::xml_schema::flags (), this)
{
}

X3DUrlObject::
X3DUrlObject (const X3DUrlObject& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  url_ (x.url_, f, this)
{
}

X3DUrlObject::
X3DUrlObject (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  url_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DUrlObject::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< url_type > r (
        url_traits::create (i, f, this));

      this->url (r);
      continue;
    }
  }
}

X3DUrlObject* X3DUrlObject::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DUrlObject (*this, f, c);
}

X3DUrlObject::
~X3DUrlObject ()
{
}

// X3DVertexAttributeNode
//

const X3DVertexAttributeNode::containerField_type X3DVertexAttributeNode::containerField_default_value_ (
  ::std::string ("attrib"), 0, 0, 0);

X3DVertexAttributeNode::
X3DVertexAttributeNode ()
: ::X3DGeometricPropertyNode (),
  name_ (::xml_schema::flags (), this),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

X3DVertexAttributeNode::
X3DVertexAttributeNode (const X3DVertexAttributeNode& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DGeometricPropertyNode (x, f, c),
  name_ (x.name_, f, this),
  containerField_ (x.containerField_, f, this)
{
}

X3DVertexAttributeNode::
X3DVertexAttributeNode (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DGeometricPropertyNode (e, f | ::xml_schema::flags::base, c),
  name_ (f, this),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DVertexAttributeNode::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometricPropertyNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name (r);
      continue;
    }

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("attrib"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

X3DVertexAttributeNode* X3DVertexAttributeNode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DVertexAttributeNode (*this, f, c);
}

X3DVertexAttributeNode::
~X3DVertexAttributeNode ()
{
}

// SceneGraphStructureNodeType
//

SceneGraphStructureNodeType::
SceneGraphStructureNodeType ()
: ::xml_schema::type ()
{
}

SceneGraphStructureNodeType::
SceneGraphStructureNodeType (const SceneGraphStructureNodeType& x,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c)
{
}

SceneGraphStructureNodeType::
SceneGraphStructureNodeType (const ::xercesc::DOMElement& e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (e, f, c)
{
}

SceneGraphStructureNodeType::
SceneGraphStructureNodeType (const ::xercesc::DOMAttr& a,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (a, f, c)
{
}

SceneGraphStructureNodeType::
SceneGraphStructureNodeType (const ::std::string& s,
                             const ::xercesc::DOMElement* e,
                             ::xml_schema::flags f,
                             ::xml_schema::container* c)
: ::xml_schema::type (s, e, f, c)
{
}

SceneGraphStructureNodeType* SceneGraphStructureNodeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SceneGraphStructureNodeType (*this, f, c);
}

SceneGraphStructureNodeType::
~SceneGraphStructureNodeType ()
{
}

// X3DPrototype
//

X3DPrototype::
X3DPrototype (const name_type& name)
: ::SceneGraphStructureNodeType (),
  name_ (name, ::xml_schema::flags (), this)
{
}

X3DPrototype::
X3DPrototype (const X3DPrototype& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (x, f, c),
  name_ (x.name_, f, this)
{
}

X3DPrototype::
X3DPrototype (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (e, f | ::xml_schema::flags::base, c),
  name_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3DPrototype::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name (r);
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

X3DPrototype* X3DPrototype::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3DPrototype (*this, f, c);
}

X3DPrototype::
~X3DPrototype ()
{
}

// WildcardNodeType
//

WildcardNodeType::
WildcardNodeType ()
: ::X3DNode ()
{
}

WildcardNodeType::
WildcardNodeType (const WildcardNodeType& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DNode (x, f, c)
{
}

WildcardNodeType::
WildcardNodeType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DNode (e, f, c)
{
}

WildcardNodeType* WildcardNodeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new WildcardNodeType (*this, f, c);
}

WildcardNodeType::
~WildcardNodeType ()
{
}

// geoSystemType
//

geoSystemType::
geoSystemType ()
: ::SFString ()
{
}

geoSystemType::
geoSystemType (const char* string)
: ::SFString (string)
{
}

geoSystemType::
geoSystemType (const ::std::string& string)
: ::SFString (string)
{
}

geoSystemType::
geoSystemType (const ::xml_schema::string& string)
: ::SFString (string)
{
}

geoSystemType::
geoSystemType (const geoSystemType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::SFString (x, f, c)
{
}

geoSystemType::
geoSystemType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::SFString (e, f, c)
{
}

geoSystemType::
geoSystemType (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::SFString (a, f, c)
{
}

geoSystemType::
geoSystemType (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::SFString (s, e, f, c)
{
}

geoSystemType* geoSystemType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new geoSystemType (*this, f, c);
}

geoSystemType::
~geoSystemType ()
{
}

// jointName
//

jointName::
jointName (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_jointName_convert ();
}

jointName::
jointName (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_jointName_convert ();
}

jointName::
jointName (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_jointName_convert ();
}

jointName* jointName::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new jointName (*this, f, c);
}

jointName::value jointName::
_xsd_jointName_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_jointName_literals_);
  const value* i (::std::lower_bound (
                    _xsd_jointName_indexes_,
                    _xsd_jointName_indexes_ + 188,
                    *this,
                    c));

  if (i == _xsd_jointName_indexes_ + 188 || _xsd_jointName_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const jointName::
_xsd_jointName_literals_[188] =
{
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "HumanoidRoot",
  "jaw",
  "l_acromioclavicular",
  "l_ankle",
  "l_calf",
  "l_clavicle",
  "l_elbow",
  "l_eyeball",
  "l_eyeball_joint",
  "l_eyebrow",
  "l_eyebrow_joint",
  "l_eyelid",
  "l_eyelid_joint",
  "l_forearm",
  "l_forefoot",
  "l_hand",
  "l_hindfoot",
  "l_hip",
  "l_index_distal",
  "l_index_metacarpal",
  "l_index_middle",
  "l_index_proximal",
  "l_index0",
  "l_index1",
  "l_index2",
  "l_index3",
  "l_knee",
  "l_metatarsal",
  "l_middistal",
  "l_middle_distal",
  "l_middle_metacarpal",
  "l_middle_middle",
  "l_middle_proximal",
  "l_middle0",
  "l_middle1",
  "l_middle2",
  "l_middle3",
  "l_midproximal",
  "l_midtarsal",
  "l_pinky_distal",
  "l_pinky_metacarpal",
  "l_pinky_middle",
  "l_pinky_proximal",
  "l_pinky0",
  "l_pinky1",
  "l_pinky2",
  "l_pinky3",
  "l_ring_distal",
  "l_ring_metacarpal",
  "l_ring_middle",
  "l_ring_proximal",
  "l_ring0",
  "l_ring1",
  "l_ring2",
  "l_ring3",
  "l_scapula",
  "l_shoulder",
  "l_sternoclavicular",
  "l_subtalar",
  "l_thigh",
  "l_thumb_distal",
  "l_thumb_metacarpal",
  "l_thumb_proximal",
  "l_thumb1",
  "l_thumb2",
  "l_thumb3",
  "l_upperarm",
  "l_wrist",
  "l1",
  "l2",
  "l3",
  "l4",
  "l5",
  "pelvis",
  "r_acromioclavicular",
  "r_ankle",
  "r_calf",
  "r_clavicle",
  "r_elbow",
  "r_eyeball",
  "r_eyeball_joint",
  "r_eyebrow",
  "r_eyebrow_joint",
  "r_eyelid",
  "r_eyelid_joint",
  "r_forearm",
  "r_forefoot",
  "r_hand",
  "r_hindfoot",
  "r_hip",
  "r_index_distal",
  "r_index_metacarpal",
  "r_index_middle",
  "r_index_proximal",
  "r_index0",
  "r_index1",
  "r_index2",
  "r_index3",
  "r_knee",
  "r_metatarsal",
  "r_middistal",
  "r_middle_distal",
  "r_middle_metacarpal",
  "r_middle_middle",
  "r_middle_proximal",
  "r_middle0",
  "r_middle1",
  "r_middle2",
  "r_middle3",
  "r_midproximal",
  "r_midtarsal",
  "r_pinky_distal",
  "r_pinky_metacarpal",
  "r_pinky_middle",
  "r_pinky_proximal",
  "r_pinky0",
  "r_pinky1",
  "r_pinky2",
  "r_pinky3",
  "r_ring_distal",
  "r_ring_metacarpal",
  "r_ring_middle",
  "r_ring_proximal",
  "r_ring0",
  "r_ring1",
  "r_ring2",
  "r_ring3",
  "r_scapula",
  "r_shoulder",
  "r_sternoclavicular",
  "r_subtalar",
  "r_thigh",
  "r_thumb_distal",
  "r_thumb_metacarpal",
  "r_thumb_proximal",
  "r_thumb1",
  "r_thumb2",
  "r_thumb3",
  "r_upperarm",
  "r_wrist",
  "sacroiliac",
  "sacrum",
  "skull",
  "skullbase",
  "t1",
  "t2",
  "t3",
  "t4",
  "t5",
  "t6",
  "t7",
  "t8",
  "t9",
  "t10",
  "t11",
  "t12",
  "temporomandibular",
  "vc1",
  "vc2",
  "vc3",
  "vc4",
  "vc5",
  "vc6",
  "vc7",
  "vl1",
  "vl2",
  "vl3",
  "vl4",
  "vl5",
  "vt1",
  "vt2",
  "vt3",
  "vt4",
  "vt5",
  "vt6",
  "vt7",
  "vt8",
  "vt9",
  "vt10",
  "vt11",
  "vt12"
};

const jointName::value jointName::
_xsd_jointName_indexes_[188] =
{
  ::jointName::HumanoidRoot,
  ::jointName::c1,
  ::jointName::c2,
  ::jointName::c3,
  ::jointName::c4,
  ::jointName::c5,
  ::jointName::c6,
  ::jointName::c7,
  ::jointName::jaw,
  ::jointName::l1,
  ::jointName::l2,
  ::jointName::l3,
  ::jointName::l4,
  ::jointName::l5,
  ::jointName::l_acromioclavicular,
  ::jointName::l_ankle,
  ::jointName::l_calf,
  ::jointName::l_clavicle,
  ::jointName::l_elbow,
  ::jointName::l_eyeball,
  ::jointName::l_eyeball_joint,
  ::jointName::l_eyebrow,
  ::jointName::l_eyebrow_joint,
  ::jointName::l_eyelid,
  ::jointName::l_eyelid_joint,
  ::jointName::l_forearm,
  ::jointName::l_forefoot,
  ::jointName::l_hand,
  ::jointName::l_hindfoot,
  ::jointName::l_hip,
  ::jointName::l_index0,
  ::jointName::l_index1,
  ::jointName::l_index2,
  ::jointName::l_index3,
  ::jointName::l_index_distal,
  ::jointName::l_index_metacarpal,
  ::jointName::l_index_middle,
  ::jointName::l_index_proximal,
  ::jointName::l_knee,
  ::jointName::l_metatarsal,
  ::jointName::l_middistal,
  ::jointName::l_middle0,
  ::jointName::l_middle1,
  ::jointName::l_middle2,
  ::jointName::l_middle3,
  ::jointName::l_middle_distal,
  ::jointName::l_middle_metacarpal,
  ::jointName::l_middle_middle,
  ::jointName::l_middle_proximal,
  ::jointName::l_midproximal,
  ::jointName::l_midtarsal,
  ::jointName::l_pinky0,
  ::jointName::l_pinky1,
  ::jointName::l_pinky2,
  ::jointName::l_pinky3,
  ::jointName::l_pinky_distal,
  ::jointName::l_pinky_metacarpal,
  ::jointName::l_pinky_middle,
  ::jointName::l_pinky_proximal,
  ::jointName::l_ring0,
  ::jointName::l_ring1,
  ::jointName::l_ring2,
  ::jointName::l_ring3,
  ::jointName::l_ring_distal,
  ::jointName::l_ring_metacarpal,
  ::jointName::l_ring_middle,
  ::jointName::l_ring_proximal,
  ::jointName::l_scapula,
  ::jointName::l_shoulder,
  ::jointName::l_sternoclavicular,
  ::jointName::l_subtalar,
  ::jointName::l_thigh,
  ::jointName::l_thumb1,
  ::jointName::l_thumb2,
  ::jointName::l_thumb3,
  ::jointName::l_thumb_distal,
  ::jointName::l_thumb_metacarpal,
  ::jointName::l_thumb_proximal,
  ::jointName::l_upperarm,
  ::jointName::l_wrist,
  ::jointName::pelvis,
  ::jointName::r_acromioclavicular,
  ::jointName::r_ankle,
  ::jointName::r_calf,
  ::jointName::r_clavicle,
  ::jointName::r_elbow,
  ::jointName::r_eyeball,
  ::jointName::r_eyeball_joint,
  ::jointName::r_eyebrow,
  ::jointName::r_eyebrow_joint,
  ::jointName::r_eyelid,
  ::jointName::r_eyelid_joint,
  ::jointName::r_forearm,
  ::jointName::r_forefoot,
  ::jointName::r_hand,
  ::jointName::r_hindfoot,
  ::jointName::r_hip,
  ::jointName::r_index0,
  ::jointName::r_index1,
  ::jointName::r_index2,
  ::jointName::r_index3,
  ::jointName::r_index_distal,
  ::jointName::r_index_metacarpal,
  ::jointName::r_index_middle,
  ::jointName::r_index_proximal,
  ::jointName::r_knee,
  ::jointName::r_metatarsal,
  ::jointName::r_middistal,
  ::jointName::r_middle0,
  ::jointName::r_middle1,
  ::jointName::r_middle2,
  ::jointName::r_middle3,
  ::jointName::r_middle_distal,
  ::jointName::r_middle_metacarpal,
  ::jointName::r_middle_middle,
  ::jointName::r_middle_proximal,
  ::jointName::r_midproximal,
  ::jointName::r_midtarsal,
  ::jointName::r_pinky0,
  ::jointName::r_pinky1,
  ::jointName::r_pinky2,
  ::jointName::r_pinky3,
  ::jointName::r_pinky_distal,
  ::jointName::r_pinky_metacarpal,
  ::jointName::r_pinky_middle,
  ::jointName::r_pinky_proximal,
  ::jointName::r_ring0,
  ::jointName::r_ring1,
  ::jointName::r_ring2,
  ::jointName::r_ring3,
  ::jointName::r_ring_distal,
  ::jointName::r_ring_metacarpal,
  ::jointName::r_ring_middle,
  ::jointName::r_ring_proximal,
  ::jointName::r_scapula,
  ::jointName::r_shoulder,
  ::jointName::r_sternoclavicular,
  ::jointName::r_subtalar,
  ::jointName::r_thigh,
  ::jointName::r_thumb1,
  ::jointName::r_thumb2,
  ::jointName::r_thumb3,
  ::jointName::r_thumb_distal,
  ::jointName::r_thumb_metacarpal,
  ::jointName::r_thumb_proximal,
  ::jointName::r_upperarm,
  ::jointName::r_wrist,
  ::jointName::sacroiliac,
  ::jointName::sacrum,
  ::jointName::skull,
  ::jointName::skullbase,
  ::jointName::t1,
  ::jointName::t10,
  ::jointName::t11,
  ::jointName::t12,
  ::jointName::t2,
  ::jointName::t3,
  ::jointName::t4,
  ::jointName::t5,
  ::jointName::t6,
  ::jointName::t7,
  ::jointName::t8,
  ::jointName::t9,
  ::jointName::temporomandibular,
  ::jointName::vc1,
  ::jointName::vc2,
  ::jointName::vc3,
  ::jointName::vc4,
  ::jointName::vc5,
  ::jointName::vc6,
  ::jointName::vc7,
  ::jointName::vl1,
  ::jointName::vl2,
  ::jointName::vl3,
  ::jointName::vl4,
  ::jointName::vl5,
  ::jointName::vt1,
  ::jointName::vt10,
  ::jointName::vt11,
  ::jointName::vt12,
  ::jointName::vt2,
  ::jointName::vt3,
  ::jointName::vt4,
  ::jointName::vt5,
  ::jointName::vt6,
  ::jointName::vt7,
  ::jointName::vt8,
  ::jointName::vt9
};

// ambientIntensity
//

ambientIntensity::
ambientIntensity (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

ambientIntensity::
ambientIntensity (const ambientIntensity& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

ambientIntensity::
ambientIntensity (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

ambientIntensity::
ambientIntensity (const ::xercesc::DOMAttr& a,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

ambientIntensity::
ambientIntensity (const ::std::string& s,
                  const ::xercesc::DOMElement* e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

ambientIntensity* ambientIntensity::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ambientIntensity (*this, f, c);
}

ambientIntensity::
~ambientIntensity ()
{
}

// intensity
//

intensity::
intensity (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

intensity::
intensity (const intensity& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

intensity::
intensity (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

intensity::
intensity (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

intensity::
intensity (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

intensity* intensity::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new intensity (*this, f, c);
}

intensity::
~intensity ()
{
}

// Anchor
//

Anchor::
Anchor ()
: ::X3DGroupingNode (),
  description_ (::xml_schema::flags (), this),
  parameter_ (::xml_schema::flags (), this),
  url_ (::xml_schema::flags (), this)
{
}

Anchor::
Anchor (const Anchor& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c),
  description_ (x.description_, f, this),
  parameter_ (x.parameter_, f, this),
  url_ (x.url_, f, this)
{
}

Anchor::
Anchor (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::X3DGroupingNode (e, f | ::xml_schema::flags::base, c),
  description_ (f, this),
  parameter_ (f, this),
  url_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Anchor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGroupingNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "description" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< description_type > r (
        description_traits::create (i, f, this));

      this->description (r);
      continue;
    }

    if (n.name () == "parameter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< parameter_type > r (
        parameter_traits::create (i, f, this));

      this->parameter (r);
      continue;
    }

    if (n.name () == "url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< url_type > r (
        url_traits::create (i, f, this));

      this->url (r);
      continue;
    }
  }
}

Anchor* Anchor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Anchor (*this, f, c);
}

Anchor::
~Anchor ()
{
}

// Appearance
//

Appearance::
Appearance ()
: ::X3DAppearanceNode ()
{
}

Appearance::
Appearance (const Appearance& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DAppearanceNode (x, f, c)
{
}

Appearance::
Appearance (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DAppearanceNode (e, f, c)
{
}

Appearance* Appearance::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Appearance (*this, f, c);
}

Appearance::
~Appearance ()
{
}

// Arc2D
//

const Arc2D::radius_type Arc2D::radius_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const Arc2D::startAngle_type Arc2D::startAngle_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const Arc2D::endAngle_type Arc2D::endAngle_default_value_ (
  ::std::string ("1.5708"), 0, 0, 0);

Arc2D::
Arc2D ()
: ::X3DGeometryNode (),
  radius_ (radius_default_value (), ::xml_schema::flags (), this),
  startAngle_ (startAngle_default_value (), ::xml_schema::flags (), this),
  endAngle_ (endAngle_default_value (), ::xml_schema::flags (), this)
{
}

Arc2D::
Arc2D (const Arc2D& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  radius_ (x.radius_, f, this),
  startAngle_ (x.startAngle_, f, this),
  endAngle_ (x.endAngle_, f, this)
{
}

Arc2D::
Arc2D (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  radius_ (f, this),
  startAngle_ (f, this),
  endAngle_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Arc2D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< radius_type > r (
        radius_traits::create (i, f, this));

      this->radius (r);
      continue;
    }

    if (n.name () == "startAngle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< startAngle_type > r (
        startAngle_traits::create (i, f, this));

      this->startAngle (r);
      continue;
    }

    if (n.name () == "endAngle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< endAngle_type > r (
        endAngle_traits::create (i, f, this));

      this->endAngle (r);
      continue;
    }
  }

  if (!radius_.present ())
  {
    ::std::auto_ptr< radius_type > r (
      radius_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->radius (r);
  }

  if (!startAngle_.present ())
  {
    ::std::auto_ptr< startAngle_type > r (
      startAngle_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->startAngle (r);
  }

  if (!endAngle_.present ())
  {
    ::std::auto_ptr< endAngle_type > r (
      endAngle_traits::create (
        ::std::string ("1.5708"),
        &p.element (), f, this));

    this->endAngle (r);
  }
}

Arc2D* Arc2D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Arc2D (*this, f, c);
}

Arc2D::
~Arc2D ()
{
}

// ArcClose2D
//

const ArcClose2D::radius_type ArcClose2D::radius_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const ArcClose2D::startAngle_type ArcClose2D::startAngle_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const ArcClose2D::endAngle_type ArcClose2D::endAngle_default_value_ (
  ::std::string ("1.5708"), 0, 0, 0);

const ArcClose2D::closureType_type ArcClose2D::closureType_default_value_ (
  ::std::string ("PIE"), 0, 0, 0);

const ArcClose2D::solid_type ArcClose2D::solid_default_value_ (
  ::std::string ("true"), 0, 0, 0);

ArcClose2D::
ArcClose2D ()
: ::X3DGeometryNode (),
  radius_ (radius_default_value (), ::xml_schema::flags (), this),
  startAngle_ (startAngle_default_value (), ::xml_schema::flags (), this),
  endAngle_ (endAngle_default_value (), ::xml_schema::flags (), this),
  closureType_ (closureType_default_value (), ::xml_schema::flags (), this),
  solid_ (solid_default_value (), ::xml_schema::flags (), this)
{
}

ArcClose2D::
ArcClose2D (const ArcClose2D& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  radius_ (x.radius_, f, this),
  startAngle_ (x.startAngle_, f, this),
  endAngle_ (x.endAngle_, f, this),
  closureType_ (x.closureType_, f, this),
  solid_ (x.solid_, f, this)
{
}

ArcClose2D::
ArcClose2D (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  radius_ (f, this),
  startAngle_ (f, this),
  endAngle_ (f, this),
  closureType_ (f, this),
  solid_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ArcClose2D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< radius_type > r (
        radius_traits::create (i, f, this));

      this->radius (r);
      continue;
    }

    if (n.name () == "startAngle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< startAngle_type > r (
        startAngle_traits::create (i, f, this));

      this->startAngle (r);
      continue;
    }

    if (n.name () == "endAngle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< endAngle_type > r (
        endAngle_traits::create (i, f, this));

      this->endAngle (r);
      continue;
    }

    if (n.name () == "closureType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< closureType_type > r (
        closureType_traits::create (i, f, this));

      this->closureType (r);
      continue;
    }

    if (n.name () == "solid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< solid_type > r (
        solid_traits::create (i, f, this));

      this->solid (r);
      continue;
    }
  }

  if (!radius_.present ())
  {
    ::std::auto_ptr< radius_type > r (
      radius_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->radius (r);
  }

  if (!startAngle_.present ())
  {
    ::std::auto_ptr< startAngle_type > r (
      startAngle_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->startAngle (r);
  }

  if (!endAngle_.present ())
  {
    ::std::auto_ptr< endAngle_type > r (
      endAngle_traits::create (
        ::std::string ("1.5708"),
        &p.element (), f, this));

    this->endAngle (r);
  }

  if (!closureType_.present ())
  {
    ::std::auto_ptr< closureType_type > r (
      closureType_traits::create (
        ::std::string ("PIE"),
        &p.element (), f, this));

    this->closureType (r);
  }

  if (!solid_.present ())
  {
    ::std::auto_ptr< solid_type > r (
      solid_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->solid (r);
  }
}

ArcClose2D* ArcClose2D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ArcClose2D (*this, f, c);
}

ArcClose2D::
~ArcClose2D ()
{
}

// AudioClip
//

AudioClip::
AudioClip ()
: ::X3DSoundSourceNode (),
  description_ (::xml_schema::flags (), this),
  url_ (::xml_schema::flags (), this)
{
}

AudioClip::
AudioClip (const AudioClip& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DSoundSourceNode (x, f, c),
  description_ (x.description_, f, this),
  url_ (x.url_, f, this)
{
}

AudioClip::
AudioClip (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DSoundSourceNode (e, f | ::xml_schema::flags::base, c),
  description_ (f, this),
  url_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void AudioClip::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DSoundSourceNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "description" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< description_type > r (
        description_traits::create (i, f, this));

      this->description (r);
      continue;
    }

    if (n.name () == "url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< url_type > r (
        url_traits::create (i, f, this));

      this->url (r);
      continue;
    }
  }
}

AudioClip* AudioClip::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new AudioClip (*this, f, c);
}

AudioClip::
~AudioClip ()
{
}

// Background
//

Background::
Background ()
: ::X3DBackgroundNode (),
  backUrl_ (::xml_schema::flags (), this),
  bottomUrl_ (::xml_schema::flags (), this),
  frontUrl_ (::xml_schema::flags (), this),
  leftUrl_ (::xml_schema::flags (), this),
  rightUrl_ (::xml_schema::flags (), this),
  topUrl_ (::xml_schema::flags (), this)
{
}

Background::
Background (const Background& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DBackgroundNode (x, f, c),
  backUrl_ (x.backUrl_, f, this),
  bottomUrl_ (x.bottomUrl_, f, this),
  frontUrl_ (x.frontUrl_, f, this),
  leftUrl_ (x.leftUrl_, f, this),
  rightUrl_ (x.rightUrl_, f, this),
  topUrl_ (x.topUrl_, f, this)
{
}

Background::
Background (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DBackgroundNode (e, f | ::xml_schema::flags::base, c),
  backUrl_ (f, this),
  bottomUrl_ (f, this),
  frontUrl_ (f, this),
  leftUrl_ (f, this),
  rightUrl_ (f, this),
  topUrl_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Background::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DBackgroundNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "backUrl" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< backUrl_type > r (
        backUrl_traits::create (i, f, this));

      this->backUrl (r);
      continue;
    }

    if (n.name () == "bottomUrl" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bottomUrl_type > r (
        bottomUrl_traits::create (i, f, this));

      this->bottomUrl (r);
      continue;
    }

    if (n.name () == "frontUrl" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< frontUrl_type > r (
        frontUrl_traits::create (i, f, this));

      this->frontUrl (r);
      continue;
    }

    if (n.name () == "leftUrl" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< leftUrl_type > r (
        leftUrl_traits::create (i, f, this));

      this->leftUrl (r);
      continue;
    }

    if (n.name () == "rightUrl" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rightUrl_type > r (
        rightUrl_traits::create (i, f, this));

      this->rightUrl (r);
      continue;
    }

    if (n.name () == "topUrl" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< topUrl_type > r (
        topUrl_traits::create (i, f, this));

      this->topUrl (r);
      continue;
    }
  }
}

Background* Background::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Background (*this, f, c);
}

Background::
~Background ()
{
}

// Billboard
//

const Billboard::axisOfRotation_type Billboard::axisOfRotation_default_value_ (
  ::std::string ("0 1 0"), 0, 0, 0);

Billboard::
Billboard ()
: ::X3DGroupingNode (),
  axisOfRotation_ (axisOfRotation_default_value (), ::xml_schema::flags (), this)
{
}

Billboard::
Billboard (const Billboard& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c),
  axisOfRotation_ (x.axisOfRotation_, f, this)
{
}

Billboard::
Billboard (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DGroupingNode (e, f | ::xml_schema::flags::base, c),
  axisOfRotation_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Billboard::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGroupingNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "axisOfRotation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< axisOfRotation_type > r (
        axisOfRotation_traits::create (i, f, this));

      this->axisOfRotation (r);
      continue;
    }
  }

  if (!axisOfRotation_.present ())
  {
    ::std::auto_ptr< axisOfRotation_type > r (
      axisOfRotation_traits::create (
        ::std::string ("0 1 0"),
        &p.element (), f, this));

    this->axisOfRotation (r);
  }
}

Billboard* Billboard::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Billboard (*this, f, c);
}

Billboard::
~Billboard ()
{
}

// BooleanFilter
//

BooleanFilter::
BooleanFilter ()
: ::X3DChildNode ()
{
}

BooleanFilter::
BooleanFilter (const BooleanFilter& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DChildNode (x, f, c)
{
}

BooleanFilter::
BooleanFilter (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DChildNode (e, f, c)
{
}

BooleanFilter* BooleanFilter::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new BooleanFilter (*this, f, c);
}

BooleanFilter::
~BooleanFilter ()
{
}

// BooleanSequencer
//

BooleanSequencer::
BooleanSequencer ()
: ::X3DSequencerNode (),
  keyValue_ (::xml_schema::flags (), this)
{
}

BooleanSequencer::
BooleanSequencer (const BooleanSequencer& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DSequencerNode (x, f, c),
  keyValue_ (x.keyValue_, f, this)
{
}

BooleanSequencer::
BooleanSequencer (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DSequencerNode (e, f | ::xml_schema::flags::base, c),
  keyValue_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void BooleanSequencer::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DSequencerNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "keyValue" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< keyValue_type > r (
        keyValue_traits::create (i, f, this));

      this->keyValue (r);
      continue;
    }
  }
}

BooleanSequencer* BooleanSequencer::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new BooleanSequencer (*this, f, c);
}

BooleanSequencer::
~BooleanSequencer ()
{
}

// BooleanToggle
//

const BooleanToggle::toggle_type BooleanToggle::toggle_default_value_ (
  ::std::string ("false"), 0, 0, 0);

BooleanToggle::
BooleanToggle ()
: ::X3DChildNode (),
  toggle_ (toggle_default_value (), ::xml_schema::flags (), this)
{
}

BooleanToggle::
BooleanToggle (const BooleanToggle& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DChildNode (x, f, c),
  toggle_ (x.toggle_, f, this)
{
}

BooleanToggle::
BooleanToggle (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DChildNode (e, f | ::xml_schema::flags::base, c),
  toggle_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void BooleanToggle::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DChildNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "toggle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< toggle_type > r (
        toggle_traits::create (i, f, this));

      this->toggle (r);
      continue;
    }
  }

  if (!toggle_.present ())
  {
    ::std::auto_ptr< toggle_type > r (
      toggle_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->toggle (r);
  }
}

BooleanToggle* BooleanToggle::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new BooleanToggle (*this, f, c);
}

BooleanToggle::
~BooleanToggle ()
{
}

// BooleanTrigger
//

BooleanTrigger::
BooleanTrigger ()
: ::X3DChildNode ()
{
}

BooleanTrigger::
BooleanTrigger (const BooleanTrigger& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DChildNode (x, f, c)
{
}

BooleanTrigger::
BooleanTrigger (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DChildNode (e, f, c)
{
}

BooleanTrigger* BooleanTrigger::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new BooleanTrigger (*this, f, c);
}

BooleanTrigger::
~BooleanTrigger ()
{
}

// Box
//

const Box::size_type Box::size_default_value_ (
  ::std::string ("2 2 2"), 0, 0, 0);

const Box::solid_type Box::solid_default_value_ (
  ::std::string ("true"), 0, 0, 0);

Box::
Box ()
: ::X3DGeometryNode (),
  size_ (size_default_value (), ::xml_schema::flags (), this),
  solid_ (solid_default_value (), ::xml_schema::flags (), this)
{
}

Box::
Box (const Box& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  size_ (x.size_, f, this),
  solid_ (x.solid_, f, this)
{
}

Box::
Box (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  size_ (f, this),
  solid_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Box::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "size" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< size_type > r (
        size_traits::create (i, f, this));

      this->size (r);
      continue;
    }

    if (n.name () == "solid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< solid_type > r (
        solid_traits::create (i, f, this));

      this->solid (r);
      continue;
    }
  }

  if (!size_.present ())
  {
    ::std::auto_ptr< size_type > r (
      size_traits::create (
        ::std::string ("2 2 2"),
        &p.element (), f, this));

    this->size (r);
  }

  if (!solid_.present ())
  {
    ::std::auto_ptr< solid_type > r (
      solid_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->solid (r);
  }
}

Box* Box::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Box (*this, f, c);
}

Box::
~Box ()
{
}

// Circle2D
//

const Circle2D::radius_type Circle2D::radius_default_value_ (
  ::std::string ("1"), 0, 0, 0);

Circle2D::
Circle2D ()
: ::X3DGeometryNode (),
  radius_ (radius_default_value (), ::xml_schema::flags (), this)
{
}

Circle2D::
Circle2D (const Circle2D& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  radius_ (x.radius_, f, this)
{
}

Circle2D::
Circle2D (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  radius_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Circle2D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< radius_type > r (
        radius_traits::create (i, f, this));

      this->radius (r);
      continue;
    }
  }

  if (!radius_.present ())
  {
    ::std::auto_ptr< radius_type > r (
      radius_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->radius (r);
  }
}

Circle2D* Circle2D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Circle2D (*this, f, c);
}

Circle2D::
~Circle2D ()
{
}

// Collision
//

const Collision::enabled_type Collision::enabled_default_value_ (
  ::std::string ("true"), 0, 0, 0);

Collision::
Collision ()
: ::X3DGroupingNode (),
  enabled_ (enabled_default_value (), ::xml_schema::flags (), this)
{
}

Collision::
Collision (const Collision& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c),
  enabled_ (x.enabled_, f, this)
{
}

Collision::
Collision (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DGroupingNode (e, f | ::xml_schema::flags::base, c),
  enabled_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Collision::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGroupingNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "enabled" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< enabled_type > r (
        enabled_traits::create (i, f, this));

      this->enabled (r);
      continue;
    }
  }

  if (!enabled_.present ())
  {
    ::std::auto_ptr< enabled_type > r (
      enabled_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->enabled (r);
  }
}

Collision* Collision::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Collision (*this, f, c);
}

Collision::
~Collision ()
{
}

// Color
//

Color::
Color ()
: ::X3DColorNode (),
  color_ (::xml_schema::flags (), this)
{
}

Color::
Color (const Color& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::X3DColorNode (x, f, c),
  color_ (x.color_, f, this)
{
}

Color::
Color (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::X3DColorNode (e, f | ::xml_schema::flags::base, c),
  color_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Color::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DColorNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< color_type > r (
        color_traits::create (i, f, this));

      this->color (r);
      continue;
    }
  }
}

Color* Color::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Color (*this, f, c);
}

Color::
~Color ()
{
}

// ColorRGBA
//

ColorRGBA::
ColorRGBA ()
: ::X3DColorNode (),
  color_ (::xml_schema::flags (), this)
{
}

ColorRGBA::
ColorRGBA (const ColorRGBA& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DColorNode (x, f, c),
  color_ (x.color_, f, this)
{
}

ColorRGBA::
ColorRGBA (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DColorNode (e, f | ::xml_schema::flags::base, c),
  color_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ColorRGBA::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DColorNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< color_type > r (
        color_traits::create (i, f, this));

      this->color (r);
      continue;
    }
  }
}

ColorRGBA* ColorRGBA::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ColorRGBA (*this, f, c);
}

ColorRGBA::
~ColorRGBA ()
{
}

// ColorInterpolator
//

ColorInterpolator::
ColorInterpolator ()
: ::X3DInterpolatorNode (),
  keyValue_ (::xml_schema::flags (), this)
{
}

ColorInterpolator::
ColorInterpolator (const ColorInterpolator& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DInterpolatorNode (x, f, c),
  keyValue_ (x.keyValue_, f, this)
{
}

ColorInterpolator::
ColorInterpolator (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DInterpolatorNode (e, f | ::xml_schema::flags::base, c),
  keyValue_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ColorInterpolator::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DInterpolatorNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "keyValue" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< keyValue_type > r (
        keyValue_traits::create (i, f, this));

      this->keyValue (r);
      continue;
    }
  }
}

ColorInterpolator* ColorInterpolator::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ColorInterpolator (*this, f, c);
}

ColorInterpolator::
~ColorInterpolator ()
{
}

// Cone
//

const Cone::bottomRadius_type Cone::bottomRadius_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const Cone::height_type Cone::height_default_value_ (
  ::std::string ("2"), 0, 0, 0);

const Cone::side_type Cone::side_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const Cone::bottom_type Cone::bottom_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const Cone::solid_type Cone::solid_default_value_ (
  ::std::string ("true"), 0, 0, 0);

Cone::
Cone ()
: ::X3DGeometryNode (),
  bottomRadius_ (bottomRadius_default_value (), ::xml_schema::flags (), this),
  height_ (height_default_value (), ::xml_schema::flags (), this),
  side_ (side_default_value (), ::xml_schema::flags (), this),
  bottom_ (bottom_default_value (), ::xml_schema::flags (), this),
  solid_ (solid_default_value (), ::xml_schema::flags (), this)
{
}

Cone::
Cone (const Cone& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  bottomRadius_ (x.bottomRadius_, f, this),
  height_ (x.height_, f, this),
  side_ (x.side_, f, this),
  bottom_ (x.bottom_, f, this),
  solid_ (x.solid_, f, this)
{
}

Cone::
Cone (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  bottomRadius_ (f, this),
  height_ (f, this),
  side_ (f, this),
  bottom_ (f, this),
  solid_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Cone::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "bottomRadius" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bottomRadius_type > r (
        bottomRadius_traits::create (i, f, this));

      this->bottomRadius (r);
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< height_type > r (
        height_traits::create (i, f, this));

      this->height (r);
      continue;
    }

    if (n.name () == "side" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< side_type > r (
        side_traits::create (i, f, this));

      this->side (r);
      continue;
    }

    if (n.name () == "bottom" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bottom_type > r (
        bottom_traits::create (i, f, this));

      this->bottom (r);
      continue;
    }

    if (n.name () == "solid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< solid_type > r (
        solid_traits::create (i, f, this));

      this->solid (r);
      continue;
    }
  }

  if (!bottomRadius_.present ())
  {
    ::std::auto_ptr< bottomRadius_type > r (
      bottomRadius_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->bottomRadius (r);
  }

  if (!height_.present ())
  {
    ::std::auto_ptr< height_type > r (
      height_traits::create (
        ::std::string ("2"),
        &p.element (), f, this));

    this->height (r);
  }

  if (!side_.present ())
  {
    ::std::auto_ptr< side_type > r (
      side_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->side (r);
  }

  if (!bottom_.present ())
  {
    ::std::auto_ptr< bottom_type > r (
      bottom_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->bottom (r);
  }

  if (!solid_.present ())
  {
    ::std::auto_ptr< solid_type > r (
      solid_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->solid (r);
  }
}

Cone* Cone::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Cone (*this, f, c);
}

Cone::
~Cone ()
{
}

// Coordinate
//

const Coordinate::containerField_type Coordinate::containerField_default_value_ (
  ::std::string ("coord"), 0, 0, 0);

Coordinate::
Coordinate ()
: ::X3DCoordinateNode (),
  point_ (::xml_schema::flags (), this),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

Coordinate::
Coordinate (const Coordinate& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DCoordinateNode (x, f, c),
  point_ (x.point_, f, this),
  containerField_ (x.containerField_, f, this)
{
}

Coordinate::
Coordinate (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DCoordinateNode (e, f | ::xml_schema::flags::base, c),
  point_ (f, this),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Coordinate::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DCoordinateNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "point" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< point_type > r (
        point_traits::create (i, f, this));

      this->point (r);
      continue;
    }

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("coord"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

Coordinate* Coordinate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Coordinate (*this, f, c);
}

Coordinate::
~Coordinate ()
{
}

// CoordinateDouble
//

const CoordinateDouble::containerField_type CoordinateDouble::containerField_default_value_ (
  ::std::string ("coord"), 0, 0, 0);

CoordinateDouble::
CoordinateDouble ()
: ::X3DCoordinateNode (),
  point_ (::xml_schema::flags (), this),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

CoordinateDouble::
CoordinateDouble (const CoordinateDouble& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DCoordinateNode (x, f, c),
  point_ (x.point_, f, this),
  containerField_ (x.containerField_, f, this)
{
}

CoordinateDouble::
CoordinateDouble (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DCoordinateNode (e, f | ::xml_schema::flags::base, c),
  point_ (f, this),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void CoordinateDouble::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DCoordinateNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "point" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< point_type > r (
        point_traits::create (i, f, this));

      this->point (r);
      continue;
    }

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("coord"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

CoordinateDouble* CoordinateDouble::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new CoordinateDouble (*this, f, c);
}

CoordinateDouble::
~CoordinateDouble ()
{
}

// CoordinateInterpolator
//

CoordinateInterpolator::
CoordinateInterpolator ()
: ::X3DInterpolatorNode (),
  keyValue_ (::xml_schema::flags (), this)
{
}

CoordinateInterpolator::
CoordinateInterpolator (const CoordinateInterpolator& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DInterpolatorNode (x, f, c),
  keyValue_ (x.keyValue_, f, this)
{
}

CoordinateInterpolator::
CoordinateInterpolator (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DInterpolatorNode (e, f | ::xml_schema::flags::base, c),
  keyValue_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void CoordinateInterpolator::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DInterpolatorNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "keyValue" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< keyValue_type > r (
        keyValue_traits::create (i, f, this));

      this->keyValue (r);
      continue;
    }
  }
}

CoordinateInterpolator* CoordinateInterpolator::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new CoordinateInterpolator (*this, f, c);
}

CoordinateInterpolator::
~CoordinateInterpolator ()
{
}

// CoordinateInterpolator2D
//

CoordinateInterpolator2D::
CoordinateInterpolator2D ()
: ::X3DInterpolatorNode (),
  keyValue_ (::xml_schema::flags (), this)
{
}

CoordinateInterpolator2D::
CoordinateInterpolator2D (const CoordinateInterpolator2D& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::X3DInterpolatorNode (x, f, c),
  keyValue_ (x.keyValue_, f, this)
{
}

CoordinateInterpolator2D::
CoordinateInterpolator2D (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::X3DInterpolatorNode (e, f | ::xml_schema::flags::base, c),
  keyValue_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void CoordinateInterpolator2D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DInterpolatorNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "keyValue" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< keyValue_type > r (
        keyValue_traits::create (i, f, this));

      this->keyValue (r);
      continue;
    }
  }
}

CoordinateInterpolator2D* CoordinateInterpolator2D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new CoordinateInterpolator2D (*this, f, c);
}

CoordinateInterpolator2D::
~CoordinateInterpolator2D ()
{
}

// Cylinder
//

const Cylinder::bottom_type Cylinder::bottom_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const Cylinder::height_type Cylinder::height_default_value_ (
  ::std::string ("2"), 0, 0, 0);

const Cylinder::radius_type Cylinder::radius_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const Cylinder::side_type Cylinder::side_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const Cylinder::top_type Cylinder::top_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const Cylinder::solid_type Cylinder::solid_default_value_ (
  ::std::string ("true"), 0, 0, 0);

Cylinder::
Cylinder ()
: ::X3DGeometryNode (),
  bottom_ (bottom_default_value (), ::xml_schema::flags (), this),
  height_ (height_default_value (), ::xml_schema::flags (), this),
  radius_ (radius_default_value (), ::xml_schema::flags (), this),
  side_ (side_default_value (), ::xml_schema::flags (), this),
  top_ (top_default_value (), ::xml_schema::flags (), this),
  solid_ (solid_default_value (), ::xml_schema::flags (), this)
{
}

Cylinder::
Cylinder (const Cylinder& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  bottom_ (x.bottom_, f, this),
  height_ (x.height_, f, this),
  radius_ (x.radius_, f, this),
  side_ (x.side_, f, this),
  top_ (x.top_, f, this),
  solid_ (x.solid_, f, this)
{
}

Cylinder::
Cylinder (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  bottom_ (f, this),
  height_ (f, this),
  radius_ (f, this),
  side_ (f, this),
  top_ (f, this),
  solid_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Cylinder::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "bottom" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bottom_type > r (
        bottom_traits::create (i, f, this));

      this->bottom (r);
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< height_type > r (
        height_traits::create (i, f, this));

      this->height (r);
      continue;
    }

    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< radius_type > r (
        radius_traits::create (i, f, this));

      this->radius (r);
      continue;
    }

    if (n.name () == "side" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< side_type > r (
        side_traits::create (i, f, this));

      this->side (r);
      continue;
    }

    if (n.name () == "top" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< top_type > r (
        top_traits::create (i, f, this));

      this->top (r);
      continue;
    }

    if (n.name () == "solid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< solid_type > r (
        solid_traits::create (i, f, this));

      this->solid (r);
      continue;
    }
  }

  if (!bottom_.present ())
  {
    ::std::auto_ptr< bottom_type > r (
      bottom_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->bottom (r);
  }

  if (!height_.present ())
  {
    ::std::auto_ptr< height_type > r (
      height_traits::create (
        ::std::string ("2"),
        &p.element (), f, this));

    this->height (r);
  }

  if (!radius_.present ())
  {
    ::std::auto_ptr< radius_type > r (
      radius_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->radius (r);
  }

  if (!side_.present ())
  {
    ::std::auto_ptr< side_type > r (
      side_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->side (r);
  }

  if (!top_.present ())
  {
    ::std::auto_ptr< top_type > r (
      top_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->top (r);
  }

  if (!solid_.present ())
  {
    ::std::auto_ptr< solid_type > r (
      solid_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->solid (r);
  }
}

Cylinder* Cylinder::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Cylinder (*this, f, c);
}

Cylinder::
~Cylinder ()
{
}

// CylinderSensor
//

const CylinderSensor::diskAngle_type CylinderSensor::diskAngle_default_value_ (
  ::std::string ("0.26179167"), 0, 0, 0);

const CylinderSensor::maxAngle_type CylinderSensor::maxAngle_default_value_ (
  ::std::string ("-1"), 0, 0, 0);

const CylinderSensor::minAngle_type CylinderSensor::minAngle_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const CylinderSensor::offset_type CylinderSensor::offset_default_value_ (
  ::std::string ("0"), 0, 0, 0);

CylinderSensor::
CylinderSensor ()
: ::X3DDragSensorNode (),
  diskAngle_ (diskAngle_default_value (), ::xml_schema::flags (), this),
  maxAngle_ (maxAngle_default_value (), ::xml_schema::flags (), this),
  minAngle_ (minAngle_default_value (), ::xml_schema::flags (), this),
  offset_ (offset_default_value (), ::xml_schema::flags (), this)
{
}

CylinderSensor::
CylinderSensor (const CylinderSensor& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DDragSensorNode (x, f, c),
  diskAngle_ (x.diskAngle_, f, this),
  maxAngle_ (x.maxAngle_, f, this),
  minAngle_ (x.minAngle_, f, this),
  offset_ (x.offset_, f, this)
{
}

CylinderSensor::
CylinderSensor (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DDragSensorNode (e, f | ::xml_schema::flags::base, c),
  diskAngle_ (f, this),
  maxAngle_ (f, this),
  minAngle_ (f, this),
  offset_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void CylinderSensor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DDragSensorNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "diskAngle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< diskAngle_type > r (
        diskAngle_traits::create (i, f, this));

      this->diskAngle (r);
      continue;
    }

    if (n.name () == "maxAngle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< maxAngle_type > r (
        maxAngle_traits::create (i, f, this));

      this->maxAngle (r);
      continue;
    }

    if (n.name () == "minAngle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< minAngle_type > r (
        minAngle_traits::create (i, f, this));

      this->minAngle (r);
      continue;
    }

    if (n.name () == "offset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< offset_type > r (
        offset_traits::create (i, f, this));

      this->offset (r);
      continue;
    }
  }

  if (!diskAngle_.present ())
  {
    ::std::auto_ptr< diskAngle_type > r (
      diskAngle_traits::create (
        ::std::string ("0.26179167"),
        &p.element (), f, this));

    this->diskAngle (r);
  }

  if (!maxAngle_.present ())
  {
    ::std::auto_ptr< maxAngle_type > r (
      maxAngle_traits::create (
        ::std::string ("-1"),
        &p.element (), f, this));

    this->maxAngle (r);
  }

  if (!minAngle_.present ())
  {
    ::std::auto_ptr< minAngle_type > r (
      minAngle_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->minAngle (r);
  }

  if (!offset_.present ())
  {
    ::std::auto_ptr< offset_type > r (
      offset_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->offset (r);
  }
}

CylinderSensor* CylinderSensor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new CylinderSensor (*this, f, c);
}

CylinderSensor::
~CylinderSensor ()
{
}

// DirectionalLight
//

const DirectionalLight::direction_type DirectionalLight::direction_default_value_ (
  ::std::string ("0 0 -1"), 0, 0, 0);

const DirectionalLight::global_type DirectionalLight::global_default_value_ (
  ::std::string ("false"), 0, 0, 0);

DirectionalLight::
DirectionalLight ()
: ::X3DLightNode (),
  direction_ (direction_default_value (), ::xml_schema::flags (), this),
  global_ (global_default_value (), ::xml_schema::flags (), this)
{
}

DirectionalLight::
DirectionalLight (const DirectionalLight& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DLightNode (x, f, c),
  direction_ (x.direction_, f, this),
  global_ (x.global_, f, this)
{
}

DirectionalLight::
DirectionalLight (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DLightNode (e, f | ::xml_schema::flags::base, c),
  direction_ (f, this),
  global_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void DirectionalLight::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DLightNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "direction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< direction_type > r (
        direction_traits::create (i, f, this));

      this->direction (r);
      continue;
    }

    if (n.name () == "global" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< global_type > r (
        global_traits::create (i, f, this));

      this->global (r);
      continue;
    }
  }

  if (!direction_.present ())
  {
    ::std::auto_ptr< direction_type > r (
      direction_traits::create (
        ::std::string ("0 0 -1"),
        &p.element (), f, this));

    this->direction (r);
  }

  if (!global_.present ())
  {
    ::std::auto_ptr< global_type > r (
      global_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->global (r);
  }
}

DirectionalLight* DirectionalLight::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new DirectionalLight (*this, f, c);
}

DirectionalLight::
~DirectionalLight ()
{
}

// Disk2D
//

const Disk2D::innerRadius_type Disk2D::innerRadius_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const Disk2D::outerRadius_type Disk2D::outerRadius_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const Disk2D::solid_type Disk2D::solid_default_value_ (
  ::std::string ("true"), 0, 0, 0);

Disk2D::
Disk2D ()
: ::X3DGeometryNode (),
  innerRadius_ (innerRadius_default_value (), ::xml_schema::flags (), this),
  outerRadius_ (outerRadius_default_value (), ::xml_schema::flags (), this),
  solid_ (solid_default_value (), ::xml_schema::flags (), this)
{
}

Disk2D::
Disk2D (const Disk2D& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  innerRadius_ (x.innerRadius_, f, this),
  outerRadius_ (x.outerRadius_, f, this),
  solid_ (x.solid_, f, this)
{
}

Disk2D::
Disk2D (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  innerRadius_ (f, this),
  outerRadius_ (f, this),
  solid_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Disk2D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "innerRadius" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< innerRadius_type > r (
        innerRadius_traits::create (i, f, this));

      this->innerRadius (r);
      continue;
    }

    if (n.name () == "outerRadius" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< outerRadius_type > r (
        outerRadius_traits::create (i, f, this));

      this->outerRadius (r);
      continue;
    }

    if (n.name () == "solid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< solid_type > r (
        solid_traits::create (i, f, this));

      this->solid (r);
      continue;
    }
  }

  if (!innerRadius_.present ())
  {
    ::std::auto_ptr< innerRadius_type > r (
      innerRadius_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->innerRadius (r);
  }

  if (!outerRadius_.present ())
  {
    ::std::auto_ptr< outerRadius_type > r (
      outerRadius_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->outerRadius (r);
  }

  if (!solid_.present ())
  {
    ::std::auto_ptr< solid_type > r (
      solid_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->solid (r);
  }
}

Disk2D* Disk2D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Disk2D (*this, f, c);
}

Disk2D::
~Disk2D ()
{
}

// ElevationGrid
//

const ElevationGrid::ccw_type ElevationGrid::ccw_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const ElevationGrid::colorPerVertex_type ElevationGrid::colorPerVertex_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const ElevationGrid::creaseAngle_type ElevationGrid::creaseAngle_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const ElevationGrid::normalPerVertex_type ElevationGrid::normalPerVertex_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const ElevationGrid::solid_type ElevationGrid::solid_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const ElevationGrid::xDimension_type ElevationGrid::xDimension_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const ElevationGrid::xSpacing_type ElevationGrid::xSpacing_default_value_ (
  ::std::string ("1.0"), 0, 0, 0);

const ElevationGrid::zDimension_type ElevationGrid::zDimension_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const ElevationGrid::zSpacing_type ElevationGrid::zSpacing_default_value_ (
  ::std::string ("1.0"), 0, 0, 0);

ElevationGrid::
ElevationGrid ()
: ::X3DGeometryNode (),
  FloatVertexAttribute_ (::xml_schema::flags (), this),
  Matrix3VertexAttribute_ (::xml_schema::flags (), this),
  Matrix4VertexAttribute_ (::xml_schema::flags (), this),
  Color_ (::xml_schema::flags (), this),
  ColorRGBA_ (::xml_schema::flags (), this),
  FogCoordinate_ (::xml_schema::flags (), this),
  Normal_ (::xml_schema::flags (), this),
  TextureCoordinate_ (::xml_schema::flags (), this),
  TextureCoordinate3D_ (::xml_schema::flags (), this),
  TextureCoordinate4D_ (::xml_schema::flags (), this),
  TextureCoordinateGenerator_ (::xml_schema::flags (), this),
  MultiTextureCoordinate_ (::xml_schema::flags (), this),
  NurbsTextureCoordinate_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  height_ (::xml_schema::flags (), this),
  ccw_ (ccw_default_value (), ::xml_schema::flags (), this),
  colorPerVertex_ (colorPerVertex_default_value (), ::xml_schema::flags (), this),
  creaseAngle_ (creaseAngle_default_value (), ::xml_schema::flags (), this),
  normalPerVertex_ (normalPerVertex_default_value (), ::xml_schema::flags (), this),
  solid_ (solid_default_value (), ::xml_schema::flags (), this),
  xDimension_ (xDimension_default_value (), ::xml_schema::flags (), this),
  xSpacing_ (xSpacing_default_value (), ::xml_schema::flags (), this),
  zDimension_ (zDimension_default_value (), ::xml_schema::flags (), this),
  zSpacing_ (zSpacing_default_value (), ::xml_schema::flags (), this)
{
}

ElevationGrid::
ElevationGrid (const ElevationGrid& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  FloatVertexAttribute_ (x.FloatVertexAttribute_, f, this),
  Matrix3VertexAttribute_ (x.Matrix3VertexAttribute_, f, this),
  Matrix4VertexAttribute_ (x.Matrix4VertexAttribute_, f, this),
  Color_ (x.Color_, f, this),
  ColorRGBA_ (x.ColorRGBA_, f, this),
  FogCoordinate_ (x.FogCoordinate_, f, this),
  Normal_ (x.Normal_, f, this),
  TextureCoordinate_ (x.TextureCoordinate_, f, this),
  TextureCoordinate3D_ (x.TextureCoordinate3D_, f, this),
  TextureCoordinate4D_ (x.TextureCoordinate4D_, f, this),
  TextureCoordinateGenerator_ (x.TextureCoordinateGenerator_, f, this),
  MultiTextureCoordinate_ (x.MultiTextureCoordinate_, f, this),
  NurbsTextureCoordinate_ (x.NurbsTextureCoordinate_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  height_ (x.height_, f, this),
  ccw_ (x.ccw_, f, this),
  colorPerVertex_ (x.colorPerVertex_, f, this),
  creaseAngle_ (x.creaseAngle_, f, this),
  normalPerVertex_ (x.normalPerVertex_, f, this),
  solid_ (x.solid_, f, this),
  xDimension_ (x.xDimension_, f, this),
  xSpacing_ (x.xSpacing_, f, this),
  zDimension_ (x.zDimension_, f, this),
  zSpacing_ (x.zSpacing_, f, this)
{
}

ElevationGrid::
ElevationGrid (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  FloatVertexAttribute_ (f, this),
  Matrix3VertexAttribute_ (f, this),
  Matrix4VertexAttribute_ (f, this),
  Color_ (f, this),
  ColorRGBA_ (f, this),
  FogCoordinate_ (f, this),
  Normal_ (f, this),
  TextureCoordinate_ (f, this),
  TextureCoordinate3D_ (f, this),
  TextureCoordinate4D_ (f, this),
  TextureCoordinateGenerator_ (f, this),
  MultiTextureCoordinate_ (f, this),
  NurbsTextureCoordinate_ (f, this),
  ProtoInstance_ (f, this),
  height_ (f, this),
  ccw_ (f, this),
  colorPerVertex_ (f, this),
  creaseAngle_ (f, this),
  normalPerVertex_ (f, this),
  solid_ (f, this),
  xDimension_ (f, this),
  xSpacing_ (f, this),
  zDimension_ (f, this),
  zSpacing_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ElevationGrid::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // FloatVertexAttribute
    //
    if (n.name () == "FloatVertexAttribute" && n.namespace_ () == "")
    {
      ::std::auto_ptr< FloatVertexAttribute_type > r (
        FloatVertexAttribute_traits::create (i, f, this));

      this->FloatVertexAttribute ().push_back (r);
      continue;
    }

    // Matrix3VertexAttribute
    //
    if (n.name () == "Matrix3VertexAttribute" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Matrix3VertexAttribute_type > r (
        Matrix3VertexAttribute_traits::create (i, f, this));

      this->Matrix3VertexAttribute ().push_back (r);
      continue;
    }

    // Matrix4VertexAttribute
    //
    if (n.name () == "Matrix4VertexAttribute" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Matrix4VertexAttribute_type > r (
        Matrix4VertexAttribute_traits::create (i, f, this));

      this->Matrix4VertexAttribute ().push_back (r);
      continue;
    }

    // Color
    //
    if (n.name () == "Color" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Color_type > r (
        Color_traits::create (i, f, this));

      this->Color ().push_back (r);
      continue;
    }

    // ColorRGBA
    //
    if (n.name () == "ColorRGBA" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ColorRGBA_type > r (
        ColorRGBA_traits::create (i, f, this));

      this->ColorRGBA ().push_back (r);
      continue;
    }

    // FogCoordinate
    //
    if (n.name () == "FogCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< FogCoordinate_type > r (
        FogCoordinate_traits::create (i, f, this));

      this->FogCoordinate ().push_back (r);
      continue;
    }

    // Normal
    //
    if (n.name () == "Normal" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Normal_type > r (
        Normal_traits::create (i, f, this));

      this->Normal ().push_back (r);
      continue;
    }

    // TextureCoordinate
    //
    if (n.name () == "TextureCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureCoordinate_type > r (
        TextureCoordinate_traits::create (i, f, this));

      this->TextureCoordinate ().push_back (r);
      continue;
    }

    // TextureCoordinate3D
    //
    if (n.name () == "TextureCoordinate3D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureCoordinate3D_type > r (
        TextureCoordinate3D_traits::create (i, f, this));

      this->TextureCoordinate3D ().push_back (r);
      continue;
    }

    // TextureCoordinate4D
    //
    if (n.name () == "TextureCoordinate4D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureCoordinate4D_type > r (
        TextureCoordinate4D_traits::create (i, f, this));

      this->TextureCoordinate4D ().push_back (r);
      continue;
    }

    // TextureCoordinateGenerator
    //
    if (n.name () == "TextureCoordinateGenerator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureCoordinateGenerator_type > r (
        TextureCoordinateGenerator_traits::create (i, f, this));

      this->TextureCoordinateGenerator ().push_back (r);
      continue;
    }

    // MultiTextureCoordinate
    //
    if (n.name () == "MultiTextureCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MultiTextureCoordinate_type > r (
        MultiTextureCoordinate_traits::create (i, f, this));

      this->MultiTextureCoordinate ().push_back (r);
      continue;
    }

    // NurbsTextureCoordinate
    //
    if (n.name () == "NurbsTextureCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsTextureCoordinate_type > r (
        NurbsTextureCoordinate_traits::create (i, f, this));

      this->NurbsTextureCoordinate ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< height_type > r (
        height_traits::create (i, f, this));

      this->height (r);
      continue;
    }

    if (n.name () == "ccw" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ccw_type > r (
        ccw_traits::create (i, f, this));

      this->ccw (r);
      continue;
    }

    if (n.name () == "colorPerVertex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< colorPerVertex_type > r (
        colorPerVertex_traits::create (i, f, this));

      this->colorPerVertex (r);
      continue;
    }

    if (n.name () == "creaseAngle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< creaseAngle_type > r (
        creaseAngle_traits::create (i, f, this));

      this->creaseAngle (r);
      continue;
    }

    if (n.name () == "normalPerVertex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< normalPerVertex_type > r (
        normalPerVertex_traits::create (i, f, this));

      this->normalPerVertex (r);
      continue;
    }

    if (n.name () == "solid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< solid_type > r (
        solid_traits::create (i, f, this));

      this->solid (r);
      continue;
    }

    if (n.name () == "xDimension" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xDimension_type > r (
        xDimension_traits::create (i, f, this));

      this->xDimension (r);
      continue;
    }

    if (n.name () == "xSpacing" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xSpacing_type > r (
        xSpacing_traits::create (i, f, this));

      this->xSpacing (r);
      continue;
    }

    if (n.name () == "zDimension" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< zDimension_type > r (
        zDimension_traits::create (i, f, this));

      this->zDimension (r);
      continue;
    }

    if (n.name () == "zSpacing" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< zSpacing_type > r (
        zSpacing_traits::create (i, f, this));

      this->zSpacing (r);
      continue;
    }
  }

  if (!ccw_.present ())
  {
    ::std::auto_ptr< ccw_type > r (
      ccw_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->ccw (r);
  }

  if (!colorPerVertex_.present ())
  {
    ::std::auto_ptr< colorPerVertex_type > r (
      colorPerVertex_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->colorPerVertex (r);
  }

  if (!creaseAngle_.present ())
  {
    ::std::auto_ptr< creaseAngle_type > r (
      creaseAngle_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->creaseAngle (r);
  }

  if (!normalPerVertex_.present ())
  {
    ::std::auto_ptr< normalPerVertex_type > r (
      normalPerVertex_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->normalPerVertex (r);
  }

  if (!solid_.present ())
  {
    ::std::auto_ptr< solid_type > r (
      solid_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->solid (r);
  }

  if (!xDimension_.present ())
  {
    ::std::auto_ptr< xDimension_type > r (
      xDimension_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->xDimension (r);
  }

  if (!xSpacing_.present ())
  {
    ::std::auto_ptr< xSpacing_type > r (
      xSpacing_traits::create (
        ::std::string ("1.0"),
        &p.element (), f, this));

    this->xSpacing (r);
  }

  if (!zDimension_.present ())
  {
    ::std::auto_ptr< zDimension_type > r (
      zDimension_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->zDimension (r);
  }

  if (!zSpacing_.present ())
  {
    ::std::auto_ptr< zSpacing_type > r (
      zSpacing_traits::create (
        ::std::string ("1.0"),
        &p.element (), f, this));

    this->zSpacing (r);
  }
}

ElevationGrid* ElevationGrid::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ElevationGrid (*this, f, c);
}

ElevationGrid::
~ElevationGrid ()
{
}

// Extrusion
//

const Extrusion::beginCap_type Extrusion::beginCap_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const Extrusion::ccw_type Extrusion::ccw_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const Extrusion::convex_type Extrusion::convex_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const Extrusion::creaseAngle_type Extrusion::creaseAngle_default_value_ (
  ::std::string ("0.0"), 0, 0, 0);

const Extrusion::crossSection_type Extrusion::crossSection_default_value_ (
  ::std::string ("1 1 1 -1 -1 -1 -1 1 1 1"), 0, 0, 0);

const Extrusion::endCap_type Extrusion::endCap_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const Extrusion::orientation_type Extrusion::orientation_default_value_ (
  ::std::string ("0 0 1 0"), 0, 0, 0);

const Extrusion::scale_type Extrusion::scale_default_value_ (
  ::std::string ("1 1"), 0, 0, 0);

const Extrusion::solid_type Extrusion::solid_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const Extrusion::spine_type Extrusion::spine_default_value_ (
  ::std::string ("0 0 0 0 1 0"), 0, 0, 0);

Extrusion::
Extrusion ()
: ::X3DGeometryNode (),
  beginCap_ (beginCap_default_value (), ::xml_schema::flags (), this),
  ccw_ (ccw_default_value (), ::xml_schema::flags (), this),
  convex_ (convex_default_value (), ::xml_schema::flags (), this),
  creaseAngle_ (creaseAngle_default_value (), ::xml_schema::flags (), this),
  crossSection_ (crossSection_default_value (), ::xml_schema::flags (), this),
  endCap_ (endCap_default_value (), ::xml_schema::flags (), this),
  orientation_ (orientation_default_value (), ::xml_schema::flags (), this),
  scale_ (scale_default_value (), ::xml_schema::flags (), this),
  solid_ (solid_default_value (), ::xml_schema::flags (), this),
  spine_ (spine_default_value (), ::xml_schema::flags (), this)
{
}

Extrusion::
Extrusion (const Extrusion& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  beginCap_ (x.beginCap_, f, this),
  ccw_ (x.ccw_, f, this),
  convex_ (x.convex_, f, this),
  creaseAngle_ (x.creaseAngle_, f, this),
  crossSection_ (x.crossSection_, f, this),
  endCap_ (x.endCap_, f, this),
  orientation_ (x.orientation_, f, this),
  scale_ (x.scale_, f, this),
  solid_ (x.solid_, f, this),
  spine_ (x.spine_, f, this)
{
}

Extrusion::
Extrusion (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  beginCap_ (f, this),
  ccw_ (f, this),
  convex_ (f, this),
  creaseAngle_ (f, this),
  crossSection_ (f, this),
  endCap_ (f, this),
  orientation_ (f, this),
  scale_ (f, this),
  solid_ (f, this),
  spine_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Extrusion::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "beginCap" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< beginCap_type > r (
        beginCap_traits::create (i, f, this));

      this->beginCap (r);
      continue;
    }

    if (n.name () == "ccw" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ccw_type > r (
        ccw_traits::create (i, f, this));

      this->ccw (r);
      continue;
    }

    if (n.name () == "convex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< convex_type > r (
        convex_traits::create (i, f, this));

      this->convex (r);
      continue;
    }

    if (n.name () == "creaseAngle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< creaseAngle_type > r (
        creaseAngle_traits::create (i, f, this));

      this->creaseAngle (r);
      continue;
    }

    if (n.name () == "crossSection" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< crossSection_type > r (
        crossSection_traits::create (i, f, this));

      this->crossSection (r);
      continue;
    }

    if (n.name () == "endCap" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< endCap_type > r (
        endCap_traits::create (i, f, this));

      this->endCap (r);
      continue;
    }

    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< orientation_type > r (
        orientation_traits::create (i, f, this));

      this->orientation (r);
      continue;
    }

    if (n.name () == "scale" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< scale_type > r (
        scale_traits::create (i, f, this));

      this->scale (r);
      continue;
    }

    if (n.name () == "solid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< solid_type > r (
        solid_traits::create (i, f, this));

      this->solid (r);
      continue;
    }

    if (n.name () == "spine" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< spine_type > r (
        spine_traits::create (i, f, this));

      this->spine (r);
      continue;
    }
  }

  if (!beginCap_.present ())
  {
    ::std::auto_ptr< beginCap_type > r (
      beginCap_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->beginCap (r);
  }

  if (!ccw_.present ())
  {
    ::std::auto_ptr< ccw_type > r (
      ccw_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->ccw (r);
  }

  if (!convex_.present ())
  {
    ::std::auto_ptr< convex_type > r (
      convex_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->convex (r);
  }

  if (!creaseAngle_.present ())
  {
    ::std::auto_ptr< creaseAngle_type > r (
      creaseAngle_traits::create (
        ::std::string ("0.0"),
        &p.element (), f, this));

    this->creaseAngle (r);
  }

  if (!crossSection_.present ())
  {
    ::std::auto_ptr< crossSection_type > r (
      crossSection_traits::create (
        ::std::string ("1 1 1 -1 -1 -1 -1 1 1 1"),
        &p.element (), f, this));

    this->crossSection (r);
  }

  if (!endCap_.present ())
  {
    ::std::auto_ptr< endCap_type > r (
      endCap_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->endCap (r);
  }

  if (!orientation_.present ())
  {
    ::std::auto_ptr< orientation_type > r (
      orientation_traits::create (
        ::std::string ("0 0 1 0"),
        &p.element (), f, this));

    this->orientation (r);
  }

  if (!scale_.present ())
  {
    ::std::auto_ptr< scale_type > r (
      scale_traits::create (
        ::std::string ("1 1"),
        &p.element (), f, this));

    this->scale (r);
  }

  if (!solid_.present ())
  {
    ::std::auto_ptr< solid_type > r (
      solid_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->solid (r);
  }

  if (!spine_.present ())
  {
    ::std::auto_ptr< spine_type > r (
      spine_traits::create (
        ::std::string ("0 0 0 0 1 0"),
        &p.element (), f, this));

    this->spine (r);
  }
}

Extrusion* Extrusion::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Extrusion (*this, f, c);
}

Extrusion::
~Extrusion ()
{
}

// FillProperties
//

const FillProperties::filled_type FillProperties::filled_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const FillProperties::hatched_type FillProperties::hatched_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const FillProperties::hatchStyle_type FillProperties::hatchStyle_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const FillProperties::hatchColor_type FillProperties::hatchColor_default_value_ (
  ::std::string ("1 1 1"), 0, 0, 0);

const FillProperties::containerField_type FillProperties::containerField_default_value_ (
  ::std::string ("fillProperties"), 0, 0, 0);

FillProperties::
FillProperties ()
: ::X3DAppearanceChildNode (),
  filled_ (filled_default_value (), ::xml_schema::flags (), this),
  hatched_ (hatched_default_value (), ::xml_schema::flags (), this),
  hatchStyle_ (hatchStyle_default_value (), ::xml_schema::flags (), this),
  hatchColor_ (hatchColor_default_value (), ::xml_schema::flags (), this),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

FillProperties::
FillProperties (const FillProperties& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DAppearanceChildNode (x, f, c),
  filled_ (x.filled_, f, this),
  hatched_ (x.hatched_, f, this),
  hatchStyle_ (x.hatchStyle_, f, this),
  hatchColor_ (x.hatchColor_, f, this),
  containerField_ (x.containerField_, f, this)
{
}

FillProperties::
FillProperties (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DAppearanceChildNode (e, f | ::xml_schema::flags::base, c),
  filled_ (f, this),
  hatched_ (f, this),
  hatchStyle_ (f, this),
  hatchColor_ (f, this),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void FillProperties::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DAppearanceChildNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "filled" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< filled_type > r (
        filled_traits::create (i, f, this));

      this->filled (r);
      continue;
    }

    if (n.name () == "hatched" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< hatched_type > r (
        hatched_traits::create (i, f, this));

      this->hatched (r);
      continue;
    }

    if (n.name () == "hatchStyle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< hatchStyle_type > r (
        hatchStyle_traits::create (i, f, this));

      this->hatchStyle (r);
      continue;
    }

    if (n.name () == "hatchColor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< hatchColor_type > r (
        hatchColor_traits::create (i, f, this));

      this->hatchColor (r);
      continue;
    }

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!filled_.present ())
  {
    ::std::auto_ptr< filled_type > r (
      filled_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->filled (r);
  }

  if (!hatched_.present ())
  {
    ::std::auto_ptr< hatched_type > r (
      hatched_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->hatched (r);
  }

  if (!hatchStyle_.present ())
  {
    ::std::auto_ptr< hatchStyle_type > r (
      hatchStyle_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->hatchStyle (r);
  }

  if (!hatchColor_.present ())
  {
    ::std::auto_ptr< hatchColor_type > r (
      hatchColor_traits::create (
        ::std::string ("1 1 1"),
        &p.element (), f, this));

    this->hatchColor (r);
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("fillProperties"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

FillProperties* FillProperties::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new FillProperties (*this, f, c);
}

FillProperties::
~FillProperties ()
{
}

// Fog
//

const Fog::color_type Fog::color_default_value_ (
  ::std::string ("1 1 1"), 0, 0, 0);

const Fog::fogType_type Fog::fogType_default_value_ (
  ::std::string ("LINEAR"), 0, 0, 0);

const Fog::visibilityRange_type Fog::visibilityRange_default_value_ (
  ::std::string ("0"), 0, 0, 0);

Fog::
Fog ()
: ::X3DBindableNode (),
  color_ (color_default_value (), ::xml_schema::flags (), this),
  fogType_ (fogType_default_value (), ::xml_schema::flags (), this),
  visibilityRange_ (visibilityRange_default_value (), ::xml_schema::flags (), this)
{
}

Fog::
Fog (const Fog& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::X3DBindableNode (x, f, c),
  color_ (x.color_, f, this),
  fogType_ (x.fogType_, f, this),
  visibilityRange_ (x.visibilityRange_, f, this)
{
}

Fog::
Fog (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::X3DBindableNode (e, f | ::xml_schema::flags::base, c),
  color_ (f, this),
  fogType_ (f, this),
  visibilityRange_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Fog::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DBindableNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< color_type > r (
        color_traits::create (i, f, this));

      this->color (r);
      continue;
    }

    if (n.name () == "fogType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< fogType_type > r (
        fogType_traits::create (i, f, this));

      this->fogType (r);
      continue;
    }

    if (n.name () == "visibilityRange" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< visibilityRange_type > r (
        visibilityRange_traits::create (i, f, this));

      this->visibilityRange (r);
      continue;
    }
  }

  if (!color_.present ())
  {
    ::std::auto_ptr< color_type > r (
      color_traits::create (
        ::std::string ("1 1 1"),
        &p.element (), f, this));

    this->color (r);
  }

  if (!fogType_.present ())
  {
    ::std::auto_ptr< fogType_type > r (
      fogType_traits::create (
        ::std::string ("LINEAR"),
        &p.element (), f, this));

    this->fogType (r);
  }

  if (!visibilityRange_.present ())
  {
    ::std::auto_ptr< visibilityRange_type > r (
      visibilityRange_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->visibilityRange (r);
  }
}

Fog* Fog::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Fog (*this, f, c);
}

Fog::
~Fog ()
{
}

// FogCoordinate
//

const FogCoordinate::containerField_type FogCoordinate::containerField_default_value_ (
  ::std::string ("fogCoord"), 0, 0, 0);

FogCoordinate::
FogCoordinate ()
: ::X3DCoordinateNode (),
  depth_ (::xml_schema::flags (), this),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

FogCoordinate::
FogCoordinate (const FogCoordinate& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DCoordinateNode (x, f, c),
  depth_ (x.depth_, f, this),
  containerField_ (x.containerField_, f, this)
{
}

FogCoordinate::
FogCoordinate (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DCoordinateNode (e, f | ::xml_schema::flags::base, c),
  depth_ (f, this),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void FogCoordinate::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DCoordinateNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "depth" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< depth_type > r (
        depth_traits::create (i, f, this));

      this->depth (r);
      continue;
    }

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("fogCoord"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

FogCoordinate* FogCoordinate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new FogCoordinate (*this, f, c);
}

FogCoordinate::
~FogCoordinate ()
{
}

// FontStyle
//

const FontStyle::family_type FontStyle::family_default_value_ (
  ::std::string ("\"SERIF\""), 0, 0, 0);

const FontStyle::horizontal_type FontStyle::horizontal_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const FontStyle::justify_type FontStyle::justify_default_value_ (
  ::std::string ("\"BEGIN\""), 0, 0, 0);

const FontStyle::leftToRight_type FontStyle::leftToRight_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const FontStyle::size_type FontStyle::size_default_value_ (
  ::std::string ("1.0"), 0, 0, 0);

const FontStyle::spacing_type FontStyle::spacing_default_value_ (
  ::std::string ("1.0"), 0, 0, 0);

const FontStyle::style_type FontStyle::style_default_value_ (
  ::std::string ("PLAIN"), 0, 0, 0);

const FontStyle::topToBottom_type FontStyle::topToBottom_default_value_ (
  ::std::string ("true"), 0, 0, 0);

FontStyle::
FontStyle ()
: ::X3DFontStyleNode (),
  family_ (family_default_value (), ::xml_schema::flags (), this),
  horizontal_ (horizontal_default_value (), ::xml_schema::flags (), this),
  justify_ (justify_default_value (), ::xml_schema::flags (), this),
  language_ (::xml_schema::flags (), this),
  leftToRight_ (leftToRight_default_value (), ::xml_schema::flags (), this),
  size_ (size_default_value (), ::xml_schema::flags (), this),
  spacing_ (spacing_default_value (), ::xml_schema::flags (), this),
  style_ (style_default_value (), ::xml_schema::flags (), this),
  topToBottom_ (topToBottom_default_value (), ::xml_schema::flags (), this)
{
}

FontStyle::
FontStyle (const FontStyle& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DFontStyleNode (x, f, c),
  family_ (x.family_, f, this),
  horizontal_ (x.horizontal_, f, this),
  justify_ (x.justify_, f, this),
  language_ (x.language_, f, this),
  leftToRight_ (x.leftToRight_, f, this),
  size_ (x.size_, f, this),
  spacing_ (x.spacing_, f, this),
  style_ (x.style_, f, this),
  topToBottom_ (x.topToBottom_, f, this)
{
}

FontStyle::
FontStyle (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DFontStyleNode (e, f | ::xml_schema::flags::base, c),
  family_ (f, this),
  horizontal_ (f, this),
  justify_ (f, this),
  language_ (f, this),
  leftToRight_ (f, this),
  size_ (f, this),
  spacing_ (f, this),
  style_ (f, this),
  topToBottom_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void FontStyle::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DFontStyleNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "family" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< family_type > r (
        family_traits::create (i, f, this));

      this->family (r);
      continue;
    }

    if (n.name () == "horizontal" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< horizontal_type > r (
        horizontal_traits::create (i, f, this));

      this->horizontal (r);
      continue;
    }

    if (n.name () == "justify" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< justify_type > r (
        justify_traits::create (i, f, this));

      this->justify (r);
      continue;
    }

    if (n.name () == "language" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< language_type > r (
        language_traits::create (i, f, this));

      this->language (r);
      continue;
    }

    if (n.name () == "leftToRight" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< leftToRight_type > r (
        leftToRight_traits::create (i, f, this));

      this->leftToRight (r);
      continue;
    }

    if (n.name () == "size" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< size_type > r (
        size_traits::create (i, f, this));

      this->size (r);
      continue;
    }

    if (n.name () == "spacing" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< spacing_type > r (
        spacing_traits::create (i, f, this));

      this->spacing (r);
      continue;
    }

    if (n.name () == "style" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< style_type > r (
        style_traits::create (i, f, this));

      this->style (r);
      continue;
    }

    if (n.name () == "topToBottom" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< topToBottom_type > r (
        topToBottom_traits::create (i, f, this));

      this->topToBottom (r);
      continue;
    }
  }

  if (!family_.present ())
  {
    ::std::auto_ptr< family_type > r (
      family_traits::create (
        ::std::string ("\"SERIF\""),
        &p.element (), f, this));

    this->family (r);
  }

  if (!horizontal_.present ())
  {
    ::std::auto_ptr< horizontal_type > r (
      horizontal_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->horizontal (r);
  }

  if (!justify_.present ())
  {
    ::std::auto_ptr< justify_type > r (
      justify_traits::create (
        ::std::string ("\"BEGIN\""),
        &p.element (), f, this));

    this->justify (r);
  }

  if (!leftToRight_.present ())
  {
    ::std::auto_ptr< leftToRight_type > r (
      leftToRight_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->leftToRight (r);
  }

  if (!size_.present ())
  {
    ::std::auto_ptr< size_type > r (
      size_traits::create (
        ::std::string ("1.0"),
        &p.element (), f, this));

    this->size (r);
  }

  if (!spacing_.present ())
  {
    ::std::auto_ptr< spacing_type > r (
      spacing_traits::create (
        ::std::string ("1.0"),
        &p.element (), f, this));

    this->spacing (r);
  }

  if (!style_.present ())
  {
    ::std::auto_ptr< style_type > r (
      style_traits::create (
        ::std::string ("PLAIN"),
        &p.element (), f, this));

    this->style (r);
  }

  if (!topToBottom_.present ())
  {
    ::std::auto_ptr< topToBottom_type > r (
      topToBottom_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->topToBottom (r);
  }
}

FontStyle* FontStyle::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new FontStyle (*this, f, c);
}

FontStyle::
~FontStyle ()
{
}

// Group
//

Group::
Group ()
: ::X3DGroupingNode ()
{
}

Group::
Group (const Group& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c)
{
}

Group::
Group (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::X3DGroupingNode (e, f, c)
{
}

Group* Group::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Group (*this, f, c);
}

Group::
~Group ()
{
}

// ImageTexture
//

ImageTexture::
ImageTexture ()
: ::X3DTexture2DNode (),
  url_ (::xml_schema::flags (), this)
{
}

ImageTexture::
ImageTexture (const ImageTexture& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DTexture2DNode (x, f, c),
  url_ (x.url_, f, this)
{
}

ImageTexture::
ImageTexture (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DTexture2DNode (e, f | ::xml_schema::flags::base, c),
  url_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ImageTexture::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTexture2DNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< url_type > r (
        url_traits::create (i, f, this));

      this->url (r);
      continue;
    }
  }
}

ImageTexture* ImageTexture::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ImageTexture (*this, f, c);
}

ImageTexture::
~ImageTexture ()
{
}

// IndexedFaceSet
//

const IndexedFaceSet::convex_type IndexedFaceSet::convex_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const IndexedFaceSet::creaseAngle_type IndexedFaceSet::creaseAngle_default_value_ (
  ::std::string ("0"), 0, 0, 0);

IndexedFaceSet::
IndexedFaceSet ()
: ::X3DComposedGeometryNode (),
  convex_ (convex_default_value (), ::xml_schema::flags (), this),
  creaseAngle_ (creaseAngle_default_value (), ::xml_schema::flags (), this),
  colorIndex_ (::xml_schema::flags (), this),
  coordIndex_ (::xml_schema::flags (), this),
  normalIndex_ (::xml_schema::flags (), this),
  texCoordIndex_ (::xml_schema::flags (), this)
{
}

IndexedFaceSet::
IndexedFaceSet (const IndexedFaceSet& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DComposedGeometryNode (x, f, c),
  convex_ (x.convex_, f, this),
  creaseAngle_ (x.creaseAngle_, f, this),
  colorIndex_ (x.colorIndex_, f, this),
  coordIndex_ (x.coordIndex_, f, this),
  normalIndex_ (x.normalIndex_, f, this),
  texCoordIndex_ (x.texCoordIndex_, f, this)
{
}

IndexedFaceSet::
IndexedFaceSet (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DComposedGeometryNode (e, f | ::xml_schema::flags::base, c),
  convex_ (f, this),
  creaseAngle_ (f, this),
  colorIndex_ (f, this),
  coordIndex_ (f, this),
  normalIndex_ (f, this),
  texCoordIndex_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void IndexedFaceSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DComposedGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "convex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< convex_type > r (
        convex_traits::create (i, f, this));

      this->convex (r);
      continue;
    }

    if (n.name () == "creaseAngle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< creaseAngle_type > r (
        creaseAngle_traits::create (i, f, this));

      this->creaseAngle (r);
      continue;
    }

    if (n.name () == "colorIndex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< colorIndex_type > r (
        colorIndex_traits::create (i, f, this));

      this->colorIndex (r);
      continue;
    }

    if (n.name () == "coordIndex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< coordIndex_type > r (
        coordIndex_traits::create (i, f, this));

      this->coordIndex (r);
      continue;
    }

    if (n.name () == "normalIndex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< normalIndex_type > r (
        normalIndex_traits::create (i, f, this));

      this->normalIndex (r);
      continue;
    }

    if (n.name () == "texCoordIndex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< texCoordIndex_type > r (
        texCoordIndex_traits::create (i, f, this));

      this->texCoordIndex (r);
      continue;
    }
  }

  if (!convex_.present ())
  {
    ::std::auto_ptr< convex_type > r (
      convex_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->convex (r);
  }

  if (!creaseAngle_.present ())
  {
    ::std::auto_ptr< creaseAngle_type > r (
      creaseAngle_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->creaseAngle (r);
  }
}

IndexedFaceSet* IndexedFaceSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new IndexedFaceSet (*this, f, c);
}

IndexedFaceSet::
~IndexedFaceSet ()
{
}

// IndexedLineSet
//

const IndexedLineSet::colorPerVertex_type IndexedLineSet::colorPerVertex_default_value_ (
  ::std::string ("true"), 0, 0, 0);

IndexedLineSet::
IndexedLineSet ()
: ::X3DGeometryNode (),
  Color_ (::xml_schema::flags (), this),
  ColorRGBA_ (::xml_schema::flags (), this),
  Coordinate_ (::xml_schema::flags (), this),
  CoordinateDouble_ (::xml_schema::flags (), this),
  GeoCoordinate_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  colorPerVertex_ (colorPerVertex_default_value (), ::xml_schema::flags (), this),
  colorIndex_ (::xml_schema::flags (), this),
  coordIndex_ (::xml_schema::flags (), this)
{
}

IndexedLineSet::
IndexedLineSet (const IndexedLineSet& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  Color_ (x.Color_, f, this),
  ColorRGBA_ (x.ColorRGBA_, f, this),
  Coordinate_ (x.Coordinate_, f, this),
  CoordinateDouble_ (x.CoordinateDouble_, f, this),
  GeoCoordinate_ (x.GeoCoordinate_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  colorPerVertex_ (x.colorPerVertex_, f, this),
  colorIndex_ (x.colorIndex_, f, this),
  coordIndex_ (x.coordIndex_, f, this)
{
}

IndexedLineSet::
IndexedLineSet (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  Color_ (f, this),
  ColorRGBA_ (f, this),
  Coordinate_ (f, this),
  CoordinateDouble_ (f, this),
  GeoCoordinate_ (f, this),
  ProtoInstance_ (f, this),
  colorPerVertex_ (f, this),
  colorIndex_ (f, this),
  coordIndex_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void IndexedLineSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Color
    //
    if (n.name () == "Color" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Color_type > r (
        Color_traits::create (i, f, this));

      if (!this->Color ())
      {
        this->Color (r);
        continue;
      }
    }

    // ColorRGBA
    //
    if (n.name () == "ColorRGBA" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ColorRGBA_type > r (
        ColorRGBA_traits::create (i, f, this));

      if (!this->ColorRGBA ())
      {
        this->ColorRGBA (r);
        continue;
      }
    }

    // Coordinate
    //
    if (n.name () == "Coordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Coordinate_type > r (
        Coordinate_traits::create (i, f, this));

      if (!this->Coordinate ())
      {
        this->Coordinate (r);
        continue;
      }
    }

    // CoordinateDouble
    //
    if (n.name () == "CoordinateDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateDouble_type > r (
        CoordinateDouble_traits::create (i, f, this));

      if (!this->CoordinateDouble ())
      {
        this->CoordinateDouble (r);
        continue;
      }
    }

    // GeoCoordinate
    //
    if (n.name () == "GeoCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoCoordinate_type > r (
        GeoCoordinate_traits::create (i, f, this));

      if (!this->GeoCoordinate ())
      {
        this->GeoCoordinate (r);
        continue;
      }
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "colorPerVertex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< colorPerVertex_type > r (
        colorPerVertex_traits::create (i, f, this));

      this->colorPerVertex (r);
      continue;
    }

    if (n.name () == "colorIndex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< colorIndex_type > r (
        colorIndex_traits::create (i, f, this));

      this->colorIndex (r);
      continue;
    }

    if (n.name () == "coordIndex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< coordIndex_type > r (
        coordIndex_traits::create (i, f, this));

      this->coordIndex (r);
      continue;
    }
  }

  if (!colorPerVertex_.present ())
  {
    ::std::auto_ptr< colorPerVertex_type > r (
      colorPerVertex_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->colorPerVertex (r);
  }
}

IndexedLineSet* IndexedLineSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new IndexedLineSet (*this, f, c);
}

IndexedLineSet::
~IndexedLineSet ()
{
}

// IndexedTriangleFanSet
//

IndexedTriangleFanSet::
IndexedTriangleFanSet ()
: ::X3DComposedGeometryNode (),
  index_ (::xml_schema::flags (), this)
{
}

IndexedTriangleFanSet::
IndexedTriangleFanSet (const IndexedTriangleFanSet& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::X3DComposedGeometryNode (x, f, c),
  index_ (x.index_, f, this)
{
}

IndexedTriangleFanSet::
IndexedTriangleFanSet (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::X3DComposedGeometryNode (e, f | ::xml_schema::flags::base, c),
  index_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void IndexedTriangleFanSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DComposedGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "index" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< index_type > r (
        index_traits::create (i, f, this));

      this->index (r);
      continue;
    }
  }
}

IndexedTriangleFanSet* IndexedTriangleFanSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new IndexedTriangleFanSet (*this, f, c);
}

IndexedTriangleFanSet::
~IndexedTriangleFanSet ()
{
}

// IndexedTriangleSet
//

IndexedTriangleSet::
IndexedTriangleSet ()
: ::X3DComposedGeometryNode (),
  index_ (::xml_schema::flags (), this)
{
}

IndexedTriangleSet::
IndexedTriangleSet (const IndexedTriangleSet& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::X3DComposedGeometryNode (x, f, c),
  index_ (x.index_, f, this)
{
}

IndexedTriangleSet::
IndexedTriangleSet (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::X3DComposedGeometryNode (e, f | ::xml_schema::flags::base, c),
  index_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void IndexedTriangleSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DComposedGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "index" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< index_type > r (
        index_traits::create (i, f, this));

      this->index (r);
      continue;
    }
  }
}

IndexedTriangleSet* IndexedTriangleSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new IndexedTriangleSet (*this, f, c);
}

IndexedTriangleSet::
~IndexedTriangleSet ()
{
}

// IndexedTriangleStripSet
//

IndexedTriangleStripSet::
IndexedTriangleStripSet ()
: ::X3DComposedGeometryNode (),
  index_ (::xml_schema::flags (), this)
{
}

IndexedTriangleStripSet::
IndexedTriangleStripSet (const IndexedTriangleStripSet& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::X3DComposedGeometryNode (x, f, c),
  index_ (x.index_, f, this)
{
}

IndexedTriangleStripSet::
IndexedTriangleStripSet (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::X3DComposedGeometryNode (e, f | ::xml_schema::flags::base, c),
  index_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void IndexedTriangleStripSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DComposedGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "index" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< index_type > r (
        index_traits::create (i, f, this));

      this->index (r);
      continue;
    }
  }
}

IndexedTriangleStripSet* IndexedTriangleStripSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new IndexedTriangleStripSet (*this, f, c);
}

IndexedTriangleStripSet::
~IndexedTriangleStripSet ()
{
}

// Inline
//

const Inline::load_type Inline::load_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const Inline::bboxCenter_type Inline::bboxCenter_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const Inline::bboxSize_type Inline::bboxSize_default_value_ (
  ::std::string ("-1 -1 -1"), 0, 0, 0);

Inline::
Inline ()
: ::X3DChildNode (),
  load_ (load_default_value (), ::xml_schema::flags (), this),
  bboxCenter_ (bboxCenter_default_value (), ::xml_schema::flags (), this),
  bboxSize_ (bboxSize_default_value (), ::xml_schema::flags (), this),
  url_ (::xml_schema::flags (), this)
{
}

Inline::
Inline (const Inline& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::X3DChildNode (x, f, c),
  load_ (x.load_, f, this),
  bboxCenter_ (x.bboxCenter_, f, this),
  bboxSize_ (x.bboxSize_, f, this),
  url_ (x.url_, f, this)
{
}

Inline::
Inline (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::X3DChildNode (e, f | ::xml_schema::flags::base, c),
  load_ (f, this),
  bboxCenter_ (f, this),
  bboxSize_ (f, this),
  url_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Inline::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DChildNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "load" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< load_type > r (
        load_traits::create (i, f, this));

      this->load (r);
      continue;
    }

    if (n.name () == "bboxCenter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bboxCenter_type > r (
        bboxCenter_traits::create (i, f, this));

      this->bboxCenter (r);
      continue;
    }

    if (n.name () == "bboxSize" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bboxSize_type > r (
        bboxSize_traits::create (i, f, this));

      this->bboxSize (r);
      continue;
    }

    if (n.name () == "url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< url_type > r (
        url_traits::create (i, f, this));

      this->url (r);
      continue;
    }
  }

  if (!load_.present ())
  {
    ::std::auto_ptr< load_type > r (
      load_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->load (r);
  }

  if (!bboxCenter_.present ())
  {
    ::std::auto_ptr< bboxCenter_type > r (
      bboxCenter_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->bboxCenter (r);
  }

  if (!bboxSize_.present ())
  {
    ::std::auto_ptr< bboxSize_type > r (
      bboxSize_traits::create (
        ::std::string ("-1 -1 -1"),
        &p.element (), f, this));

    this->bboxSize (r);
  }
}

Inline* Inline::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Inline (*this, f, c);
}

Inline::
~Inline ()
{
}

// IntegerSequencer
//

IntegerSequencer::
IntegerSequencer ()
: ::X3DSequencerNode (),
  keyValue_ (::xml_schema::flags (), this)
{
}

IntegerSequencer::
IntegerSequencer (const IntegerSequencer& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DSequencerNode (x, f, c),
  keyValue_ (x.keyValue_, f, this)
{
}

IntegerSequencer::
IntegerSequencer (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DSequencerNode (e, f | ::xml_schema::flags::base, c),
  keyValue_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void IntegerSequencer::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DSequencerNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "keyValue" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< keyValue_type > r (
        keyValue_traits::create (i, f, this));

      this->keyValue (r);
      continue;
    }
  }
}

IntegerSequencer* IntegerSequencer::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new IntegerSequencer (*this, f, c);
}

IntegerSequencer::
~IntegerSequencer ()
{
}

// IntegerTrigger
//

const IntegerTrigger::integerKey_type IntegerTrigger::integerKey_default_value_ (
  ::std::string ("-1"), 0, 0, 0);

IntegerTrigger::
IntegerTrigger ()
: ::X3DChildNode (),
  integerKey_ (integerKey_default_value (), ::xml_schema::flags (), this)
{
}

IntegerTrigger::
IntegerTrigger (const IntegerTrigger& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DChildNode (x, f, c),
  integerKey_ (x.integerKey_, f, this)
{
}

IntegerTrigger::
IntegerTrigger (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DChildNode (e, f | ::xml_schema::flags::base, c),
  integerKey_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void IntegerTrigger::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DChildNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "integerKey" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< integerKey_type > r (
        integerKey_traits::create (i, f, this));

      this->integerKey (r);
      continue;
    }
  }

  if (!integerKey_.present ())
  {
    ::std::auto_ptr< integerKey_type > r (
      integerKey_traits::create (
        ::std::string ("-1"),
        &p.element (), f, this));

    this->integerKey (r);
  }
}

IntegerTrigger* IntegerTrigger::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new IntegerTrigger (*this, f, c);
}

IntegerTrigger::
~IntegerTrigger ()
{
}

// KeySensor
//

KeySensor::
KeySensor ()
: ::X3DKeyDeviceSensorNode ()
{
}

KeySensor::
KeySensor (const KeySensor& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DKeyDeviceSensorNode (x, f, c)
{
}

KeySensor::
KeySensor (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DKeyDeviceSensorNode (e, f, c)
{
}

KeySensor* KeySensor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new KeySensor (*this, f, c);
}

KeySensor::
~KeySensor ()
{
}

// LineProperties
//

const LineProperties::applied_type LineProperties::applied_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const LineProperties::linetype_type LineProperties::linetype_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const LineProperties::linewidthScaleFactor_type LineProperties::linewidthScaleFactor_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const LineProperties::containerField_type LineProperties::containerField_default_value_ (
  ::std::string ("lineProperties"), 0, 0, 0);

LineProperties::
LineProperties ()
: ::X3DAppearanceChildNode (),
  applied_ (applied_default_value (), ::xml_schema::flags (), this),
  linetype_ (linetype_default_value (), ::xml_schema::flags (), this),
  linewidthScaleFactor_ (linewidthScaleFactor_default_value (), ::xml_schema::flags (), this),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

LineProperties::
LineProperties (const LineProperties& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DAppearanceChildNode (x, f, c),
  applied_ (x.applied_, f, this),
  linetype_ (x.linetype_, f, this),
  linewidthScaleFactor_ (x.linewidthScaleFactor_, f, this),
  containerField_ (x.containerField_, f, this)
{
}

LineProperties::
LineProperties (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DAppearanceChildNode (e, f | ::xml_schema::flags::base, c),
  applied_ (f, this),
  linetype_ (f, this),
  linewidthScaleFactor_ (f, this),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void LineProperties::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DAppearanceChildNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "applied" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< applied_type > r (
        applied_traits::create (i, f, this));

      this->applied (r);
      continue;
    }

    if (n.name () == "linetype" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< linetype_type > r (
        linetype_traits::create (i, f, this));

      this->linetype (r);
      continue;
    }

    if (n.name () == "linewidthScaleFactor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< linewidthScaleFactor_type > r (
        linewidthScaleFactor_traits::create (i, f, this));

      this->linewidthScaleFactor (r);
      continue;
    }

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!applied_.present ())
  {
    ::std::auto_ptr< applied_type > r (
      applied_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->applied (r);
  }

  if (!linetype_.present ())
  {
    ::std::auto_ptr< linetype_type > r (
      linetype_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->linetype (r);
  }

  if (!linewidthScaleFactor_.present ())
  {
    ::std::auto_ptr< linewidthScaleFactor_type > r (
      linewidthScaleFactor_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->linewidthScaleFactor (r);
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("lineProperties"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

LineProperties* LineProperties::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new LineProperties (*this, f, c);
}

LineProperties::
~LineProperties ()
{
}

// LineSet
//

LineSet::
LineSet ()
: ::X3DGeometryNode (),
  Color_ (::xml_schema::flags (), this),
  ColorRGBA_ (::xml_schema::flags (), this),
  Coordinate_ (::xml_schema::flags (), this),
  CoordinateDouble_ (::xml_schema::flags (), this),
  GeoCoordinate_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  vertexCount_ (::xml_schema::flags (), this)
{
}

LineSet::
LineSet (const LineSet& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  Color_ (x.Color_, f, this),
  ColorRGBA_ (x.ColorRGBA_, f, this),
  Coordinate_ (x.Coordinate_, f, this),
  CoordinateDouble_ (x.CoordinateDouble_, f, this),
  GeoCoordinate_ (x.GeoCoordinate_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  vertexCount_ (x.vertexCount_, f, this)
{
}

LineSet::
LineSet (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  Color_ (f, this),
  ColorRGBA_ (f, this),
  Coordinate_ (f, this),
  CoordinateDouble_ (f, this),
  GeoCoordinate_ (f, this),
  ProtoInstance_ (f, this),
  vertexCount_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void LineSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Color
    //
    if (n.name () == "Color" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Color_type > r (
        Color_traits::create (i, f, this));

      if (!this->Color ())
      {
        this->Color (r);
        continue;
      }
    }

    // ColorRGBA
    //
    if (n.name () == "ColorRGBA" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ColorRGBA_type > r (
        ColorRGBA_traits::create (i, f, this));

      if (!this->ColorRGBA ())
      {
        this->ColorRGBA (r);
        continue;
      }
    }

    // Coordinate
    //
    if (n.name () == "Coordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Coordinate_type > r (
        Coordinate_traits::create (i, f, this));

      if (!this->Coordinate ())
      {
        this->Coordinate (r);
        continue;
      }
    }

    // CoordinateDouble
    //
    if (n.name () == "CoordinateDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateDouble_type > r (
        CoordinateDouble_traits::create (i, f, this));

      if (!this->CoordinateDouble ())
      {
        this->CoordinateDouble (r);
        continue;
      }
    }

    // GeoCoordinate
    //
    if (n.name () == "GeoCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoCoordinate_type > r (
        GeoCoordinate_traits::create (i, f, this));

      if (!this->GeoCoordinate ())
      {
        this->GeoCoordinate (r);
        continue;
      }
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "vertexCount" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vertexCount_type > r (
        vertexCount_traits::create (i, f, this));

      this->vertexCount (r);
      continue;
    }
  }
}

LineSet* LineSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new LineSet (*this, f, c);
}

LineSet::
~LineSet ()
{
}

// LoadSensor
//

const LoadSensor::timeOut_type LoadSensor::timeOut_default_value_ (
  ::std::string ("0"), 0, 0, 0);

LoadSensor::
LoadSensor ()
: ::X3DNetworkSensorNode (),
  timeOut_ (timeOut_default_value (), ::xml_schema::flags (), this)
{
}

LoadSensor::
LoadSensor (const LoadSensor& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DNetworkSensorNode (x, f, c),
  timeOut_ (x.timeOut_, f, this)
{
}

LoadSensor::
LoadSensor (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DNetworkSensorNode (e, f | ::xml_schema::flags::base, c),
  timeOut_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void LoadSensor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DNetworkSensorNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "timeOut" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< timeOut_type > r (
        timeOut_traits::create (i, f, this));

      this->timeOut (r);
      continue;
    }
  }

  if (!timeOut_.present ())
  {
    ::std::auto_ptr< timeOut_type > r (
      timeOut_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->timeOut (r);
  }
}

LoadSensor* LoadSensor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new LoadSensor (*this, f, c);
}

LoadSensor::
~LoadSensor ()
{
}

// LocalFog
//

const LocalFog::enabled_type LocalFog::enabled_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const LocalFog::color_type LocalFog::color_default_value_ (
  ::std::string ("1 1 1"), 0, 0, 0);

const LocalFog::fogType_type LocalFog::fogType_default_value_ (
  ::std::string ("LINEAR"), 0, 0, 0);

const LocalFog::visibilityRange_type LocalFog::visibilityRange_default_value_ (
  ::std::string ("0"), 0, 0, 0);

LocalFog::
LocalFog ()
: ::X3DBindableNode (),
  enabled_ (enabled_default_value (), ::xml_schema::flags (), this),
  color_ (color_default_value (), ::xml_schema::flags (), this),
  fogType_ (fogType_default_value (), ::xml_schema::flags (), this),
  visibilityRange_ (visibilityRange_default_value (), ::xml_schema::flags (), this)
{
}

LocalFog::
LocalFog (const LocalFog& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::X3DBindableNode (x, f, c),
  enabled_ (x.enabled_, f, this),
  color_ (x.color_, f, this),
  fogType_ (x.fogType_, f, this),
  visibilityRange_ (x.visibilityRange_, f, this)
{
}

LocalFog::
LocalFog (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::X3DBindableNode (e, f | ::xml_schema::flags::base, c),
  enabled_ (f, this),
  color_ (f, this),
  fogType_ (f, this),
  visibilityRange_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void LocalFog::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DBindableNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "enabled" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< enabled_type > r (
        enabled_traits::create (i, f, this));

      this->enabled (r);
      continue;
    }

    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< color_type > r (
        color_traits::create (i, f, this));

      this->color (r);
      continue;
    }

    if (n.name () == "fogType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< fogType_type > r (
        fogType_traits::create (i, f, this));

      this->fogType (r);
      continue;
    }

    if (n.name () == "visibilityRange" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< visibilityRange_type > r (
        visibilityRange_traits::create (i, f, this));

      this->visibilityRange (r);
      continue;
    }
  }

  if (!enabled_.present ())
  {
    ::std::auto_ptr< enabled_type > r (
      enabled_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->enabled (r);
  }

  if (!color_.present ())
  {
    ::std::auto_ptr< color_type > r (
      color_traits::create (
        ::std::string ("1 1 1"),
        &p.element (), f, this));

    this->color (r);
  }

  if (!fogType_.present ())
  {
    ::std::auto_ptr< fogType_type > r (
      fogType_traits::create (
        ::std::string ("LINEAR"),
        &p.element (), f, this));

    this->fogType (r);
  }

  if (!visibilityRange_.present ())
  {
    ::std::auto_ptr< visibilityRange_type > r (
      visibilityRange_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->visibilityRange (r);
  }
}

LocalFog* LocalFog::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new LocalFog (*this, f, c);
}

LocalFog::
~LocalFog ()
{
}

// LOD
//

const LOD::forceTransitions_type LOD::forceTransitions_default_value_ (
  ::std::string ("false"), 0, 0, 0);

const LOD::center_type LOD::center_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

LOD::
LOD ()
: ::X3DGroupingNode (),
  forceTransitions_ (forceTransitions_default_value (), ::xml_schema::flags (), this),
  center_ (center_default_value (), ::xml_schema::flags (), this),
  range_ (::xml_schema::flags (), this)
{
}

LOD::
LOD (const LOD& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c),
  forceTransitions_ (x.forceTransitions_, f, this),
  center_ (x.center_, f, this),
  range_ (x.range_, f, this)
{
}

LOD::
LOD (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::X3DGroupingNode (e, f | ::xml_schema::flags::base, c),
  forceTransitions_ (f, this),
  center_ (f, this),
  range_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void LOD::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGroupingNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "forceTransitions" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< forceTransitions_type > r (
        forceTransitions_traits::create (i, f, this));

      this->forceTransitions (r);
      continue;
    }

    if (n.name () == "center" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< center_type > r (
        center_traits::create (i, f, this));

      this->center (r);
      continue;
    }

    if (n.name () == "range" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< range_type > r (
        range_traits::create (i, f, this));

      this->range (r);
      continue;
    }
  }

  if (!forceTransitions_.present ())
  {
    ::std::auto_ptr< forceTransitions_type > r (
      forceTransitions_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->forceTransitions (r);
  }

  if (!center_.present ())
  {
    ::std::auto_ptr< center_type > r (
      center_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->center (r);
  }
}

LOD* LOD::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new LOD (*this, f, c);
}

LOD::
~LOD ()
{
}

// Material
//

const Material::ambientIntensity_type Material::ambientIntensity_default_value_ (
  ::std::string ("0.2"), 0, 0, 0);

const Material::diffuseColor_type Material::diffuseColor_default_value_ (
  ::std::string ("0.8 0.8 0.8"), 0, 0, 0);

const Material::emissiveColor_type Material::emissiveColor_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const Material::shininess_type Material::shininess_default_value_ (
  ::std::string ("0.2"), 0, 0, 0);

const Material::specularColor_type Material::specularColor_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const Material::transparency_type Material::transparency_default_value_ (
  ::std::string ("0"), 0, 0, 0);

Material::
Material ()
: ::X3DMaterialNode (),
  ambientIntensity_ (ambientIntensity_default_value (), ::xml_schema::flags (), this),
  diffuseColor_ (diffuseColor_default_value (), ::xml_schema::flags (), this),
  emissiveColor_ (emissiveColor_default_value (), ::xml_schema::flags (), this),
  shininess_ (shininess_default_value (), ::xml_schema::flags (), this),
  specularColor_ (specularColor_default_value (), ::xml_schema::flags (), this),
  transparency_ (transparency_default_value (), ::xml_schema::flags (), this)
{
}

Material::
Material (const Material& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::X3DMaterialNode (x, f, c),
  ambientIntensity_ (x.ambientIntensity_, f, this),
  diffuseColor_ (x.diffuseColor_, f, this),
  emissiveColor_ (x.emissiveColor_, f, this),
  shininess_ (x.shininess_, f, this),
  specularColor_ (x.specularColor_, f, this),
  transparency_ (x.transparency_, f, this)
{
}

Material::
Material (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::X3DMaterialNode (e, f | ::xml_schema::flags::base, c),
  ambientIntensity_ (f, this),
  diffuseColor_ (f, this),
  emissiveColor_ (f, this),
  shininess_ (f, this),
  specularColor_ (f, this),
  transparency_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Material::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DMaterialNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "ambientIntensity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ambientIntensity_type > r (
        ambientIntensity_traits::create (i, f, this));

      this->ambientIntensity (r);
      continue;
    }

    if (n.name () == "diffuseColor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< diffuseColor_type > r (
        diffuseColor_traits::create (i, f, this));

      this->diffuseColor (r);
      continue;
    }

    if (n.name () == "emissiveColor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< emissiveColor_type > r (
        emissiveColor_traits::create (i, f, this));

      this->emissiveColor (r);
      continue;
    }

    if (n.name () == "shininess" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< shininess_type > r (
        shininess_traits::create (i, f, this));

      this->shininess (r);
      continue;
    }

    if (n.name () == "specularColor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< specularColor_type > r (
        specularColor_traits::create (i, f, this));

      this->specularColor (r);
      continue;
    }

    if (n.name () == "transparency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< transparency_type > r (
        transparency_traits::create (i, f, this));

      this->transparency (r);
      continue;
    }
  }

  if (!ambientIntensity_.present ())
  {
    ::std::auto_ptr< ambientIntensity_type > r (
      ambientIntensity_traits::create (
        ::std::string ("0.2"),
        &p.element (), f, this));

    this->ambientIntensity (r);
  }

  if (!diffuseColor_.present ())
  {
    ::std::auto_ptr< diffuseColor_type > r (
      diffuseColor_traits::create (
        ::std::string ("0.8 0.8 0.8"),
        &p.element (), f, this));

    this->diffuseColor (r);
  }

  if (!emissiveColor_.present ())
  {
    ::std::auto_ptr< emissiveColor_type > r (
      emissiveColor_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->emissiveColor (r);
  }

  if (!shininess_.present ())
  {
    ::std::auto_ptr< shininess_type > r (
      shininess_traits::create (
        ::std::string ("0.2"),
        &p.element (), f, this));

    this->shininess (r);
  }

  if (!specularColor_.present ())
  {
    ::std::auto_ptr< specularColor_type > r (
      specularColor_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->specularColor (r);
  }

  if (!transparency_.present ())
  {
    ::std::auto_ptr< transparency_type > r (
      transparency_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->transparency (r);
  }
}

Material* Material::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Material (*this, f, c);
}

Material::
~Material ()
{
}

// MetadataDouble
//

MetadataDouble::
MetadataDouble ()
: ::X3DMetadataObject (),
  value_ (::xml_schema::flags (), this)
{
}

MetadataDouble::
MetadataDouble (const MetadataDouble& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DMetadataObject (x, f, c),
  value_ (x.value_, f, this)
{
}

MetadataDouble::
MetadataDouble (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DMetadataObject (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void MetadataDouble::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DMetadataObject::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< value_type > r (
        value_traits::create (i, f, this));

      this->value (r);
      continue;
    }
  }
}

MetadataDouble* MetadataDouble::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MetadataDouble (*this, f, c);
}

MetadataDouble::
~MetadataDouble ()
{
}

// MetadataFloat
//

MetadataFloat::
MetadataFloat ()
: ::X3DMetadataObject (),
  value_ (::xml_schema::flags (), this)
{
}

MetadataFloat::
MetadataFloat (const MetadataFloat& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DMetadataObject (x, f, c),
  value_ (x.value_, f, this)
{
}

MetadataFloat::
MetadataFloat (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DMetadataObject (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void MetadataFloat::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DMetadataObject::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< value_type > r (
        value_traits::create (i, f, this));

      this->value (r);
      continue;
    }
  }
}

MetadataFloat* MetadataFloat::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MetadataFloat (*this, f, c);
}

MetadataFloat::
~MetadataFloat ()
{
}

// MetadataInteger
//

MetadataInteger::
MetadataInteger ()
: ::X3DMetadataObject (),
  value_ (::xml_schema::flags (), this)
{
}

MetadataInteger::
MetadataInteger (const MetadataInteger& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::X3DMetadataObject (x, f, c),
  value_ (x.value_, f, this)
{
}

MetadataInteger::
MetadataInteger (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::X3DMetadataObject (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void MetadataInteger::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DMetadataObject::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< value_type > r (
        value_traits::create (i, f, this));

      this->value (r);
      continue;
    }
  }
}

MetadataInteger* MetadataInteger::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MetadataInteger (*this, f, c);
}

MetadataInteger::
~MetadataInteger ()
{
}

// MetadataSet
//

const MetadataSet::containerField_type MetadataSet::containerField_default_value_ (
  ::std::string ("metadata"), 0, 0, 0);

MetadataSet::
MetadataSet ()
: ::SceneGraphStructureNodeType (),
  IS_ (::xml_schema::flags (), this),
  MetadataDouble_ (::xml_schema::flags (), this),
  MetadataFloat_ (::xml_schema::flags (), this),
  MetadataInteger_ (::xml_schema::flags (), this),
  MetadataSet1_ (::xml_schema::flags (), this),
  MetadataString_ (::xml_schema::flags (), this),
  DEF_ (::xml_schema::flags (), this),
  USE_ (::xml_schema::flags (), this),
  class__ (::xml_schema::flags (), this),
  name_ (::xml_schema::flags (), this),
  reference_ (::xml_schema::flags (), this),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

MetadataSet::
MetadataSet (const MetadataSet& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (x, f, c),
  IS_ (x.IS_, f, this),
  MetadataDouble_ (x.MetadataDouble_, f, this),
  MetadataFloat_ (x.MetadataFloat_, f, this),
  MetadataInteger_ (x.MetadataInteger_, f, this),
  MetadataSet1_ (x.MetadataSet1_, f, this),
  MetadataString_ (x.MetadataString_, f, this),
  DEF_ (x.DEF_, f, this),
  USE_ (x.USE_, f, this),
  class__ (x.class__, f, this),
  name_ (x.name_, f, this),
  reference_ (x.reference_, f, this),
  containerField_ (x.containerField_, f, this)
{
}

MetadataSet::
MetadataSet (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (e, f | ::xml_schema::flags::base, c),
  IS_ (f, this),
  MetadataDouble_ (f, this),
  MetadataFloat_ (f, this),
  MetadataInteger_ (f, this),
  MetadataSet1_ (f, this),
  MetadataString_ (f, this),
  DEF_ (f, this),
  USE_ (f, this),
  class__ (f, this),
  name_ (f, this),
  reference_ (f, this),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void MetadataSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // IS
    //
    if (n.name () == "IS" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IS_type > r (
        IS_traits::create (i, f, this));

      if (!this->IS ())
      {
        this->IS (r);
        continue;
      }
    }

    // MetadataDouble
    //
    if (n.name () == "MetadataDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataDouble_type > r (
        MetadataDouble_traits::create (i, f, this));

      this->MetadataDouble ().push_back (r);
      continue;
    }

    // MetadataFloat
    //
    if (n.name () == "MetadataFloat" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataFloat_type > r (
        MetadataFloat_traits::create (i, f, this));

      this->MetadataFloat ().push_back (r);
      continue;
    }

    // MetadataInteger
    //
    if (n.name () == "MetadataInteger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataInteger_type > r (
        MetadataInteger_traits::create (i, f, this));

      this->MetadataInteger ().push_back (r);
      continue;
    }

    // MetadataSet
    //
    if (n.name () == "MetadataSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataSet1_type > r (
        MetadataSet1_traits::create (i, f, this));

      this->MetadataSet1 ().push_back (r);
      continue;
    }

    // MetadataString
    //
    if (n.name () == "MetadataString" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataString_type > r (
        MetadataString_traits::create (i, f, this));

      this->MetadataString ().push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "DEF" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DEF_type > r (
        DEF_traits::create (i, f, this));

      this->DEF (r);
      continue;
    }

    if (n.name () == "USE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< USE_type > r (
        USE_traits::create (i, f, this));

      this->USE (r);
      continue;
    }

    if (n.name () == "class" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< class_type > r (
        class_traits::create (i, f, this));

      this->class_ (r);
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name (r);
      continue;
    }

    if (n.name () == "reference" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< reference_type > r (
        reference_traits::create (i, f, this));

      this->reference (r);
      continue;
    }

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("metadata"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

MetadataSet* MetadataSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MetadataSet (*this, f, c);
}

MetadataSet::
~MetadataSet ()
{
}

// MetadataString
//

MetadataString::
MetadataString ()
: ::X3DMetadataObject (),
  value_ (::xml_schema::flags (), this)
{
}

MetadataString::
MetadataString (const MetadataString& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DMetadataObject (x, f, c),
  value_ (x.value_, f, this)
{
}

MetadataString::
MetadataString (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DMetadataObject (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void MetadataString::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DMetadataObject::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< value_type > r (
        value_traits::create (i, f, this));

      this->value (r);
      continue;
    }
  }
}

MetadataString* MetadataString::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MetadataString (*this, f, c);
}

MetadataString::
~MetadataString ()
{
}

// MovieTexture
//

const MovieTexture::repeatS_type MovieTexture::repeatS_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const MovieTexture::repeatT_type MovieTexture::repeatT_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const MovieTexture::speed_type MovieTexture::speed_default_value_ (
  ::std::string ("1.0"), 0, 0, 0);

MovieTexture::
MovieTexture ()
: ::X3DSoundSourceNode (),
  description_ (::xml_schema::flags (), this),
  url_ (::xml_schema::flags (), this),
  repeatS_ (repeatS_default_value (), ::xml_schema::flags (), this),
  repeatT_ (repeatT_default_value (), ::xml_schema::flags (), this),
  speed_ (speed_default_value (), ::xml_schema::flags (), this)
{
}

MovieTexture::
MovieTexture (const MovieTexture& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DSoundSourceNode (x, f, c),
  description_ (x.description_, f, this),
  url_ (x.url_, f, this),
  repeatS_ (x.repeatS_, f, this),
  repeatT_ (x.repeatT_, f, this),
  speed_ (x.speed_, f, this)
{
}

MovieTexture::
MovieTexture (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DSoundSourceNode (e, f | ::xml_schema::flags::base, c),
  description_ (f, this),
  url_ (f, this),
  repeatS_ (f, this),
  repeatT_ (f, this),
  speed_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void MovieTexture::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DSoundSourceNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "description" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< description_type > r (
        description_traits::create (i, f, this));

      this->description (r);
      continue;
    }

    if (n.name () == "url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< url_type > r (
        url_traits::create (i, f, this));

      this->url (r);
      continue;
    }

    if (n.name () == "repeatS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< repeatS_type > r (
        repeatS_traits::create (i, f, this));

      this->repeatS (r);
      continue;
    }

    if (n.name () == "repeatT" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< repeatT_type > r (
        repeatT_traits::create (i, f, this));

      this->repeatT (r);
      continue;
    }

    if (n.name () == "speed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< speed_type > r (
        speed_traits::create (i, f, this));

      this->speed (r);
      continue;
    }
  }

  if (!repeatS_.present ())
  {
    ::std::auto_ptr< repeatS_type > r (
      repeatS_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->repeatS (r);
  }

  if (!repeatT_.present ())
  {
    ::std::auto_ptr< repeatT_type > r (
      repeatT_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->repeatT (r);
  }

  if (!speed_.present ())
  {
    ::std::auto_ptr< speed_type > r (
      speed_traits::create (
        ::std::string ("1.0"),
        &p.element (), f, this));

    this->speed (r);
  }
}

MovieTexture* MovieTexture::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MovieTexture (*this, f, c);
}

MovieTexture::
~MovieTexture ()
{
}

// MultiTexture
//

const MultiTexture::alpha_type MultiTexture::alpha_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const MultiTexture::color_type MultiTexture::color_default_value_ (
  ::std::string ("1 1 1"), 0, 0, 0);

const MultiTexture::transparent_type MultiTexture::transparent_default_value_ (
  ::std::string ("false"), 0, 0, 0);

MultiTexture::
MultiTexture ()
: ::X3DTextureNode (),
  ImageTexture_ (::xml_schema::flags (), this),
  MovieTexture_ (::xml_schema::flags (), this),
  PixelTexture_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  alpha_ (alpha_default_value (), ::xml_schema::flags (), this),
  color_ (color_default_value (), ::xml_schema::flags (), this),
  function_ (::xml_schema::flags (), this),
  mode_ (::xml_schema::flags (), this),
  source_ (::xml_schema::flags (), this),
  transparent_ (transparent_default_value (), ::xml_schema::flags (), this)
{
}

MultiTexture::
MultiTexture (const MultiTexture& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DTextureNode (x, f, c),
  ImageTexture_ (x.ImageTexture_, f, this),
  MovieTexture_ (x.MovieTexture_, f, this),
  PixelTexture_ (x.PixelTexture_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  alpha_ (x.alpha_, f, this),
  color_ (x.color_, f, this),
  function_ (x.function_, f, this),
  mode_ (x.mode_, f, this),
  source_ (x.source_, f, this),
  transparent_ (x.transparent_, f, this)
{
}

MultiTexture::
MultiTexture (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DTextureNode (e, f | ::xml_schema::flags::base, c),
  ImageTexture_ (f, this),
  MovieTexture_ (f, this),
  PixelTexture_ (f, this),
  ProtoInstance_ (f, this),
  alpha_ (f, this),
  color_ (f, this),
  function_ (f, this),
  mode_ (f, this),
  source_ (f, this),
  transparent_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void MultiTexture::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTextureNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ImageTexture
    //
    if (n.name () == "ImageTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ImageTexture_type > r (
        ImageTexture_traits::create (i, f, this));

      this->ImageTexture ().push_back (r);
      continue;
    }

    // MovieTexture
    //
    if (n.name () == "MovieTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MovieTexture_type > r (
        MovieTexture_traits::create (i, f, this));

      this->MovieTexture ().push_back (r);
      continue;
    }

    // PixelTexture
    //
    if (n.name () == "PixelTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PixelTexture_type > r (
        PixelTexture_traits::create (i, f, this));

      this->PixelTexture ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "alpha" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< alpha_type > r (
        alpha_traits::create (i, f, this));

      this->alpha (r);
      continue;
    }

    if (n.name () == "color" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< color_type > r (
        color_traits::create (i, f, this));

      this->color (r);
      continue;
    }

    if (n.name () == "function" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< function_type > r (
        function_traits::create (i, f, this));

      this->function (r);
      continue;
    }

    if (n.name () == "mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< mode_type > r (
        mode_traits::create (i, f, this));

      this->mode (r);
      continue;
    }

    if (n.name () == "source" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< source_type > r (
        source_traits::create (i, f, this));

      this->source (r);
      continue;
    }

    if (n.name () == "transparent" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< transparent_type > r (
        transparent_traits::create (i, f, this));

      this->transparent (r);
      continue;
    }
  }

  if (!alpha_.present ())
  {
    ::std::auto_ptr< alpha_type > r (
      alpha_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->alpha (r);
  }

  if (!color_.present ())
  {
    ::std::auto_ptr< color_type > r (
      color_traits::create (
        ::std::string ("1 1 1"),
        &p.element (), f, this));

    this->color (r);
  }

  if (!transparent_.present ())
  {
    ::std::auto_ptr< transparent_type > r (
      transparent_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->transparent (r);
  }
}

MultiTexture* MultiTexture::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MultiTexture (*this, f, c);
}

MultiTexture::
~MultiTexture ()
{
}

// MultiTextureCoordinate
//

MultiTextureCoordinate::
MultiTextureCoordinate ()
: ::X3DTextureCoordinateNode ()
{
}

MultiTextureCoordinate::
MultiTextureCoordinate (const MultiTextureCoordinate& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DTextureCoordinateNode (x, f, c)
{
}

MultiTextureCoordinate::
MultiTextureCoordinate (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DTextureCoordinateNode (e, f, c)
{
}

MultiTextureCoordinate* MultiTextureCoordinate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MultiTextureCoordinate (*this, f, c);
}

MultiTextureCoordinate::
~MultiTextureCoordinate ()
{
}

// MultiTextureTransform
//

MultiTextureTransform::
MultiTextureTransform ()
: ::X3DTextureTransformNode (),
  TextureTransform_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this)
{
}

MultiTextureTransform::
MultiTextureTransform (const MultiTextureTransform& x,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::X3DTextureTransformNode (x, f, c),
  TextureTransform_ (x.TextureTransform_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this)
{
}

MultiTextureTransform::
MultiTextureTransform (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f,
                       ::xml_schema::container* c)
: ::X3DTextureTransformNode (e, f | ::xml_schema::flags::base, c),
  TextureTransform_ (f, this),
  ProtoInstance_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void MultiTextureTransform::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTextureTransformNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // TextureTransform
    //
    if (n.name () == "TextureTransform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureTransform_type > r (
        TextureTransform_traits::create (i, f, this));

      this->TextureTransform ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    break;
  }
}

MultiTextureTransform* MultiTextureTransform::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new MultiTextureTransform (*this, f, c);
}

MultiTextureTransform::
~MultiTextureTransform ()
{
}

// NavigationInfo
//

const NavigationInfo::avatarSize_type NavigationInfo::avatarSize_default_value_ (
  ::std::string ("0.25 1.6 0.75"), 0, 0, 0);

const NavigationInfo::headlight_type NavigationInfo::headlight_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const NavigationInfo::speed_type NavigationInfo::speed_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const NavigationInfo::type_type NavigationInfo::type_default_value_ (
  ::std::string ("\"EXAMINE\" \"ANY\""), 0, 0, 0);

const NavigationInfo::transitionType_type NavigationInfo::transitionType_default_value_ (
  ::std::string ("\"ANIMATE\""), 0, 0, 0);

const NavigationInfo::transitionTime_type NavigationInfo::transitionTime_default_value_ (
  ::std::string ("1.0"), 0, 0, 0);

const NavigationInfo::visibilityLimit_type NavigationInfo::visibilityLimit_default_value_ (
  ::std::string ("0"), 0, 0, 0);

NavigationInfo::
NavigationInfo ()
: ::X3DBindableNode (),
  avatarSize_ (avatarSize_default_value (), ::xml_schema::flags (), this),
  headlight_ (headlight_default_value (), ::xml_schema::flags (), this),
  speed_ (speed_default_value (), ::xml_schema::flags (), this),
  type_ (type_default_value (), ::xml_schema::flags (), this),
  transitionType_ (transitionType_default_value (), ::xml_schema::flags (), this),
  transitionTime_ (transitionTime_default_value (), ::xml_schema::flags (), this),
  visibilityLimit_ (visibilityLimit_default_value (), ::xml_schema::flags (), this)
{
}

NavigationInfo::
NavigationInfo (const NavigationInfo& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DBindableNode (x, f, c),
  avatarSize_ (x.avatarSize_, f, this),
  headlight_ (x.headlight_, f, this),
  speed_ (x.speed_, f, this),
  type_ (x.type_, f, this),
  transitionType_ (x.transitionType_, f, this),
  transitionTime_ (x.transitionTime_, f, this),
  visibilityLimit_ (x.visibilityLimit_, f, this)
{
}

NavigationInfo::
NavigationInfo (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DBindableNode (e, f | ::xml_schema::flags::base, c),
  avatarSize_ (f, this),
  headlight_ (f, this),
  speed_ (f, this),
  type_ (f, this),
  transitionType_ (f, this),
  transitionTime_ (f, this),
  visibilityLimit_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void NavigationInfo::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DBindableNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "avatarSize" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< avatarSize_type > r (
        avatarSize_traits::create (i, f, this));

      this->avatarSize (r);
      continue;
    }

    if (n.name () == "headlight" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< headlight_type > r (
        headlight_traits::create (i, f, this));

      this->headlight (r);
      continue;
    }

    if (n.name () == "speed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< speed_type > r (
        speed_traits::create (i, f, this));

      this->speed (r);
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      this->type (r);
      continue;
    }

    if (n.name () == "transitionType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< transitionType_type > r (
        transitionType_traits::create (i, f, this));

      this->transitionType (r);
      continue;
    }

    if (n.name () == "transitionTime" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< transitionTime_type > r (
        transitionTime_traits::create (i, f, this));

      this->transitionTime (r);
      continue;
    }

    if (n.name () == "visibilityLimit" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< visibilityLimit_type > r (
        visibilityLimit_traits::create (i, f, this));

      this->visibilityLimit (r);
      continue;
    }
  }

  if (!avatarSize_.present ())
  {
    ::std::auto_ptr< avatarSize_type > r (
      avatarSize_traits::create (
        ::std::string ("0.25 1.6 0.75"),
        &p.element (), f, this));

    this->avatarSize (r);
  }

  if (!headlight_.present ())
  {
    ::std::auto_ptr< headlight_type > r (
      headlight_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->headlight (r);
  }

  if (!speed_.present ())
  {
    ::std::auto_ptr< speed_type > r (
      speed_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->speed (r);
  }

  if (!type_.present ())
  {
    ::std::auto_ptr< type_type > r (
      type_traits::create (
        ::std::string ("\"EXAMINE\" \"ANY\""),
        &p.element (), f, this));

    this->type (r);
  }

  if (!transitionType_.present ())
  {
    ::std::auto_ptr< transitionType_type > r (
      transitionType_traits::create (
        ::std::string ("\"ANIMATE\""),
        &p.element (), f, this));

    this->transitionType (r);
  }

  if (!transitionTime_.present ())
  {
    ::std::auto_ptr< transitionTime_type > r (
      transitionTime_traits::create (
        ::std::string ("1.0"),
        &p.element (), f, this));

    this->transitionTime (r);
  }

  if (!visibilityLimit_.present ())
  {
    ::std::auto_ptr< visibilityLimit_type > r (
      visibilityLimit_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->visibilityLimit (r);
  }
}

NavigationInfo* NavigationInfo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new NavigationInfo (*this, f, c);
}

NavigationInfo::
~NavigationInfo ()
{
}

// Normal
//

Normal::
Normal ()
: ::X3DNormalNode (),
  vector_ (::xml_schema::flags (), this)
{
}

Normal::
Normal (const Normal& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::X3DNormalNode (x, f, c),
  vector_ (x.vector_, f, this)
{
}

Normal::
Normal (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::X3DNormalNode (e, f | ::xml_schema::flags::base, c),
  vector_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Normal::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DNormalNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "vector" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vector_type > r (
        vector_traits::create (i, f, this));

      this->vector (r);
      continue;
    }
  }
}

Normal* Normal::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Normal (*this, f, c);
}

Normal::
~Normal ()
{
}

// NormalInterpolator
//

NormalInterpolator::
NormalInterpolator ()
: ::X3DInterpolatorNode (),
  keyValue_ (::xml_schema::flags (), this)
{
}

NormalInterpolator::
NormalInterpolator (const NormalInterpolator& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::X3DInterpolatorNode (x, f, c),
  keyValue_ (x.keyValue_, f, this)
{
}

NormalInterpolator::
NormalInterpolator (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::X3DInterpolatorNode (e, f | ::xml_schema::flags::base, c),
  keyValue_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void NormalInterpolator::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DInterpolatorNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "keyValue" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< keyValue_type > r (
        keyValue_traits::create (i, f, this));

      this->keyValue (r);
      continue;
    }
  }
}

NormalInterpolator* NormalInterpolator::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new NormalInterpolator (*this, f, c);
}

NormalInterpolator::
~NormalInterpolator ()
{
}

// OrientationInterpolator
//

OrientationInterpolator::
OrientationInterpolator ()
: ::X3DInterpolatorNode (),
  keyValue_ (::xml_schema::flags (), this)
{
}

OrientationInterpolator::
OrientationInterpolator (const OrientationInterpolator& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::X3DInterpolatorNode (x, f, c),
  keyValue_ (x.keyValue_, f, this)
{
}

OrientationInterpolator::
OrientationInterpolator (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::X3DInterpolatorNode (e, f | ::xml_schema::flags::base, c),
  keyValue_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void OrientationInterpolator::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DInterpolatorNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "keyValue" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< keyValue_type > r (
        keyValue_traits::create (i, f, this));

      this->keyValue (r);
      continue;
    }
  }
}

OrientationInterpolator* OrientationInterpolator::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new OrientationInterpolator (*this, f, c);
}

OrientationInterpolator::
~OrientationInterpolator ()
{
}

// PixelTexture
//

const PixelTexture::image_type PixelTexture::image_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

PixelTexture::
PixelTexture ()
: ::X3DTexture2DNode (),
  image_ (image_default_value (), ::xml_schema::flags (), this)
{
}

PixelTexture::
PixelTexture (const PixelTexture& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DTexture2DNode (x, f, c),
  image_ (x.image_, f, this)
{
}

PixelTexture::
PixelTexture (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DTexture2DNode (e, f | ::xml_schema::flags::base, c),
  image_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void PixelTexture::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTexture2DNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "image" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< image_type > r (
        image_traits::create (i, f, this));

      this->image (r);
      continue;
    }
  }

  if (!image_.present ())
  {
    ::std::auto_ptr< image_type > r (
      image_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->image (r);
  }
}

PixelTexture* PixelTexture::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new PixelTexture (*this, f, c);
}

PixelTexture::
~PixelTexture ()
{
}

// PlaneSensor
//

const PlaneSensor::maxPosition_type PlaneSensor::maxPosition_default_value_ (
  ::std::string ("-1 -1"), 0, 0, 0);

const PlaneSensor::minPosition_type PlaneSensor::minPosition_default_value_ (
  ::std::string ("0 0"), 0, 0, 0);

const PlaneSensor::offset_type PlaneSensor::offset_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

PlaneSensor::
PlaneSensor ()
: ::X3DDragSensorNode (),
  maxPosition_ (maxPosition_default_value (), ::xml_schema::flags (), this),
  minPosition_ (minPosition_default_value (), ::xml_schema::flags (), this),
  offset_ (offset_default_value (), ::xml_schema::flags (), this)
{
}

PlaneSensor::
PlaneSensor (const PlaneSensor& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DDragSensorNode (x, f, c),
  maxPosition_ (x.maxPosition_, f, this),
  minPosition_ (x.minPosition_, f, this),
  offset_ (x.offset_, f, this)
{
}

PlaneSensor::
PlaneSensor (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DDragSensorNode (e, f | ::xml_schema::flags::base, c),
  maxPosition_ (f, this),
  minPosition_ (f, this),
  offset_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void PlaneSensor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DDragSensorNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "maxPosition" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< maxPosition_type > r (
        maxPosition_traits::create (i, f, this));

      this->maxPosition (r);
      continue;
    }

    if (n.name () == "minPosition" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< minPosition_type > r (
        minPosition_traits::create (i, f, this));

      this->minPosition (r);
      continue;
    }

    if (n.name () == "offset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< offset_type > r (
        offset_traits::create (i, f, this));

      this->offset (r);
      continue;
    }
  }

  if (!maxPosition_.present ())
  {
    ::std::auto_ptr< maxPosition_type > r (
      maxPosition_traits::create (
        ::std::string ("-1 -1"),
        &p.element (), f, this));

    this->maxPosition (r);
  }

  if (!minPosition_.present ())
  {
    ::std::auto_ptr< minPosition_type > r (
      minPosition_traits::create (
        ::std::string ("0 0"),
        &p.element (), f, this));

    this->minPosition (r);
  }

  if (!offset_.present ())
  {
    ::std::auto_ptr< offset_type > r (
      offset_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->offset (r);
  }
}

PlaneSensor* PlaneSensor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new PlaneSensor (*this, f, c);
}

PlaneSensor::
~PlaneSensor ()
{
}

// PointLight
//

const PointLight::attenuation_type PointLight::attenuation_default_value_ (
  ::std::string ("1 0 0"), 0, 0, 0);

const PointLight::location_type PointLight::location_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const PointLight::radius_type PointLight::radius_default_value_ (
  ::std::string ("100"), 0, 0, 0);

const PointLight::global_type PointLight::global_default_value_ (
  ::std::string ("true"), 0, 0, 0);

PointLight::
PointLight ()
: ::X3DLightNode (),
  attenuation_ (attenuation_default_value (), ::xml_schema::flags (), this),
  location_ (location_default_value (), ::xml_schema::flags (), this),
  radius_ (radius_default_value (), ::xml_schema::flags (), this),
  global_ (global_default_value (), ::xml_schema::flags (), this)
{
}

PointLight::
PointLight (const PointLight& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DLightNode (x, f, c),
  attenuation_ (x.attenuation_, f, this),
  location_ (x.location_, f, this),
  radius_ (x.radius_, f, this),
  global_ (x.global_, f, this)
{
}

PointLight::
PointLight (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DLightNode (e, f | ::xml_schema::flags::base, c),
  attenuation_ (f, this),
  location_ (f, this),
  radius_ (f, this),
  global_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void PointLight::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DLightNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "attenuation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< attenuation_type > r (
        attenuation_traits::create (i, f, this));

      this->attenuation (r);
      continue;
    }

    if (n.name () == "location" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< location_type > r (
        location_traits::create (i, f, this));

      this->location (r);
      continue;
    }

    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< radius_type > r (
        radius_traits::create (i, f, this));

      this->radius (r);
      continue;
    }

    if (n.name () == "global" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< global_type > r (
        global_traits::create (i, f, this));

      this->global (r);
      continue;
    }
  }

  if (!attenuation_.present ())
  {
    ::std::auto_ptr< attenuation_type > r (
      attenuation_traits::create (
        ::std::string ("1 0 0"),
        &p.element (), f, this));

    this->attenuation (r);
  }

  if (!location_.present ())
  {
    ::std::auto_ptr< location_type > r (
      location_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->location (r);
  }

  if (!radius_.present ())
  {
    ::std::auto_ptr< radius_type > r (
      radius_traits::create (
        ::std::string ("100"),
        &p.element (), f, this));

    this->radius (r);
  }

  if (!global_.present ())
  {
    ::std::auto_ptr< global_type > r (
      global_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->global (r);
  }
}

PointLight* PointLight::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new PointLight (*this, f, c);
}

PointLight::
~PointLight ()
{
}

// PointSet
//

PointSet::
PointSet ()
: ::X3DGeometryNode (),
  Color_ (::xml_schema::flags (), this),
  ColorRGBA_ (::xml_schema::flags (), this),
  Coordinate_ (::xml_schema::flags (), this),
  CoordinateDouble_ (::xml_schema::flags (), this),
  GeoCoordinate_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this)
{
}

PointSet::
PointSet (const PointSet& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  Color_ (x.Color_, f, this),
  ColorRGBA_ (x.ColorRGBA_, f, this),
  Coordinate_ (x.Coordinate_, f, this),
  CoordinateDouble_ (x.CoordinateDouble_, f, this),
  GeoCoordinate_ (x.GeoCoordinate_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this)
{
}

PointSet::
PointSet (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  Color_ (f, this),
  ColorRGBA_ (f, this),
  Coordinate_ (f, this),
  CoordinateDouble_ (f, this),
  GeoCoordinate_ (f, this),
  ProtoInstance_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void PointSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Color
    //
    if (n.name () == "Color" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Color_type > r (
        Color_traits::create (i, f, this));

      if (!this->Color ())
      {
        this->Color (r);
        continue;
      }
    }

    // ColorRGBA
    //
    if (n.name () == "ColorRGBA" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ColorRGBA_type > r (
        ColorRGBA_traits::create (i, f, this));

      if (!this->ColorRGBA ())
      {
        this->ColorRGBA (r);
        continue;
      }
    }

    // Coordinate
    //
    if (n.name () == "Coordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Coordinate_type > r (
        Coordinate_traits::create (i, f, this));

      if (!this->Coordinate ())
      {
        this->Coordinate (r);
        continue;
      }
    }

    // CoordinateDouble
    //
    if (n.name () == "CoordinateDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateDouble_type > r (
        CoordinateDouble_traits::create (i, f, this));

      if (!this->CoordinateDouble ())
      {
        this->CoordinateDouble (r);
        continue;
      }
    }

    // GeoCoordinate
    //
    if (n.name () == "GeoCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoCoordinate_type > r (
        GeoCoordinate_traits::create (i, f, this));

      if (!this->GeoCoordinate ())
      {
        this->GeoCoordinate (r);
        continue;
      }
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    break;
  }
}

PointSet* PointSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new PointSet (*this, f, c);
}

PointSet::
~PointSet ()
{
}

// Polyline2D
//

Polyline2D::
Polyline2D ()
: ::X3DGeometryNode (),
  lineSegments_ (::xml_schema::flags (), this)
{
}

Polyline2D::
Polyline2D (const Polyline2D& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  lineSegments_ (x.lineSegments_, f, this)
{
}

Polyline2D::
Polyline2D (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  lineSegments_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Polyline2D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "lineSegments" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< lineSegments_type > r (
        lineSegments_traits::create (i, f, this));

      this->lineSegments (r);
      continue;
    }
  }
}

Polyline2D* Polyline2D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Polyline2D (*this, f, c);
}

Polyline2D::
~Polyline2D ()
{
}

// Polypoint2D
//

Polypoint2D::
Polypoint2D ()
: ::X3DGeometryNode (),
  point_ (::xml_schema::flags (), this)
{
}

Polypoint2D::
Polypoint2D (const Polypoint2D& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  point_ (x.point_, f, this)
{
}

Polypoint2D::
Polypoint2D (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  point_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Polypoint2D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "point" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< point_type > r (
        point_traits::create (i, f, this));

      this->point (r);
      continue;
    }
  }
}

Polypoint2D* Polypoint2D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Polypoint2D (*this, f, c);
}

Polypoint2D::
~Polypoint2D ()
{
}

// PositionInterpolator
//

PositionInterpolator::
PositionInterpolator ()
: ::X3DInterpolatorNode (),
  keyValue_ (::xml_schema::flags (), this)
{
}

PositionInterpolator::
PositionInterpolator (const PositionInterpolator& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::X3DInterpolatorNode (x, f, c),
  keyValue_ (x.keyValue_, f, this)
{
}

PositionInterpolator::
PositionInterpolator (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::X3DInterpolatorNode (e, f | ::xml_schema::flags::base, c),
  keyValue_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void PositionInterpolator::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DInterpolatorNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "keyValue" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< keyValue_type > r (
        keyValue_traits::create (i, f, this));

      this->keyValue (r);
      continue;
    }
  }
}

PositionInterpolator* PositionInterpolator::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new PositionInterpolator (*this, f, c);
}

PositionInterpolator::
~PositionInterpolator ()
{
}

// PositionInterpolator2D
//

PositionInterpolator2D::
PositionInterpolator2D ()
: ::X3DInterpolatorNode (),
  keyValue_ (::xml_schema::flags (), this)
{
}

PositionInterpolator2D::
PositionInterpolator2D (const PositionInterpolator2D& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DInterpolatorNode (x, f, c),
  keyValue_ (x.keyValue_, f, this)
{
}

PositionInterpolator2D::
PositionInterpolator2D (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DInterpolatorNode (e, f | ::xml_schema::flags::base, c),
  keyValue_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void PositionInterpolator2D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DInterpolatorNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "keyValue" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< keyValue_type > r (
        keyValue_traits::create (i, f, this));

      this->keyValue (r);
      continue;
    }
  }
}

PositionInterpolator2D* PositionInterpolator2D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new PositionInterpolator2D (*this, f, c);
}

PositionInterpolator2D::
~PositionInterpolator2D ()
{
}

// ProximitySensor
//

ProximitySensor::
ProximitySensor ()
: ::X3DEnvironmentalSensorNode ()
{
}

ProximitySensor::
ProximitySensor (const ProximitySensor& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::X3DEnvironmentalSensorNode (x, f, c)
{
}

ProximitySensor::
ProximitySensor (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::X3DEnvironmentalSensorNode (e, f, c)
{
}

ProximitySensor* ProximitySensor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ProximitySensor (*this, f, c);
}

ProximitySensor::
~ProximitySensor ()
{
}

// Rectangle2D
//

const Rectangle2D::size_type Rectangle2D::size_default_value_ (
  ::std::string ("2 2"), 0, 0, 0);

const Rectangle2D::solid_type Rectangle2D::solid_default_value_ (
  ::std::string ("true"), 0, 0, 0);

Rectangle2D::
Rectangle2D ()
: ::X3DGeometryNode (),
  size_ (size_default_value (), ::xml_schema::flags (), this),
  solid_ (solid_default_value (), ::xml_schema::flags (), this)
{
}

Rectangle2D::
Rectangle2D (const Rectangle2D& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  size_ (x.size_, f, this),
  solid_ (x.solid_, f, this)
{
}

Rectangle2D::
Rectangle2D (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  size_ (f, this),
  solid_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Rectangle2D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "size" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< size_type > r (
        size_traits::create (i, f, this));

      this->size (r);
      continue;
    }

    if (n.name () == "solid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< solid_type > r (
        solid_traits::create (i, f, this));

      this->solid (r);
      continue;
    }
  }

  if (!size_.present ())
  {
    ::std::auto_ptr< size_type > r (
      size_traits::create (
        ::std::string ("2 2"),
        &p.element (), f, this));

    this->size (r);
  }

  if (!solid_.present ())
  {
    ::std::auto_ptr< solid_type > r (
      solid_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->solid (r);
  }
}

Rectangle2D* Rectangle2D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Rectangle2D (*this, f, c);
}

Rectangle2D::
~Rectangle2D ()
{
}

// ScalarInterpolator
//

ScalarInterpolator::
ScalarInterpolator ()
: ::X3DInterpolatorNode (),
  keyValue_ (::xml_schema::flags (), this)
{
}

ScalarInterpolator::
ScalarInterpolator (const ScalarInterpolator& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::X3DInterpolatorNode (x, f, c),
  keyValue_ (x.keyValue_, f, this)
{
}

ScalarInterpolator::
ScalarInterpolator (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::X3DInterpolatorNode (e, f | ::xml_schema::flags::base, c),
  keyValue_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ScalarInterpolator::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DInterpolatorNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "keyValue" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< keyValue_type > r (
        keyValue_traits::create (i, f, this));

      this->keyValue (r);
      continue;
    }
  }
}

ScalarInterpolator* ScalarInterpolator::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ScalarInterpolator (*this, f, c);
}

ScalarInterpolator::
~ScalarInterpolator ()
{
}

// Script
//

const Script::directOutput_type Script::directOutput_default_value_ (
  ::std::string ("false"), 0, 0, 0);

const Script::mustEvaluate_type Script::mustEvaluate_default_value_ (
  ::std::string ("false"), 0, 0, 0);

Script::
Script ()
: ::X3DScriptNode (),
  directOutput_ (directOutput_default_value (), ::xml_schema::flags (), this),
  mustEvaluate_ (mustEvaluate_default_value (), ::xml_schema::flags (), this),
  url_ (::xml_schema::flags (), this)
{
}

Script::
Script (const Script& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::X3DScriptNode (x, f, c),
  directOutput_ (x.directOutput_, f, this),
  mustEvaluate_ (x.mustEvaluate_, f, this),
  url_ (x.url_, f, this)
{
}

Script::
Script (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::X3DScriptNode (e, f | ::xml_schema::flags::base, c),
  directOutput_ (f, this),
  mustEvaluate_ (f, this),
  url_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Script::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DScriptNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "directOutput" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< directOutput_type > r (
        directOutput_traits::create (i, f, this));

      this->directOutput (r);
      continue;
    }

    if (n.name () == "mustEvaluate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< mustEvaluate_type > r (
        mustEvaluate_traits::create (i, f, this));

      this->mustEvaluate (r);
      continue;
    }

    if (n.name () == "url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< url_type > r (
        url_traits::create (i, f, this));

      this->url (r);
      continue;
    }
  }

  if (!directOutput_.present ())
  {
    ::std::auto_ptr< directOutput_type > r (
      directOutput_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->directOutput (r);
  }

  if (!mustEvaluate_.present ())
  {
    ::std::auto_ptr< mustEvaluate_type > r (
      mustEvaluate_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->mustEvaluate (r);
  }
}

Script* Script::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Script (*this, f, c);
}

Script::
~Script ()
{
}

// Shape
//

Shape::
Shape ()
: ::X3DShapeNode ()
{
}

Shape::
Shape (const Shape& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::X3DShapeNode (x, f, c)
{
}

Shape::
Shape (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::X3DShapeNode (e, f, c)
{
}

Shape* Shape::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Shape (*this, f, c);
}

Shape::
~Shape ()
{
}

// Sound
//

const Sound::direction_type Sound::direction_default_value_ (
  ::std::string ("0 0 1"), 0, 0, 0);

const Sound::intensity_type Sound::intensity_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const Sound::location_type Sound::location_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const Sound::maxBack_type Sound::maxBack_default_value_ (
  ::std::string ("10"), 0, 0, 0);

const Sound::maxFront_type Sound::maxFront_default_value_ (
  ::std::string ("10"), 0, 0, 0);

const Sound::minBack_type Sound::minBack_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const Sound::minFront_type Sound::minFront_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const Sound::priority_type Sound::priority_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const Sound::spatialize_type Sound::spatialize_default_value_ (
  ::std::string ("true"), 0, 0, 0);

Sound::
Sound ()
: ::X3DSoundNode (),
  direction_ (direction_default_value (), ::xml_schema::flags (), this),
  intensity_ (intensity_default_value (), ::xml_schema::flags (), this),
  location_ (location_default_value (), ::xml_schema::flags (), this),
  maxBack_ (maxBack_default_value (), ::xml_schema::flags (), this),
  maxFront_ (maxFront_default_value (), ::xml_schema::flags (), this),
  minBack_ (minBack_default_value (), ::xml_schema::flags (), this),
  minFront_ (minFront_default_value (), ::xml_schema::flags (), this),
  priority_ (priority_default_value (), ::xml_schema::flags (), this),
  spatialize_ (spatialize_default_value (), ::xml_schema::flags (), this)
{
}

Sound::
Sound (const Sound& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::X3DSoundNode (x, f, c),
  direction_ (x.direction_, f, this),
  intensity_ (x.intensity_, f, this),
  location_ (x.location_, f, this),
  maxBack_ (x.maxBack_, f, this),
  maxFront_ (x.maxFront_, f, this),
  minBack_ (x.minBack_, f, this),
  minFront_ (x.minFront_, f, this),
  priority_ (x.priority_, f, this),
  spatialize_ (x.spatialize_, f, this)
{
}

Sound::
Sound (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::X3DSoundNode (e, f | ::xml_schema::flags::base, c),
  direction_ (f, this),
  intensity_ (f, this),
  location_ (f, this),
  maxBack_ (f, this),
  maxFront_ (f, this),
  minBack_ (f, this),
  minFront_ (f, this),
  priority_ (f, this),
  spatialize_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Sound::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DSoundNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "direction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< direction_type > r (
        direction_traits::create (i, f, this));

      this->direction (r);
      continue;
    }

    if (n.name () == "intensity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< intensity_type > r (
        intensity_traits::create (i, f, this));

      this->intensity (r);
      continue;
    }

    if (n.name () == "location" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< location_type > r (
        location_traits::create (i, f, this));

      this->location (r);
      continue;
    }

    if (n.name () == "maxBack" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< maxBack_type > r (
        maxBack_traits::create (i, f, this));

      this->maxBack (r);
      continue;
    }

    if (n.name () == "maxFront" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< maxFront_type > r (
        maxFront_traits::create (i, f, this));

      this->maxFront (r);
      continue;
    }

    if (n.name () == "minBack" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< minBack_type > r (
        minBack_traits::create (i, f, this));

      this->minBack (r);
      continue;
    }

    if (n.name () == "minFront" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< minFront_type > r (
        minFront_traits::create (i, f, this));

      this->minFront (r);
      continue;
    }

    if (n.name () == "priority" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< priority_type > r (
        priority_traits::create (i, f, this));

      this->priority (r);
      continue;
    }

    if (n.name () == "spatialize" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< spatialize_type > r (
        spatialize_traits::create (i, f, this));

      this->spatialize (r);
      continue;
    }
  }

  if (!direction_.present ())
  {
    ::std::auto_ptr< direction_type > r (
      direction_traits::create (
        ::std::string ("0 0 1"),
        &p.element (), f, this));

    this->direction (r);
  }

  if (!intensity_.present ())
  {
    ::std::auto_ptr< intensity_type > r (
      intensity_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->intensity (r);
  }

  if (!location_.present ())
  {
    ::std::auto_ptr< location_type > r (
      location_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->location (r);
  }

  if (!maxBack_.present ())
  {
    ::std::auto_ptr< maxBack_type > r (
      maxBack_traits::create (
        ::std::string ("10"),
        &p.element (), f, this));

    this->maxBack (r);
  }

  if (!maxFront_.present ())
  {
    ::std::auto_ptr< maxFront_type > r (
      maxFront_traits::create (
        ::std::string ("10"),
        &p.element (), f, this));

    this->maxFront (r);
  }

  if (!minBack_.present ())
  {
    ::std::auto_ptr< minBack_type > r (
      minBack_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->minBack (r);
  }

  if (!minFront_.present ())
  {
    ::std::auto_ptr< minFront_type > r (
      minFront_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->minFront (r);
  }

  if (!priority_.present ())
  {
    ::std::auto_ptr< priority_type > r (
      priority_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->priority (r);
  }

  if (!spatialize_.present ())
  {
    ::std::auto_ptr< spatialize_type > r (
      spatialize_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->spatialize (r);
  }
}

Sound* Sound::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Sound (*this, f, c);
}

Sound::
~Sound ()
{
}

// Sphere
//

const Sphere::radius_type Sphere::radius_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const Sphere::solid_type Sphere::solid_default_value_ (
  ::std::string ("true"), 0, 0, 0);

Sphere::
Sphere ()
: ::X3DGeometryNode (),
  radius_ (radius_default_value (), ::xml_schema::flags (), this),
  solid_ (solid_default_value (), ::xml_schema::flags (), this)
{
}

Sphere::
Sphere (const Sphere& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  radius_ (x.radius_, f, this),
  solid_ (x.solid_, f, this)
{
}

Sphere::
Sphere (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  radius_ (f, this),
  solid_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Sphere::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< radius_type > r (
        radius_traits::create (i, f, this));

      this->radius (r);
      continue;
    }

    if (n.name () == "solid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< solid_type > r (
        solid_traits::create (i, f, this));

      this->solid (r);
      continue;
    }
  }

  if (!radius_.present ())
  {
    ::std::auto_ptr< radius_type > r (
      radius_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->radius (r);
  }

  if (!solid_.present ())
  {
    ::std::auto_ptr< solid_type > r (
      solid_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->solid (r);
  }
}

Sphere* Sphere::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Sphere (*this, f, c);
}

Sphere::
~Sphere ()
{
}

// SphereSensor
//

const SphereSensor::offset_type SphereSensor::offset_default_value_ (
  ::std::string ("0 1 0 0"), 0, 0, 0);

SphereSensor::
SphereSensor ()
: ::X3DDragSensorNode (),
  offset_ (offset_default_value (), ::xml_schema::flags (), this)
{
}

SphereSensor::
SphereSensor (const SphereSensor& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DDragSensorNode (x, f, c),
  offset_ (x.offset_, f, this)
{
}

SphereSensor::
SphereSensor (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DDragSensorNode (e, f | ::xml_schema::flags::base, c),
  offset_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void SphereSensor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DDragSensorNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "offset" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< offset_type > r (
        offset_traits::create (i, f, this));

      this->offset (r);
      continue;
    }
  }

  if (!offset_.present ())
  {
    ::std::auto_ptr< offset_type > r (
      offset_traits::create (
        ::std::string ("0 1 0 0"),
        &p.element (), f, this));

    this->offset (r);
  }
}

SphereSensor* SphereSensor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SphereSensor (*this, f, c);
}

SphereSensor::
~SphereSensor ()
{
}

// SpotLight
//

const SpotLight::attenuation_type SpotLight::attenuation_default_value_ (
  ::std::string ("1 0 0"), 0, 0, 0);

const SpotLight::beamWidth_type SpotLight::beamWidth_default_value_ (
  ::std::string ("1.5708"), 0, 0, 0);

const SpotLight::cutOffAngle_type SpotLight::cutOffAngle_default_value_ (
  ::std::string ("0.785398"), 0, 0, 0);

const SpotLight::direction_type SpotLight::direction_default_value_ (
  ::std::string ("0 0 -1"), 0, 0, 0);

const SpotLight::location_type SpotLight::location_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const SpotLight::radius_type SpotLight::radius_default_value_ (
  ::std::string ("100"), 0, 0, 0);

const SpotLight::global_type SpotLight::global_default_value_ (
  ::std::string ("true"), 0, 0, 0);

SpotLight::
SpotLight ()
: ::X3DLightNode (),
  attenuation_ (attenuation_default_value (), ::xml_schema::flags (), this),
  beamWidth_ (beamWidth_default_value (), ::xml_schema::flags (), this),
  cutOffAngle_ (cutOffAngle_default_value (), ::xml_schema::flags (), this),
  direction_ (direction_default_value (), ::xml_schema::flags (), this),
  location_ (location_default_value (), ::xml_schema::flags (), this),
  radius_ (radius_default_value (), ::xml_schema::flags (), this),
  global_ (global_default_value (), ::xml_schema::flags (), this)
{
}

SpotLight::
SpotLight (const SpotLight& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DLightNode (x, f, c),
  attenuation_ (x.attenuation_, f, this),
  beamWidth_ (x.beamWidth_, f, this),
  cutOffAngle_ (x.cutOffAngle_, f, this),
  direction_ (x.direction_, f, this),
  location_ (x.location_, f, this),
  radius_ (x.radius_, f, this),
  global_ (x.global_, f, this)
{
}

SpotLight::
SpotLight (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DLightNode (e, f | ::xml_schema::flags::base, c),
  attenuation_ (f, this),
  beamWidth_ (f, this),
  cutOffAngle_ (f, this),
  direction_ (f, this),
  location_ (f, this),
  radius_ (f, this),
  global_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void SpotLight::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DLightNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "attenuation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< attenuation_type > r (
        attenuation_traits::create (i, f, this));

      this->attenuation (r);
      continue;
    }

    if (n.name () == "beamWidth" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< beamWidth_type > r (
        beamWidth_traits::create (i, f, this));

      this->beamWidth (r);
      continue;
    }

    if (n.name () == "cutOffAngle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cutOffAngle_type > r (
        cutOffAngle_traits::create (i, f, this));

      this->cutOffAngle (r);
      continue;
    }

    if (n.name () == "direction" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< direction_type > r (
        direction_traits::create (i, f, this));

      this->direction (r);
      continue;
    }

    if (n.name () == "location" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< location_type > r (
        location_traits::create (i, f, this));

      this->location (r);
      continue;
    }

    if (n.name () == "radius" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< radius_type > r (
        radius_traits::create (i, f, this));

      this->radius (r);
      continue;
    }

    if (n.name () == "global" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< global_type > r (
        global_traits::create (i, f, this));

      this->global (r);
      continue;
    }
  }

  if (!attenuation_.present ())
  {
    ::std::auto_ptr< attenuation_type > r (
      attenuation_traits::create (
        ::std::string ("1 0 0"),
        &p.element (), f, this));

    this->attenuation (r);
  }

  if (!beamWidth_.present ())
  {
    ::std::auto_ptr< beamWidth_type > r (
      beamWidth_traits::create (
        ::std::string ("1.5708"),
        &p.element (), f, this));

    this->beamWidth (r);
  }

  if (!cutOffAngle_.present ())
  {
    ::std::auto_ptr< cutOffAngle_type > r (
      cutOffAngle_traits::create (
        ::std::string ("0.785398"),
        &p.element (), f, this));

    this->cutOffAngle (r);
  }

  if (!direction_.present ())
  {
    ::std::auto_ptr< direction_type > r (
      direction_traits::create (
        ::std::string ("0 0 -1"),
        &p.element (), f, this));

    this->direction (r);
  }

  if (!location_.present ())
  {
    ::std::auto_ptr< location_type > r (
      location_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->location (r);
  }

  if (!radius_.present ())
  {
    ::std::auto_ptr< radius_type > r (
      radius_traits::create (
        ::std::string ("100"),
        &p.element (), f, this));

    this->radius (r);
  }

  if (!global_.present ())
  {
    ::std::auto_ptr< global_type > r (
      global_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->global (r);
  }
}

SpotLight* SpotLight::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SpotLight (*this, f, c);
}

SpotLight::
~SpotLight ()
{
}

// StaticGroup
//

StaticGroup::
StaticGroup ()
: ::X3DGroupingNode ()
{
}

StaticGroup::
StaticGroup (const StaticGroup& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c)
{
}

StaticGroup::
StaticGroup (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DGroupingNode (e, f, c)
{
}

StaticGroup* StaticGroup::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new StaticGroup (*this, f, c);
}

StaticGroup::
~StaticGroup ()
{
}

// StringSensor
//

const StringSensor::deletionAllowed_type StringSensor::deletionAllowed_default_value_ (
  ::std::string ("true"), 0, 0, 0);

StringSensor::
StringSensor ()
: ::X3DKeyDeviceSensorNode (),
  deletionAllowed_ (deletionAllowed_default_value (), ::xml_schema::flags (), this)
{
}

StringSensor::
StringSensor (const StringSensor& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DKeyDeviceSensorNode (x, f, c),
  deletionAllowed_ (x.deletionAllowed_, f, this)
{
}

StringSensor::
StringSensor (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DKeyDeviceSensorNode (e, f | ::xml_schema::flags::base, c),
  deletionAllowed_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void StringSensor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DKeyDeviceSensorNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "deletionAllowed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< deletionAllowed_type > r (
        deletionAllowed_traits::create (i, f, this));

      this->deletionAllowed (r);
      continue;
    }
  }

  if (!deletionAllowed_.present ())
  {
    ::std::auto_ptr< deletionAllowed_type > r (
      deletionAllowed_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->deletionAllowed (r);
  }
}

StringSensor* StringSensor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new StringSensor (*this, f, c);
}

StringSensor::
~StringSensor ()
{
}

// Switch
//

const Switch::whichChoice_type Switch::whichChoice_default_value_ (
  ::std::string ("-1"), 0, 0, 0);

Switch::
Switch ()
: ::X3DGroupingNode (),
  whichChoice_ (whichChoice_default_value (), ::xml_schema::flags (), this)
{
}

Switch::
Switch (const Switch& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c),
  whichChoice_ (x.whichChoice_, f, this)
{
}

Switch::
Switch (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::X3DGroupingNode (e, f | ::xml_schema::flags::base, c),
  whichChoice_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Switch::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGroupingNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "whichChoice" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< whichChoice_type > r (
        whichChoice_traits::create (i, f, this));

      this->whichChoice (r);
      continue;
    }
  }

  if (!whichChoice_.present ())
  {
    ::std::auto_ptr< whichChoice_type > r (
      whichChoice_traits::create (
        ::std::string ("-1"),
        &p.element (), f, this));

    this->whichChoice (r);
  }
}

Switch* Switch::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Switch (*this, f, c);
}

Switch::
~Switch ()
{
}

// Text
//

const Text::maxExtent_type Text::maxExtent_default_value_ (
  ::std::string ("0.0"), 0, 0, 0);

const Text::solid_type Text::solid_default_value_ (
  ::std::string ("true"), 0, 0, 0);

Text::
Text ()
: ::X3DGeometryNode (),
  FontStyle_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  string_ (::xml_schema::flags (), this),
  length_ (::xml_schema::flags (), this),
  maxExtent_ (maxExtent_default_value (), ::xml_schema::flags (), this),
  solid_ (solid_default_value (), ::xml_schema::flags (), this)
{
}

Text::
Text (const Text& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  FontStyle_ (x.FontStyle_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  string_ (x.string_, f, this),
  length_ (x.length_, f, this),
  maxExtent_ (x.maxExtent_, f, this),
  solid_ (x.solid_, f, this)
{
}

Text::
Text (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  FontStyle_ (f, this),
  ProtoInstance_ (f, this),
  string_ (f, this),
  length_ (f, this),
  maxExtent_ (f, this),
  solid_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Text::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // FontStyle
    //
    if (n.name () == "FontStyle" && n.namespace_ () == "")
    {
      ::std::auto_ptr< FontStyle_type > r (
        FontStyle_traits::create (i, f, this));

      if (!this->FontStyle ())
      {
        this->FontStyle (r);
        continue;
      }
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      if (!this->ProtoInstance ())
      {
        this->ProtoInstance (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "string" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< string_type > r (
        string_traits::create (i, f, this));

      this->string (r);
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< length_type > r (
        length_traits::create (i, f, this));

      this->length (r);
      continue;
    }

    if (n.name () == "maxExtent" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< maxExtent_type > r (
        maxExtent_traits::create (i, f, this));

      this->maxExtent (r);
      continue;
    }

    if (n.name () == "solid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< solid_type > r (
        solid_traits::create (i, f, this));

      this->solid (r);
      continue;
    }
  }

  if (!maxExtent_.present ())
  {
    ::std::auto_ptr< maxExtent_type > r (
      maxExtent_traits::create (
        ::std::string ("0.0"),
        &p.element (), f, this));

    this->maxExtent (r);
  }

  if (!solid_.present ())
  {
    ::std::auto_ptr< solid_type > r (
      solid_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->solid (r);
  }
}

Text* Text::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Text (*this, f, c);
}

Text::
~Text ()
{
}

// TextureBackground
//

const TextureBackground::transparency_type TextureBackground::transparency_default_value_ (
  ::std::string ("0"), 0, 0, 0);

TextureBackground::
TextureBackground ()
: ::X3DBackgroundNode (),
  ImageTexture_ (::xml_schema::flags (), this),
  MovieTexture_ (::xml_schema::flags (), this),
  MultiTexture_ (::xml_schema::flags (), this),
  PixelTexture_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  transparency_ (transparency_default_value (), ::xml_schema::flags (), this)
{
}

TextureBackground::
TextureBackground (const TextureBackground& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DBackgroundNode (x, f, c),
  ImageTexture_ (x.ImageTexture_, f, this),
  MovieTexture_ (x.MovieTexture_, f, this),
  MultiTexture_ (x.MultiTexture_, f, this),
  PixelTexture_ (x.PixelTexture_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  transparency_ (x.transparency_, f, this)
{
}

TextureBackground::
TextureBackground (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DBackgroundNode (e, f | ::xml_schema::flags::base, c),
  ImageTexture_ (f, this),
  MovieTexture_ (f, this),
  MultiTexture_ (f, this),
  PixelTexture_ (f, this),
  ProtoInstance_ (f, this),
  transparency_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void TextureBackground::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DBackgroundNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ImageTexture
    //
    if (n.name () == "ImageTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ImageTexture_type > r (
        ImageTexture_traits::create (i, f, this));

      this->ImageTexture ().push_back (r);
      continue;
    }

    // MovieTexture
    //
    if (n.name () == "MovieTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MovieTexture_type > r (
        MovieTexture_traits::create (i, f, this));

      this->MovieTexture ().push_back (r);
      continue;
    }

    // MultiTexture
    //
    if (n.name () == "MultiTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MultiTexture_type > r (
        MultiTexture_traits::create (i, f, this));

      this->MultiTexture ().push_back (r);
      continue;
    }

    // PixelTexture
    //
    if (n.name () == "PixelTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PixelTexture_type > r (
        PixelTexture_traits::create (i, f, this));

      this->PixelTexture ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "transparency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< transparency_type > r (
        transparency_traits::create (i, f, this));

      this->transparency (r);
      continue;
    }
  }

  if (!transparency_.present ())
  {
    ::std::auto_ptr< transparency_type > r (
      transparency_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->transparency (r);
  }
}

TextureBackground* TextureBackground::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new TextureBackground (*this, f, c);
}

TextureBackground::
~TextureBackground ()
{
}

// TextureCoordinate
//

TextureCoordinate::
TextureCoordinate ()
: ::X3DTextureCoordinateNode (),
  point_ (::xml_schema::flags (), this)
{
}

TextureCoordinate::
TextureCoordinate (const TextureCoordinate& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DTextureCoordinateNode (x, f, c),
  point_ (x.point_, f, this)
{
}

TextureCoordinate::
TextureCoordinate (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DTextureCoordinateNode (e, f | ::xml_schema::flags::base, c),
  point_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void TextureCoordinate::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTextureCoordinateNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "point" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< point_type > r (
        point_traits::create (i, f, this));

      this->point (r);
      continue;
    }
  }
}

TextureCoordinate* TextureCoordinate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new TextureCoordinate (*this, f, c);
}

TextureCoordinate::
~TextureCoordinate ()
{
}

// TextureCoordinateGenerator
//

const TextureCoordinateGenerator::mode_type TextureCoordinateGenerator::mode_default_value_ (
  ::std::string ("SPHERE"), 0, 0, 0);

TextureCoordinateGenerator::
TextureCoordinateGenerator ()
: ::X3DTextureCoordinateNode (),
  mode_ (mode_default_value (), ::xml_schema::flags (), this),
  parameter_ (::xml_schema::flags (), this)
{
}

TextureCoordinateGenerator::
TextureCoordinateGenerator (const TextureCoordinateGenerator& x,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::X3DTextureCoordinateNode (x, f, c),
  mode_ (x.mode_, f, this),
  parameter_ (x.parameter_, f, this)
{
}

TextureCoordinateGenerator::
TextureCoordinateGenerator (const ::xercesc::DOMElement& e,
                            ::xml_schema::flags f,
                            ::xml_schema::container* c)
: ::X3DTextureCoordinateNode (e, f | ::xml_schema::flags::base, c),
  mode_ (f, this),
  parameter_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void TextureCoordinateGenerator::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTextureCoordinateNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "mode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< mode_type > r (
        mode_traits::create (i, f, this));

      this->mode (r);
      continue;
    }

    if (n.name () == "parameter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< parameter_type > r (
        parameter_traits::create (i, f, this));

      this->parameter (r);
      continue;
    }
  }

  if (!mode_.present ())
  {
    ::std::auto_ptr< mode_type > r (
      mode_traits::create (
        ::std::string ("SPHERE"),
        &p.element (), f, this));

    this->mode (r);
  }
}

TextureCoordinateGenerator* TextureCoordinateGenerator::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new TextureCoordinateGenerator (*this, f, c);
}

TextureCoordinateGenerator::
~TextureCoordinateGenerator ()
{
}

// TextureTransform
//

TextureTransform::
TextureTransform ()
: ::X3DTextureTransform2DNode ()
{
}

TextureTransform::
TextureTransform (const TextureTransform& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DTextureTransform2DNode (x, f, c)
{
}

TextureTransform::
TextureTransform (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DTextureTransform2DNode (e, f, c)
{
}

TextureTransform* TextureTransform::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new TextureTransform (*this, f, c);
}

TextureTransform::
~TextureTransform ()
{
}

// TimeSensor
//

const TimeSensor::cycleInterval_type TimeSensor::cycleInterval_default_value_ (
  ::std::string ("1.0"), 0, 0, 0);

const TimeSensor::enabled_type TimeSensor::enabled_default_value_ (
  ::std::string ("true"), 0, 0, 0);

TimeSensor::
TimeSensor ()
: ::X3DTimeDependentNode (),
  cycleInterval_ (cycleInterval_default_value (), ::xml_schema::flags (), this),
  enabled_ (enabled_default_value (), ::xml_schema::flags (), this)
{
}

TimeSensor::
TimeSensor (const TimeSensor& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DTimeDependentNode (x, f, c),
  cycleInterval_ (x.cycleInterval_, f, this),
  enabled_ (x.enabled_, f, this)
{
}

TimeSensor::
TimeSensor (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DTimeDependentNode (e, f | ::xml_schema::flags::base, c),
  cycleInterval_ (f, this),
  enabled_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void TimeSensor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTimeDependentNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "cycleInterval" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cycleInterval_type > r (
        cycleInterval_traits::create (i, f, this));

      this->cycleInterval (r);
      continue;
    }

    if (n.name () == "enabled" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< enabled_type > r (
        enabled_traits::create (i, f, this));

      this->enabled (r);
      continue;
    }
  }

  if (!cycleInterval_.present ())
  {
    ::std::auto_ptr< cycleInterval_type > r (
      cycleInterval_traits::create (
        ::std::string ("1.0"),
        &p.element (), f, this));

    this->cycleInterval (r);
  }

  if (!enabled_.present ())
  {
    ::std::auto_ptr< enabled_type > r (
      enabled_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->enabled (r);
  }
}

TimeSensor* TimeSensor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new TimeSensor (*this, f, c);
}

TimeSensor::
~TimeSensor ()
{
}

// TimeTrigger
//

TimeTrigger::
TimeTrigger ()
: ::X3DChildNode ()
{
}

TimeTrigger::
TimeTrigger (const TimeTrigger& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DChildNode (x, f, c)
{
}

TimeTrigger::
TimeTrigger (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DChildNode (e, f, c)
{
}

TimeTrigger* TimeTrigger::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new TimeTrigger (*this, f, c);
}

TimeTrigger::
~TimeTrigger ()
{
}

// TouchSensor
//

TouchSensor::
TouchSensor ()
: ::X3DTouchSensorNode ()
{
}

TouchSensor::
TouchSensor (const TouchSensor& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DTouchSensorNode (x, f, c)
{
}

TouchSensor::
TouchSensor (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DTouchSensorNode (e, f, c)
{
}

TouchSensor* TouchSensor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new TouchSensor (*this, f, c);
}

TouchSensor::
~TouchSensor ()
{
}

// Transform
//

const Transform::center_type Transform::center_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const Transform::rotation_type Transform::rotation_default_value_ (
  ::std::string ("0 0 1 0"), 0, 0, 0);

const Transform::scale_type Transform::scale_default_value_ (
  ::std::string ("1 1 1"), 0, 0, 0);

const Transform::scaleOrientation_type Transform::scaleOrientation_default_value_ (
  ::std::string ("0 0 1 0"), 0, 0, 0);

const Transform::translation_type Transform::translation_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

Transform::
Transform ()
: ::X3DGroupingNode (),
  center_ (center_default_value (), ::xml_schema::flags (), this),
  rotation_ (rotation_default_value (), ::xml_schema::flags (), this),
  scale_ (scale_default_value (), ::xml_schema::flags (), this),
  scaleOrientation_ (scaleOrientation_default_value (), ::xml_schema::flags (), this),
  translation_ (translation_default_value (), ::xml_schema::flags (), this)
{
}

Transform::
Transform (const Transform& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c),
  center_ (x.center_, f, this),
  rotation_ (x.rotation_, f, this),
  scale_ (x.scale_, f, this),
  scaleOrientation_ (x.scaleOrientation_, f, this),
  translation_ (x.translation_, f, this)
{
}

Transform::
Transform (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DGroupingNode (e, f | ::xml_schema::flags::base, c),
  center_ (f, this),
  rotation_ (f, this),
  scale_ (f, this),
  scaleOrientation_ (f, this),
  translation_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Transform::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGroupingNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "center" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< center_type > r (
        center_traits::create (i, f, this));

      this->center (r);
      continue;
    }

    if (n.name () == "rotation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rotation_type > r (
        rotation_traits::create (i, f, this));

      this->rotation (r);
      continue;
    }

    if (n.name () == "scale" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< scale_type > r (
        scale_traits::create (i, f, this));

      this->scale (r);
      continue;
    }

    if (n.name () == "scaleOrientation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< scaleOrientation_type > r (
        scaleOrientation_traits::create (i, f, this));

      this->scaleOrientation (r);
      continue;
    }

    if (n.name () == "translation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< translation_type > r (
        translation_traits::create (i, f, this));

      this->translation (r);
      continue;
    }
  }

  if (!center_.present ())
  {
    ::std::auto_ptr< center_type > r (
      center_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->center (r);
  }

  if (!rotation_.present ())
  {
    ::std::auto_ptr< rotation_type > r (
      rotation_traits::create (
        ::std::string ("0 0 1 0"),
        &p.element (), f, this));

    this->rotation (r);
  }

  if (!scale_.present ())
  {
    ::std::auto_ptr< scale_type > r (
      scale_traits::create (
        ::std::string ("1 1 1"),
        &p.element (), f, this));

    this->scale (r);
  }

  if (!scaleOrientation_.present ())
  {
    ::std::auto_ptr< scaleOrientation_type > r (
      scaleOrientation_traits::create (
        ::std::string ("0 0 1 0"),
        &p.element (), f, this));

    this->scaleOrientation (r);
  }

  if (!translation_.present ())
  {
    ::std::auto_ptr< translation_type > r (
      translation_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->translation (r);
  }
}

Transform* Transform::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Transform (*this, f, c);
}

Transform::
~Transform ()
{
}

// TriangleFanSet
//

TriangleFanSet::
TriangleFanSet ()
: ::X3DComposedGeometryNode (),
  fanCount_ (::xml_schema::flags (), this)
{
}

TriangleFanSet::
TriangleFanSet (const TriangleFanSet& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DComposedGeometryNode (x, f, c),
  fanCount_ (x.fanCount_, f, this)
{
}

TriangleFanSet::
TriangleFanSet (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DComposedGeometryNode (e, f | ::xml_schema::flags::base, c),
  fanCount_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void TriangleFanSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DComposedGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "fanCount" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< fanCount_type > r (
        fanCount_traits::create (i, f, this));

      this->fanCount (r);
      continue;
    }
  }
}

TriangleFanSet* TriangleFanSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new TriangleFanSet (*this, f, c);
}

TriangleFanSet::
~TriangleFanSet ()
{
}

// TriangleSet
//

TriangleSet::
TriangleSet ()
: ::X3DComposedGeometryNode ()
{
}

TriangleSet::
TriangleSet (const TriangleSet& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DComposedGeometryNode (x, f, c)
{
}

TriangleSet::
TriangleSet (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DComposedGeometryNode (e, f, c)
{
}

TriangleSet* TriangleSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new TriangleSet (*this, f, c);
}

TriangleSet::
~TriangleSet ()
{
}

// TriangleSet2D
//

const TriangleSet2D::solid_type TriangleSet2D::solid_default_value_ (
  ::std::string ("true"), 0, 0, 0);

TriangleSet2D::
TriangleSet2D ()
: ::X3DGeometryNode (),
  vertices_ (::xml_schema::flags (), this),
  solid_ (solid_default_value (), ::xml_schema::flags (), this)
{
}

TriangleSet2D::
TriangleSet2D (const TriangleSet2D& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  vertices_ (x.vertices_, f, this),
  solid_ (x.solid_, f, this)
{
}

TriangleSet2D::
TriangleSet2D (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  vertices_ (f, this),
  solid_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void TriangleSet2D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "vertices" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vertices_type > r (
        vertices_traits::create (i, f, this));

      this->vertices (r);
      continue;
    }

    if (n.name () == "solid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< solid_type > r (
        solid_traits::create (i, f, this));

      this->solid (r);
      continue;
    }
  }

  if (!solid_.present ())
  {
    ::std::auto_ptr< solid_type > r (
      solid_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->solid (r);
  }
}

TriangleSet2D* TriangleSet2D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new TriangleSet2D (*this, f, c);
}

TriangleSet2D::
~TriangleSet2D ()
{
}

// TriangleStripSet
//

TriangleStripSet::
TriangleStripSet ()
: ::X3DComposedGeometryNode (),
  stripCount_ (::xml_schema::flags (), this)
{
}

TriangleStripSet::
TriangleStripSet (const TriangleStripSet& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DComposedGeometryNode (x, f, c),
  stripCount_ (x.stripCount_, f, this)
{
}

TriangleStripSet::
TriangleStripSet (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DComposedGeometryNode (e, f | ::xml_schema::flags::base, c),
  stripCount_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void TriangleStripSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DComposedGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "stripCount" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< stripCount_type > r (
        stripCount_traits::create (i, f, this));

      this->stripCount (r);
      continue;
    }
  }
}

TriangleStripSet* TriangleStripSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new TriangleStripSet (*this, f, c);
}

TriangleStripSet::
~TriangleStripSet ()
{
}

// Viewpoint
//

const Viewpoint::fieldOfView_type Viewpoint::fieldOfView_default_value_ (
  ::std::string ("0.785398"), 0, 0, 0);

const Viewpoint::jump_type Viewpoint::jump_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const Viewpoint::orientation_type Viewpoint::orientation_default_value_ (
  ::std::string ("0 0 1 0"), 0, 0, 0);

const Viewpoint::position_type Viewpoint::position_default_value_ (
  ::std::string ("0 0 10"), 0, 0, 0);

const Viewpoint::centerOfRotation_type Viewpoint::centerOfRotation_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

Viewpoint::
Viewpoint ()
: ::X3DBindableNode (),
  fieldOfView_ (fieldOfView_default_value (), ::xml_schema::flags (), this),
  jump_ (jump_default_value (), ::xml_schema::flags (), this),
  orientation_ (orientation_default_value (), ::xml_schema::flags (), this),
  position_ (position_default_value (), ::xml_schema::flags (), this),
  description_ (::xml_schema::flags (), this),
  centerOfRotation_ (centerOfRotation_default_value (), ::xml_schema::flags (), this)
{
}

Viewpoint::
Viewpoint (const Viewpoint& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DBindableNode (x, f, c),
  fieldOfView_ (x.fieldOfView_, f, this),
  jump_ (x.jump_, f, this),
  orientation_ (x.orientation_, f, this),
  position_ (x.position_, f, this),
  description_ (x.description_, f, this),
  centerOfRotation_ (x.centerOfRotation_, f, this)
{
}

Viewpoint::
Viewpoint (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DBindableNode (e, f | ::xml_schema::flags::base, c),
  fieldOfView_ (f, this),
  jump_ (f, this),
  orientation_ (f, this),
  position_ (f, this),
  description_ (f, this),
  centerOfRotation_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Viewpoint::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DBindableNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "fieldOfView" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< fieldOfView_type > r (
        fieldOfView_traits::create (i, f, this));

      this->fieldOfView (r);
      continue;
    }

    if (n.name () == "jump" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< jump_type > r (
        jump_traits::create (i, f, this));

      this->jump (r);
      continue;
    }

    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< orientation_type > r (
        orientation_traits::create (i, f, this));

      this->orientation (r);
      continue;
    }

    if (n.name () == "position" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< position_type > r (
        position_traits::create (i, f, this));

      this->position (r);
      continue;
    }

    if (n.name () == "description" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< description_type > r (
        description_traits::create (i, f, this));

      this->description (r);
      continue;
    }

    if (n.name () == "centerOfRotation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< centerOfRotation_type > r (
        centerOfRotation_traits::create (i, f, this));

      this->centerOfRotation (r);
      continue;
    }
  }

  if (!fieldOfView_.present ())
  {
    ::std::auto_ptr< fieldOfView_type > r (
      fieldOfView_traits::create (
        ::std::string ("0.785398"),
        &p.element (), f, this));

    this->fieldOfView (r);
  }

  if (!jump_.present ())
  {
    ::std::auto_ptr< jump_type > r (
      jump_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->jump (r);
  }

  if (!orientation_.present ())
  {
    ::std::auto_ptr< orientation_type > r (
      orientation_traits::create (
        ::std::string ("0 0 1 0"),
        &p.element (), f, this));

    this->orientation (r);
  }

  if (!position_.present ())
  {
    ::std::auto_ptr< position_type > r (
      position_traits::create (
        ::std::string ("0 0 10"),
        &p.element (), f, this));

    this->position (r);
  }

  if (!centerOfRotation_.present ())
  {
    ::std::auto_ptr< centerOfRotation_type > r (
      centerOfRotation_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->centerOfRotation (r);
  }
}

Viewpoint* Viewpoint::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Viewpoint (*this, f, c);
}

Viewpoint::
~Viewpoint ()
{
}

// VisibilitySensor
//

VisibilitySensor::
VisibilitySensor ()
: ::X3DEnvironmentalSensorNode ()
{
}

VisibilitySensor::
VisibilitySensor (const VisibilitySensor& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DEnvironmentalSensorNode (x, f, c)
{
}

VisibilitySensor::
VisibilitySensor (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DEnvironmentalSensorNode (e, f, c)
{
}

VisibilitySensor* VisibilitySensor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new VisibilitySensor (*this, f, c);
}

VisibilitySensor::
~VisibilitySensor ()
{
}

// WorldInfo
//

WorldInfo::
WorldInfo ()
: ::X3DInfoNode (),
  info_ (::xml_schema::flags (), this),
  title_ (::xml_schema::flags (), this)
{
}

WorldInfo::
WorldInfo (const WorldInfo& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DInfoNode (x, f, c),
  info_ (x.info_, f, this),
  title_ (x.title_, f, this)
{
}

WorldInfo::
WorldInfo (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DInfoNode (e, f | ::xml_schema::flags::base, c),
  info_ (f, this),
  title_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void WorldInfo::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DInfoNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "info" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< info_type > r (
        info_traits::create (i, f, this));

      this->info (r);
      continue;
    }

    if (n.name () == "title" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< title_type > r (
        title_traits::create (i, f, this));

      this->title (r);
      continue;
    }
  }
}

WorldInfo* WorldInfo::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new WorldInfo (*this, f, c);
}

WorldInfo::
~WorldInfo ()
{
}

// component
//

component::
component (const name_type& name,
           const level_type& level)
: ::SceneGraphStructureNodeType (),
  name_ (name, ::xml_schema::flags (), this),
  level_ (level, ::xml_schema::flags (), this)
{
}

component::
component (const component& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (x, f, c),
  name_ (x.name_, f, this),
  level_ (x.level_, f, this)
{
}

component::
component (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (e, f | ::xml_schema::flags::base, c),
  name_ (f, this),
  level_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void component::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name (r);
      continue;
    }

    if (n.name () == "level" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< level_type > r (
        level_traits::create (i, f, this));

      this->level (r);
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!level_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "level",
      "");
  }
}

component* component::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new component (*this, f, c);
}

component::
~component ()
{
}

// EXPORT
//

EXPORT::
EXPORT (const localDEF_type& localDEF)
: ::SceneGraphStructureNodeType (),
  localDEF_ (localDEF, ::xml_schema::flags (), this),
  AS_ (::xml_schema::flags (), this)
{
}

EXPORT::
EXPORT (const EXPORT& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (x, f, c),
  localDEF_ (x.localDEF_, f, this),
  AS_ (x.AS_, f, this)
{
}

EXPORT::
EXPORT (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (e, f | ::xml_schema::flags::base, c),
  localDEF_ (f, this),
  AS_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void EXPORT::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "localDEF" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< localDEF_type > r (
        localDEF_traits::create (i, f, this));

      this->localDEF (r);
      continue;
    }

    if (n.name () == "AS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AS_type > r (
        AS_traits::create (i, f, this));

      this->AS (r);
      continue;
    }
  }

  if (!localDEF_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "localDEF",
      "");
  }
}

EXPORT* EXPORT::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new EXPORT (*this, f, c);
}

EXPORT::
~EXPORT ()
{
}

// IMPORT
//

IMPORT::
IMPORT (const inlineDEF_type& inlineDEF,
        const importedDEF_type& importedDEF)
: ::SceneGraphStructureNodeType (),
  inlineDEF_ (inlineDEF, ::xml_schema::flags (), this),
  importedDEF_ (importedDEF, ::xml_schema::flags (), this),
  AS_ (::xml_schema::flags (), this)
{
}

IMPORT::
IMPORT (const IMPORT& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (x, f, c),
  inlineDEF_ (x.inlineDEF_, f, this),
  importedDEF_ (x.importedDEF_, f, this),
  AS_ (x.AS_, f, this)
{
}

IMPORT::
IMPORT (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (e, f | ::xml_schema::flags::base, c),
  inlineDEF_ (f, this),
  importedDEF_ (f, this),
  AS_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void IMPORT::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "inlineDEF" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< inlineDEF_type > r (
        inlineDEF_traits::create (i, f, this));

      this->inlineDEF (r);
      continue;
    }

    if (n.name () == "importedDEF" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< importedDEF_type > r (
        importedDEF_traits::create (i, f, this));

      this->importedDEF (r);
      continue;
    }

    if (n.name () == "AS" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AS_type > r (
        AS_traits::create (i, f, this));

      this->AS (r);
      continue;
    }
  }

  if (!inlineDEF_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "inlineDEF",
      "");
  }

  if (!importedDEF_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "importedDEF",
      "");
  }
}

IMPORT* IMPORT::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new IMPORT (*this, f, c);
}

IMPORT::
~IMPORT ()
{
}

// IS
//

IS::
IS ()
: ::SceneGraphStructureNodeType (),
  connect_ (::xml_schema::flags (), this)
{
}

IS::
IS (const IS& x,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (x, f, c),
  connect_ (x.connect_, f, this)
{
}

IS::
IS (const ::xercesc::DOMElement& e,
    ::xml_schema::flags f,
    ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (e, f | ::xml_schema::flags::base, c),
  connect_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void IS::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // connect
    //
    if (n.name () == "connect" && n.namespace_ () == "")
    {
      ::std::auto_ptr< connect_type > r (
        connect_traits::create (i, f, this));

      this->connect ().push_back (r);
      continue;
    }

    break;
  }
}

IS* IS::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new IS (*this, f, c);
}

IS::
~IS ()
{
}

// connect
//

connect::
connect (const nodeField_type& nodeField,
         const protoField_type& protoField)
: ::SceneGraphStructureNodeType (),
  nodeField_ (nodeField, ::xml_schema::flags (), this),
  protoField_ (protoField, ::xml_schema::flags (), this)
{
}

connect::
connect (const connect& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (x, f, c),
  nodeField_ (x.nodeField_, f, this),
  protoField_ (x.protoField_, f, this)
{
}

connect::
connect (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (e, f | ::xml_schema::flags::base, c),
  nodeField_ (f, this),
  protoField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void connect::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "nodeField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< nodeField_type > r (
        nodeField_traits::create (i, f, this));

      this->nodeField (r);
      continue;
    }

    if (n.name () == "protoField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< protoField_type > r (
        protoField_traits::create (i, f, this));

      this->protoField (r);
      continue;
    }
  }

  if (!nodeField_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "nodeField",
      "");
  }

  if (!protoField_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "protoField",
      "");
  }
}

connect* connect::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new connect (*this, f, c);
}

connect::
~connect ()
{
}

// field
//

field::
field (const name_type& name,
       const accessType_type& accessType,
       const type_type& type)
: ::SceneGraphStructureNodeType (),
  FillProperties_ (::xml_schema::flags (), this),
  LineProperties_ (::xml_schema::flags (), this),
  Material_ (::xml_schema::flags (), this),
  ComposedShader_ (::xml_schema::flags (), this),
  PackagedShader_ (::xml_schema::flags (), this),
  ProgramShader_ (::xml_schema::flags (), this),
  ComposedCubeMapTexture_ (::xml_schema::flags (), this),
  ImageTexture_ (::xml_schema::flags (), this),
  MovieTexture_ (::xml_schema::flags (), this),
  MultiTexture_ (::xml_schema::flags (), this),
  PixelTexture_ (::xml_schema::flags (), this),
  GeneratedCubeMapTexture_ (::xml_schema::flags (), this),
  ImageCubeMapTexture_ (::xml_schema::flags (), this),
  MultiTextureTransform_ (::xml_schema::flags (), this),
  TextureTransform_ (::xml_schema::flags (), this),
  MetadataDouble_ (::xml_schema::flags (), this),
  MetadataFloat_ (::xml_schema::flags (), this),
  MetadataInteger_ (::xml_schema::flags (), this),
  MetadataSet_ (::xml_schema::flags (), this),
  MetadataString_ (::xml_schema::flags (), this),
  Appearance_ (::xml_schema::flags (), this),
  Background_ (::xml_schema::flags (), this),
  ColorInterpolator_ (::xml_schema::flags (), this),
  CoordinateInterpolator_ (::xml_schema::flags (), this),
  DirectionalLight_ (::xml_schema::flags (), this),
  Group_ (::xml_schema::flags (), this),
  NavigationInfo_ (::xml_schema::flags (), this),
  NormalInterpolator_ (::xml_schema::flags (), this),
  OrientationInterpolator_ (::xml_schema::flags (), this),
  PositionInterpolator_ (::xml_schema::flags (), this),
  ScalarInterpolator_ (::xml_schema::flags (), this),
  Shape_ (::xml_schema::flags (), this),
  TimeSensor_ (::xml_schema::flags (), this),
  Transform_ (::xml_schema::flags (), this),
  Viewpoint_ (::xml_schema::flags (), this),
  WorldInfo_ (::xml_schema::flags (), this),
  Anchor_ (::xml_schema::flags (), this),
  BooleanFilter_ (::xml_schema::flags (), this),
  BooleanSequencer_ (::xml_schema::flags (), this),
  BooleanToggle_ (::xml_schema::flags (), this),
  BooleanTrigger_ (::xml_schema::flags (), this),
  CylinderSensor_ (::xml_schema::flags (), this),
  Inline_ (::xml_schema::flags (), this),
  IntegerSequencer_ (::xml_schema::flags (), this),
  IntegerTrigger_ (::xml_schema::flags (), this),
  KeySensor_ (::xml_schema::flags (), this),
  PlaneSensor_ (::xml_schema::flags (), this),
  PointLight_ (::xml_schema::flags (), this),
  ProximitySensor_ (::xml_schema::flags (), this),
  SphereSensor_ (::xml_schema::flags (), this),
  SpotLight_ (::xml_schema::flags (), this),
  StringSensor_ (::xml_schema::flags (), this),
  Switch_ (::xml_schema::flags (), this),
  TimeTrigger_ (::xml_schema::flags (), this),
  TouchSensor_ (::xml_schema::flags (), this),
  AudioClip_ (::xml_schema::flags (), this),
  Billboard_ (::xml_schema::flags (), this),
  Collision_ (::xml_schema::flags (), this),
  Fog_ (::xml_schema::flags (), this),
  LoadSensor_ (::xml_schema::flags (), this),
  LocalFog_ (::xml_schema::flags (), this),
  LOD_ (::xml_schema::flags (), this),
  Script_ (::xml_schema::flags (), this),
  Sound_ (::xml_schema::flags (), this),
  VisibilitySensor_ (::xml_schema::flags (), this),
  CoordinateInterpolator2D_ (::xml_schema::flags (), this),
  PositionInterpolator2D_ (::xml_schema::flags (), this),
  StaticGroup_ (::xml_schema::flags (), this),
  CADAssembly_ (::xml_schema::flags (), this),
  CADLayer_ (::xml_schema::flags (), this),
  EspduTransform_ (::xml_schema::flags (), this),
  ReceiverPdu_ (::xml_schema::flags (), this),
  SignalPdu_ (::xml_schema::flags (), this),
  TransmitterPdu_ (::xml_schema::flags (), this),
  GeoLocation_ (::xml_schema::flags (), this),
  GeoLOD_ (::xml_schema::flags (), this),
  GeoMetadata_ (::xml_schema::flags (), this),
  GeoOrigin_ (::xml_schema::flags (), this),
  GeoPositionInterpolator_ (::xml_schema::flags (), this),
  GeoTouchSensor_ (::xml_schema::flags (), this),
  GeoViewpoint_ (::xml_schema::flags (), this),
  HAnimHumanoid_ (::xml_schema::flags (), this),
  HAnimJoint_ (::xml_schema::flags (), this),
  HAnimSegment_ (::xml_schema::flags (), this),
  HAnimSite_ (::xml_schema::flags (), this),
  NurbsOrientationInterpolator_ (::xml_schema::flags (), this),
  NurbsPositionInterpolator_ (::xml_schema::flags (), this),
  NurbsSurfaceInterpolator_ (::xml_schema::flags (), this),
  NurbsSet_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  Box_ (::xml_schema::flags (), this),
  Cone_ (::xml_schema::flags (), this),
  Cylinder_ (::xml_schema::flags (), this),
  IndexedFaceSet_ (::xml_schema::flags (), this),
  IndexedLineSet_ (::xml_schema::flags (), this),
  IndexedTriangleFanSet_ (::xml_schema::flags (), this),
  IndexedTriangleSet_ (::xml_schema::flags (), this),
  IndexedTriangleStripSet_ (::xml_schema::flags (), this),
  LineSet_ (::xml_schema::flags (), this),
  PointSet_ (::xml_schema::flags (), this),
  Sphere_ (::xml_schema::flags (), this),
  TriangleFanSet_ (::xml_schema::flags (), this),
  TriangleSet_ (::xml_schema::flags (), this),
  TriangleStripSet_ (::xml_schema::flags (), this),
  ElevationGrid_ (::xml_schema::flags (), this),
  Polyline2D_ (::xml_schema::flags (), this),
  Polypoint2D_ (::xml_schema::flags (), this),
  Rectangle2D_ (::xml_schema::flags (), this),
  TriangleSet2D_ (::xml_schema::flags (), this),
  Extrusion_ (::xml_schema::flags (), this),
  Text_ (::xml_schema::flags (), this),
  Arc2D_ (::xml_schema::flags (), this),
  ArcClose2D_ (::xml_schema::flags (), this),
  Circle2D_ (::xml_schema::flags (), this),
  Disk2D_ (::xml_schema::flags (), this),
  QuadSet_ (::xml_schema::flags (), this),
  IndexedQuadSet_ (::xml_schema::flags (), this),
  GeoElevationGrid_ (::xml_schema::flags (), this),
  NurbsCurve_ (::xml_schema::flags (), this),
  NurbsCurve2D_ (::xml_schema::flags (), this),
  NurbsPatchSurface_ (::xml_schema::flags (), this),
  NurbsSweptSurface_ (::xml_schema::flags (), this),
  NurbsSwungSurface_ (::xml_schema::flags (), this),
  NurbsTrimmedSurface_ (::xml_schema::flags (), this),
  Color_ (::xml_schema::flags (), this),
  ColorRGBA_ (::xml_schema::flags (), this),
  Coordinate_ (::xml_schema::flags (), this),
  CoordinateDouble_ (::xml_schema::flags (), this),
  FontStyle_ (::xml_schema::flags (), this),
  GeoCoordinate_ (::xml_schema::flags (), this),
  Normal_ (::xml_schema::flags (), this),
  TextureCoordinate_ (::xml_schema::flags (), this),
  NurbsTextureCoordinate_ (::xml_schema::flags (), this),
  name_ (name, ::xml_schema::flags (), this),
  accessType_ (accessType, ::xml_schema::flags (), this),
  type_ (type, ::xml_schema::flags (), this),
  value_ (::xml_schema::flags (), this),
  appinfo_ (::xml_schema::flags (), this),
  documentation_ (::xml_schema::flags (), this)
{
}

field::
field (const field& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (x, f, c),
  FillProperties_ (x.FillProperties_, f, this),
  LineProperties_ (x.LineProperties_, f, this),
  Material_ (x.Material_, f, this),
  ComposedShader_ (x.ComposedShader_, f, this),
  PackagedShader_ (x.PackagedShader_, f, this),
  ProgramShader_ (x.ProgramShader_, f, this),
  ComposedCubeMapTexture_ (x.ComposedCubeMapTexture_, f, this),
  ImageTexture_ (x.ImageTexture_, f, this),
  MovieTexture_ (x.MovieTexture_, f, this),
  MultiTexture_ (x.MultiTexture_, f, this),
  PixelTexture_ (x.PixelTexture_, f, this),
  GeneratedCubeMapTexture_ (x.GeneratedCubeMapTexture_, f, this),
  ImageCubeMapTexture_ (x.ImageCubeMapTexture_, f, this),
  MultiTextureTransform_ (x.MultiTextureTransform_, f, this),
  TextureTransform_ (x.TextureTransform_, f, this),
  MetadataDouble_ (x.MetadataDouble_, f, this),
  MetadataFloat_ (x.MetadataFloat_, f, this),
  MetadataInteger_ (x.MetadataInteger_, f, this),
  MetadataSet_ (x.MetadataSet_, f, this),
  MetadataString_ (x.MetadataString_, f, this),
  Appearance_ (x.Appearance_, f, this),
  Background_ (x.Background_, f, this),
  ColorInterpolator_ (x.ColorInterpolator_, f, this),
  CoordinateInterpolator_ (x.CoordinateInterpolator_, f, this),
  DirectionalLight_ (x.DirectionalLight_, f, this),
  Group_ (x.Group_, f, this),
  NavigationInfo_ (x.NavigationInfo_, f, this),
  NormalInterpolator_ (x.NormalInterpolator_, f, this),
  OrientationInterpolator_ (x.OrientationInterpolator_, f, this),
  PositionInterpolator_ (x.PositionInterpolator_, f, this),
  ScalarInterpolator_ (x.ScalarInterpolator_, f, this),
  Shape_ (x.Shape_, f, this),
  TimeSensor_ (x.TimeSensor_, f, this),
  Transform_ (x.Transform_, f, this),
  Viewpoint_ (x.Viewpoint_, f, this),
  WorldInfo_ (x.WorldInfo_, f, this),
  Anchor_ (x.Anchor_, f, this),
  BooleanFilter_ (x.BooleanFilter_, f, this),
  BooleanSequencer_ (x.BooleanSequencer_, f, this),
  BooleanToggle_ (x.BooleanToggle_, f, this),
  BooleanTrigger_ (x.BooleanTrigger_, f, this),
  CylinderSensor_ (x.CylinderSensor_, f, this),
  Inline_ (x.Inline_, f, this),
  IntegerSequencer_ (x.IntegerSequencer_, f, this),
  IntegerTrigger_ (x.IntegerTrigger_, f, this),
  KeySensor_ (x.KeySensor_, f, this),
  PlaneSensor_ (x.PlaneSensor_, f, this),
  PointLight_ (x.PointLight_, f, this),
  ProximitySensor_ (x.ProximitySensor_, f, this),
  SphereSensor_ (x.SphereSensor_, f, this),
  SpotLight_ (x.SpotLight_, f, this),
  StringSensor_ (x.StringSensor_, f, this),
  Switch_ (x.Switch_, f, this),
  TimeTrigger_ (x.TimeTrigger_, f, this),
  TouchSensor_ (x.TouchSensor_, f, this),
  AudioClip_ (x.AudioClip_, f, this),
  Billboard_ (x.Billboard_, f, this),
  Collision_ (x.Collision_, f, this),
  Fog_ (x.Fog_, f, this),
  LoadSensor_ (x.LoadSensor_, f, this),
  LocalFog_ (x.LocalFog_, f, this),
  LOD_ (x.LOD_, f, this),
  Script_ (x.Script_, f, this),
  Sound_ (x.Sound_, f, this),
  VisibilitySensor_ (x.VisibilitySensor_, f, this),
  CoordinateInterpolator2D_ (x.CoordinateInterpolator2D_, f, this),
  PositionInterpolator2D_ (x.PositionInterpolator2D_, f, this),
  StaticGroup_ (x.StaticGroup_, f, this),
  CADAssembly_ (x.CADAssembly_, f, this),
  CADLayer_ (x.CADLayer_, f, this),
  EspduTransform_ (x.EspduTransform_, f, this),
  ReceiverPdu_ (x.ReceiverPdu_, f, this),
  SignalPdu_ (x.SignalPdu_, f, this),
  TransmitterPdu_ (x.TransmitterPdu_, f, this),
  GeoLocation_ (x.GeoLocation_, f, this),
  GeoLOD_ (x.GeoLOD_, f, this),
  GeoMetadata_ (x.GeoMetadata_, f, this),
  GeoOrigin_ (x.GeoOrigin_, f, this),
  GeoPositionInterpolator_ (x.GeoPositionInterpolator_, f, this),
  GeoTouchSensor_ (x.GeoTouchSensor_, f, this),
  GeoViewpoint_ (x.GeoViewpoint_, f, this),
  HAnimHumanoid_ (x.HAnimHumanoid_, f, this),
  HAnimJoint_ (x.HAnimJoint_, f, this),
  HAnimSegment_ (x.HAnimSegment_, f, this),
  HAnimSite_ (x.HAnimSite_, f, this),
  NurbsOrientationInterpolator_ (x.NurbsOrientationInterpolator_, f, this),
  NurbsPositionInterpolator_ (x.NurbsPositionInterpolator_, f, this),
  NurbsSurfaceInterpolator_ (x.NurbsSurfaceInterpolator_, f, this),
  NurbsSet_ (x.NurbsSet_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  Box_ (x.Box_, f, this),
  Cone_ (x.Cone_, f, this),
  Cylinder_ (x.Cylinder_, f, this),
  IndexedFaceSet_ (x.IndexedFaceSet_, f, this),
  IndexedLineSet_ (x.IndexedLineSet_, f, this),
  IndexedTriangleFanSet_ (x.IndexedTriangleFanSet_, f, this),
  IndexedTriangleSet_ (x.IndexedTriangleSet_, f, this),
  IndexedTriangleStripSet_ (x.IndexedTriangleStripSet_, f, this),
  LineSet_ (x.LineSet_, f, this),
  PointSet_ (x.PointSet_, f, this),
  Sphere_ (x.Sphere_, f, this),
  TriangleFanSet_ (x.TriangleFanSet_, f, this),
  TriangleSet_ (x.TriangleSet_, f, this),
  TriangleStripSet_ (x.TriangleStripSet_, f, this),
  ElevationGrid_ (x.ElevationGrid_, f, this),
  Polyline2D_ (x.Polyline2D_, f, this),
  Polypoint2D_ (x.Polypoint2D_, f, this),
  Rectangle2D_ (x.Rectangle2D_, f, this),
  TriangleSet2D_ (x.TriangleSet2D_, f, this),
  Extrusion_ (x.Extrusion_, f, this),
  Text_ (x.Text_, f, this),
  Arc2D_ (x.Arc2D_, f, this),
  ArcClose2D_ (x.ArcClose2D_, f, this),
  Circle2D_ (x.Circle2D_, f, this),
  Disk2D_ (x.Disk2D_, f, this),
  QuadSet_ (x.QuadSet_, f, this),
  IndexedQuadSet_ (x.IndexedQuadSet_, f, this),
  GeoElevationGrid_ (x.GeoElevationGrid_, f, this),
  NurbsCurve_ (x.NurbsCurve_, f, this),
  NurbsCurve2D_ (x.NurbsCurve2D_, f, this),
  NurbsPatchSurface_ (x.NurbsPatchSurface_, f, this),
  NurbsSweptSurface_ (x.NurbsSweptSurface_, f, this),
  NurbsSwungSurface_ (x.NurbsSwungSurface_, f, this),
  NurbsTrimmedSurface_ (x.NurbsTrimmedSurface_, f, this),
  Color_ (x.Color_, f, this),
  ColorRGBA_ (x.ColorRGBA_, f, this),
  Coordinate_ (x.Coordinate_, f, this),
  CoordinateDouble_ (x.CoordinateDouble_, f, this),
  FontStyle_ (x.FontStyle_, f, this),
  GeoCoordinate_ (x.GeoCoordinate_, f, this),
  Normal_ (x.Normal_, f, this),
  TextureCoordinate_ (x.TextureCoordinate_, f, this),
  NurbsTextureCoordinate_ (x.NurbsTextureCoordinate_, f, this),
  name_ (x.name_, f, this),
  accessType_ (x.accessType_, f, this),
  type_ (x.type_, f, this),
  value_ (x.value_, f, this),
  appinfo_ (x.appinfo_, f, this),
  documentation_ (x.documentation_, f, this)
{
}

field::
field (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (e, f | ::xml_schema::flags::base, c),
  FillProperties_ (f, this),
  LineProperties_ (f, this),
  Material_ (f, this),
  ComposedShader_ (f, this),
  PackagedShader_ (f, this),
  ProgramShader_ (f, this),
  ComposedCubeMapTexture_ (f, this),
  ImageTexture_ (f, this),
  MovieTexture_ (f, this),
  MultiTexture_ (f, this),
  PixelTexture_ (f, this),
  GeneratedCubeMapTexture_ (f, this),
  ImageCubeMapTexture_ (f, this),
  MultiTextureTransform_ (f, this),
  TextureTransform_ (f, this),
  MetadataDouble_ (f, this),
  MetadataFloat_ (f, this),
  MetadataInteger_ (f, this),
  MetadataSet_ (f, this),
  MetadataString_ (f, this),
  Appearance_ (f, this),
  Background_ (f, this),
  ColorInterpolator_ (f, this),
  CoordinateInterpolator_ (f, this),
  DirectionalLight_ (f, this),
  Group_ (f, this),
  NavigationInfo_ (f, this),
  NormalInterpolator_ (f, this),
  OrientationInterpolator_ (f, this),
  PositionInterpolator_ (f, this),
  ScalarInterpolator_ (f, this),
  Shape_ (f, this),
  TimeSensor_ (f, this),
  Transform_ (f, this),
  Viewpoint_ (f, this),
  WorldInfo_ (f, this),
  Anchor_ (f, this),
  BooleanFilter_ (f, this),
  BooleanSequencer_ (f, this),
  BooleanToggle_ (f, this),
  BooleanTrigger_ (f, this),
  CylinderSensor_ (f, this),
  Inline_ (f, this),
  IntegerSequencer_ (f, this),
  IntegerTrigger_ (f, this),
  KeySensor_ (f, this),
  PlaneSensor_ (f, this),
  PointLight_ (f, this),
  ProximitySensor_ (f, this),
  SphereSensor_ (f, this),
  SpotLight_ (f, this),
  StringSensor_ (f, this),
  Switch_ (f, this),
  TimeTrigger_ (f, this),
  TouchSensor_ (f, this),
  AudioClip_ (f, this),
  Billboard_ (f, this),
  Collision_ (f, this),
  Fog_ (f, this),
  LoadSensor_ (f, this),
  LocalFog_ (f, this),
  LOD_ (f, this),
  Script_ (f, this),
  Sound_ (f, this),
  VisibilitySensor_ (f, this),
  CoordinateInterpolator2D_ (f, this),
  PositionInterpolator2D_ (f, this),
  StaticGroup_ (f, this),
  CADAssembly_ (f, this),
  CADLayer_ (f, this),
  EspduTransform_ (f, this),
  ReceiverPdu_ (f, this),
  SignalPdu_ (f, this),
  TransmitterPdu_ (f, this),
  GeoLocation_ (f, this),
  GeoLOD_ (f, this),
  GeoMetadata_ (f, this),
  GeoOrigin_ (f, this),
  GeoPositionInterpolator_ (f, this),
  GeoTouchSensor_ (f, this),
  GeoViewpoint_ (f, this),
  HAnimHumanoid_ (f, this),
  HAnimJoint_ (f, this),
  HAnimSegment_ (f, this),
  HAnimSite_ (f, this),
  NurbsOrientationInterpolator_ (f, this),
  NurbsPositionInterpolator_ (f, this),
  NurbsSurfaceInterpolator_ (f, this),
  NurbsSet_ (f, this),
  ProtoInstance_ (f, this),
  Box_ (f, this),
  Cone_ (f, this),
  Cylinder_ (f, this),
  IndexedFaceSet_ (f, this),
  IndexedLineSet_ (f, this),
  IndexedTriangleFanSet_ (f, this),
  IndexedTriangleSet_ (f, this),
  IndexedTriangleStripSet_ (f, this),
  LineSet_ (f, this),
  PointSet_ (f, this),
  Sphere_ (f, this),
  TriangleFanSet_ (f, this),
  TriangleSet_ (f, this),
  TriangleStripSet_ (f, this),
  ElevationGrid_ (f, this),
  Polyline2D_ (f, this),
  Polypoint2D_ (f, this),
  Rectangle2D_ (f, this),
  TriangleSet2D_ (f, this),
  Extrusion_ (f, this),
  Text_ (f, this),
  Arc2D_ (f, this),
  ArcClose2D_ (f, this),
  Circle2D_ (f, this),
  Disk2D_ (f, this),
  QuadSet_ (f, this),
  IndexedQuadSet_ (f, this),
  GeoElevationGrid_ (f, this),
  NurbsCurve_ (f, this),
  NurbsCurve2D_ (f, this),
  NurbsPatchSurface_ (f, this),
  NurbsSweptSurface_ (f, this),
  NurbsSwungSurface_ (f, this),
  NurbsTrimmedSurface_ (f, this),
  Color_ (f, this),
  ColorRGBA_ (f, this),
  Coordinate_ (f, this),
  CoordinateDouble_ (f, this),
  FontStyle_ (f, this),
  GeoCoordinate_ (f, this),
  Normal_ (f, this),
  TextureCoordinate_ (f, this),
  NurbsTextureCoordinate_ (f, this),
  name_ (f, this),
  accessType_ (f, this),
  type_ (f, this),
  value_ (f, this),
  appinfo_ (f, this),
  documentation_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void field::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // FillProperties
    //
    if (n.name () == "FillProperties" && n.namespace_ () == "")
    {
      ::std::auto_ptr< FillProperties_type > r (
        FillProperties_traits::create (i, f, this));

      this->FillProperties ().push_back (r);
      continue;
    }

    // LineProperties
    //
    if (n.name () == "LineProperties" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LineProperties_type > r (
        LineProperties_traits::create (i, f, this));

      this->LineProperties ().push_back (r);
      continue;
    }

    // Material
    //
    if (n.name () == "Material" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Material_type > r (
        Material_traits::create (i, f, this));

      this->Material ().push_back (r);
      continue;
    }

    // ComposedShader
    //
    if (n.name () == "ComposedShader" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ComposedShader_type > r (
        ComposedShader_traits::create (i, f, this));

      this->ComposedShader ().push_back (r);
      continue;
    }

    // PackagedShader
    //
    if (n.name () == "PackagedShader" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PackagedShader_type > r (
        PackagedShader_traits::create (i, f, this));

      this->PackagedShader ().push_back (r);
      continue;
    }

    // ProgramShader
    //
    if (n.name () == "ProgramShader" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProgramShader_type > r (
        ProgramShader_traits::create (i, f, this));

      this->ProgramShader ().push_back (r);
      continue;
    }

    // ComposedCubeMapTexture
    //
    if (n.name () == "ComposedCubeMapTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ComposedCubeMapTexture_type > r (
        ComposedCubeMapTexture_traits::create (i, f, this));

      this->ComposedCubeMapTexture ().push_back (r);
      continue;
    }

    // ImageTexture
    //
    if (n.name () == "ImageTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ImageTexture_type > r (
        ImageTexture_traits::create (i, f, this));

      this->ImageTexture ().push_back (r);
      continue;
    }

    // MovieTexture
    //
    if (n.name () == "MovieTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MovieTexture_type > r (
        MovieTexture_traits::create (i, f, this));

      this->MovieTexture ().push_back (r);
      continue;
    }

    // MultiTexture
    //
    if (n.name () == "MultiTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MultiTexture_type > r (
        MultiTexture_traits::create (i, f, this));

      this->MultiTexture ().push_back (r);
      continue;
    }

    // PixelTexture
    //
    if (n.name () == "PixelTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PixelTexture_type > r (
        PixelTexture_traits::create (i, f, this));

      this->PixelTexture ().push_back (r);
      continue;
    }

    // GeneratedCubeMapTexture
    //
    if (n.name () == "GeneratedCubeMapTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeneratedCubeMapTexture_type > r (
        GeneratedCubeMapTexture_traits::create (i, f, this));

      this->GeneratedCubeMapTexture ().push_back (r);
      continue;
    }

    // ImageCubeMapTexture
    //
    if (n.name () == "ImageCubeMapTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ImageCubeMapTexture_type > r (
        ImageCubeMapTexture_traits::create (i, f, this));

      this->ImageCubeMapTexture ().push_back (r);
      continue;
    }

    // MultiTextureTransform
    //
    if (n.name () == "MultiTextureTransform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MultiTextureTransform_type > r (
        MultiTextureTransform_traits::create (i, f, this));

      this->MultiTextureTransform ().push_back (r);
      continue;
    }

    // TextureTransform
    //
    if (n.name () == "TextureTransform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureTransform_type > r (
        TextureTransform_traits::create (i, f, this));

      this->TextureTransform ().push_back (r);
      continue;
    }

    // MetadataDouble
    //
    if (n.name () == "MetadataDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataDouble_type > r (
        MetadataDouble_traits::create (i, f, this));

      this->MetadataDouble ().push_back (r);
      continue;
    }

    // MetadataFloat
    //
    if (n.name () == "MetadataFloat" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataFloat_type > r (
        MetadataFloat_traits::create (i, f, this));

      this->MetadataFloat ().push_back (r);
      continue;
    }

    // MetadataInteger
    //
    if (n.name () == "MetadataInteger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataInteger_type > r (
        MetadataInteger_traits::create (i, f, this));

      this->MetadataInteger ().push_back (r);
      continue;
    }

    // MetadataSet
    //
    if (n.name () == "MetadataSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataSet_type > r (
        MetadataSet_traits::create (i, f, this));

      this->MetadataSet ().push_back (r);
      continue;
    }

    // MetadataString
    //
    if (n.name () == "MetadataString" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataString_type > r (
        MetadataString_traits::create (i, f, this));

      this->MetadataString ().push_back (r);
      continue;
    }

    // Appearance
    //
    if (n.name () == "Appearance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Appearance_type > r (
        Appearance_traits::create (i, f, this));

      this->Appearance ().push_back (r);
      continue;
    }

    // Background
    //
    if (n.name () == "Background" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Background_type > r (
        Background_traits::create (i, f, this));

      this->Background ().push_back (r);
      continue;
    }

    // ColorInterpolator
    //
    if (n.name () == "ColorInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ColorInterpolator_type > r (
        ColorInterpolator_traits::create (i, f, this));

      this->ColorInterpolator ().push_back (r);
      continue;
    }

    // CoordinateInterpolator
    //
    if (n.name () == "CoordinateInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateInterpolator_type > r (
        CoordinateInterpolator_traits::create (i, f, this));

      this->CoordinateInterpolator ().push_back (r);
      continue;
    }

    // DirectionalLight
    //
    if (n.name () == "DirectionalLight" && n.namespace_ () == "")
    {
      ::std::auto_ptr< DirectionalLight_type > r (
        DirectionalLight_traits::create (i, f, this));

      this->DirectionalLight ().push_back (r);
      continue;
    }

    // Group
    //
    if (n.name () == "Group" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Group_type > r (
        Group_traits::create (i, f, this));

      this->Group ().push_back (r);
      continue;
    }

    // NavigationInfo
    //
    if (n.name () == "NavigationInfo" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NavigationInfo_type > r (
        NavigationInfo_traits::create (i, f, this));

      this->NavigationInfo ().push_back (r);
      continue;
    }

    // NormalInterpolator
    //
    if (n.name () == "NormalInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NormalInterpolator_type > r (
        NormalInterpolator_traits::create (i, f, this));

      this->NormalInterpolator ().push_back (r);
      continue;
    }

    // OrientationInterpolator
    //
    if (n.name () == "OrientationInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< OrientationInterpolator_type > r (
        OrientationInterpolator_traits::create (i, f, this));

      this->OrientationInterpolator ().push_back (r);
      continue;
    }

    // PositionInterpolator
    //
    if (n.name () == "PositionInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PositionInterpolator_type > r (
        PositionInterpolator_traits::create (i, f, this));

      this->PositionInterpolator ().push_back (r);
      continue;
    }

    // ScalarInterpolator
    //
    if (n.name () == "ScalarInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ScalarInterpolator_type > r (
        ScalarInterpolator_traits::create (i, f, this));

      this->ScalarInterpolator ().push_back (r);
      continue;
    }

    // Shape
    //
    if (n.name () == "Shape" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Shape_type > r (
        Shape_traits::create (i, f, this));

      this->Shape ().push_back (r);
      continue;
    }

    // TimeSensor
    //
    if (n.name () == "TimeSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TimeSensor_type > r (
        TimeSensor_traits::create (i, f, this));

      this->TimeSensor ().push_back (r);
      continue;
    }

    // Transform
    //
    if (n.name () == "Transform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Transform_type > r (
        Transform_traits::create (i, f, this));

      this->Transform ().push_back (r);
      continue;
    }

    // Viewpoint
    //
    if (n.name () == "Viewpoint" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Viewpoint_type > r (
        Viewpoint_traits::create (i, f, this));

      this->Viewpoint ().push_back (r);
      continue;
    }

    // WorldInfo
    //
    if (n.name () == "WorldInfo" && n.namespace_ () == "")
    {
      ::std::auto_ptr< WorldInfo_type > r (
        WorldInfo_traits::create (i, f, this));

      this->WorldInfo ().push_back (r);
      continue;
    }

    // Anchor
    //
    if (n.name () == "Anchor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Anchor_type > r (
        Anchor_traits::create (i, f, this));

      this->Anchor ().push_back (r);
      continue;
    }

    // BooleanFilter
    //
    if (n.name () == "BooleanFilter" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanFilter_type > r (
        BooleanFilter_traits::create (i, f, this));

      this->BooleanFilter ().push_back (r);
      continue;
    }

    // BooleanSequencer
    //
    if (n.name () == "BooleanSequencer" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanSequencer_type > r (
        BooleanSequencer_traits::create (i, f, this));

      this->BooleanSequencer ().push_back (r);
      continue;
    }

    // BooleanToggle
    //
    if (n.name () == "BooleanToggle" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanToggle_type > r (
        BooleanToggle_traits::create (i, f, this));

      this->BooleanToggle ().push_back (r);
      continue;
    }

    // BooleanTrigger
    //
    if (n.name () == "BooleanTrigger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanTrigger_type > r (
        BooleanTrigger_traits::create (i, f, this));

      this->BooleanTrigger ().push_back (r);
      continue;
    }

    // CylinderSensor
    //
    if (n.name () == "CylinderSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CylinderSensor_type > r (
        CylinderSensor_traits::create (i, f, this));

      this->CylinderSensor ().push_back (r);
      continue;
    }

    // Inline
    //
    if (n.name () == "Inline" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Inline_type > r (
        Inline_traits::create (i, f, this));

      this->Inline ().push_back (r);
      continue;
    }

    // IntegerSequencer
    //
    if (n.name () == "IntegerSequencer" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IntegerSequencer_type > r (
        IntegerSequencer_traits::create (i, f, this));

      this->IntegerSequencer ().push_back (r);
      continue;
    }

    // IntegerTrigger
    //
    if (n.name () == "IntegerTrigger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IntegerTrigger_type > r (
        IntegerTrigger_traits::create (i, f, this));

      this->IntegerTrigger ().push_back (r);
      continue;
    }

    // KeySensor
    //
    if (n.name () == "KeySensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< KeySensor_type > r (
        KeySensor_traits::create (i, f, this));

      this->KeySensor ().push_back (r);
      continue;
    }

    // PlaneSensor
    //
    if (n.name () == "PlaneSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PlaneSensor_type > r (
        PlaneSensor_traits::create (i, f, this));

      this->PlaneSensor ().push_back (r);
      continue;
    }

    // PointLight
    //
    if (n.name () == "PointLight" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PointLight_type > r (
        PointLight_traits::create (i, f, this));

      this->PointLight ().push_back (r);
      continue;
    }

    // ProximitySensor
    //
    if (n.name () == "ProximitySensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProximitySensor_type > r (
        ProximitySensor_traits::create (i, f, this));

      this->ProximitySensor ().push_back (r);
      continue;
    }

    // SphereSensor
    //
    if (n.name () == "SphereSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< SphereSensor_type > r (
        SphereSensor_traits::create (i, f, this));

      this->SphereSensor ().push_back (r);
      continue;
    }

    // SpotLight
    //
    if (n.name () == "SpotLight" && n.namespace_ () == "")
    {
      ::std::auto_ptr< SpotLight_type > r (
        SpotLight_traits::create (i, f, this));

      this->SpotLight ().push_back (r);
      continue;
    }

    // StringSensor
    //
    if (n.name () == "StringSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< StringSensor_type > r (
        StringSensor_traits::create (i, f, this));

      this->StringSensor ().push_back (r);
      continue;
    }

    // Switch
    //
    if (n.name () == "Switch" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Switch_type > r (
        Switch_traits::create (i, f, this));

      this->Switch ().push_back (r);
      continue;
    }

    // TimeTrigger
    //
    if (n.name () == "TimeTrigger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TimeTrigger_type > r (
        TimeTrigger_traits::create (i, f, this));

      this->TimeTrigger ().push_back (r);
      continue;
    }

    // TouchSensor
    //
    if (n.name () == "TouchSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TouchSensor_type > r (
        TouchSensor_traits::create (i, f, this));

      this->TouchSensor ().push_back (r);
      continue;
    }

    // AudioClip
    //
    if (n.name () == "AudioClip" && n.namespace_ () == "")
    {
      ::std::auto_ptr< AudioClip_type > r (
        AudioClip_traits::create (i, f, this));

      this->AudioClip ().push_back (r);
      continue;
    }

    // Billboard
    //
    if (n.name () == "Billboard" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Billboard_type > r (
        Billboard_traits::create (i, f, this));

      this->Billboard ().push_back (r);
      continue;
    }

    // Collision
    //
    if (n.name () == "Collision" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Collision_type > r (
        Collision_traits::create (i, f, this));

      this->Collision ().push_back (r);
      continue;
    }

    // Fog
    //
    if (n.name () == "Fog" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Fog_type > r (
        Fog_traits::create (i, f, this));

      this->Fog ().push_back (r);
      continue;
    }

    // LoadSensor
    //
    if (n.name () == "LoadSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LoadSensor_type > r (
        LoadSensor_traits::create (i, f, this));

      this->LoadSensor ().push_back (r);
      continue;
    }

    // LocalFog
    //
    if (n.name () == "LocalFog" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LocalFog_type > r (
        LocalFog_traits::create (i, f, this));

      this->LocalFog ().push_back (r);
      continue;
    }

    // LOD
    //
    if (n.name () == "LOD" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LOD_type > r (
        LOD_traits::create (i, f, this));

      this->LOD ().push_back (r);
      continue;
    }

    // Script
    //
    if (n.name () == "Script" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Script_type > r (
        Script_traits::create (i, f, this));

      this->Script ().push_back (r);
      continue;
    }

    // Sound
    //
    if (n.name () == "Sound" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Sound_type > r (
        Sound_traits::create (i, f, this));

      this->Sound ().push_back (r);
      continue;
    }

    // VisibilitySensor
    //
    if (n.name () == "VisibilitySensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< VisibilitySensor_type > r (
        VisibilitySensor_traits::create (i, f, this));

      this->VisibilitySensor ().push_back (r);
      continue;
    }

    // CoordinateInterpolator2D
    //
    if (n.name () == "CoordinateInterpolator2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateInterpolator2D_type > r (
        CoordinateInterpolator2D_traits::create (i, f, this));

      this->CoordinateInterpolator2D ().push_back (r);
      continue;
    }

    // PositionInterpolator2D
    //
    if (n.name () == "PositionInterpolator2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PositionInterpolator2D_type > r (
        PositionInterpolator2D_traits::create (i, f, this));

      this->PositionInterpolator2D ().push_back (r);
      continue;
    }

    // StaticGroup
    //
    if (n.name () == "StaticGroup" && n.namespace_ () == "")
    {
      ::std::auto_ptr< StaticGroup_type > r (
        StaticGroup_traits::create (i, f, this));

      this->StaticGroup ().push_back (r);
      continue;
    }

    // CADAssembly
    //
    if (n.name () == "CADAssembly" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CADAssembly_type > r (
        CADAssembly_traits::create (i, f, this));

      this->CADAssembly ().push_back (r);
      continue;
    }

    // CADLayer
    //
    if (n.name () == "CADLayer" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CADLayer_type > r (
        CADLayer_traits::create (i, f, this));

      this->CADLayer ().push_back (r);
      continue;
    }

    // EspduTransform
    //
    if (n.name () == "EspduTransform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< EspduTransform_type > r (
        EspduTransform_traits::create (i, f, this));

      this->EspduTransform ().push_back (r);
      continue;
    }

    // ReceiverPdu
    //
    if (n.name () == "ReceiverPdu" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ReceiverPdu_type > r (
        ReceiverPdu_traits::create (i, f, this));

      this->ReceiverPdu ().push_back (r);
      continue;
    }

    // SignalPdu
    //
    if (n.name () == "SignalPdu" && n.namespace_ () == "")
    {
      ::std::auto_ptr< SignalPdu_type > r (
        SignalPdu_traits::create (i, f, this));

      this->SignalPdu ().push_back (r);
      continue;
    }

    // TransmitterPdu
    //
    if (n.name () == "TransmitterPdu" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TransmitterPdu_type > r (
        TransmitterPdu_traits::create (i, f, this));

      this->TransmitterPdu ().push_back (r);
      continue;
    }

    // GeoLocation
    //
    if (n.name () == "GeoLocation" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoLocation_type > r (
        GeoLocation_traits::create (i, f, this));

      this->GeoLocation ().push_back (r);
      continue;
    }

    // GeoLOD
    //
    if (n.name () == "GeoLOD" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoLOD_type > r (
        GeoLOD_traits::create (i, f, this));

      this->GeoLOD ().push_back (r);
      continue;
    }

    // GeoMetadata
    //
    if (n.name () == "GeoMetadata" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoMetadata_type > r (
        GeoMetadata_traits::create (i, f, this));

      this->GeoMetadata ().push_back (r);
      continue;
    }

    // GeoOrigin
    //
    if (n.name () == "GeoOrigin" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoOrigin_type > r (
        GeoOrigin_traits::create (i, f, this));

      this->GeoOrigin ().push_back (r);
      continue;
    }

    // GeoPositionInterpolator
    //
    if (n.name () == "GeoPositionInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoPositionInterpolator_type > r (
        GeoPositionInterpolator_traits::create (i, f, this));

      this->GeoPositionInterpolator ().push_back (r);
      continue;
    }

    // GeoTouchSensor
    //
    if (n.name () == "GeoTouchSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoTouchSensor_type > r (
        GeoTouchSensor_traits::create (i, f, this));

      this->GeoTouchSensor ().push_back (r);
      continue;
    }

    // GeoViewpoint
    //
    if (n.name () == "GeoViewpoint" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoViewpoint_type > r (
        GeoViewpoint_traits::create (i, f, this));

      this->GeoViewpoint ().push_back (r);
      continue;
    }

    // HAnimHumanoid
    //
    if (n.name () == "HAnimHumanoid" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimHumanoid_type > r (
        HAnimHumanoid_traits::create (i, f, this));

      this->HAnimHumanoid ().push_back (r);
      continue;
    }

    // HAnimJoint
    //
    if (n.name () == "HAnimJoint" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimJoint_type > r (
        HAnimJoint_traits::create (i, f, this));

      this->HAnimJoint ().push_back (r);
      continue;
    }

    // HAnimSegment
    //
    if (n.name () == "HAnimSegment" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimSegment_type > r (
        HAnimSegment_traits::create (i, f, this));

      this->HAnimSegment ().push_back (r);
      continue;
    }

    // HAnimSite
    //
    if (n.name () == "HAnimSite" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimSite_type > r (
        HAnimSite_traits::create (i, f, this));

      this->HAnimSite ().push_back (r);
      continue;
    }

    // NurbsOrientationInterpolator
    //
    if (n.name () == "NurbsOrientationInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsOrientationInterpolator_type > r (
        NurbsOrientationInterpolator_traits::create (i, f, this));

      this->NurbsOrientationInterpolator ().push_back (r);
      continue;
    }

    // NurbsPositionInterpolator
    //
    if (n.name () == "NurbsPositionInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsPositionInterpolator_type > r (
        NurbsPositionInterpolator_traits::create (i, f, this));

      this->NurbsPositionInterpolator ().push_back (r);
      continue;
    }

    // NurbsSurfaceInterpolator
    //
    if (n.name () == "NurbsSurfaceInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSurfaceInterpolator_type > r (
        NurbsSurfaceInterpolator_traits::create (i, f, this));

      this->NurbsSurfaceInterpolator ().push_back (r);
      continue;
    }

    // NurbsSet
    //
    if (n.name () == "NurbsSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSet_type > r (
        NurbsSet_traits::create (i, f, this));

      this->NurbsSet ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    // Box
    //
    if (n.name () == "Box" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Box_type > r (
        Box_traits::create (i, f, this));

      this->Box ().push_back (r);
      continue;
    }

    // Cone
    //
    if (n.name () == "Cone" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Cone_type > r (
        Cone_traits::create (i, f, this));

      this->Cone ().push_back (r);
      continue;
    }

    // Cylinder
    //
    if (n.name () == "Cylinder" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Cylinder_type > r (
        Cylinder_traits::create (i, f, this));

      this->Cylinder ().push_back (r);
      continue;
    }

    // IndexedFaceSet
    //
    if (n.name () == "IndexedFaceSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedFaceSet_type > r (
        IndexedFaceSet_traits::create (i, f, this));

      this->IndexedFaceSet ().push_back (r);
      continue;
    }

    // IndexedLineSet
    //
    if (n.name () == "IndexedLineSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedLineSet_type > r (
        IndexedLineSet_traits::create (i, f, this));

      this->IndexedLineSet ().push_back (r);
      continue;
    }

    // IndexedTriangleFanSet
    //
    if (n.name () == "IndexedTriangleFanSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedTriangleFanSet_type > r (
        IndexedTriangleFanSet_traits::create (i, f, this));

      this->IndexedTriangleFanSet ().push_back (r);
      continue;
    }

    // IndexedTriangleSet
    //
    if (n.name () == "IndexedTriangleSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedTriangleSet_type > r (
        IndexedTriangleSet_traits::create (i, f, this));

      this->IndexedTriangleSet ().push_back (r);
      continue;
    }

    // IndexedTriangleStripSet
    //
    if (n.name () == "IndexedTriangleStripSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedTriangleStripSet_type > r (
        IndexedTriangleStripSet_traits::create (i, f, this));

      this->IndexedTriangleStripSet ().push_back (r);
      continue;
    }

    // LineSet
    //
    if (n.name () == "LineSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LineSet_type > r (
        LineSet_traits::create (i, f, this));

      this->LineSet ().push_back (r);
      continue;
    }

    // PointSet
    //
    if (n.name () == "PointSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PointSet_type > r (
        PointSet_traits::create (i, f, this));

      this->PointSet ().push_back (r);
      continue;
    }

    // Sphere
    //
    if (n.name () == "Sphere" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Sphere_type > r (
        Sphere_traits::create (i, f, this));

      this->Sphere ().push_back (r);
      continue;
    }

    // TriangleFanSet
    //
    if (n.name () == "TriangleFanSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TriangleFanSet_type > r (
        TriangleFanSet_traits::create (i, f, this));

      this->TriangleFanSet ().push_back (r);
      continue;
    }

    // TriangleSet
    //
    if (n.name () == "TriangleSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TriangleSet_type > r (
        TriangleSet_traits::create (i, f, this));

      this->TriangleSet ().push_back (r);
      continue;
    }

    // TriangleStripSet
    //
    if (n.name () == "TriangleStripSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TriangleStripSet_type > r (
        TriangleStripSet_traits::create (i, f, this));

      this->TriangleStripSet ().push_back (r);
      continue;
    }

    // ElevationGrid
    //
    if (n.name () == "ElevationGrid" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ElevationGrid_type > r (
        ElevationGrid_traits::create (i, f, this));

      this->ElevationGrid ().push_back (r);
      continue;
    }

    // Polyline2D
    //
    if (n.name () == "Polyline2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Polyline2D_type > r (
        Polyline2D_traits::create (i, f, this));

      this->Polyline2D ().push_back (r);
      continue;
    }

    // Polypoint2D
    //
    if (n.name () == "Polypoint2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Polypoint2D_type > r (
        Polypoint2D_traits::create (i, f, this));

      this->Polypoint2D ().push_back (r);
      continue;
    }

    // Rectangle2D
    //
    if (n.name () == "Rectangle2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Rectangle2D_type > r (
        Rectangle2D_traits::create (i, f, this));

      this->Rectangle2D ().push_back (r);
      continue;
    }

    // TriangleSet2D
    //
    if (n.name () == "TriangleSet2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TriangleSet2D_type > r (
        TriangleSet2D_traits::create (i, f, this));

      this->TriangleSet2D ().push_back (r);
      continue;
    }

    // Extrusion
    //
    if (n.name () == "Extrusion" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Extrusion_type > r (
        Extrusion_traits::create (i, f, this));

      this->Extrusion ().push_back (r);
      continue;
    }

    // Text
    //
    if (n.name () == "Text" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Text_type > r (
        Text_traits::create (i, f, this));

      this->Text ().push_back (r);
      continue;
    }

    // Arc2D
    //
    if (n.name () == "Arc2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Arc2D_type > r (
        Arc2D_traits::create (i, f, this));

      this->Arc2D ().push_back (r);
      continue;
    }

    // ArcClose2D
    //
    if (n.name () == "ArcClose2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ArcClose2D_type > r (
        ArcClose2D_traits::create (i, f, this));

      this->ArcClose2D ().push_back (r);
      continue;
    }

    // Circle2D
    //
    if (n.name () == "Circle2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Circle2D_type > r (
        Circle2D_traits::create (i, f, this));

      this->Circle2D ().push_back (r);
      continue;
    }

    // Disk2D
    //
    if (n.name () == "Disk2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Disk2D_type > r (
        Disk2D_traits::create (i, f, this));

      this->Disk2D ().push_back (r);
      continue;
    }

    // QuadSet
    //
    if (n.name () == "QuadSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< QuadSet_type > r (
        QuadSet_traits::create (i, f, this));

      this->QuadSet ().push_back (r);
      continue;
    }

    // IndexedQuadSet
    //
    if (n.name () == "IndexedQuadSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedQuadSet_type > r (
        IndexedQuadSet_traits::create (i, f, this));

      this->IndexedQuadSet ().push_back (r);
      continue;
    }

    // GeoElevationGrid
    //
    if (n.name () == "GeoElevationGrid" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoElevationGrid_type > r (
        GeoElevationGrid_traits::create (i, f, this));

      this->GeoElevationGrid ().push_back (r);
      continue;
    }

    // NurbsCurve
    //
    if (n.name () == "NurbsCurve" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsCurve_type > r (
        NurbsCurve_traits::create (i, f, this));

      this->NurbsCurve ().push_back (r);
      continue;
    }

    // NurbsCurve2D
    //
    if (n.name () == "NurbsCurve2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsCurve2D_type > r (
        NurbsCurve2D_traits::create (i, f, this));

      this->NurbsCurve2D ().push_back (r);
      continue;
    }

    // NurbsPatchSurface
    //
    if (n.name () == "NurbsPatchSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsPatchSurface_type > r (
        NurbsPatchSurface_traits::create (i, f, this));

      this->NurbsPatchSurface ().push_back (r);
      continue;
    }

    // NurbsSweptSurface
    //
    if (n.name () == "NurbsSweptSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSweptSurface_type > r (
        NurbsSweptSurface_traits::create (i, f, this));

      this->NurbsSweptSurface ().push_back (r);
      continue;
    }

    // NurbsSwungSurface
    //
    if (n.name () == "NurbsSwungSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSwungSurface_type > r (
        NurbsSwungSurface_traits::create (i, f, this));

      this->NurbsSwungSurface ().push_back (r);
      continue;
    }

    // NurbsTrimmedSurface
    //
    if (n.name () == "NurbsTrimmedSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsTrimmedSurface_type > r (
        NurbsTrimmedSurface_traits::create (i, f, this));

      this->NurbsTrimmedSurface ().push_back (r);
      continue;
    }

    // Color
    //
    if (n.name () == "Color" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Color_type > r (
        Color_traits::create (i, f, this));

      this->Color ().push_back (r);
      continue;
    }

    // ColorRGBA
    //
    if (n.name () == "ColorRGBA" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ColorRGBA_type > r (
        ColorRGBA_traits::create (i, f, this));

      this->ColorRGBA ().push_back (r);
      continue;
    }

    // Coordinate
    //
    if (n.name () == "Coordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Coordinate_type > r (
        Coordinate_traits::create (i, f, this));

      this->Coordinate ().push_back (r);
      continue;
    }

    // CoordinateDouble
    //
    if (n.name () == "CoordinateDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateDouble_type > r (
        CoordinateDouble_traits::create (i, f, this));

      this->CoordinateDouble ().push_back (r);
      continue;
    }

    // FontStyle
    //
    if (n.name () == "FontStyle" && n.namespace_ () == "")
    {
      ::std::auto_ptr< FontStyle_type > r (
        FontStyle_traits::create (i, f, this));

      this->FontStyle ().push_back (r);
      continue;
    }

    // GeoCoordinate
    //
    if (n.name () == "GeoCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoCoordinate_type > r (
        GeoCoordinate_traits::create (i, f, this));

      this->GeoCoordinate ().push_back (r);
      continue;
    }

    // Normal
    //
    if (n.name () == "Normal" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Normal_type > r (
        Normal_traits::create (i, f, this));

      this->Normal ().push_back (r);
      continue;
    }

    // TextureCoordinate
    //
    if (n.name () == "TextureCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureCoordinate_type > r (
        TextureCoordinate_traits::create (i, f, this));

      this->TextureCoordinate ().push_back (r);
      continue;
    }

    // NurbsTextureCoordinate
    //
    if (n.name () == "NurbsTextureCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsTextureCoordinate_type > r (
        NurbsTextureCoordinate_traits::create (i, f, this));

      this->NurbsTextureCoordinate ().push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name (r);
      continue;
    }

    if (n.name () == "accessType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< accessType_type > r (
        accessType_traits::create (i, f, this));

      this->accessType (r);
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      this->type (r);
      continue;
    }

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< value_type > r (
        value_traits::create (i, f, this));

      this->value (r);
      continue;
    }

    if (n.name () == "appinfo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< appinfo_type > r (
        appinfo_traits::create (i, f, this));

      this->appinfo (r);
      continue;
    }

    if (n.name () == "documentation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< documentation_type > r (
        documentation_traits::create (i, f, this));

      this->documentation (r);
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!accessType_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "accessType",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

field* field::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new field (*this, f, c);
}

field::
~field ()
{
}

// fieldValue
//

fieldValue::
fieldValue (const name_type& name)
: ::SceneGraphStructureNodeType (),
  FillProperties_ (::xml_schema::flags (), this),
  LineProperties_ (::xml_schema::flags (), this),
  Material_ (::xml_schema::flags (), this),
  ComposedShader_ (::xml_schema::flags (), this),
  PackagedShader_ (::xml_schema::flags (), this),
  ProgramShader_ (::xml_schema::flags (), this),
  ComposedCubeMapTexture_ (::xml_schema::flags (), this),
  ImageTexture_ (::xml_schema::flags (), this),
  MovieTexture_ (::xml_schema::flags (), this),
  MultiTexture_ (::xml_schema::flags (), this),
  PixelTexture_ (::xml_schema::flags (), this),
  GeneratedCubeMapTexture_ (::xml_schema::flags (), this),
  ImageCubeMapTexture_ (::xml_schema::flags (), this),
  MultiTextureTransform_ (::xml_schema::flags (), this),
  TextureTransform_ (::xml_schema::flags (), this),
  MetadataDouble_ (::xml_schema::flags (), this),
  MetadataFloat_ (::xml_schema::flags (), this),
  MetadataInteger_ (::xml_schema::flags (), this),
  MetadataSet_ (::xml_schema::flags (), this),
  MetadataString_ (::xml_schema::flags (), this),
  Appearance_ (::xml_schema::flags (), this),
  Background_ (::xml_schema::flags (), this),
  ColorInterpolator_ (::xml_schema::flags (), this),
  CoordinateInterpolator_ (::xml_schema::flags (), this),
  DirectionalLight_ (::xml_schema::flags (), this),
  Group_ (::xml_schema::flags (), this),
  NavigationInfo_ (::xml_schema::flags (), this),
  NormalInterpolator_ (::xml_schema::flags (), this),
  OrientationInterpolator_ (::xml_schema::flags (), this),
  PositionInterpolator_ (::xml_schema::flags (), this),
  ScalarInterpolator_ (::xml_schema::flags (), this),
  Shape_ (::xml_schema::flags (), this),
  TimeSensor_ (::xml_schema::flags (), this),
  Transform_ (::xml_schema::flags (), this),
  Viewpoint_ (::xml_schema::flags (), this),
  WorldInfo_ (::xml_schema::flags (), this),
  Anchor_ (::xml_schema::flags (), this),
  BooleanFilter_ (::xml_schema::flags (), this),
  BooleanSequencer_ (::xml_schema::flags (), this),
  BooleanToggle_ (::xml_schema::flags (), this),
  BooleanTrigger_ (::xml_schema::flags (), this),
  CylinderSensor_ (::xml_schema::flags (), this),
  Inline_ (::xml_schema::flags (), this),
  IntegerSequencer_ (::xml_schema::flags (), this),
  IntegerTrigger_ (::xml_schema::flags (), this),
  KeySensor_ (::xml_schema::flags (), this),
  PlaneSensor_ (::xml_schema::flags (), this),
  PointLight_ (::xml_schema::flags (), this),
  ProximitySensor_ (::xml_schema::flags (), this),
  SphereSensor_ (::xml_schema::flags (), this),
  SpotLight_ (::xml_schema::flags (), this),
  StringSensor_ (::xml_schema::flags (), this),
  Switch_ (::xml_schema::flags (), this),
  TimeTrigger_ (::xml_schema::flags (), this),
  TouchSensor_ (::xml_schema::flags (), this),
  AudioClip_ (::xml_schema::flags (), this),
  Billboard_ (::xml_schema::flags (), this),
  Collision_ (::xml_schema::flags (), this),
  Fog_ (::xml_schema::flags (), this),
  LoadSensor_ (::xml_schema::flags (), this),
  LocalFog_ (::xml_schema::flags (), this),
  LOD_ (::xml_schema::flags (), this),
  Script_ (::xml_schema::flags (), this),
  Sound_ (::xml_schema::flags (), this),
  VisibilitySensor_ (::xml_schema::flags (), this),
  CoordinateInterpolator2D_ (::xml_schema::flags (), this),
  PositionInterpolator2D_ (::xml_schema::flags (), this),
  StaticGroup_ (::xml_schema::flags (), this),
  CADAssembly_ (::xml_schema::flags (), this),
  CADLayer_ (::xml_schema::flags (), this),
  EspduTransform_ (::xml_schema::flags (), this),
  ReceiverPdu_ (::xml_schema::flags (), this),
  SignalPdu_ (::xml_schema::flags (), this),
  TransmitterPdu_ (::xml_schema::flags (), this),
  GeoLocation_ (::xml_schema::flags (), this),
  GeoLOD_ (::xml_schema::flags (), this),
  GeoMetadata_ (::xml_schema::flags (), this),
  GeoOrigin_ (::xml_schema::flags (), this),
  GeoPositionInterpolator_ (::xml_schema::flags (), this),
  GeoTouchSensor_ (::xml_schema::flags (), this),
  GeoViewpoint_ (::xml_schema::flags (), this),
  HAnimHumanoid_ (::xml_schema::flags (), this),
  HAnimJoint_ (::xml_schema::flags (), this),
  HAnimSegment_ (::xml_schema::flags (), this),
  HAnimSite_ (::xml_schema::flags (), this),
  NurbsOrientationInterpolator_ (::xml_schema::flags (), this),
  NurbsPositionInterpolator_ (::xml_schema::flags (), this),
  NurbsSurfaceInterpolator_ (::xml_schema::flags (), this),
  NurbsSet_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  Box_ (::xml_schema::flags (), this),
  Cone_ (::xml_schema::flags (), this),
  Cylinder_ (::xml_schema::flags (), this),
  IndexedFaceSet_ (::xml_schema::flags (), this),
  IndexedLineSet_ (::xml_schema::flags (), this),
  IndexedTriangleFanSet_ (::xml_schema::flags (), this),
  IndexedTriangleSet_ (::xml_schema::flags (), this),
  IndexedTriangleStripSet_ (::xml_schema::flags (), this),
  LineSet_ (::xml_schema::flags (), this),
  PointSet_ (::xml_schema::flags (), this),
  Sphere_ (::xml_schema::flags (), this),
  TriangleFanSet_ (::xml_schema::flags (), this),
  TriangleSet_ (::xml_schema::flags (), this),
  TriangleStripSet_ (::xml_schema::flags (), this),
  ElevationGrid_ (::xml_schema::flags (), this),
  Polyline2D_ (::xml_schema::flags (), this),
  Polypoint2D_ (::xml_schema::flags (), this),
  Rectangle2D_ (::xml_schema::flags (), this),
  TriangleSet2D_ (::xml_schema::flags (), this),
  Extrusion_ (::xml_schema::flags (), this),
  Text_ (::xml_schema::flags (), this),
  Arc2D_ (::xml_schema::flags (), this),
  ArcClose2D_ (::xml_schema::flags (), this),
  Circle2D_ (::xml_schema::flags (), this),
  Disk2D_ (::xml_schema::flags (), this),
  QuadSet_ (::xml_schema::flags (), this),
  IndexedQuadSet_ (::xml_schema::flags (), this),
  GeoElevationGrid_ (::xml_schema::flags (), this),
  NurbsCurve_ (::xml_schema::flags (), this),
  NurbsCurve2D_ (::xml_schema::flags (), this),
  NurbsPatchSurface_ (::xml_schema::flags (), this),
  NurbsSweptSurface_ (::xml_schema::flags (), this),
  NurbsSwungSurface_ (::xml_schema::flags (), this),
  NurbsTrimmedSurface_ (::xml_schema::flags (), this),
  Color_ (::xml_schema::flags (), this),
  ColorRGBA_ (::xml_schema::flags (), this),
  Coordinate_ (::xml_schema::flags (), this),
  CoordinateDouble_ (::xml_schema::flags (), this),
  FontStyle_ (::xml_schema::flags (), this),
  GeoCoordinate_ (::xml_schema::flags (), this),
  Normal_ (::xml_schema::flags (), this),
  TextureCoordinate_ (::xml_schema::flags (), this),
  NurbsTextureCoordinate_ (::xml_schema::flags (), this),
  name_ (name, ::xml_schema::flags (), this),
  value_ (::xml_schema::flags (), this)
{
}

fieldValue::
fieldValue (const fieldValue& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (x, f, c),
  FillProperties_ (x.FillProperties_, f, this),
  LineProperties_ (x.LineProperties_, f, this),
  Material_ (x.Material_, f, this),
  ComposedShader_ (x.ComposedShader_, f, this),
  PackagedShader_ (x.PackagedShader_, f, this),
  ProgramShader_ (x.ProgramShader_, f, this),
  ComposedCubeMapTexture_ (x.ComposedCubeMapTexture_, f, this),
  ImageTexture_ (x.ImageTexture_, f, this),
  MovieTexture_ (x.MovieTexture_, f, this),
  MultiTexture_ (x.MultiTexture_, f, this),
  PixelTexture_ (x.PixelTexture_, f, this),
  GeneratedCubeMapTexture_ (x.GeneratedCubeMapTexture_, f, this),
  ImageCubeMapTexture_ (x.ImageCubeMapTexture_, f, this),
  MultiTextureTransform_ (x.MultiTextureTransform_, f, this),
  TextureTransform_ (x.TextureTransform_, f, this),
  MetadataDouble_ (x.MetadataDouble_, f, this),
  MetadataFloat_ (x.MetadataFloat_, f, this),
  MetadataInteger_ (x.MetadataInteger_, f, this),
  MetadataSet_ (x.MetadataSet_, f, this),
  MetadataString_ (x.MetadataString_, f, this),
  Appearance_ (x.Appearance_, f, this),
  Background_ (x.Background_, f, this),
  ColorInterpolator_ (x.ColorInterpolator_, f, this),
  CoordinateInterpolator_ (x.CoordinateInterpolator_, f, this),
  DirectionalLight_ (x.DirectionalLight_, f, this),
  Group_ (x.Group_, f, this),
  NavigationInfo_ (x.NavigationInfo_, f, this),
  NormalInterpolator_ (x.NormalInterpolator_, f, this),
  OrientationInterpolator_ (x.OrientationInterpolator_, f, this),
  PositionInterpolator_ (x.PositionInterpolator_, f, this),
  ScalarInterpolator_ (x.ScalarInterpolator_, f, this),
  Shape_ (x.Shape_, f, this),
  TimeSensor_ (x.TimeSensor_, f, this),
  Transform_ (x.Transform_, f, this),
  Viewpoint_ (x.Viewpoint_, f, this),
  WorldInfo_ (x.WorldInfo_, f, this),
  Anchor_ (x.Anchor_, f, this),
  BooleanFilter_ (x.BooleanFilter_, f, this),
  BooleanSequencer_ (x.BooleanSequencer_, f, this),
  BooleanToggle_ (x.BooleanToggle_, f, this),
  BooleanTrigger_ (x.BooleanTrigger_, f, this),
  CylinderSensor_ (x.CylinderSensor_, f, this),
  Inline_ (x.Inline_, f, this),
  IntegerSequencer_ (x.IntegerSequencer_, f, this),
  IntegerTrigger_ (x.IntegerTrigger_, f, this),
  KeySensor_ (x.KeySensor_, f, this),
  PlaneSensor_ (x.PlaneSensor_, f, this),
  PointLight_ (x.PointLight_, f, this),
  ProximitySensor_ (x.ProximitySensor_, f, this),
  SphereSensor_ (x.SphereSensor_, f, this),
  SpotLight_ (x.SpotLight_, f, this),
  StringSensor_ (x.StringSensor_, f, this),
  Switch_ (x.Switch_, f, this),
  TimeTrigger_ (x.TimeTrigger_, f, this),
  TouchSensor_ (x.TouchSensor_, f, this),
  AudioClip_ (x.AudioClip_, f, this),
  Billboard_ (x.Billboard_, f, this),
  Collision_ (x.Collision_, f, this),
  Fog_ (x.Fog_, f, this),
  LoadSensor_ (x.LoadSensor_, f, this),
  LocalFog_ (x.LocalFog_, f, this),
  LOD_ (x.LOD_, f, this),
  Script_ (x.Script_, f, this),
  Sound_ (x.Sound_, f, this),
  VisibilitySensor_ (x.VisibilitySensor_, f, this),
  CoordinateInterpolator2D_ (x.CoordinateInterpolator2D_, f, this),
  PositionInterpolator2D_ (x.PositionInterpolator2D_, f, this),
  StaticGroup_ (x.StaticGroup_, f, this),
  CADAssembly_ (x.CADAssembly_, f, this),
  CADLayer_ (x.CADLayer_, f, this),
  EspduTransform_ (x.EspduTransform_, f, this),
  ReceiverPdu_ (x.ReceiverPdu_, f, this),
  SignalPdu_ (x.SignalPdu_, f, this),
  TransmitterPdu_ (x.TransmitterPdu_, f, this),
  GeoLocation_ (x.GeoLocation_, f, this),
  GeoLOD_ (x.GeoLOD_, f, this),
  GeoMetadata_ (x.GeoMetadata_, f, this),
  GeoOrigin_ (x.GeoOrigin_, f, this),
  GeoPositionInterpolator_ (x.GeoPositionInterpolator_, f, this),
  GeoTouchSensor_ (x.GeoTouchSensor_, f, this),
  GeoViewpoint_ (x.GeoViewpoint_, f, this),
  HAnimHumanoid_ (x.HAnimHumanoid_, f, this),
  HAnimJoint_ (x.HAnimJoint_, f, this),
  HAnimSegment_ (x.HAnimSegment_, f, this),
  HAnimSite_ (x.HAnimSite_, f, this),
  NurbsOrientationInterpolator_ (x.NurbsOrientationInterpolator_, f, this),
  NurbsPositionInterpolator_ (x.NurbsPositionInterpolator_, f, this),
  NurbsSurfaceInterpolator_ (x.NurbsSurfaceInterpolator_, f, this),
  NurbsSet_ (x.NurbsSet_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  Box_ (x.Box_, f, this),
  Cone_ (x.Cone_, f, this),
  Cylinder_ (x.Cylinder_, f, this),
  IndexedFaceSet_ (x.IndexedFaceSet_, f, this),
  IndexedLineSet_ (x.IndexedLineSet_, f, this),
  IndexedTriangleFanSet_ (x.IndexedTriangleFanSet_, f, this),
  IndexedTriangleSet_ (x.IndexedTriangleSet_, f, this),
  IndexedTriangleStripSet_ (x.IndexedTriangleStripSet_, f, this),
  LineSet_ (x.LineSet_, f, this),
  PointSet_ (x.PointSet_, f, this),
  Sphere_ (x.Sphere_, f, this),
  TriangleFanSet_ (x.TriangleFanSet_, f, this),
  TriangleSet_ (x.TriangleSet_, f, this),
  TriangleStripSet_ (x.TriangleStripSet_, f, this),
  ElevationGrid_ (x.ElevationGrid_, f, this),
  Polyline2D_ (x.Polyline2D_, f, this),
  Polypoint2D_ (x.Polypoint2D_, f, this),
  Rectangle2D_ (x.Rectangle2D_, f, this),
  TriangleSet2D_ (x.TriangleSet2D_, f, this),
  Extrusion_ (x.Extrusion_, f, this),
  Text_ (x.Text_, f, this),
  Arc2D_ (x.Arc2D_, f, this),
  ArcClose2D_ (x.ArcClose2D_, f, this),
  Circle2D_ (x.Circle2D_, f, this),
  Disk2D_ (x.Disk2D_, f, this),
  QuadSet_ (x.QuadSet_, f, this),
  IndexedQuadSet_ (x.IndexedQuadSet_, f, this),
  GeoElevationGrid_ (x.GeoElevationGrid_, f, this),
  NurbsCurve_ (x.NurbsCurve_, f, this),
  NurbsCurve2D_ (x.NurbsCurve2D_, f, this),
  NurbsPatchSurface_ (x.NurbsPatchSurface_, f, this),
  NurbsSweptSurface_ (x.NurbsSweptSurface_, f, this),
  NurbsSwungSurface_ (x.NurbsSwungSurface_, f, this),
  NurbsTrimmedSurface_ (x.NurbsTrimmedSurface_, f, this),
  Color_ (x.Color_, f, this),
  ColorRGBA_ (x.ColorRGBA_, f, this),
  Coordinate_ (x.Coordinate_, f, this),
  CoordinateDouble_ (x.CoordinateDouble_, f, this),
  FontStyle_ (x.FontStyle_, f, this),
  GeoCoordinate_ (x.GeoCoordinate_, f, this),
  Normal_ (x.Normal_, f, this),
  TextureCoordinate_ (x.TextureCoordinate_, f, this),
  NurbsTextureCoordinate_ (x.NurbsTextureCoordinate_, f, this),
  name_ (x.name_, f, this),
  value_ (x.value_, f, this)
{
}

fieldValue::
fieldValue (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (e, f | ::xml_schema::flags::base, c),
  FillProperties_ (f, this),
  LineProperties_ (f, this),
  Material_ (f, this),
  ComposedShader_ (f, this),
  PackagedShader_ (f, this),
  ProgramShader_ (f, this),
  ComposedCubeMapTexture_ (f, this),
  ImageTexture_ (f, this),
  MovieTexture_ (f, this),
  MultiTexture_ (f, this),
  PixelTexture_ (f, this),
  GeneratedCubeMapTexture_ (f, this),
  ImageCubeMapTexture_ (f, this),
  MultiTextureTransform_ (f, this),
  TextureTransform_ (f, this),
  MetadataDouble_ (f, this),
  MetadataFloat_ (f, this),
  MetadataInteger_ (f, this),
  MetadataSet_ (f, this),
  MetadataString_ (f, this),
  Appearance_ (f, this),
  Background_ (f, this),
  ColorInterpolator_ (f, this),
  CoordinateInterpolator_ (f, this),
  DirectionalLight_ (f, this),
  Group_ (f, this),
  NavigationInfo_ (f, this),
  NormalInterpolator_ (f, this),
  OrientationInterpolator_ (f, this),
  PositionInterpolator_ (f, this),
  ScalarInterpolator_ (f, this),
  Shape_ (f, this),
  TimeSensor_ (f, this),
  Transform_ (f, this),
  Viewpoint_ (f, this),
  WorldInfo_ (f, this),
  Anchor_ (f, this),
  BooleanFilter_ (f, this),
  BooleanSequencer_ (f, this),
  BooleanToggle_ (f, this),
  BooleanTrigger_ (f, this),
  CylinderSensor_ (f, this),
  Inline_ (f, this),
  IntegerSequencer_ (f, this),
  IntegerTrigger_ (f, this),
  KeySensor_ (f, this),
  PlaneSensor_ (f, this),
  PointLight_ (f, this),
  ProximitySensor_ (f, this),
  SphereSensor_ (f, this),
  SpotLight_ (f, this),
  StringSensor_ (f, this),
  Switch_ (f, this),
  TimeTrigger_ (f, this),
  TouchSensor_ (f, this),
  AudioClip_ (f, this),
  Billboard_ (f, this),
  Collision_ (f, this),
  Fog_ (f, this),
  LoadSensor_ (f, this),
  LocalFog_ (f, this),
  LOD_ (f, this),
  Script_ (f, this),
  Sound_ (f, this),
  VisibilitySensor_ (f, this),
  CoordinateInterpolator2D_ (f, this),
  PositionInterpolator2D_ (f, this),
  StaticGroup_ (f, this),
  CADAssembly_ (f, this),
  CADLayer_ (f, this),
  EspduTransform_ (f, this),
  ReceiverPdu_ (f, this),
  SignalPdu_ (f, this),
  TransmitterPdu_ (f, this),
  GeoLocation_ (f, this),
  GeoLOD_ (f, this),
  GeoMetadata_ (f, this),
  GeoOrigin_ (f, this),
  GeoPositionInterpolator_ (f, this),
  GeoTouchSensor_ (f, this),
  GeoViewpoint_ (f, this),
  HAnimHumanoid_ (f, this),
  HAnimJoint_ (f, this),
  HAnimSegment_ (f, this),
  HAnimSite_ (f, this),
  NurbsOrientationInterpolator_ (f, this),
  NurbsPositionInterpolator_ (f, this),
  NurbsSurfaceInterpolator_ (f, this),
  NurbsSet_ (f, this),
  ProtoInstance_ (f, this),
  Box_ (f, this),
  Cone_ (f, this),
  Cylinder_ (f, this),
  IndexedFaceSet_ (f, this),
  IndexedLineSet_ (f, this),
  IndexedTriangleFanSet_ (f, this),
  IndexedTriangleSet_ (f, this),
  IndexedTriangleStripSet_ (f, this),
  LineSet_ (f, this),
  PointSet_ (f, this),
  Sphere_ (f, this),
  TriangleFanSet_ (f, this),
  TriangleSet_ (f, this),
  TriangleStripSet_ (f, this),
  ElevationGrid_ (f, this),
  Polyline2D_ (f, this),
  Polypoint2D_ (f, this),
  Rectangle2D_ (f, this),
  TriangleSet2D_ (f, this),
  Extrusion_ (f, this),
  Text_ (f, this),
  Arc2D_ (f, this),
  ArcClose2D_ (f, this),
  Circle2D_ (f, this),
  Disk2D_ (f, this),
  QuadSet_ (f, this),
  IndexedQuadSet_ (f, this),
  GeoElevationGrid_ (f, this),
  NurbsCurve_ (f, this),
  NurbsCurve2D_ (f, this),
  NurbsPatchSurface_ (f, this),
  NurbsSweptSurface_ (f, this),
  NurbsSwungSurface_ (f, this),
  NurbsTrimmedSurface_ (f, this),
  Color_ (f, this),
  ColorRGBA_ (f, this),
  Coordinate_ (f, this),
  CoordinateDouble_ (f, this),
  FontStyle_ (f, this),
  GeoCoordinate_ (f, this),
  Normal_ (f, this),
  TextureCoordinate_ (f, this),
  NurbsTextureCoordinate_ (f, this),
  name_ (f, this),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void fieldValue::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // FillProperties
    //
    if (n.name () == "FillProperties" && n.namespace_ () == "")
    {
      ::std::auto_ptr< FillProperties_type > r (
        FillProperties_traits::create (i, f, this));

      this->FillProperties ().push_back (r);
      continue;
    }

    // LineProperties
    //
    if (n.name () == "LineProperties" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LineProperties_type > r (
        LineProperties_traits::create (i, f, this));

      this->LineProperties ().push_back (r);
      continue;
    }

    // Material
    //
    if (n.name () == "Material" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Material_type > r (
        Material_traits::create (i, f, this));

      this->Material ().push_back (r);
      continue;
    }

    // ComposedShader
    //
    if (n.name () == "ComposedShader" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ComposedShader_type > r (
        ComposedShader_traits::create (i, f, this));

      this->ComposedShader ().push_back (r);
      continue;
    }

    // PackagedShader
    //
    if (n.name () == "PackagedShader" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PackagedShader_type > r (
        PackagedShader_traits::create (i, f, this));

      this->PackagedShader ().push_back (r);
      continue;
    }

    // ProgramShader
    //
    if (n.name () == "ProgramShader" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProgramShader_type > r (
        ProgramShader_traits::create (i, f, this));

      this->ProgramShader ().push_back (r);
      continue;
    }

    // ComposedCubeMapTexture
    //
    if (n.name () == "ComposedCubeMapTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ComposedCubeMapTexture_type > r (
        ComposedCubeMapTexture_traits::create (i, f, this));

      this->ComposedCubeMapTexture ().push_back (r);
      continue;
    }

    // ImageTexture
    //
    if (n.name () == "ImageTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ImageTexture_type > r (
        ImageTexture_traits::create (i, f, this));

      this->ImageTexture ().push_back (r);
      continue;
    }

    // MovieTexture
    //
    if (n.name () == "MovieTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MovieTexture_type > r (
        MovieTexture_traits::create (i, f, this));

      this->MovieTexture ().push_back (r);
      continue;
    }

    // MultiTexture
    //
    if (n.name () == "MultiTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MultiTexture_type > r (
        MultiTexture_traits::create (i, f, this));

      this->MultiTexture ().push_back (r);
      continue;
    }

    // PixelTexture
    //
    if (n.name () == "PixelTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PixelTexture_type > r (
        PixelTexture_traits::create (i, f, this));

      this->PixelTexture ().push_back (r);
      continue;
    }

    // GeneratedCubeMapTexture
    //
    if (n.name () == "GeneratedCubeMapTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeneratedCubeMapTexture_type > r (
        GeneratedCubeMapTexture_traits::create (i, f, this));

      this->GeneratedCubeMapTexture ().push_back (r);
      continue;
    }

    // ImageCubeMapTexture
    //
    if (n.name () == "ImageCubeMapTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ImageCubeMapTexture_type > r (
        ImageCubeMapTexture_traits::create (i, f, this));

      this->ImageCubeMapTexture ().push_back (r);
      continue;
    }

    // MultiTextureTransform
    //
    if (n.name () == "MultiTextureTransform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MultiTextureTransform_type > r (
        MultiTextureTransform_traits::create (i, f, this));

      this->MultiTextureTransform ().push_back (r);
      continue;
    }

    // TextureTransform
    //
    if (n.name () == "TextureTransform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureTransform_type > r (
        TextureTransform_traits::create (i, f, this));

      this->TextureTransform ().push_back (r);
      continue;
    }

    // MetadataDouble
    //
    if (n.name () == "MetadataDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataDouble_type > r (
        MetadataDouble_traits::create (i, f, this));

      this->MetadataDouble ().push_back (r);
      continue;
    }

    // MetadataFloat
    //
    if (n.name () == "MetadataFloat" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataFloat_type > r (
        MetadataFloat_traits::create (i, f, this));

      this->MetadataFloat ().push_back (r);
      continue;
    }

    // MetadataInteger
    //
    if (n.name () == "MetadataInteger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataInteger_type > r (
        MetadataInteger_traits::create (i, f, this));

      this->MetadataInteger ().push_back (r);
      continue;
    }

    // MetadataSet
    //
    if (n.name () == "MetadataSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataSet_type > r (
        MetadataSet_traits::create (i, f, this));

      this->MetadataSet ().push_back (r);
      continue;
    }

    // MetadataString
    //
    if (n.name () == "MetadataString" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataString_type > r (
        MetadataString_traits::create (i, f, this));

      this->MetadataString ().push_back (r);
      continue;
    }

    // Appearance
    //
    if (n.name () == "Appearance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Appearance_type > r (
        Appearance_traits::create (i, f, this));

      this->Appearance ().push_back (r);
      continue;
    }

    // Background
    //
    if (n.name () == "Background" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Background_type > r (
        Background_traits::create (i, f, this));

      this->Background ().push_back (r);
      continue;
    }

    // ColorInterpolator
    //
    if (n.name () == "ColorInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ColorInterpolator_type > r (
        ColorInterpolator_traits::create (i, f, this));

      this->ColorInterpolator ().push_back (r);
      continue;
    }

    // CoordinateInterpolator
    //
    if (n.name () == "CoordinateInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateInterpolator_type > r (
        CoordinateInterpolator_traits::create (i, f, this));

      this->CoordinateInterpolator ().push_back (r);
      continue;
    }

    // DirectionalLight
    //
    if (n.name () == "DirectionalLight" && n.namespace_ () == "")
    {
      ::std::auto_ptr< DirectionalLight_type > r (
        DirectionalLight_traits::create (i, f, this));

      this->DirectionalLight ().push_back (r);
      continue;
    }

    // Group
    //
    if (n.name () == "Group" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Group_type > r (
        Group_traits::create (i, f, this));

      this->Group ().push_back (r);
      continue;
    }

    // NavigationInfo
    //
    if (n.name () == "NavigationInfo" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NavigationInfo_type > r (
        NavigationInfo_traits::create (i, f, this));

      this->NavigationInfo ().push_back (r);
      continue;
    }

    // NormalInterpolator
    //
    if (n.name () == "NormalInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NormalInterpolator_type > r (
        NormalInterpolator_traits::create (i, f, this));

      this->NormalInterpolator ().push_back (r);
      continue;
    }

    // OrientationInterpolator
    //
    if (n.name () == "OrientationInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< OrientationInterpolator_type > r (
        OrientationInterpolator_traits::create (i, f, this));

      this->OrientationInterpolator ().push_back (r);
      continue;
    }

    // PositionInterpolator
    //
    if (n.name () == "PositionInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PositionInterpolator_type > r (
        PositionInterpolator_traits::create (i, f, this));

      this->PositionInterpolator ().push_back (r);
      continue;
    }

    // ScalarInterpolator
    //
    if (n.name () == "ScalarInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ScalarInterpolator_type > r (
        ScalarInterpolator_traits::create (i, f, this));

      this->ScalarInterpolator ().push_back (r);
      continue;
    }

    // Shape
    //
    if (n.name () == "Shape" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Shape_type > r (
        Shape_traits::create (i, f, this));

      this->Shape ().push_back (r);
      continue;
    }

    // TimeSensor
    //
    if (n.name () == "TimeSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TimeSensor_type > r (
        TimeSensor_traits::create (i, f, this));

      this->TimeSensor ().push_back (r);
      continue;
    }

    // Transform
    //
    if (n.name () == "Transform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Transform_type > r (
        Transform_traits::create (i, f, this));

      this->Transform ().push_back (r);
      continue;
    }

    // Viewpoint
    //
    if (n.name () == "Viewpoint" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Viewpoint_type > r (
        Viewpoint_traits::create (i, f, this));

      this->Viewpoint ().push_back (r);
      continue;
    }

    // WorldInfo
    //
    if (n.name () == "WorldInfo" && n.namespace_ () == "")
    {
      ::std::auto_ptr< WorldInfo_type > r (
        WorldInfo_traits::create (i, f, this));

      this->WorldInfo ().push_back (r);
      continue;
    }

    // Anchor
    //
    if (n.name () == "Anchor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Anchor_type > r (
        Anchor_traits::create (i, f, this));

      this->Anchor ().push_back (r);
      continue;
    }

    // BooleanFilter
    //
    if (n.name () == "BooleanFilter" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanFilter_type > r (
        BooleanFilter_traits::create (i, f, this));

      this->BooleanFilter ().push_back (r);
      continue;
    }

    // BooleanSequencer
    //
    if (n.name () == "BooleanSequencer" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanSequencer_type > r (
        BooleanSequencer_traits::create (i, f, this));

      this->BooleanSequencer ().push_back (r);
      continue;
    }

    // BooleanToggle
    //
    if (n.name () == "BooleanToggle" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanToggle_type > r (
        BooleanToggle_traits::create (i, f, this));

      this->BooleanToggle ().push_back (r);
      continue;
    }

    // BooleanTrigger
    //
    if (n.name () == "BooleanTrigger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanTrigger_type > r (
        BooleanTrigger_traits::create (i, f, this));

      this->BooleanTrigger ().push_back (r);
      continue;
    }

    // CylinderSensor
    //
    if (n.name () == "CylinderSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CylinderSensor_type > r (
        CylinderSensor_traits::create (i, f, this));

      this->CylinderSensor ().push_back (r);
      continue;
    }

    // Inline
    //
    if (n.name () == "Inline" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Inline_type > r (
        Inline_traits::create (i, f, this));

      this->Inline ().push_back (r);
      continue;
    }

    // IntegerSequencer
    //
    if (n.name () == "IntegerSequencer" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IntegerSequencer_type > r (
        IntegerSequencer_traits::create (i, f, this));

      this->IntegerSequencer ().push_back (r);
      continue;
    }

    // IntegerTrigger
    //
    if (n.name () == "IntegerTrigger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IntegerTrigger_type > r (
        IntegerTrigger_traits::create (i, f, this));

      this->IntegerTrigger ().push_back (r);
      continue;
    }

    // KeySensor
    //
    if (n.name () == "KeySensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< KeySensor_type > r (
        KeySensor_traits::create (i, f, this));

      this->KeySensor ().push_back (r);
      continue;
    }

    // PlaneSensor
    //
    if (n.name () == "PlaneSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PlaneSensor_type > r (
        PlaneSensor_traits::create (i, f, this));

      this->PlaneSensor ().push_back (r);
      continue;
    }

    // PointLight
    //
    if (n.name () == "PointLight" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PointLight_type > r (
        PointLight_traits::create (i, f, this));

      this->PointLight ().push_back (r);
      continue;
    }

    // ProximitySensor
    //
    if (n.name () == "ProximitySensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProximitySensor_type > r (
        ProximitySensor_traits::create (i, f, this));

      this->ProximitySensor ().push_back (r);
      continue;
    }

    // SphereSensor
    //
    if (n.name () == "SphereSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< SphereSensor_type > r (
        SphereSensor_traits::create (i, f, this));

      this->SphereSensor ().push_back (r);
      continue;
    }

    // SpotLight
    //
    if (n.name () == "SpotLight" && n.namespace_ () == "")
    {
      ::std::auto_ptr< SpotLight_type > r (
        SpotLight_traits::create (i, f, this));

      this->SpotLight ().push_back (r);
      continue;
    }

    // StringSensor
    //
    if (n.name () == "StringSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< StringSensor_type > r (
        StringSensor_traits::create (i, f, this));

      this->StringSensor ().push_back (r);
      continue;
    }

    // Switch
    //
    if (n.name () == "Switch" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Switch_type > r (
        Switch_traits::create (i, f, this));

      this->Switch ().push_back (r);
      continue;
    }

    // TimeTrigger
    //
    if (n.name () == "TimeTrigger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TimeTrigger_type > r (
        TimeTrigger_traits::create (i, f, this));

      this->TimeTrigger ().push_back (r);
      continue;
    }

    // TouchSensor
    //
    if (n.name () == "TouchSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TouchSensor_type > r (
        TouchSensor_traits::create (i, f, this));

      this->TouchSensor ().push_back (r);
      continue;
    }

    // AudioClip
    //
    if (n.name () == "AudioClip" && n.namespace_ () == "")
    {
      ::std::auto_ptr< AudioClip_type > r (
        AudioClip_traits::create (i, f, this));

      this->AudioClip ().push_back (r);
      continue;
    }

    // Billboard
    //
    if (n.name () == "Billboard" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Billboard_type > r (
        Billboard_traits::create (i, f, this));

      this->Billboard ().push_back (r);
      continue;
    }

    // Collision
    //
    if (n.name () == "Collision" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Collision_type > r (
        Collision_traits::create (i, f, this));

      this->Collision ().push_back (r);
      continue;
    }

    // Fog
    //
    if (n.name () == "Fog" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Fog_type > r (
        Fog_traits::create (i, f, this));

      this->Fog ().push_back (r);
      continue;
    }

    // LoadSensor
    //
    if (n.name () == "LoadSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LoadSensor_type > r (
        LoadSensor_traits::create (i, f, this));

      this->LoadSensor ().push_back (r);
      continue;
    }

    // LocalFog
    //
    if (n.name () == "LocalFog" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LocalFog_type > r (
        LocalFog_traits::create (i, f, this));

      this->LocalFog ().push_back (r);
      continue;
    }

    // LOD
    //
    if (n.name () == "LOD" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LOD_type > r (
        LOD_traits::create (i, f, this));

      this->LOD ().push_back (r);
      continue;
    }

    // Script
    //
    if (n.name () == "Script" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Script_type > r (
        Script_traits::create (i, f, this));

      this->Script ().push_back (r);
      continue;
    }

    // Sound
    //
    if (n.name () == "Sound" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Sound_type > r (
        Sound_traits::create (i, f, this));

      this->Sound ().push_back (r);
      continue;
    }

    // VisibilitySensor
    //
    if (n.name () == "VisibilitySensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< VisibilitySensor_type > r (
        VisibilitySensor_traits::create (i, f, this));

      this->VisibilitySensor ().push_back (r);
      continue;
    }

    // CoordinateInterpolator2D
    //
    if (n.name () == "CoordinateInterpolator2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateInterpolator2D_type > r (
        CoordinateInterpolator2D_traits::create (i, f, this));

      this->CoordinateInterpolator2D ().push_back (r);
      continue;
    }

    // PositionInterpolator2D
    //
    if (n.name () == "PositionInterpolator2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PositionInterpolator2D_type > r (
        PositionInterpolator2D_traits::create (i, f, this));

      this->PositionInterpolator2D ().push_back (r);
      continue;
    }

    // StaticGroup
    //
    if (n.name () == "StaticGroup" && n.namespace_ () == "")
    {
      ::std::auto_ptr< StaticGroup_type > r (
        StaticGroup_traits::create (i, f, this));

      this->StaticGroup ().push_back (r);
      continue;
    }

    // CADAssembly
    //
    if (n.name () == "CADAssembly" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CADAssembly_type > r (
        CADAssembly_traits::create (i, f, this));

      this->CADAssembly ().push_back (r);
      continue;
    }

    // CADLayer
    //
    if (n.name () == "CADLayer" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CADLayer_type > r (
        CADLayer_traits::create (i, f, this));

      this->CADLayer ().push_back (r);
      continue;
    }

    // EspduTransform
    //
    if (n.name () == "EspduTransform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< EspduTransform_type > r (
        EspduTransform_traits::create (i, f, this));

      this->EspduTransform ().push_back (r);
      continue;
    }

    // ReceiverPdu
    //
    if (n.name () == "ReceiverPdu" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ReceiverPdu_type > r (
        ReceiverPdu_traits::create (i, f, this));

      this->ReceiverPdu ().push_back (r);
      continue;
    }

    // SignalPdu
    //
    if (n.name () == "SignalPdu" && n.namespace_ () == "")
    {
      ::std::auto_ptr< SignalPdu_type > r (
        SignalPdu_traits::create (i, f, this));

      this->SignalPdu ().push_back (r);
      continue;
    }

    // TransmitterPdu
    //
    if (n.name () == "TransmitterPdu" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TransmitterPdu_type > r (
        TransmitterPdu_traits::create (i, f, this));

      this->TransmitterPdu ().push_back (r);
      continue;
    }

    // GeoLocation
    //
    if (n.name () == "GeoLocation" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoLocation_type > r (
        GeoLocation_traits::create (i, f, this));

      this->GeoLocation ().push_back (r);
      continue;
    }

    // GeoLOD
    //
    if (n.name () == "GeoLOD" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoLOD_type > r (
        GeoLOD_traits::create (i, f, this));

      this->GeoLOD ().push_back (r);
      continue;
    }

    // GeoMetadata
    //
    if (n.name () == "GeoMetadata" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoMetadata_type > r (
        GeoMetadata_traits::create (i, f, this));

      this->GeoMetadata ().push_back (r);
      continue;
    }

    // GeoOrigin
    //
    if (n.name () == "GeoOrigin" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoOrigin_type > r (
        GeoOrigin_traits::create (i, f, this));

      this->GeoOrigin ().push_back (r);
      continue;
    }

    // GeoPositionInterpolator
    //
    if (n.name () == "GeoPositionInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoPositionInterpolator_type > r (
        GeoPositionInterpolator_traits::create (i, f, this));

      this->GeoPositionInterpolator ().push_back (r);
      continue;
    }

    // GeoTouchSensor
    //
    if (n.name () == "GeoTouchSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoTouchSensor_type > r (
        GeoTouchSensor_traits::create (i, f, this));

      this->GeoTouchSensor ().push_back (r);
      continue;
    }

    // GeoViewpoint
    //
    if (n.name () == "GeoViewpoint" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoViewpoint_type > r (
        GeoViewpoint_traits::create (i, f, this));

      this->GeoViewpoint ().push_back (r);
      continue;
    }

    // HAnimHumanoid
    //
    if (n.name () == "HAnimHumanoid" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimHumanoid_type > r (
        HAnimHumanoid_traits::create (i, f, this));

      this->HAnimHumanoid ().push_back (r);
      continue;
    }

    // HAnimJoint
    //
    if (n.name () == "HAnimJoint" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimJoint_type > r (
        HAnimJoint_traits::create (i, f, this));

      this->HAnimJoint ().push_back (r);
      continue;
    }

    // HAnimSegment
    //
    if (n.name () == "HAnimSegment" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimSegment_type > r (
        HAnimSegment_traits::create (i, f, this));

      this->HAnimSegment ().push_back (r);
      continue;
    }

    // HAnimSite
    //
    if (n.name () == "HAnimSite" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimSite_type > r (
        HAnimSite_traits::create (i, f, this));

      this->HAnimSite ().push_back (r);
      continue;
    }

    // NurbsOrientationInterpolator
    //
    if (n.name () == "NurbsOrientationInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsOrientationInterpolator_type > r (
        NurbsOrientationInterpolator_traits::create (i, f, this));

      this->NurbsOrientationInterpolator ().push_back (r);
      continue;
    }

    // NurbsPositionInterpolator
    //
    if (n.name () == "NurbsPositionInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsPositionInterpolator_type > r (
        NurbsPositionInterpolator_traits::create (i, f, this));

      this->NurbsPositionInterpolator ().push_back (r);
      continue;
    }

    // NurbsSurfaceInterpolator
    //
    if (n.name () == "NurbsSurfaceInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSurfaceInterpolator_type > r (
        NurbsSurfaceInterpolator_traits::create (i, f, this));

      this->NurbsSurfaceInterpolator ().push_back (r);
      continue;
    }

    // NurbsSet
    //
    if (n.name () == "NurbsSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSet_type > r (
        NurbsSet_traits::create (i, f, this));

      this->NurbsSet ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    // Box
    //
    if (n.name () == "Box" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Box_type > r (
        Box_traits::create (i, f, this));

      this->Box ().push_back (r);
      continue;
    }

    // Cone
    //
    if (n.name () == "Cone" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Cone_type > r (
        Cone_traits::create (i, f, this));

      this->Cone ().push_back (r);
      continue;
    }

    // Cylinder
    //
    if (n.name () == "Cylinder" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Cylinder_type > r (
        Cylinder_traits::create (i, f, this));

      this->Cylinder ().push_back (r);
      continue;
    }

    // IndexedFaceSet
    //
    if (n.name () == "IndexedFaceSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedFaceSet_type > r (
        IndexedFaceSet_traits::create (i, f, this));

      this->IndexedFaceSet ().push_back (r);
      continue;
    }

    // IndexedLineSet
    //
    if (n.name () == "IndexedLineSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedLineSet_type > r (
        IndexedLineSet_traits::create (i, f, this));

      this->IndexedLineSet ().push_back (r);
      continue;
    }

    // IndexedTriangleFanSet
    //
    if (n.name () == "IndexedTriangleFanSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedTriangleFanSet_type > r (
        IndexedTriangleFanSet_traits::create (i, f, this));

      this->IndexedTriangleFanSet ().push_back (r);
      continue;
    }

    // IndexedTriangleSet
    //
    if (n.name () == "IndexedTriangleSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedTriangleSet_type > r (
        IndexedTriangleSet_traits::create (i, f, this));

      this->IndexedTriangleSet ().push_back (r);
      continue;
    }

    // IndexedTriangleStripSet
    //
    if (n.name () == "IndexedTriangleStripSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedTriangleStripSet_type > r (
        IndexedTriangleStripSet_traits::create (i, f, this));

      this->IndexedTriangleStripSet ().push_back (r);
      continue;
    }

    // LineSet
    //
    if (n.name () == "LineSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LineSet_type > r (
        LineSet_traits::create (i, f, this));

      this->LineSet ().push_back (r);
      continue;
    }

    // PointSet
    //
    if (n.name () == "PointSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PointSet_type > r (
        PointSet_traits::create (i, f, this));

      this->PointSet ().push_back (r);
      continue;
    }

    // Sphere
    //
    if (n.name () == "Sphere" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Sphere_type > r (
        Sphere_traits::create (i, f, this));

      this->Sphere ().push_back (r);
      continue;
    }

    // TriangleFanSet
    //
    if (n.name () == "TriangleFanSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TriangleFanSet_type > r (
        TriangleFanSet_traits::create (i, f, this));

      this->TriangleFanSet ().push_back (r);
      continue;
    }

    // TriangleSet
    //
    if (n.name () == "TriangleSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TriangleSet_type > r (
        TriangleSet_traits::create (i, f, this));

      this->TriangleSet ().push_back (r);
      continue;
    }

    // TriangleStripSet
    //
    if (n.name () == "TriangleStripSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TriangleStripSet_type > r (
        TriangleStripSet_traits::create (i, f, this));

      this->TriangleStripSet ().push_back (r);
      continue;
    }

    // ElevationGrid
    //
    if (n.name () == "ElevationGrid" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ElevationGrid_type > r (
        ElevationGrid_traits::create (i, f, this));

      this->ElevationGrid ().push_back (r);
      continue;
    }

    // Polyline2D
    //
    if (n.name () == "Polyline2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Polyline2D_type > r (
        Polyline2D_traits::create (i, f, this));

      this->Polyline2D ().push_back (r);
      continue;
    }

    // Polypoint2D
    //
    if (n.name () == "Polypoint2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Polypoint2D_type > r (
        Polypoint2D_traits::create (i, f, this));

      this->Polypoint2D ().push_back (r);
      continue;
    }

    // Rectangle2D
    //
    if (n.name () == "Rectangle2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Rectangle2D_type > r (
        Rectangle2D_traits::create (i, f, this));

      this->Rectangle2D ().push_back (r);
      continue;
    }

    // TriangleSet2D
    //
    if (n.name () == "TriangleSet2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TriangleSet2D_type > r (
        TriangleSet2D_traits::create (i, f, this));

      this->TriangleSet2D ().push_back (r);
      continue;
    }

    // Extrusion
    //
    if (n.name () == "Extrusion" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Extrusion_type > r (
        Extrusion_traits::create (i, f, this));

      this->Extrusion ().push_back (r);
      continue;
    }

    // Text
    //
    if (n.name () == "Text" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Text_type > r (
        Text_traits::create (i, f, this));

      this->Text ().push_back (r);
      continue;
    }

    // Arc2D
    //
    if (n.name () == "Arc2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Arc2D_type > r (
        Arc2D_traits::create (i, f, this));

      this->Arc2D ().push_back (r);
      continue;
    }

    // ArcClose2D
    //
    if (n.name () == "ArcClose2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ArcClose2D_type > r (
        ArcClose2D_traits::create (i, f, this));

      this->ArcClose2D ().push_back (r);
      continue;
    }

    // Circle2D
    //
    if (n.name () == "Circle2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Circle2D_type > r (
        Circle2D_traits::create (i, f, this));

      this->Circle2D ().push_back (r);
      continue;
    }

    // Disk2D
    //
    if (n.name () == "Disk2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Disk2D_type > r (
        Disk2D_traits::create (i, f, this));

      this->Disk2D ().push_back (r);
      continue;
    }

    // QuadSet
    //
    if (n.name () == "QuadSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< QuadSet_type > r (
        QuadSet_traits::create (i, f, this));

      this->QuadSet ().push_back (r);
      continue;
    }

    // IndexedQuadSet
    //
    if (n.name () == "IndexedQuadSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedQuadSet_type > r (
        IndexedQuadSet_traits::create (i, f, this));

      this->IndexedQuadSet ().push_back (r);
      continue;
    }

    // GeoElevationGrid
    //
    if (n.name () == "GeoElevationGrid" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoElevationGrid_type > r (
        GeoElevationGrid_traits::create (i, f, this));

      this->GeoElevationGrid ().push_back (r);
      continue;
    }

    // NurbsCurve
    //
    if (n.name () == "NurbsCurve" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsCurve_type > r (
        NurbsCurve_traits::create (i, f, this));

      this->NurbsCurve ().push_back (r);
      continue;
    }

    // NurbsCurve2D
    //
    if (n.name () == "NurbsCurve2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsCurve2D_type > r (
        NurbsCurve2D_traits::create (i, f, this));

      this->NurbsCurve2D ().push_back (r);
      continue;
    }

    // NurbsPatchSurface
    //
    if (n.name () == "NurbsPatchSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsPatchSurface_type > r (
        NurbsPatchSurface_traits::create (i, f, this));

      this->NurbsPatchSurface ().push_back (r);
      continue;
    }

    // NurbsSweptSurface
    //
    if (n.name () == "NurbsSweptSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSweptSurface_type > r (
        NurbsSweptSurface_traits::create (i, f, this));

      this->NurbsSweptSurface ().push_back (r);
      continue;
    }

    // NurbsSwungSurface
    //
    if (n.name () == "NurbsSwungSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSwungSurface_type > r (
        NurbsSwungSurface_traits::create (i, f, this));

      this->NurbsSwungSurface ().push_back (r);
      continue;
    }

    // NurbsTrimmedSurface
    //
    if (n.name () == "NurbsTrimmedSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsTrimmedSurface_type > r (
        NurbsTrimmedSurface_traits::create (i, f, this));

      this->NurbsTrimmedSurface ().push_back (r);
      continue;
    }

    // Color
    //
    if (n.name () == "Color" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Color_type > r (
        Color_traits::create (i, f, this));

      this->Color ().push_back (r);
      continue;
    }

    // ColorRGBA
    //
    if (n.name () == "ColorRGBA" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ColorRGBA_type > r (
        ColorRGBA_traits::create (i, f, this));

      this->ColorRGBA ().push_back (r);
      continue;
    }

    // Coordinate
    //
    if (n.name () == "Coordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Coordinate_type > r (
        Coordinate_traits::create (i, f, this));

      this->Coordinate ().push_back (r);
      continue;
    }

    // CoordinateDouble
    //
    if (n.name () == "CoordinateDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateDouble_type > r (
        CoordinateDouble_traits::create (i, f, this));

      this->CoordinateDouble ().push_back (r);
      continue;
    }

    // FontStyle
    //
    if (n.name () == "FontStyle" && n.namespace_ () == "")
    {
      ::std::auto_ptr< FontStyle_type > r (
        FontStyle_traits::create (i, f, this));

      this->FontStyle ().push_back (r);
      continue;
    }

    // GeoCoordinate
    //
    if (n.name () == "GeoCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoCoordinate_type > r (
        GeoCoordinate_traits::create (i, f, this));

      this->GeoCoordinate ().push_back (r);
      continue;
    }

    // Normal
    //
    if (n.name () == "Normal" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Normal_type > r (
        Normal_traits::create (i, f, this));

      this->Normal ().push_back (r);
      continue;
    }

    // TextureCoordinate
    //
    if (n.name () == "TextureCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureCoordinate_type > r (
        TextureCoordinate_traits::create (i, f, this));

      this->TextureCoordinate ().push_back (r);
      continue;
    }

    // NurbsTextureCoordinate
    //
    if (n.name () == "NurbsTextureCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsTextureCoordinate_type > r (
        NurbsTextureCoordinate_traits::create (i, f, this));

      this->NurbsTextureCoordinate ().push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name (r);
      continue;
    }

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< value_type > r (
        value_traits::create (i, f, this));

      this->value (r);
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }
}

fieldValue* fieldValue::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new fieldValue (*this, f, c);
}

fieldValue::
~fieldValue ()
{
}

// head
//

head::
head ()
: ::SceneGraphStructureNodeType (),
  component_ (::xml_schema::flags (), this),
  meta_ (::xml_schema::flags (), this)
{
}

head::
head (const head& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (x, f, c),
  component_ (x.component_, f, this),
  meta_ (x.meta_, f, this)
{
}

head::
head (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (e, f | ::xml_schema::flags::base, c),
  component_ (f, this),
  meta_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void head::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // component
    //
    if (n.name () == "component" && n.namespace_ () == "")
    {
      ::std::auto_ptr< component_type > r (
        component_traits::create (i, f, this));

      this->component ().push_back (r);
      continue;
    }

    // meta
    //
    if (n.name () == "meta" && n.namespace_ () == "")
    {
      ::std::auto_ptr< meta_type > r (
        meta_traits::create (i, f, this));

      this->meta ().push_back (r);
      continue;
    }

    break;
  }
}

head* head::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new head (*this, f, c);
}

head::
~head ()
{
}

// meta
//

meta::
meta (const name_type& name,
      const content_type& content)
: ::SceneGraphStructureNodeType (),
  name_ (name, ::xml_schema::flags (), this),
  content_ (content, ::xml_schema::flags (), this),
  http_equiv_ (::xml_schema::flags (), this),
  lang_ (::xml_schema::flags (), this),
  dir_ (::xml_schema::flags (), this)
{
}

meta::
meta (const meta& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (x, f, c),
  name_ (x.name_, f, this),
  content_ (x.content_, f, this),
  http_equiv_ (x.http_equiv_, f, this),
  lang_ (x.lang_, f, this),
  dir_ (x.dir_, f, this)
{
}

meta::
meta (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (e, f | ::xml_schema::flags::base, c),
  name_ (f, this),
  content_ (f, this),
  http_equiv_ (f, this),
  lang_ (f, this),
  dir_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void meta::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name (r);
      continue;
    }

    if (n.name () == "content" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< content_type > r (
        content_traits::create (i, f, this));

      this->content (r);
      continue;
    }

    if (n.name () == "http-equiv" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< http_equiv_type > r (
        http_equiv_traits::create (i, f, this));

      this->http_equiv (r);
      continue;
    }

    if (n.name () == "lang" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< lang_type > r (
        lang_traits::create (i, f, this));

      this->lang (r);
      continue;
    }

    if (n.name () == "dir" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dir_type > r (
        dir_traits::create (i, f, this));

      this->dir (r);
      continue;
    }
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "name",
      "");
  }

  if (!content_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "content",
      "");
  }
}

meta* meta::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new meta (*this, f, c);
}

meta::
~meta ()
{
}

// ExternProtoDeclare
//

ExternProtoDeclare::
ExternProtoDeclare (const name_type& name,
                    const url_type& url)
: ::X3DPrototype (name),
  field_ (::xml_schema::flags (), this),
  url_ (url, ::xml_schema::flags (), this),
  appinfo_ (::xml_schema::flags (), this),
  documentation_ (::xml_schema::flags (), this)
{
}

ExternProtoDeclare::
ExternProtoDeclare (const ExternProtoDeclare& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::X3DPrototype (x, f, c),
  field_ (x.field_, f, this),
  url_ (x.url_, f, this),
  appinfo_ (x.appinfo_, f, this),
  documentation_ (x.documentation_, f, this)
{
}

ExternProtoDeclare::
ExternProtoDeclare (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::X3DPrototype (e, f | ::xml_schema::flags::base, c),
  field_ (f, this),
  url_ (f, this),
  appinfo_ (f, this),
  documentation_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ExternProtoDeclare::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DPrototype::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // field
    //
    if (n.name () == "field" && n.namespace_ () == "")
    {
      ::std::auto_ptr< field_type > r (
        field_traits::create (i, f, this));

      this->field ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< url_type > r (
        url_traits::create (i, f, this));

      this->url (r);
      continue;
    }

    if (n.name () == "appinfo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< appinfo_type > r (
        appinfo_traits::create (i, f, this));

      this->appinfo (r);
      continue;
    }

    if (n.name () == "documentation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< documentation_type > r (
        documentation_traits::create (i, f, this));

      this->documentation (r);
      continue;
    }
  }

  if (!url_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "url",
      "");
  }
}

ExternProtoDeclare* ExternProtoDeclare::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ExternProtoDeclare (*this, f, c);
}

ExternProtoDeclare::
~ExternProtoDeclare ()
{
}

// ProtoDeclare
//

ProtoDeclare::
ProtoDeclare (const name_type& name,
              const ProtoBody_type& ProtoBody)
: ::X3DPrototype (name),
  ProtoInterface_ (::xml_schema::flags (), this),
  ProtoBody_ (ProtoBody, ::xml_schema::flags (), this),
  appinfo_ (::xml_schema::flags (), this),
  documentation_ (::xml_schema::flags (), this)
{
}

ProtoDeclare::
ProtoDeclare (const ProtoDeclare& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DPrototype (x, f, c),
  ProtoInterface_ (x.ProtoInterface_, f, this),
  ProtoBody_ (x.ProtoBody_, f, this),
  appinfo_ (x.appinfo_, f, this),
  documentation_ (x.documentation_, f, this)
{
}

ProtoDeclare::
ProtoDeclare (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DPrototype (e, f | ::xml_schema::flags::base, c),
  ProtoInterface_ (f, this),
  ProtoBody_ (f, this),
  appinfo_ (f, this),
  documentation_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ProtoDeclare::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DPrototype::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ProtoInterface
    //
    if (n.name () == "ProtoInterface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInterface_type > r (
        ProtoInterface_traits::create (i, f, this));

      if (!this->ProtoInterface ())
      {
        this->ProtoInterface (r);
        continue;
      }
    }

    // ProtoBody
    //
    if (n.name () == "ProtoBody" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoBody_type > r (
        ProtoBody_traits::create (i, f, this));

      if (!ProtoBody_.present ())
      {
        this->ProtoBody (r);
        continue;
      }
    }

    break;
  }

  if (!ProtoBody_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "ProtoBody",
      "");
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "appinfo" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< appinfo_type > r (
        appinfo_traits::create (i, f, this));

      this->appinfo (r);
      continue;
    }

    if (n.name () == "documentation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< documentation_type > r (
        documentation_traits::create (i, f, this));

      this->documentation (r);
      continue;
    }
  }
}

ProtoDeclare* ProtoDeclare::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ProtoDeclare (*this, f, c);
}

ProtoDeclare::
~ProtoDeclare ()
{
}

// ProtoInterface
//

ProtoInterface::
ProtoInterface ()
: ::SceneGraphStructureNodeType (),
  field_ (::xml_schema::flags (), this)
{
}

ProtoInterface::
ProtoInterface (const ProtoInterface& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (x, f, c),
  field_ (x.field_, f, this)
{
}

ProtoInterface::
ProtoInterface (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (e, f | ::xml_schema::flags::base, c),
  field_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ProtoInterface::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // field
    //
    if (n.name () == "field" && n.namespace_ () == "")
    {
      ::std::auto_ptr< field_type > r (
        field_traits::create (i, f, this));

      this->field ().push_back (r);
      continue;
    }

    break;
  }
}

ProtoInterface* ProtoInterface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ProtoInterface (*this, f, c);
}

ProtoInterface::
~ProtoInterface ()
{
}

// ProtoBody
//

ProtoBody::
ProtoBody ()
: ::SceneGraphStructureNodeType (),
  FillProperties_ (::xml_schema::flags (), this),
  LineProperties_ (::xml_schema::flags (), this),
  Material_ (::xml_schema::flags (), this),
  ComposedShader_ (::xml_schema::flags (), this),
  PackagedShader_ (::xml_schema::flags (), this),
  ProgramShader_ (::xml_schema::flags (), this),
  ComposedCubeMapTexture_ (::xml_schema::flags (), this),
  ImageTexture_ (::xml_schema::flags (), this),
  MovieTexture_ (::xml_schema::flags (), this),
  MultiTexture_ (::xml_schema::flags (), this),
  PixelTexture_ (::xml_schema::flags (), this),
  GeneratedCubeMapTexture_ (::xml_schema::flags (), this),
  ImageCubeMapTexture_ (::xml_schema::flags (), this),
  MultiTextureTransform_ (::xml_schema::flags (), this),
  TextureTransform_ (::xml_schema::flags (), this),
  MetadataDouble_ (::xml_schema::flags (), this),
  MetadataFloat_ (::xml_schema::flags (), this),
  MetadataInteger_ (::xml_schema::flags (), this),
  MetadataSet_ (::xml_schema::flags (), this),
  MetadataString_ (::xml_schema::flags (), this),
  Appearance_ (::xml_schema::flags (), this),
  Background_ (::xml_schema::flags (), this),
  ColorInterpolator_ (::xml_schema::flags (), this),
  CoordinateInterpolator_ (::xml_schema::flags (), this),
  DirectionalLight_ (::xml_schema::flags (), this),
  Group_ (::xml_schema::flags (), this),
  NavigationInfo_ (::xml_schema::flags (), this),
  NormalInterpolator_ (::xml_schema::flags (), this),
  OrientationInterpolator_ (::xml_schema::flags (), this),
  PositionInterpolator_ (::xml_schema::flags (), this),
  ScalarInterpolator_ (::xml_schema::flags (), this),
  Shape_ (::xml_schema::flags (), this),
  TimeSensor_ (::xml_schema::flags (), this),
  Transform_ (::xml_schema::flags (), this),
  Viewpoint_ (::xml_schema::flags (), this),
  WorldInfo_ (::xml_schema::flags (), this),
  Anchor_ (::xml_schema::flags (), this),
  BooleanFilter_ (::xml_schema::flags (), this),
  BooleanSequencer_ (::xml_schema::flags (), this),
  BooleanToggle_ (::xml_schema::flags (), this),
  BooleanTrigger_ (::xml_schema::flags (), this),
  CylinderSensor_ (::xml_schema::flags (), this),
  Inline_ (::xml_schema::flags (), this),
  IntegerSequencer_ (::xml_schema::flags (), this),
  IntegerTrigger_ (::xml_schema::flags (), this),
  KeySensor_ (::xml_schema::flags (), this),
  PlaneSensor_ (::xml_schema::flags (), this),
  PointLight_ (::xml_schema::flags (), this),
  ProximitySensor_ (::xml_schema::flags (), this),
  SphereSensor_ (::xml_schema::flags (), this),
  SpotLight_ (::xml_schema::flags (), this),
  StringSensor_ (::xml_schema::flags (), this),
  Switch_ (::xml_schema::flags (), this),
  TimeTrigger_ (::xml_schema::flags (), this),
  TouchSensor_ (::xml_schema::flags (), this),
  AudioClip_ (::xml_schema::flags (), this),
  Billboard_ (::xml_schema::flags (), this),
  Collision_ (::xml_schema::flags (), this),
  Fog_ (::xml_schema::flags (), this),
  LoadSensor_ (::xml_schema::flags (), this),
  LocalFog_ (::xml_schema::flags (), this),
  LOD_ (::xml_schema::flags (), this),
  Script_ (::xml_schema::flags (), this),
  Sound_ (::xml_schema::flags (), this),
  VisibilitySensor_ (::xml_schema::flags (), this),
  CoordinateInterpolator2D_ (::xml_schema::flags (), this),
  PositionInterpolator2D_ (::xml_schema::flags (), this),
  StaticGroup_ (::xml_schema::flags (), this),
  CADAssembly_ (::xml_schema::flags (), this),
  CADLayer_ (::xml_schema::flags (), this),
  EspduTransform_ (::xml_schema::flags (), this),
  ReceiverPdu_ (::xml_schema::flags (), this),
  SignalPdu_ (::xml_schema::flags (), this),
  TransmitterPdu_ (::xml_schema::flags (), this),
  GeoLocation_ (::xml_schema::flags (), this),
  GeoLOD_ (::xml_schema::flags (), this),
  GeoMetadata_ (::xml_schema::flags (), this),
  GeoOrigin_ (::xml_schema::flags (), this),
  GeoPositionInterpolator_ (::xml_schema::flags (), this),
  GeoTouchSensor_ (::xml_schema::flags (), this),
  GeoViewpoint_ (::xml_schema::flags (), this),
  HAnimHumanoid_ (::xml_schema::flags (), this),
  HAnimJoint_ (::xml_schema::flags (), this),
  HAnimSegment_ (::xml_schema::flags (), this),
  HAnimSite_ (::xml_schema::flags (), this),
  NurbsOrientationInterpolator_ (::xml_schema::flags (), this),
  NurbsPositionInterpolator_ (::xml_schema::flags (), this),
  NurbsSurfaceInterpolator_ (::xml_schema::flags (), this),
  NurbsSet_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  Box_ (::xml_schema::flags (), this),
  Cone_ (::xml_schema::flags (), this),
  Cylinder_ (::xml_schema::flags (), this),
  IndexedFaceSet_ (::xml_schema::flags (), this),
  IndexedLineSet_ (::xml_schema::flags (), this),
  IndexedTriangleFanSet_ (::xml_schema::flags (), this),
  IndexedTriangleSet_ (::xml_schema::flags (), this),
  IndexedTriangleStripSet_ (::xml_schema::flags (), this),
  LineSet_ (::xml_schema::flags (), this),
  PointSet_ (::xml_schema::flags (), this),
  Sphere_ (::xml_schema::flags (), this),
  TriangleFanSet_ (::xml_schema::flags (), this),
  TriangleSet_ (::xml_schema::flags (), this),
  TriangleStripSet_ (::xml_schema::flags (), this),
  ElevationGrid_ (::xml_schema::flags (), this),
  Polyline2D_ (::xml_schema::flags (), this),
  Polypoint2D_ (::xml_schema::flags (), this),
  Rectangle2D_ (::xml_schema::flags (), this),
  TriangleSet2D_ (::xml_schema::flags (), this),
  Extrusion_ (::xml_schema::flags (), this),
  Text_ (::xml_schema::flags (), this),
  Arc2D_ (::xml_schema::flags (), this),
  ArcClose2D_ (::xml_schema::flags (), this),
  Circle2D_ (::xml_schema::flags (), this),
  Disk2D_ (::xml_schema::flags (), this),
  QuadSet_ (::xml_schema::flags (), this),
  IndexedQuadSet_ (::xml_schema::flags (), this),
  GeoElevationGrid_ (::xml_schema::flags (), this),
  NurbsCurve_ (::xml_schema::flags (), this),
  NurbsCurve2D_ (::xml_schema::flags (), this),
  NurbsPatchSurface_ (::xml_schema::flags (), this),
  NurbsSweptSurface_ (::xml_schema::flags (), this),
  NurbsSwungSurface_ (::xml_schema::flags (), this),
  NurbsTrimmedSurface_ (::xml_schema::flags (), this),
  Color_ (::xml_schema::flags (), this),
  ColorRGBA_ (::xml_schema::flags (), this),
  Coordinate_ (::xml_schema::flags (), this),
  CoordinateDouble_ (::xml_schema::flags (), this),
  FontStyle_ (::xml_schema::flags (), this),
  GeoCoordinate_ (::xml_schema::flags (), this),
  Normal_ (::xml_schema::flags (), this),
  TextureCoordinate_ (::xml_schema::flags (), this),
  NurbsTextureCoordinate_ (::xml_schema::flags (), this),
  ROUTE_ (::xml_schema::flags (), this),
  ExternProtoDeclare_ (::xml_schema::flags (), this),
  ProtoDeclare_ (::xml_schema::flags (), this),
  IMPORT_ (::xml_schema::flags (), this),
  EXPORT_ (::xml_schema::flags (), this)
{
}

ProtoBody::
ProtoBody (const ProtoBody& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (x, f, c),
  FillProperties_ (x.FillProperties_, f, this),
  LineProperties_ (x.LineProperties_, f, this),
  Material_ (x.Material_, f, this),
  ComposedShader_ (x.ComposedShader_, f, this),
  PackagedShader_ (x.PackagedShader_, f, this),
  ProgramShader_ (x.ProgramShader_, f, this),
  ComposedCubeMapTexture_ (x.ComposedCubeMapTexture_, f, this),
  ImageTexture_ (x.ImageTexture_, f, this),
  MovieTexture_ (x.MovieTexture_, f, this),
  MultiTexture_ (x.MultiTexture_, f, this),
  PixelTexture_ (x.PixelTexture_, f, this),
  GeneratedCubeMapTexture_ (x.GeneratedCubeMapTexture_, f, this),
  ImageCubeMapTexture_ (x.ImageCubeMapTexture_, f, this),
  MultiTextureTransform_ (x.MultiTextureTransform_, f, this),
  TextureTransform_ (x.TextureTransform_, f, this),
  MetadataDouble_ (x.MetadataDouble_, f, this),
  MetadataFloat_ (x.MetadataFloat_, f, this),
  MetadataInteger_ (x.MetadataInteger_, f, this),
  MetadataSet_ (x.MetadataSet_, f, this),
  MetadataString_ (x.MetadataString_, f, this),
  Appearance_ (x.Appearance_, f, this),
  Background_ (x.Background_, f, this),
  ColorInterpolator_ (x.ColorInterpolator_, f, this),
  CoordinateInterpolator_ (x.CoordinateInterpolator_, f, this),
  DirectionalLight_ (x.DirectionalLight_, f, this),
  Group_ (x.Group_, f, this),
  NavigationInfo_ (x.NavigationInfo_, f, this),
  NormalInterpolator_ (x.NormalInterpolator_, f, this),
  OrientationInterpolator_ (x.OrientationInterpolator_, f, this),
  PositionInterpolator_ (x.PositionInterpolator_, f, this),
  ScalarInterpolator_ (x.ScalarInterpolator_, f, this),
  Shape_ (x.Shape_, f, this),
  TimeSensor_ (x.TimeSensor_, f, this),
  Transform_ (x.Transform_, f, this),
  Viewpoint_ (x.Viewpoint_, f, this),
  WorldInfo_ (x.WorldInfo_, f, this),
  Anchor_ (x.Anchor_, f, this),
  BooleanFilter_ (x.BooleanFilter_, f, this),
  BooleanSequencer_ (x.BooleanSequencer_, f, this),
  BooleanToggle_ (x.BooleanToggle_, f, this),
  BooleanTrigger_ (x.BooleanTrigger_, f, this),
  CylinderSensor_ (x.CylinderSensor_, f, this),
  Inline_ (x.Inline_, f, this),
  IntegerSequencer_ (x.IntegerSequencer_, f, this),
  IntegerTrigger_ (x.IntegerTrigger_, f, this),
  KeySensor_ (x.KeySensor_, f, this),
  PlaneSensor_ (x.PlaneSensor_, f, this),
  PointLight_ (x.PointLight_, f, this),
  ProximitySensor_ (x.ProximitySensor_, f, this),
  SphereSensor_ (x.SphereSensor_, f, this),
  SpotLight_ (x.SpotLight_, f, this),
  StringSensor_ (x.StringSensor_, f, this),
  Switch_ (x.Switch_, f, this),
  TimeTrigger_ (x.TimeTrigger_, f, this),
  TouchSensor_ (x.TouchSensor_, f, this),
  AudioClip_ (x.AudioClip_, f, this),
  Billboard_ (x.Billboard_, f, this),
  Collision_ (x.Collision_, f, this),
  Fog_ (x.Fog_, f, this),
  LoadSensor_ (x.LoadSensor_, f, this),
  LocalFog_ (x.LocalFog_, f, this),
  LOD_ (x.LOD_, f, this),
  Script_ (x.Script_, f, this),
  Sound_ (x.Sound_, f, this),
  VisibilitySensor_ (x.VisibilitySensor_, f, this),
  CoordinateInterpolator2D_ (x.CoordinateInterpolator2D_, f, this),
  PositionInterpolator2D_ (x.PositionInterpolator2D_, f, this),
  StaticGroup_ (x.StaticGroup_, f, this),
  CADAssembly_ (x.CADAssembly_, f, this),
  CADLayer_ (x.CADLayer_, f, this),
  EspduTransform_ (x.EspduTransform_, f, this),
  ReceiverPdu_ (x.ReceiverPdu_, f, this),
  SignalPdu_ (x.SignalPdu_, f, this),
  TransmitterPdu_ (x.TransmitterPdu_, f, this),
  GeoLocation_ (x.GeoLocation_, f, this),
  GeoLOD_ (x.GeoLOD_, f, this),
  GeoMetadata_ (x.GeoMetadata_, f, this),
  GeoOrigin_ (x.GeoOrigin_, f, this),
  GeoPositionInterpolator_ (x.GeoPositionInterpolator_, f, this),
  GeoTouchSensor_ (x.GeoTouchSensor_, f, this),
  GeoViewpoint_ (x.GeoViewpoint_, f, this),
  HAnimHumanoid_ (x.HAnimHumanoid_, f, this),
  HAnimJoint_ (x.HAnimJoint_, f, this),
  HAnimSegment_ (x.HAnimSegment_, f, this),
  HAnimSite_ (x.HAnimSite_, f, this),
  NurbsOrientationInterpolator_ (x.NurbsOrientationInterpolator_, f, this),
  NurbsPositionInterpolator_ (x.NurbsPositionInterpolator_, f, this),
  NurbsSurfaceInterpolator_ (x.NurbsSurfaceInterpolator_, f, this),
  NurbsSet_ (x.NurbsSet_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  Box_ (x.Box_, f, this),
  Cone_ (x.Cone_, f, this),
  Cylinder_ (x.Cylinder_, f, this),
  IndexedFaceSet_ (x.IndexedFaceSet_, f, this),
  IndexedLineSet_ (x.IndexedLineSet_, f, this),
  IndexedTriangleFanSet_ (x.IndexedTriangleFanSet_, f, this),
  IndexedTriangleSet_ (x.IndexedTriangleSet_, f, this),
  IndexedTriangleStripSet_ (x.IndexedTriangleStripSet_, f, this),
  LineSet_ (x.LineSet_, f, this),
  PointSet_ (x.PointSet_, f, this),
  Sphere_ (x.Sphere_, f, this),
  TriangleFanSet_ (x.TriangleFanSet_, f, this),
  TriangleSet_ (x.TriangleSet_, f, this),
  TriangleStripSet_ (x.TriangleStripSet_, f, this),
  ElevationGrid_ (x.ElevationGrid_, f, this),
  Polyline2D_ (x.Polyline2D_, f, this),
  Polypoint2D_ (x.Polypoint2D_, f, this),
  Rectangle2D_ (x.Rectangle2D_, f, this),
  TriangleSet2D_ (x.TriangleSet2D_, f, this),
  Extrusion_ (x.Extrusion_, f, this),
  Text_ (x.Text_, f, this),
  Arc2D_ (x.Arc2D_, f, this),
  ArcClose2D_ (x.ArcClose2D_, f, this),
  Circle2D_ (x.Circle2D_, f, this),
  Disk2D_ (x.Disk2D_, f, this),
  QuadSet_ (x.QuadSet_, f, this),
  IndexedQuadSet_ (x.IndexedQuadSet_, f, this),
  GeoElevationGrid_ (x.GeoElevationGrid_, f, this),
  NurbsCurve_ (x.NurbsCurve_, f, this),
  NurbsCurve2D_ (x.NurbsCurve2D_, f, this),
  NurbsPatchSurface_ (x.NurbsPatchSurface_, f, this),
  NurbsSweptSurface_ (x.NurbsSweptSurface_, f, this),
  NurbsSwungSurface_ (x.NurbsSwungSurface_, f, this),
  NurbsTrimmedSurface_ (x.NurbsTrimmedSurface_, f, this),
  Color_ (x.Color_, f, this),
  ColorRGBA_ (x.ColorRGBA_, f, this),
  Coordinate_ (x.Coordinate_, f, this),
  CoordinateDouble_ (x.CoordinateDouble_, f, this),
  FontStyle_ (x.FontStyle_, f, this),
  GeoCoordinate_ (x.GeoCoordinate_, f, this),
  Normal_ (x.Normal_, f, this),
  TextureCoordinate_ (x.TextureCoordinate_, f, this),
  NurbsTextureCoordinate_ (x.NurbsTextureCoordinate_, f, this),
  ROUTE_ (x.ROUTE_, f, this),
  ExternProtoDeclare_ (x.ExternProtoDeclare_, f, this),
  ProtoDeclare_ (x.ProtoDeclare_, f, this),
  IMPORT_ (x.IMPORT_, f, this),
  EXPORT_ (x.EXPORT_, f, this)
{
}

ProtoBody::
ProtoBody (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (e, f | ::xml_schema::flags::base, c),
  FillProperties_ (f, this),
  LineProperties_ (f, this),
  Material_ (f, this),
  ComposedShader_ (f, this),
  PackagedShader_ (f, this),
  ProgramShader_ (f, this),
  ComposedCubeMapTexture_ (f, this),
  ImageTexture_ (f, this),
  MovieTexture_ (f, this),
  MultiTexture_ (f, this),
  PixelTexture_ (f, this),
  GeneratedCubeMapTexture_ (f, this),
  ImageCubeMapTexture_ (f, this),
  MultiTextureTransform_ (f, this),
  TextureTransform_ (f, this),
  MetadataDouble_ (f, this),
  MetadataFloat_ (f, this),
  MetadataInteger_ (f, this),
  MetadataSet_ (f, this),
  MetadataString_ (f, this),
  Appearance_ (f, this),
  Background_ (f, this),
  ColorInterpolator_ (f, this),
  CoordinateInterpolator_ (f, this),
  DirectionalLight_ (f, this),
  Group_ (f, this),
  NavigationInfo_ (f, this),
  NormalInterpolator_ (f, this),
  OrientationInterpolator_ (f, this),
  PositionInterpolator_ (f, this),
  ScalarInterpolator_ (f, this),
  Shape_ (f, this),
  TimeSensor_ (f, this),
  Transform_ (f, this),
  Viewpoint_ (f, this),
  WorldInfo_ (f, this),
  Anchor_ (f, this),
  BooleanFilter_ (f, this),
  BooleanSequencer_ (f, this),
  BooleanToggle_ (f, this),
  BooleanTrigger_ (f, this),
  CylinderSensor_ (f, this),
  Inline_ (f, this),
  IntegerSequencer_ (f, this),
  IntegerTrigger_ (f, this),
  KeySensor_ (f, this),
  PlaneSensor_ (f, this),
  PointLight_ (f, this),
  ProximitySensor_ (f, this),
  SphereSensor_ (f, this),
  SpotLight_ (f, this),
  StringSensor_ (f, this),
  Switch_ (f, this),
  TimeTrigger_ (f, this),
  TouchSensor_ (f, this),
  AudioClip_ (f, this),
  Billboard_ (f, this),
  Collision_ (f, this),
  Fog_ (f, this),
  LoadSensor_ (f, this),
  LocalFog_ (f, this),
  LOD_ (f, this),
  Script_ (f, this),
  Sound_ (f, this),
  VisibilitySensor_ (f, this),
  CoordinateInterpolator2D_ (f, this),
  PositionInterpolator2D_ (f, this),
  StaticGroup_ (f, this),
  CADAssembly_ (f, this),
  CADLayer_ (f, this),
  EspduTransform_ (f, this),
  ReceiverPdu_ (f, this),
  SignalPdu_ (f, this),
  TransmitterPdu_ (f, this),
  GeoLocation_ (f, this),
  GeoLOD_ (f, this),
  GeoMetadata_ (f, this),
  GeoOrigin_ (f, this),
  GeoPositionInterpolator_ (f, this),
  GeoTouchSensor_ (f, this),
  GeoViewpoint_ (f, this),
  HAnimHumanoid_ (f, this),
  HAnimJoint_ (f, this),
  HAnimSegment_ (f, this),
  HAnimSite_ (f, this),
  NurbsOrientationInterpolator_ (f, this),
  NurbsPositionInterpolator_ (f, this),
  NurbsSurfaceInterpolator_ (f, this),
  NurbsSet_ (f, this),
  ProtoInstance_ (f, this),
  Box_ (f, this),
  Cone_ (f, this),
  Cylinder_ (f, this),
  IndexedFaceSet_ (f, this),
  IndexedLineSet_ (f, this),
  IndexedTriangleFanSet_ (f, this),
  IndexedTriangleSet_ (f, this),
  IndexedTriangleStripSet_ (f, this),
  LineSet_ (f, this),
  PointSet_ (f, this),
  Sphere_ (f, this),
  TriangleFanSet_ (f, this),
  TriangleSet_ (f, this),
  TriangleStripSet_ (f, this),
  ElevationGrid_ (f, this),
  Polyline2D_ (f, this),
  Polypoint2D_ (f, this),
  Rectangle2D_ (f, this),
  TriangleSet2D_ (f, this),
  Extrusion_ (f, this),
  Text_ (f, this),
  Arc2D_ (f, this),
  ArcClose2D_ (f, this),
  Circle2D_ (f, this),
  Disk2D_ (f, this),
  QuadSet_ (f, this),
  IndexedQuadSet_ (f, this),
  GeoElevationGrid_ (f, this),
  NurbsCurve_ (f, this),
  NurbsCurve2D_ (f, this),
  NurbsPatchSurface_ (f, this),
  NurbsSweptSurface_ (f, this),
  NurbsSwungSurface_ (f, this),
  NurbsTrimmedSurface_ (f, this),
  Color_ (f, this),
  ColorRGBA_ (f, this),
  Coordinate_ (f, this),
  CoordinateDouble_ (f, this),
  FontStyle_ (f, this),
  GeoCoordinate_ (f, this),
  Normal_ (f, this),
  TextureCoordinate_ (f, this),
  NurbsTextureCoordinate_ (f, this),
  ROUTE_ (f, this),
  ExternProtoDeclare_ (f, this),
  ProtoDeclare_ (f, this),
  IMPORT_ (f, this),
  EXPORT_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ProtoBody::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // FillProperties
    //
    if (n.name () == "FillProperties" && n.namespace_ () == "")
    {
      ::std::auto_ptr< FillProperties_type > r (
        FillProperties_traits::create (i, f, this));

      this->FillProperties ().push_back (r);
      continue;
    }

    // LineProperties
    //
    if (n.name () == "LineProperties" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LineProperties_type > r (
        LineProperties_traits::create (i, f, this));

      this->LineProperties ().push_back (r);
      continue;
    }

    // Material
    //
    if (n.name () == "Material" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Material_type > r (
        Material_traits::create (i, f, this));

      this->Material ().push_back (r);
      continue;
    }

    // ComposedShader
    //
    if (n.name () == "ComposedShader" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ComposedShader_type > r (
        ComposedShader_traits::create (i, f, this));

      this->ComposedShader ().push_back (r);
      continue;
    }

    // PackagedShader
    //
    if (n.name () == "PackagedShader" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PackagedShader_type > r (
        PackagedShader_traits::create (i, f, this));

      this->PackagedShader ().push_back (r);
      continue;
    }

    // ProgramShader
    //
    if (n.name () == "ProgramShader" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProgramShader_type > r (
        ProgramShader_traits::create (i, f, this));

      this->ProgramShader ().push_back (r);
      continue;
    }

    // ComposedCubeMapTexture
    //
    if (n.name () == "ComposedCubeMapTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ComposedCubeMapTexture_type > r (
        ComposedCubeMapTexture_traits::create (i, f, this));

      this->ComposedCubeMapTexture ().push_back (r);
      continue;
    }

    // ImageTexture
    //
    if (n.name () == "ImageTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ImageTexture_type > r (
        ImageTexture_traits::create (i, f, this));

      this->ImageTexture ().push_back (r);
      continue;
    }

    // MovieTexture
    //
    if (n.name () == "MovieTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MovieTexture_type > r (
        MovieTexture_traits::create (i, f, this));

      this->MovieTexture ().push_back (r);
      continue;
    }

    // MultiTexture
    //
    if (n.name () == "MultiTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MultiTexture_type > r (
        MultiTexture_traits::create (i, f, this));

      this->MultiTexture ().push_back (r);
      continue;
    }

    // PixelTexture
    //
    if (n.name () == "PixelTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PixelTexture_type > r (
        PixelTexture_traits::create (i, f, this));

      this->PixelTexture ().push_back (r);
      continue;
    }

    // GeneratedCubeMapTexture
    //
    if (n.name () == "GeneratedCubeMapTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeneratedCubeMapTexture_type > r (
        GeneratedCubeMapTexture_traits::create (i, f, this));

      this->GeneratedCubeMapTexture ().push_back (r);
      continue;
    }

    // ImageCubeMapTexture
    //
    if (n.name () == "ImageCubeMapTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ImageCubeMapTexture_type > r (
        ImageCubeMapTexture_traits::create (i, f, this));

      this->ImageCubeMapTexture ().push_back (r);
      continue;
    }

    // MultiTextureTransform
    //
    if (n.name () == "MultiTextureTransform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MultiTextureTransform_type > r (
        MultiTextureTransform_traits::create (i, f, this));

      this->MultiTextureTransform ().push_back (r);
      continue;
    }

    // TextureTransform
    //
    if (n.name () == "TextureTransform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureTransform_type > r (
        TextureTransform_traits::create (i, f, this));

      this->TextureTransform ().push_back (r);
      continue;
    }

    // MetadataDouble
    //
    if (n.name () == "MetadataDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataDouble_type > r (
        MetadataDouble_traits::create (i, f, this));

      this->MetadataDouble ().push_back (r);
      continue;
    }

    // MetadataFloat
    //
    if (n.name () == "MetadataFloat" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataFloat_type > r (
        MetadataFloat_traits::create (i, f, this));

      this->MetadataFloat ().push_back (r);
      continue;
    }

    // MetadataInteger
    //
    if (n.name () == "MetadataInteger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataInteger_type > r (
        MetadataInteger_traits::create (i, f, this));

      this->MetadataInteger ().push_back (r);
      continue;
    }

    // MetadataSet
    //
    if (n.name () == "MetadataSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataSet_type > r (
        MetadataSet_traits::create (i, f, this));

      this->MetadataSet ().push_back (r);
      continue;
    }

    // MetadataString
    //
    if (n.name () == "MetadataString" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataString_type > r (
        MetadataString_traits::create (i, f, this));

      this->MetadataString ().push_back (r);
      continue;
    }

    // Appearance
    //
    if (n.name () == "Appearance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Appearance_type > r (
        Appearance_traits::create (i, f, this));

      this->Appearance ().push_back (r);
      continue;
    }

    // Background
    //
    if (n.name () == "Background" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Background_type > r (
        Background_traits::create (i, f, this));

      this->Background ().push_back (r);
      continue;
    }

    // ColorInterpolator
    //
    if (n.name () == "ColorInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ColorInterpolator_type > r (
        ColorInterpolator_traits::create (i, f, this));

      this->ColorInterpolator ().push_back (r);
      continue;
    }

    // CoordinateInterpolator
    //
    if (n.name () == "CoordinateInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateInterpolator_type > r (
        CoordinateInterpolator_traits::create (i, f, this));

      this->CoordinateInterpolator ().push_back (r);
      continue;
    }

    // DirectionalLight
    //
    if (n.name () == "DirectionalLight" && n.namespace_ () == "")
    {
      ::std::auto_ptr< DirectionalLight_type > r (
        DirectionalLight_traits::create (i, f, this));

      this->DirectionalLight ().push_back (r);
      continue;
    }

    // Group
    //
    if (n.name () == "Group" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Group_type > r (
        Group_traits::create (i, f, this));

      this->Group ().push_back (r);
      continue;
    }

    // NavigationInfo
    //
    if (n.name () == "NavigationInfo" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NavigationInfo_type > r (
        NavigationInfo_traits::create (i, f, this));

      this->NavigationInfo ().push_back (r);
      continue;
    }

    // NormalInterpolator
    //
    if (n.name () == "NormalInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NormalInterpolator_type > r (
        NormalInterpolator_traits::create (i, f, this));

      this->NormalInterpolator ().push_back (r);
      continue;
    }

    // OrientationInterpolator
    //
    if (n.name () == "OrientationInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< OrientationInterpolator_type > r (
        OrientationInterpolator_traits::create (i, f, this));

      this->OrientationInterpolator ().push_back (r);
      continue;
    }

    // PositionInterpolator
    //
    if (n.name () == "PositionInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PositionInterpolator_type > r (
        PositionInterpolator_traits::create (i, f, this));

      this->PositionInterpolator ().push_back (r);
      continue;
    }

    // ScalarInterpolator
    //
    if (n.name () == "ScalarInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ScalarInterpolator_type > r (
        ScalarInterpolator_traits::create (i, f, this));

      this->ScalarInterpolator ().push_back (r);
      continue;
    }

    // Shape
    //
    if (n.name () == "Shape" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Shape_type > r (
        Shape_traits::create (i, f, this));

      this->Shape ().push_back (r);
      continue;
    }

    // TimeSensor
    //
    if (n.name () == "TimeSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TimeSensor_type > r (
        TimeSensor_traits::create (i, f, this));

      this->TimeSensor ().push_back (r);
      continue;
    }

    // Transform
    //
    if (n.name () == "Transform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Transform_type > r (
        Transform_traits::create (i, f, this));

      this->Transform ().push_back (r);
      continue;
    }

    // Viewpoint
    //
    if (n.name () == "Viewpoint" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Viewpoint_type > r (
        Viewpoint_traits::create (i, f, this));

      this->Viewpoint ().push_back (r);
      continue;
    }

    // WorldInfo
    //
    if (n.name () == "WorldInfo" && n.namespace_ () == "")
    {
      ::std::auto_ptr< WorldInfo_type > r (
        WorldInfo_traits::create (i, f, this));

      this->WorldInfo ().push_back (r);
      continue;
    }

    // Anchor
    //
    if (n.name () == "Anchor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Anchor_type > r (
        Anchor_traits::create (i, f, this));

      this->Anchor ().push_back (r);
      continue;
    }

    // BooleanFilter
    //
    if (n.name () == "BooleanFilter" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanFilter_type > r (
        BooleanFilter_traits::create (i, f, this));

      this->BooleanFilter ().push_back (r);
      continue;
    }

    // BooleanSequencer
    //
    if (n.name () == "BooleanSequencer" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanSequencer_type > r (
        BooleanSequencer_traits::create (i, f, this));

      this->BooleanSequencer ().push_back (r);
      continue;
    }

    // BooleanToggle
    //
    if (n.name () == "BooleanToggle" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanToggle_type > r (
        BooleanToggle_traits::create (i, f, this));

      this->BooleanToggle ().push_back (r);
      continue;
    }

    // BooleanTrigger
    //
    if (n.name () == "BooleanTrigger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanTrigger_type > r (
        BooleanTrigger_traits::create (i, f, this));

      this->BooleanTrigger ().push_back (r);
      continue;
    }

    // CylinderSensor
    //
    if (n.name () == "CylinderSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CylinderSensor_type > r (
        CylinderSensor_traits::create (i, f, this));

      this->CylinderSensor ().push_back (r);
      continue;
    }

    // Inline
    //
    if (n.name () == "Inline" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Inline_type > r (
        Inline_traits::create (i, f, this));

      this->Inline ().push_back (r);
      continue;
    }

    // IntegerSequencer
    //
    if (n.name () == "IntegerSequencer" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IntegerSequencer_type > r (
        IntegerSequencer_traits::create (i, f, this));

      this->IntegerSequencer ().push_back (r);
      continue;
    }

    // IntegerTrigger
    //
    if (n.name () == "IntegerTrigger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IntegerTrigger_type > r (
        IntegerTrigger_traits::create (i, f, this));

      this->IntegerTrigger ().push_back (r);
      continue;
    }

    // KeySensor
    //
    if (n.name () == "KeySensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< KeySensor_type > r (
        KeySensor_traits::create (i, f, this));

      this->KeySensor ().push_back (r);
      continue;
    }

    // PlaneSensor
    //
    if (n.name () == "PlaneSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PlaneSensor_type > r (
        PlaneSensor_traits::create (i, f, this));

      this->PlaneSensor ().push_back (r);
      continue;
    }

    // PointLight
    //
    if (n.name () == "PointLight" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PointLight_type > r (
        PointLight_traits::create (i, f, this));

      this->PointLight ().push_back (r);
      continue;
    }

    // ProximitySensor
    //
    if (n.name () == "ProximitySensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProximitySensor_type > r (
        ProximitySensor_traits::create (i, f, this));

      this->ProximitySensor ().push_back (r);
      continue;
    }

    // SphereSensor
    //
    if (n.name () == "SphereSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< SphereSensor_type > r (
        SphereSensor_traits::create (i, f, this));

      this->SphereSensor ().push_back (r);
      continue;
    }

    // SpotLight
    //
    if (n.name () == "SpotLight" && n.namespace_ () == "")
    {
      ::std::auto_ptr< SpotLight_type > r (
        SpotLight_traits::create (i, f, this));

      this->SpotLight ().push_back (r);
      continue;
    }

    // StringSensor
    //
    if (n.name () == "StringSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< StringSensor_type > r (
        StringSensor_traits::create (i, f, this));

      this->StringSensor ().push_back (r);
      continue;
    }

    // Switch
    //
    if (n.name () == "Switch" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Switch_type > r (
        Switch_traits::create (i, f, this));

      this->Switch ().push_back (r);
      continue;
    }

    // TimeTrigger
    //
    if (n.name () == "TimeTrigger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TimeTrigger_type > r (
        TimeTrigger_traits::create (i, f, this));

      this->TimeTrigger ().push_back (r);
      continue;
    }

    // TouchSensor
    //
    if (n.name () == "TouchSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TouchSensor_type > r (
        TouchSensor_traits::create (i, f, this));

      this->TouchSensor ().push_back (r);
      continue;
    }

    // AudioClip
    //
    if (n.name () == "AudioClip" && n.namespace_ () == "")
    {
      ::std::auto_ptr< AudioClip_type > r (
        AudioClip_traits::create (i, f, this));

      this->AudioClip ().push_back (r);
      continue;
    }

    // Billboard
    //
    if (n.name () == "Billboard" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Billboard_type > r (
        Billboard_traits::create (i, f, this));

      this->Billboard ().push_back (r);
      continue;
    }

    // Collision
    //
    if (n.name () == "Collision" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Collision_type > r (
        Collision_traits::create (i, f, this));

      this->Collision ().push_back (r);
      continue;
    }

    // Fog
    //
    if (n.name () == "Fog" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Fog_type > r (
        Fog_traits::create (i, f, this));

      this->Fog ().push_back (r);
      continue;
    }

    // LoadSensor
    //
    if (n.name () == "LoadSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LoadSensor_type > r (
        LoadSensor_traits::create (i, f, this));

      this->LoadSensor ().push_back (r);
      continue;
    }

    // LocalFog
    //
    if (n.name () == "LocalFog" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LocalFog_type > r (
        LocalFog_traits::create (i, f, this));

      this->LocalFog ().push_back (r);
      continue;
    }

    // LOD
    //
    if (n.name () == "LOD" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LOD_type > r (
        LOD_traits::create (i, f, this));

      this->LOD ().push_back (r);
      continue;
    }

    // Script
    //
    if (n.name () == "Script" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Script_type > r (
        Script_traits::create (i, f, this));

      this->Script ().push_back (r);
      continue;
    }

    // Sound
    //
    if (n.name () == "Sound" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Sound_type > r (
        Sound_traits::create (i, f, this));

      this->Sound ().push_back (r);
      continue;
    }

    // VisibilitySensor
    //
    if (n.name () == "VisibilitySensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< VisibilitySensor_type > r (
        VisibilitySensor_traits::create (i, f, this));

      this->VisibilitySensor ().push_back (r);
      continue;
    }

    // CoordinateInterpolator2D
    //
    if (n.name () == "CoordinateInterpolator2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateInterpolator2D_type > r (
        CoordinateInterpolator2D_traits::create (i, f, this));

      this->CoordinateInterpolator2D ().push_back (r);
      continue;
    }

    // PositionInterpolator2D
    //
    if (n.name () == "PositionInterpolator2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PositionInterpolator2D_type > r (
        PositionInterpolator2D_traits::create (i, f, this));

      this->PositionInterpolator2D ().push_back (r);
      continue;
    }

    // StaticGroup
    //
    if (n.name () == "StaticGroup" && n.namespace_ () == "")
    {
      ::std::auto_ptr< StaticGroup_type > r (
        StaticGroup_traits::create (i, f, this));

      this->StaticGroup ().push_back (r);
      continue;
    }

    // CADAssembly
    //
    if (n.name () == "CADAssembly" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CADAssembly_type > r (
        CADAssembly_traits::create (i, f, this));

      this->CADAssembly ().push_back (r);
      continue;
    }

    // CADLayer
    //
    if (n.name () == "CADLayer" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CADLayer_type > r (
        CADLayer_traits::create (i, f, this));

      this->CADLayer ().push_back (r);
      continue;
    }

    // EspduTransform
    //
    if (n.name () == "EspduTransform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< EspduTransform_type > r (
        EspduTransform_traits::create (i, f, this));

      this->EspduTransform ().push_back (r);
      continue;
    }

    // ReceiverPdu
    //
    if (n.name () == "ReceiverPdu" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ReceiverPdu_type > r (
        ReceiverPdu_traits::create (i, f, this));

      this->ReceiverPdu ().push_back (r);
      continue;
    }

    // SignalPdu
    //
    if (n.name () == "SignalPdu" && n.namespace_ () == "")
    {
      ::std::auto_ptr< SignalPdu_type > r (
        SignalPdu_traits::create (i, f, this));

      this->SignalPdu ().push_back (r);
      continue;
    }

    // TransmitterPdu
    //
    if (n.name () == "TransmitterPdu" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TransmitterPdu_type > r (
        TransmitterPdu_traits::create (i, f, this));

      this->TransmitterPdu ().push_back (r);
      continue;
    }

    // GeoLocation
    //
    if (n.name () == "GeoLocation" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoLocation_type > r (
        GeoLocation_traits::create (i, f, this));

      this->GeoLocation ().push_back (r);
      continue;
    }

    // GeoLOD
    //
    if (n.name () == "GeoLOD" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoLOD_type > r (
        GeoLOD_traits::create (i, f, this));

      this->GeoLOD ().push_back (r);
      continue;
    }

    // GeoMetadata
    //
    if (n.name () == "GeoMetadata" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoMetadata_type > r (
        GeoMetadata_traits::create (i, f, this));

      this->GeoMetadata ().push_back (r);
      continue;
    }

    // GeoOrigin
    //
    if (n.name () == "GeoOrigin" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoOrigin_type > r (
        GeoOrigin_traits::create (i, f, this));

      this->GeoOrigin ().push_back (r);
      continue;
    }

    // GeoPositionInterpolator
    //
    if (n.name () == "GeoPositionInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoPositionInterpolator_type > r (
        GeoPositionInterpolator_traits::create (i, f, this));

      this->GeoPositionInterpolator ().push_back (r);
      continue;
    }

    // GeoTouchSensor
    //
    if (n.name () == "GeoTouchSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoTouchSensor_type > r (
        GeoTouchSensor_traits::create (i, f, this));

      this->GeoTouchSensor ().push_back (r);
      continue;
    }

    // GeoViewpoint
    //
    if (n.name () == "GeoViewpoint" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoViewpoint_type > r (
        GeoViewpoint_traits::create (i, f, this));

      this->GeoViewpoint ().push_back (r);
      continue;
    }

    // HAnimHumanoid
    //
    if (n.name () == "HAnimHumanoid" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimHumanoid_type > r (
        HAnimHumanoid_traits::create (i, f, this));

      this->HAnimHumanoid ().push_back (r);
      continue;
    }

    // HAnimJoint
    //
    if (n.name () == "HAnimJoint" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimJoint_type > r (
        HAnimJoint_traits::create (i, f, this));

      this->HAnimJoint ().push_back (r);
      continue;
    }

    // HAnimSegment
    //
    if (n.name () == "HAnimSegment" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimSegment_type > r (
        HAnimSegment_traits::create (i, f, this));

      this->HAnimSegment ().push_back (r);
      continue;
    }

    // HAnimSite
    //
    if (n.name () == "HAnimSite" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimSite_type > r (
        HAnimSite_traits::create (i, f, this));

      this->HAnimSite ().push_back (r);
      continue;
    }

    // NurbsOrientationInterpolator
    //
    if (n.name () == "NurbsOrientationInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsOrientationInterpolator_type > r (
        NurbsOrientationInterpolator_traits::create (i, f, this));

      this->NurbsOrientationInterpolator ().push_back (r);
      continue;
    }

    // NurbsPositionInterpolator
    //
    if (n.name () == "NurbsPositionInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsPositionInterpolator_type > r (
        NurbsPositionInterpolator_traits::create (i, f, this));

      this->NurbsPositionInterpolator ().push_back (r);
      continue;
    }

    // NurbsSurfaceInterpolator
    //
    if (n.name () == "NurbsSurfaceInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSurfaceInterpolator_type > r (
        NurbsSurfaceInterpolator_traits::create (i, f, this));

      this->NurbsSurfaceInterpolator ().push_back (r);
      continue;
    }

    // NurbsSet
    //
    if (n.name () == "NurbsSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSet_type > r (
        NurbsSet_traits::create (i, f, this));

      this->NurbsSet ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    // Box
    //
    if (n.name () == "Box" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Box_type > r (
        Box_traits::create (i, f, this));

      this->Box ().push_back (r);
      continue;
    }

    // Cone
    //
    if (n.name () == "Cone" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Cone_type > r (
        Cone_traits::create (i, f, this));

      this->Cone ().push_back (r);
      continue;
    }

    // Cylinder
    //
    if (n.name () == "Cylinder" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Cylinder_type > r (
        Cylinder_traits::create (i, f, this));

      this->Cylinder ().push_back (r);
      continue;
    }

    // IndexedFaceSet
    //
    if (n.name () == "IndexedFaceSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedFaceSet_type > r (
        IndexedFaceSet_traits::create (i, f, this));

      this->IndexedFaceSet ().push_back (r);
      continue;
    }

    // IndexedLineSet
    //
    if (n.name () == "IndexedLineSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedLineSet_type > r (
        IndexedLineSet_traits::create (i, f, this));

      this->IndexedLineSet ().push_back (r);
      continue;
    }

    // IndexedTriangleFanSet
    //
    if (n.name () == "IndexedTriangleFanSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedTriangleFanSet_type > r (
        IndexedTriangleFanSet_traits::create (i, f, this));

      this->IndexedTriangleFanSet ().push_back (r);
      continue;
    }

    // IndexedTriangleSet
    //
    if (n.name () == "IndexedTriangleSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedTriangleSet_type > r (
        IndexedTriangleSet_traits::create (i, f, this));

      this->IndexedTriangleSet ().push_back (r);
      continue;
    }

    // IndexedTriangleStripSet
    //
    if (n.name () == "IndexedTriangleStripSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedTriangleStripSet_type > r (
        IndexedTriangleStripSet_traits::create (i, f, this));

      this->IndexedTriangleStripSet ().push_back (r);
      continue;
    }

    // LineSet
    //
    if (n.name () == "LineSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LineSet_type > r (
        LineSet_traits::create (i, f, this));

      this->LineSet ().push_back (r);
      continue;
    }

    // PointSet
    //
    if (n.name () == "PointSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PointSet_type > r (
        PointSet_traits::create (i, f, this));

      this->PointSet ().push_back (r);
      continue;
    }

    // Sphere
    //
    if (n.name () == "Sphere" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Sphere_type > r (
        Sphere_traits::create (i, f, this));

      this->Sphere ().push_back (r);
      continue;
    }

    // TriangleFanSet
    //
    if (n.name () == "TriangleFanSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TriangleFanSet_type > r (
        TriangleFanSet_traits::create (i, f, this));

      this->TriangleFanSet ().push_back (r);
      continue;
    }

    // TriangleSet
    //
    if (n.name () == "TriangleSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TriangleSet_type > r (
        TriangleSet_traits::create (i, f, this));

      this->TriangleSet ().push_back (r);
      continue;
    }

    // TriangleStripSet
    //
    if (n.name () == "TriangleStripSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TriangleStripSet_type > r (
        TriangleStripSet_traits::create (i, f, this));

      this->TriangleStripSet ().push_back (r);
      continue;
    }

    // ElevationGrid
    //
    if (n.name () == "ElevationGrid" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ElevationGrid_type > r (
        ElevationGrid_traits::create (i, f, this));

      this->ElevationGrid ().push_back (r);
      continue;
    }

    // Polyline2D
    //
    if (n.name () == "Polyline2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Polyline2D_type > r (
        Polyline2D_traits::create (i, f, this));

      this->Polyline2D ().push_back (r);
      continue;
    }

    // Polypoint2D
    //
    if (n.name () == "Polypoint2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Polypoint2D_type > r (
        Polypoint2D_traits::create (i, f, this));

      this->Polypoint2D ().push_back (r);
      continue;
    }

    // Rectangle2D
    //
    if (n.name () == "Rectangle2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Rectangle2D_type > r (
        Rectangle2D_traits::create (i, f, this));

      this->Rectangle2D ().push_back (r);
      continue;
    }

    // TriangleSet2D
    //
    if (n.name () == "TriangleSet2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TriangleSet2D_type > r (
        TriangleSet2D_traits::create (i, f, this));

      this->TriangleSet2D ().push_back (r);
      continue;
    }

    // Extrusion
    //
    if (n.name () == "Extrusion" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Extrusion_type > r (
        Extrusion_traits::create (i, f, this));

      this->Extrusion ().push_back (r);
      continue;
    }

    // Text
    //
    if (n.name () == "Text" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Text_type > r (
        Text_traits::create (i, f, this));

      this->Text ().push_back (r);
      continue;
    }

    // Arc2D
    //
    if (n.name () == "Arc2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Arc2D_type > r (
        Arc2D_traits::create (i, f, this));

      this->Arc2D ().push_back (r);
      continue;
    }

    // ArcClose2D
    //
    if (n.name () == "ArcClose2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ArcClose2D_type > r (
        ArcClose2D_traits::create (i, f, this));

      this->ArcClose2D ().push_back (r);
      continue;
    }

    // Circle2D
    //
    if (n.name () == "Circle2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Circle2D_type > r (
        Circle2D_traits::create (i, f, this));

      this->Circle2D ().push_back (r);
      continue;
    }

    // Disk2D
    //
    if (n.name () == "Disk2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Disk2D_type > r (
        Disk2D_traits::create (i, f, this));

      this->Disk2D ().push_back (r);
      continue;
    }

    // QuadSet
    //
    if (n.name () == "QuadSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< QuadSet_type > r (
        QuadSet_traits::create (i, f, this));

      this->QuadSet ().push_back (r);
      continue;
    }

    // IndexedQuadSet
    //
    if (n.name () == "IndexedQuadSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IndexedQuadSet_type > r (
        IndexedQuadSet_traits::create (i, f, this));

      this->IndexedQuadSet ().push_back (r);
      continue;
    }

    // GeoElevationGrid
    //
    if (n.name () == "GeoElevationGrid" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoElevationGrid_type > r (
        GeoElevationGrid_traits::create (i, f, this));

      this->GeoElevationGrid ().push_back (r);
      continue;
    }

    // NurbsCurve
    //
    if (n.name () == "NurbsCurve" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsCurve_type > r (
        NurbsCurve_traits::create (i, f, this));

      this->NurbsCurve ().push_back (r);
      continue;
    }

    // NurbsCurve2D
    //
    if (n.name () == "NurbsCurve2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsCurve2D_type > r (
        NurbsCurve2D_traits::create (i, f, this));

      this->NurbsCurve2D ().push_back (r);
      continue;
    }

    // NurbsPatchSurface
    //
    if (n.name () == "NurbsPatchSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsPatchSurface_type > r (
        NurbsPatchSurface_traits::create (i, f, this));

      this->NurbsPatchSurface ().push_back (r);
      continue;
    }

    // NurbsSweptSurface
    //
    if (n.name () == "NurbsSweptSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSweptSurface_type > r (
        NurbsSweptSurface_traits::create (i, f, this));

      this->NurbsSweptSurface ().push_back (r);
      continue;
    }

    // NurbsSwungSurface
    //
    if (n.name () == "NurbsSwungSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSwungSurface_type > r (
        NurbsSwungSurface_traits::create (i, f, this));

      this->NurbsSwungSurface ().push_back (r);
      continue;
    }

    // NurbsTrimmedSurface
    //
    if (n.name () == "NurbsTrimmedSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsTrimmedSurface_type > r (
        NurbsTrimmedSurface_traits::create (i, f, this));

      this->NurbsTrimmedSurface ().push_back (r);
      continue;
    }

    // Color
    //
    if (n.name () == "Color" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Color_type > r (
        Color_traits::create (i, f, this));

      this->Color ().push_back (r);
      continue;
    }

    // ColorRGBA
    //
    if (n.name () == "ColorRGBA" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ColorRGBA_type > r (
        ColorRGBA_traits::create (i, f, this));

      this->ColorRGBA ().push_back (r);
      continue;
    }

    // Coordinate
    //
    if (n.name () == "Coordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Coordinate_type > r (
        Coordinate_traits::create (i, f, this));

      this->Coordinate ().push_back (r);
      continue;
    }

    // CoordinateDouble
    //
    if (n.name () == "CoordinateDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateDouble_type > r (
        CoordinateDouble_traits::create (i, f, this));

      this->CoordinateDouble ().push_back (r);
      continue;
    }

    // FontStyle
    //
    if (n.name () == "FontStyle" && n.namespace_ () == "")
    {
      ::std::auto_ptr< FontStyle_type > r (
        FontStyle_traits::create (i, f, this));

      this->FontStyle ().push_back (r);
      continue;
    }

    // GeoCoordinate
    //
    if (n.name () == "GeoCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoCoordinate_type > r (
        GeoCoordinate_traits::create (i, f, this));

      this->GeoCoordinate ().push_back (r);
      continue;
    }

    // Normal
    //
    if (n.name () == "Normal" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Normal_type > r (
        Normal_traits::create (i, f, this));

      this->Normal ().push_back (r);
      continue;
    }

    // TextureCoordinate
    //
    if (n.name () == "TextureCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureCoordinate_type > r (
        TextureCoordinate_traits::create (i, f, this));

      this->TextureCoordinate ().push_back (r);
      continue;
    }

    // NurbsTextureCoordinate
    //
    if (n.name () == "NurbsTextureCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsTextureCoordinate_type > r (
        NurbsTextureCoordinate_traits::create (i, f, this));

      this->NurbsTextureCoordinate ().push_back (r);
      continue;
    }

    // ROUTE
    //
    if (n.name () == "ROUTE" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ROUTE_type > r (
        ROUTE_traits::create (i, f, this));

      this->ROUTE ().push_back (r);
      continue;
    }

    // ExternProtoDeclare
    //
    if (n.name () == "ExternProtoDeclare" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ExternProtoDeclare_type > r (
        ExternProtoDeclare_traits::create (i, f, this));

      this->ExternProtoDeclare ().push_back (r);
      continue;
    }

    // ProtoDeclare
    //
    if (n.name () == "ProtoDeclare" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoDeclare_type > r (
        ProtoDeclare_traits::create (i, f, this));

      this->ProtoDeclare ().push_back (r);
      continue;
    }

    // IMPORT
    //
    if (n.name () == "IMPORT" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IMPORT_type > r (
        IMPORT_traits::create (i, f, this));

      this->IMPORT ().push_back (r);
      continue;
    }

    // EXPORT
    //
    if (n.name () == "EXPORT" && n.namespace_ () == "")
    {
      ::std::auto_ptr< EXPORT_type > r (
        EXPORT_traits::create (i, f, this));

      this->EXPORT ().push_back (r);
      continue;
    }

    break;
  }
}

ProtoBody* ProtoBody::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ProtoBody (*this, f, c);
}

ProtoBody::
~ProtoBody ()
{
}

// ProtoInstance
//

const ProtoInstance::containerField_type ProtoInstance::containerField_default_value_ (
  ::std::string ("children"), 0, 0, 0);

ProtoInstance::
ProtoInstance (const name_type& name)
: ::X3DPrototype (name),
  fieldValue_ (::xml_schema::flags (), this),
  IS_ (::xml_schema::flags (), this),
  DEF_ (::xml_schema::flags (), this),
  USE_ (::xml_schema::flags (), this),
  class__ (::xml_schema::flags (), this),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

ProtoInstance::
ProtoInstance (const ProtoInstance& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DPrototype (x, f, c),
  fieldValue_ (x.fieldValue_, f, this),
  IS_ (x.IS_, f, this),
  DEF_ (x.DEF_, f, this),
  USE_ (x.USE_, f, this),
  class__ (x.class__, f, this),
  containerField_ (x.containerField_, f, this)
{
}

ProtoInstance::
ProtoInstance (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DPrototype (e, f | ::xml_schema::flags::base, c),
  fieldValue_ (f, this),
  IS_ (f, this),
  DEF_ (f, this),
  USE_ (f, this),
  class__ (f, this),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ProtoInstance::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DPrototype::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // fieldValue
    //
    if (n.name () == "fieldValue" && n.namespace_ () == "")
    {
      ::std::auto_ptr< fieldValue_type > r (
        fieldValue_traits::create (i, f, this));

      this->fieldValue ().push_back (r);
      continue;
    }

    // IS
    //
    if (n.name () == "IS" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IS_type > r (
        IS_traits::create (i, f, this));

      this->IS ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "DEF" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DEF_type > r (
        DEF_traits::create (i, f, this));

      this->DEF (r);
      continue;
    }

    if (n.name () == "USE" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< USE_type > r (
        USE_traits::create (i, f, this));

      this->USE (r);
      continue;
    }

    if (n.name () == "class" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< class_type > r (
        class_traits::create (i, f, this));

      this->class_ (r);
      continue;
    }

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("children"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

ProtoInstance* ProtoInstance::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ProtoInstance (*this, f, c);
}

ProtoInstance::
~ProtoInstance ()
{
}

// ROUTE
//

ROUTE::
ROUTE (const fromNode_type& fromNode,
       const fromField_type& fromField,
       const toNode_type& toNode,
       const toField_type& toField)
: ::SceneGraphStructureNodeType (),
  fromNode_ (fromNode, ::xml_schema::flags (), this),
  fromField_ (fromField, ::xml_schema::flags (), this),
  toNode_ (toNode, ::xml_schema::flags (), this),
  toField_ (toField, ::xml_schema::flags (), this)
{
}

ROUTE::
ROUTE (const ROUTE& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (x, f, c),
  fromNode_ (x.fromNode_, f, this),
  fromField_ (x.fromField_, f, this),
  toNode_ (x.toNode_, f, this),
  toField_ (x.toField_, f, this)
{
}

ROUTE::
ROUTE (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (e, f | ::xml_schema::flags::base, c),
  fromNode_ (f, this),
  fromField_ (f, this),
  toNode_ (f, this),
  toField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ROUTE::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "fromNode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< fromNode_type > r (
        fromNode_traits::create (i, f, this));

      this->fromNode (r);
      continue;
    }

    if (n.name () == "fromField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< fromField_type > r (
        fromField_traits::create (i, f, this));

      this->fromField (r);
      continue;
    }

    if (n.name () == "toNode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< toNode_type > r (
        toNode_traits::create (i, f, this));

      this->toNode (r);
      continue;
    }

    if (n.name () == "toField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< toField_type > r (
        toField_traits::create (i, f, this));

      this->toField (r);
      continue;
    }
  }

  if (!fromNode_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "fromNode",
      "");
  }

  if (!fromField_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "fromField",
      "");
  }

  if (!toNode_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "toNode",
      "");
  }

  if (!toField_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "toField",
      "");
  }
}

ROUTE* ROUTE::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ROUTE (*this, f, c);
}

ROUTE::
~ROUTE ()
{
}

// Scene
//

Scene::
Scene ()
: ::SceneGraphStructureNodeType (),
  MetadataDouble_ (::xml_schema::flags (), this),
  MetadataFloat_ (::xml_schema::flags (), this),
  MetadataInteger_ (::xml_schema::flags (), this),
  MetadataSet_ (::xml_schema::flags (), this),
  MetadataString_ (::xml_schema::flags (), this),
  Appearance_ (::xml_schema::flags (), this),
  Background_ (::xml_schema::flags (), this),
  ColorInterpolator_ (::xml_schema::flags (), this),
  CoordinateInterpolator_ (::xml_schema::flags (), this),
  DirectionalLight_ (::xml_schema::flags (), this),
  Group_ (::xml_schema::flags (), this),
  NavigationInfo_ (::xml_schema::flags (), this),
  NormalInterpolator_ (::xml_schema::flags (), this),
  OrientationInterpolator_ (::xml_schema::flags (), this),
  PositionInterpolator_ (::xml_schema::flags (), this),
  ScalarInterpolator_ (::xml_schema::flags (), this),
  Shape_ (::xml_schema::flags (), this),
  TimeSensor_ (::xml_schema::flags (), this),
  Transform_ (::xml_schema::flags (), this),
  Viewpoint_ (::xml_schema::flags (), this),
  WorldInfo_ (::xml_schema::flags (), this),
  Anchor_ (::xml_schema::flags (), this),
  BooleanFilter_ (::xml_schema::flags (), this),
  BooleanSequencer_ (::xml_schema::flags (), this),
  BooleanToggle_ (::xml_schema::flags (), this),
  BooleanTrigger_ (::xml_schema::flags (), this),
  CylinderSensor_ (::xml_schema::flags (), this),
  Inline_ (::xml_schema::flags (), this),
  IntegerSequencer_ (::xml_schema::flags (), this),
  IntegerTrigger_ (::xml_schema::flags (), this),
  KeySensor_ (::xml_schema::flags (), this),
  PlaneSensor_ (::xml_schema::flags (), this),
  PointLight_ (::xml_schema::flags (), this),
  ProximitySensor_ (::xml_schema::flags (), this),
  SphereSensor_ (::xml_schema::flags (), this),
  SpotLight_ (::xml_schema::flags (), this),
  StringSensor_ (::xml_schema::flags (), this),
  Switch_ (::xml_schema::flags (), this),
  TimeTrigger_ (::xml_schema::flags (), this),
  TouchSensor_ (::xml_schema::flags (), this),
  AudioClip_ (::xml_schema::flags (), this),
  Billboard_ (::xml_schema::flags (), this),
  Collision_ (::xml_schema::flags (), this),
  Fog_ (::xml_schema::flags (), this),
  LoadSensor_ (::xml_schema::flags (), this),
  LocalFog_ (::xml_schema::flags (), this),
  LOD_ (::xml_schema::flags (), this),
  Script_ (::xml_schema::flags (), this),
  Sound_ (::xml_schema::flags (), this),
  VisibilitySensor_ (::xml_schema::flags (), this),
  CoordinateInterpolator2D_ (::xml_schema::flags (), this),
  PositionInterpolator2D_ (::xml_schema::flags (), this),
  StaticGroup_ (::xml_schema::flags (), this),
  CADAssembly_ (::xml_schema::flags (), this),
  CADLayer_ (::xml_schema::flags (), this),
  EspduTransform_ (::xml_schema::flags (), this),
  ReceiverPdu_ (::xml_schema::flags (), this),
  SignalPdu_ (::xml_schema::flags (), this),
  TransmitterPdu_ (::xml_schema::flags (), this),
  GeoLocation_ (::xml_schema::flags (), this),
  GeoLOD_ (::xml_schema::flags (), this),
  GeoMetadata_ (::xml_schema::flags (), this),
  GeoOrigin_ (::xml_schema::flags (), this),
  GeoPositionInterpolator_ (::xml_schema::flags (), this),
  GeoTouchSensor_ (::xml_schema::flags (), this),
  GeoViewpoint_ (::xml_schema::flags (), this),
  HAnimHumanoid_ (::xml_schema::flags (), this),
  HAnimJoint_ (::xml_schema::flags (), this),
  HAnimSegment_ (::xml_schema::flags (), this),
  HAnimSite_ (::xml_schema::flags (), this),
  NurbsOrientationInterpolator_ (::xml_schema::flags (), this),
  NurbsPositionInterpolator_ (::xml_schema::flags (), this),
  NurbsSurfaceInterpolator_ (::xml_schema::flags (), this),
  NurbsSet_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  ROUTE_ (::xml_schema::flags (), this),
  ExternProtoDeclare_ (::xml_schema::flags (), this),
  ProtoDeclare_ (::xml_schema::flags (), this),
  IMPORT_ (::xml_schema::flags (), this),
  EXPORT_ (::xml_schema::flags (), this)
{
}

Scene::
Scene (const Scene& x,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (x, f, c),
  MetadataDouble_ (x.MetadataDouble_, f, this),
  MetadataFloat_ (x.MetadataFloat_, f, this),
  MetadataInteger_ (x.MetadataInteger_, f, this),
  MetadataSet_ (x.MetadataSet_, f, this),
  MetadataString_ (x.MetadataString_, f, this),
  Appearance_ (x.Appearance_, f, this),
  Background_ (x.Background_, f, this),
  ColorInterpolator_ (x.ColorInterpolator_, f, this),
  CoordinateInterpolator_ (x.CoordinateInterpolator_, f, this),
  DirectionalLight_ (x.DirectionalLight_, f, this),
  Group_ (x.Group_, f, this),
  NavigationInfo_ (x.NavigationInfo_, f, this),
  NormalInterpolator_ (x.NormalInterpolator_, f, this),
  OrientationInterpolator_ (x.OrientationInterpolator_, f, this),
  PositionInterpolator_ (x.PositionInterpolator_, f, this),
  ScalarInterpolator_ (x.ScalarInterpolator_, f, this),
  Shape_ (x.Shape_, f, this),
  TimeSensor_ (x.TimeSensor_, f, this),
  Transform_ (x.Transform_, f, this),
  Viewpoint_ (x.Viewpoint_, f, this),
  WorldInfo_ (x.WorldInfo_, f, this),
  Anchor_ (x.Anchor_, f, this),
  BooleanFilter_ (x.BooleanFilter_, f, this),
  BooleanSequencer_ (x.BooleanSequencer_, f, this),
  BooleanToggle_ (x.BooleanToggle_, f, this),
  BooleanTrigger_ (x.BooleanTrigger_, f, this),
  CylinderSensor_ (x.CylinderSensor_, f, this),
  Inline_ (x.Inline_, f, this),
  IntegerSequencer_ (x.IntegerSequencer_, f, this),
  IntegerTrigger_ (x.IntegerTrigger_, f, this),
  KeySensor_ (x.KeySensor_, f, this),
  PlaneSensor_ (x.PlaneSensor_, f, this),
  PointLight_ (x.PointLight_, f, this),
  ProximitySensor_ (x.ProximitySensor_, f, this),
  SphereSensor_ (x.SphereSensor_, f, this),
  SpotLight_ (x.SpotLight_, f, this),
  StringSensor_ (x.StringSensor_, f, this),
  Switch_ (x.Switch_, f, this),
  TimeTrigger_ (x.TimeTrigger_, f, this),
  TouchSensor_ (x.TouchSensor_, f, this),
  AudioClip_ (x.AudioClip_, f, this),
  Billboard_ (x.Billboard_, f, this),
  Collision_ (x.Collision_, f, this),
  Fog_ (x.Fog_, f, this),
  LoadSensor_ (x.LoadSensor_, f, this),
  LocalFog_ (x.LocalFog_, f, this),
  LOD_ (x.LOD_, f, this),
  Script_ (x.Script_, f, this),
  Sound_ (x.Sound_, f, this),
  VisibilitySensor_ (x.VisibilitySensor_, f, this),
  CoordinateInterpolator2D_ (x.CoordinateInterpolator2D_, f, this),
  PositionInterpolator2D_ (x.PositionInterpolator2D_, f, this),
  StaticGroup_ (x.StaticGroup_, f, this),
  CADAssembly_ (x.CADAssembly_, f, this),
  CADLayer_ (x.CADLayer_, f, this),
  EspduTransform_ (x.EspduTransform_, f, this),
  ReceiverPdu_ (x.ReceiverPdu_, f, this),
  SignalPdu_ (x.SignalPdu_, f, this),
  TransmitterPdu_ (x.TransmitterPdu_, f, this),
  GeoLocation_ (x.GeoLocation_, f, this),
  GeoLOD_ (x.GeoLOD_, f, this),
  GeoMetadata_ (x.GeoMetadata_, f, this),
  GeoOrigin_ (x.GeoOrigin_, f, this),
  GeoPositionInterpolator_ (x.GeoPositionInterpolator_, f, this),
  GeoTouchSensor_ (x.GeoTouchSensor_, f, this),
  GeoViewpoint_ (x.GeoViewpoint_, f, this),
  HAnimHumanoid_ (x.HAnimHumanoid_, f, this),
  HAnimJoint_ (x.HAnimJoint_, f, this),
  HAnimSegment_ (x.HAnimSegment_, f, this),
  HAnimSite_ (x.HAnimSite_, f, this),
  NurbsOrientationInterpolator_ (x.NurbsOrientationInterpolator_, f, this),
  NurbsPositionInterpolator_ (x.NurbsPositionInterpolator_, f, this),
  NurbsSurfaceInterpolator_ (x.NurbsSurfaceInterpolator_, f, this),
  NurbsSet_ (x.NurbsSet_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  ROUTE_ (x.ROUTE_, f, this),
  ExternProtoDeclare_ (x.ExternProtoDeclare_, f, this),
  ProtoDeclare_ (x.ProtoDeclare_, f, this),
  IMPORT_ (x.IMPORT_, f, this),
  EXPORT_ (x.EXPORT_, f, this)
{
}

Scene::
Scene (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (e, f | ::xml_schema::flags::base, c),
  MetadataDouble_ (f, this),
  MetadataFloat_ (f, this),
  MetadataInteger_ (f, this),
  MetadataSet_ (f, this),
  MetadataString_ (f, this),
  Appearance_ (f, this),
  Background_ (f, this),
  ColorInterpolator_ (f, this),
  CoordinateInterpolator_ (f, this),
  DirectionalLight_ (f, this),
  Group_ (f, this),
  NavigationInfo_ (f, this),
  NormalInterpolator_ (f, this),
  OrientationInterpolator_ (f, this),
  PositionInterpolator_ (f, this),
  ScalarInterpolator_ (f, this),
  Shape_ (f, this),
  TimeSensor_ (f, this),
  Transform_ (f, this),
  Viewpoint_ (f, this),
  WorldInfo_ (f, this),
  Anchor_ (f, this),
  BooleanFilter_ (f, this),
  BooleanSequencer_ (f, this),
  BooleanToggle_ (f, this),
  BooleanTrigger_ (f, this),
  CylinderSensor_ (f, this),
  Inline_ (f, this),
  IntegerSequencer_ (f, this),
  IntegerTrigger_ (f, this),
  KeySensor_ (f, this),
  PlaneSensor_ (f, this),
  PointLight_ (f, this),
  ProximitySensor_ (f, this),
  SphereSensor_ (f, this),
  SpotLight_ (f, this),
  StringSensor_ (f, this),
  Switch_ (f, this),
  TimeTrigger_ (f, this),
  TouchSensor_ (f, this),
  AudioClip_ (f, this),
  Billboard_ (f, this),
  Collision_ (f, this),
  Fog_ (f, this),
  LoadSensor_ (f, this),
  LocalFog_ (f, this),
  LOD_ (f, this),
  Script_ (f, this),
  Sound_ (f, this),
  VisibilitySensor_ (f, this),
  CoordinateInterpolator2D_ (f, this),
  PositionInterpolator2D_ (f, this),
  StaticGroup_ (f, this),
  CADAssembly_ (f, this),
  CADLayer_ (f, this),
  EspduTransform_ (f, this),
  ReceiverPdu_ (f, this),
  SignalPdu_ (f, this),
  TransmitterPdu_ (f, this),
  GeoLocation_ (f, this),
  GeoLOD_ (f, this),
  GeoMetadata_ (f, this),
  GeoOrigin_ (f, this),
  GeoPositionInterpolator_ (f, this),
  GeoTouchSensor_ (f, this),
  GeoViewpoint_ (f, this),
  HAnimHumanoid_ (f, this),
  HAnimJoint_ (f, this),
  HAnimSegment_ (f, this),
  HAnimSite_ (f, this),
  NurbsOrientationInterpolator_ (f, this),
  NurbsPositionInterpolator_ (f, this),
  NurbsSurfaceInterpolator_ (f, this),
  NurbsSet_ (f, this),
  ProtoInstance_ (f, this),
  ROUTE_ (f, this),
  ExternProtoDeclare_ (f, this),
  ProtoDeclare_ (f, this),
  IMPORT_ (f, this),
  EXPORT_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Scene::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // MetadataDouble
    //
    if (n.name () == "MetadataDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataDouble_type > r (
        MetadataDouble_traits::create (i, f, this));

      this->MetadataDouble ().push_back (r);
      continue;
    }

    // MetadataFloat
    //
    if (n.name () == "MetadataFloat" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataFloat_type > r (
        MetadataFloat_traits::create (i, f, this));

      this->MetadataFloat ().push_back (r);
      continue;
    }

    // MetadataInteger
    //
    if (n.name () == "MetadataInteger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataInteger_type > r (
        MetadataInteger_traits::create (i, f, this));

      this->MetadataInteger ().push_back (r);
      continue;
    }

    // MetadataSet
    //
    if (n.name () == "MetadataSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataSet_type > r (
        MetadataSet_traits::create (i, f, this));

      this->MetadataSet ().push_back (r);
      continue;
    }

    // MetadataString
    //
    if (n.name () == "MetadataString" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MetadataString_type > r (
        MetadataString_traits::create (i, f, this));

      this->MetadataString ().push_back (r);
      continue;
    }

    // Appearance
    //
    if (n.name () == "Appearance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Appearance_type > r (
        Appearance_traits::create (i, f, this));

      this->Appearance ().push_back (r);
      continue;
    }

    // Background
    //
    if (n.name () == "Background" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Background_type > r (
        Background_traits::create (i, f, this));

      this->Background ().push_back (r);
      continue;
    }

    // ColorInterpolator
    //
    if (n.name () == "ColorInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ColorInterpolator_type > r (
        ColorInterpolator_traits::create (i, f, this));

      this->ColorInterpolator ().push_back (r);
      continue;
    }

    // CoordinateInterpolator
    //
    if (n.name () == "CoordinateInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateInterpolator_type > r (
        CoordinateInterpolator_traits::create (i, f, this));

      this->CoordinateInterpolator ().push_back (r);
      continue;
    }

    // DirectionalLight
    //
    if (n.name () == "DirectionalLight" && n.namespace_ () == "")
    {
      ::std::auto_ptr< DirectionalLight_type > r (
        DirectionalLight_traits::create (i, f, this));

      this->DirectionalLight ().push_back (r);
      continue;
    }

    // Group
    //
    if (n.name () == "Group" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Group_type > r (
        Group_traits::create (i, f, this));

      this->Group ().push_back (r);
      continue;
    }

    // NavigationInfo
    //
    if (n.name () == "NavigationInfo" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NavigationInfo_type > r (
        NavigationInfo_traits::create (i, f, this));

      this->NavigationInfo ().push_back (r);
      continue;
    }

    // NormalInterpolator
    //
    if (n.name () == "NormalInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NormalInterpolator_type > r (
        NormalInterpolator_traits::create (i, f, this));

      this->NormalInterpolator ().push_back (r);
      continue;
    }

    // OrientationInterpolator
    //
    if (n.name () == "OrientationInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< OrientationInterpolator_type > r (
        OrientationInterpolator_traits::create (i, f, this));

      this->OrientationInterpolator ().push_back (r);
      continue;
    }

    // PositionInterpolator
    //
    if (n.name () == "PositionInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PositionInterpolator_type > r (
        PositionInterpolator_traits::create (i, f, this));

      this->PositionInterpolator ().push_back (r);
      continue;
    }

    // ScalarInterpolator
    //
    if (n.name () == "ScalarInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ScalarInterpolator_type > r (
        ScalarInterpolator_traits::create (i, f, this));

      this->ScalarInterpolator ().push_back (r);
      continue;
    }

    // Shape
    //
    if (n.name () == "Shape" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Shape_type > r (
        Shape_traits::create (i, f, this));

      this->Shape ().push_back (r);
      continue;
    }

    // TimeSensor
    //
    if (n.name () == "TimeSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TimeSensor_type > r (
        TimeSensor_traits::create (i, f, this));

      this->TimeSensor ().push_back (r);
      continue;
    }

    // Transform
    //
    if (n.name () == "Transform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Transform_type > r (
        Transform_traits::create (i, f, this));

      this->Transform ().push_back (r);
      continue;
    }

    // Viewpoint
    //
    if (n.name () == "Viewpoint" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Viewpoint_type > r (
        Viewpoint_traits::create (i, f, this));

      this->Viewpoint ().push_back (r);
      continue;
    }

    // WorldInfo
    //
    if (n.name () == "WorldInfo" && n.namespace_ () == "")
    {
      ::std::auto_ptr< WorldInfo_type > r (
        WorldInfo_traits::create (i, f, this));

      this->WorldInfo ().push_back (r);
      continue;
    }

    // Anchor
    //
    if (n.name () == "Anchor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Anchor_type > r (
        Anchor_traits::create (i, f, this));

      this->Anchor ().push_back (r);
      continue;
    }

    // BooleanFilter
    //
    if (n.name () == "BooleanFilter" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanFilter_type > r (
        BooleanFilter_traits::create (i, f, this));

      this->BooleanFilter ().push_back (r);
      continue;
    }

    // BooleanSequencer
    //
    if (n.name () == "BooleanSequencer" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanSequencer_type > r (
        BooleanSequencer_traits::create (i, f, this));

      this->BooleanSequencer ().push_back (r);
      continue;
    }

    // BooleanToggle
    //
    if (n.name () == "BooleanToggle" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanToggle_type > r (
        BooleanToggle_traits::create (i, f, this));

      this->BooleanToggle ().push_back (r);
      continue;
    }

    // BooleanTrigger
    //
    if (n.name () == "BooleanTrigger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanTrigger_type > r (
        BooleanTrigger_traits::create (i, f, this));

      this->BooleanTrigger ().push_back (r);
      continue;
    }

    // CylinderSensor
    //
    if (n.name () == "CylinderSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CylinderSensor_type > r (
        CylinderSensor_traits::create (i, f, this));

      this->CylinderSensor ().push_back (r);
      continue;
    }

    // Inline
    //
    if (n.name () == "Inline" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Inline_type > r (
        Inline_traits::create (i, f, this));

      this->Inline ().push_back (r);
      continue;
    }

    // IntegerSequencer
    //
    if (n.name () == "IntegerSequencer" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IntegerSequencer_type > r (
        IntegerSequencer_traits::create (i, f, this));

      this->IntegerSequencer ().push_back (r);
      continue;
    }

    // IntegerTrigger
    //
    if (n.name () == "IntegerTrigger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IntegerTrigger_type > r (
        IntegerTrigger_traits::create (i, f, this));

      this->IntegerTrigger ().push_back (r);
      continue;
    }

    // KeySensor
    //
    if (n.name () == "KeySensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< KeySensor_type > r (
        KeySensor_traits::create (i, f, this));

      this->KeySensor ().push_back (r);
      continue;
    }

    // PlaneSensor
    //
    if (n.name () == "PlaneSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PlaneSensor_type > r (
        PlaneSensor_traits::create (i, f, this));

      this->PlaneSensor ().push_back (r);
      continue;
    }

    // PointLight
    //
    if (n.name () == "PointLight" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PointLight_type > r (
        PointLight_traits::create (i, f, this));

      this->PointLight ().push_back (r);
      continue;
    }

    // ProximitySensor
    //
    if (n.name () == "ProximitySensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProximitySensor_type > r (
        ProximitySensor_traits::create (i, f, this));

      this->ProximitySensor ().push_back (r);
      continue;
    }

    // SphereSensor
    //
    if (n.name () == "SphereSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< SphereSensor_type > r (
        SphereSensor_traits::create (i, f, this));

      this->SphereSensor ().push_back (r);
      continue;
    }

    // SpotLight
    //
    if (n.name () == "SpotLight" && n.namespace_ () == "")
    {
      ::std::auto_ptr< SpotLight_type > r (
        SpotLight_traits::create (i, f, this));

      this->SpotLight ().push_back (r);
      continue;
    }

    // StringSensor
    //
    if (n.name () == "StringSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< StringSensor_type > r (
        StringSensor_traits::create (i, f, this));

      this->StringSensor ().push_back (r);
      continue;
    }

    // Switch
    //
    if (n.name () == "Switch" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Switch_type > r (
        Switch_traits::create (i, f, this));

      this->Switch ().push_back (r);
      continue;
    }

    // TimeTrigger
    //
    if (n.name () == "TimeTrigger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TimeTrigger_type > r (
        TimeTrigger_traits::create (i, f, this));

      this->TimeTrigger ().push_back (r);
      continue;
    }

    // TouchSensor
    //
    if (n.name () == "TouchSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TouchSensor_type > r (
        TouchSensor_traits::create (i, f, this));

      this->TouchSensor ().push_back (r);
      continue;
    }

    // AudioClip
    //
    if (n.name () == "AudioClip" && n.namespace_ () == "")
    {
      ::std::auto_ptr< AudioClip_type > r (
        AudioClip_traits::create (i, f, this));

      this->AudioClip ().push_back (r);
      continue;
    }

    // Billboard
    //
    if (n.name () == "Billboard" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Billboard_type > r (
        Billboard_traits::create (i, f, this));

      this->Billboard ().push_back (r);
      continue;
    }

    // Collision
    //
    if (n.name () == "Collision" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Collision_type > r (
        Collision_traits::create (i, f, this));

      this->Collision ().push_back (r);
      continue;
    }

    // Fog
    //
    if (n.name () == "Fog" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Fog_type > r (
        Fog_traits::create (i, f, this));

      this->Fog ().push_back (r);
      continue;
    }

    // LoadSensor
    //
    if (n.name () == "LoadSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LoadSensor_type > r (
        LoadSensor_traits::create (i, f, this));

      this->LoadSensor ().push_back (r);
      continue;
    }

    // LocalFog
    //
    if (n.name () == "LocalFog" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LocalFog_type > r (
        LocalFog_traits::create (i, f, this));

      this->LocalFog ().push_back (r);
      continue;
    }

    // LOD
    //
    if (n.name () == "LOD" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LOD_type > r (
        LOD_traits::create (i, f, this));

      this->LOD ().push_back (r);
      continue;
    }

    // Script
    //
    if (n.name () == "Script" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Script_type > r (
        Script_traits::create (i, f, this));

      this->Script ().push_back (r);
      continue;
    }

    // Sound
    //
    if (n.name () == "Sound" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Sound_type > r (
        Sound_traits::create (i, f, this));

      this->Sound ().push_back (r);
      continue;
    }

    // VisibilitySensor
    //
    if (n.name () == "VisibilitySensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< VisibilitySensor_type > r (
        VisibilitySensor_traits::create (i, f, this));

      this->VisibilitySensor ().push_back (r);
      continue;
    }

    // CoordinateInterpolator2D
    //
    if (n.name () == "CoordinateInterpolator2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateInterpolator2D_type > r (
        CoordinateInterpolator2D_traits::create (i, f, this));

      this->CoordinateInterpolator2D ().push_back (r);
      continue;
    }

    // PositionInterpolator2D
    //
    if (n.name () == "PositionInterpolator2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PositionInterpolator2D_type > r (
        PositionInterpolator2D_traits::create (i, f, this));

      this->PositionInterpolator2D ().push_back (r);
      continue;
    }

    // StaticGroup
    //
    if (n.name () == "StaticGroup" && n.namespace_ () == "")
    {
      ::std::auto_ptr< StaticGroup_type > r (
        StaticGroup_traits::create (i, f, this));

      this->StaticGroup ().push_back (r);
      continue;
    }

    // CADAssembly
    //
    if (n.name () == "CADAssembly" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CADAssembly_type > r (
        CADAssembly_traits::create (i, f, this));

      this->CADAssembly ().push_back (r);
      continue;
    }

    // CADLayer
    //
    if (n.name () == "CADLayer" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CADLayer_type > r (
        CADLayer_traits::create (i, f, this));

      this->CADLayer ().push_back (r);
      continue;
    }

    // EspduTransform
    //
    if (n.name () == "EspduTransform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< EspduTransform_type > r (
        EspduTransform_traits::create (i, f, this));

      this->EspduTransform ().push_back (r);
      continue;
    }

    // ReceiverPdu
    //
    if (n.name () == "ReceiverPdu" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ReceiverPdu_type > r (
        ReceiverPdu_traits::create (i, f, this));

      this->ReceiverPdu ().push_back (r);
      continue;
    }

    // SignalPdu
    //
    if (n.name () == "SignalPdu" && n.namespace_ () == "")
    {
      ::std::auto_ptr< SignalPdu_type > r (
        SignalPdu_traits::create (i, f, this));

      this->SignalPdu ().push_back (r);
      continue;
    }

    // TransmitterPdu
    //
    if (n.name () == "TransmitterPdu" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TransmitterPdu_type > r (
        TransmitterPdu_traits::create (i, f, this));

      this->TransmitterPdu ().push_back (r);
      continue;
    }

    // GeoLocation
    //
    if (n.name () == "GeoLocation" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoLocation_type > r (
        GeoLocation_traits::create (i, f, this));

      this->GeoLocation ().push_back (r);
      continue;
    }

    // GeoLOD
    //
    if (n.name () == "GeoLOD" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoLOD_type > r (
        GeoLOD_traits::create (i, f, this));

      this->GeoLOD ().push_back (r);
      continue;
    }

    // GeoMetadata
    //
    if (n.name () == "GeoMetadata" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoMetadata_type > r (
        GeoMetadata_traits::create (i, f, this));

      this->GeoMetadata ().push_back (r);
      continue;
    }

    // GeoOrigin
    //
    if (n.name () == "GeoOrigin" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoOrigin_type > r (
        GeoOrigin_traits::create (i, f, this));

      this->GeoOrigin ().push_back (r);
      continue;
    }

    // GeoPositionInterpolator
    //
    if (n.name () == "GeoPositionInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoPositionInterpolator_type > r (
        GeoPositionInterpolator_traits::create (i, f, this));

      this->GeoPositionInterpolator ().push_back (r);
      continue;
    }

    // GeoTouchSensor
    //
    if (n.name () == "GeoTouchSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoTouchSensor_type > r (
        GeoTouchSensor_traits::create (i, f, this));

      this->GeoTouchSensor ().push_back (r);
      continue;
    }

    // GeoViewpoint
    //
    if (n.name () == "GeoViewpoint" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoViewpoint_type > r (
        GeoViewpoint_traits::create (i, f, this));

      this->GeoViewpoint ().push_back (r);
      continue;
    }

    // HAnimHumanoid
    //
    if (n.name () == "HAnimHumanoid" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimHumanoid_type > r (
        HAnimHumanoid_traits::create (i, f, this));

      this->HAnimHumanoid ().push_back (r);
      continue;
    }

    // HAnimJoint
    //
    if (n.name () == "HAnimJoint" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimJoint_type > r (
        HAnimJoint_traits::create (i, f, this));

      this->HAnimJoint ().push_back (r);
      continue;
    }

    // HAnimSegment
    //
    if (n.name () == "HAnimSegment" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimSegment_type > r (
        HAnimSegment_traits::create (i, f, this));

      this->HAnimSegment ().push_back (r);
      continue;
    }

    // HAnimSite
    //
    if (n.name () == "HAnimSite" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimSite_type > r (
        HAnimSite_traits::create (i, f, this));

      this->HAnimSite ().push_back (r);
      continue;
    }

    // NurbsOrientationInterpolator
    //
    if (n.name () == "NurbsOrientationInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsOrientationInterpolator_type > r (
        NurbsOrientationInterpolator_traits::create (i, f, this));

      this->NurbsOrientationInterpolator ().push_back (r);
      continue;
    }

    // NurbsPositionInterpolator
    //
    if (n.name () == "NurbsPositionInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsPositionInterpolator_type > r (
        NurbsPositionInterpolator_traits::create (i, f, this));

      this->NurbsPositionInterpolator ().push_back (r);
      continue;
    }

    // NurbsSurfaceInterpolator
    //
    if (n.name () == "NurbsSurfaceInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSurfaceInterpolator_type > r (
        NurbsSurfaceInterpolator_traits::create (i, f, this));

      this->NurbsSurfaceInterpolator ().push_back (r);
      continue;
    }

    // NurbsSet
    //
    if (n.name () == "NurbsSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSet_type > r (
        NurbsSet_traits::create (i, f, this));

      this->NurbsSet ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    // ROUTE
    //
    if (n.name () == "ROUTE" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ROUTE_type > r (
        ROUTE_traits::create (i, f, this));

      this->ROUTE ().push_back (r);
      continue;
    }

    // ExternProtoDeclare
    //
    if (n.name () == "ExternProtoDeclare" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ExternProtoDeclare_type > r (
        ExternProtoDeclare_traits::create (i, f, this));

      this->ExternProtoDeclare ().push_back (r);
      continue;
    }

    // ProtoDeclare
    //
    if (n.name () == "ProtoDeclare" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoDeclare_type > r (
        ProtoDeclare_traits::create (i, f, this));

      this->ProtoDeclare ().push_back (r);
      continue;
    }

    // IMPORT
    //
    if (n.name () == "IMPORT" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IMPORT_type > r (
        IMPORT_traits::create (i, f, this));

      this->IMPORT ().push_back (r);
      continue;
    }

    // EXPORT
    //
    if (n.name () == "EXPORT" && n.namespace_ () == "")
    {
      ::std::auto_ptr< EXPORT_type > r (
        EXPORT_traits::create (i, f, this));

      this->EXPORT ().push_back (r);
      continue;
    }

    break;
  }
}

Scene* Scene::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Scene (*this, f, c);
}

Scene::
~Scene ()
{
}

// X3D
//

X3D::
X3D (const Scene_type& Scene,
     const version_type& version,
     const profile_type& profile)
: ::SceneGraphStructureNodeType (),
  head_ (::xml_schema::flags (), this),
  Scene_ (Scene, ::xml_schema::flags (), this),
  version_ (version, ::xml_schema::flags (), this),
  profile_ (profile, ::xml_schema::flags (), this)
{
}

X3D::
X3D (const X3D& x,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (x, f, c),
  head_ (x.head_, f, this),
  Scene_ (x.Scene_, f, this),
  version_ (x.version_, f, this),
  profile_ (x.profile_, f, this)
{
}

X3D::
X3D (const ::xercesc::DOMElement& e,
     ::xml_schema::flags f,
     ::xml_schema::container* c)
: ::SceneGraphStructureNodeType (e, f | ::xml_schema::flags::base, c),
  head_ (f, this),
  Scene_ (f, this),
  version_ (f, this),
  profile_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void X3D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // head
    //
    if (n.name () == "head" && n.namespace_ () == "")
    {
      ::std::auto_ptr< head_type > r (
        head_traits::create (i, f, this));

      if (!this->head ())
      {
        this->head (r);
        continue;
      }
    }

    // Scene
    //
    if (n.name () == "Scene" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Scene_type > r (
        Scene_traits::create (i, f, this));

      if (!Scene_.present ())
      {
        this->Scene (r);
        continue;
      }
    }

    break;
  }

  if (!Scene_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "Scene",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "version" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< version_type > r (
        version_traits::create (i, f, this));

      this->version (r);
      continue;
    }

    if (n.name () == "profile" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< profile_type > r (
        profile_traits::create (i, f, this));

      this->profile (r);
      continue;
    }
  }

  if (!version_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "version",
      "");
  }

  if (!profile_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "profile",
      "");
  }
}

X3D* X3D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new X3D (*this, f, c);
}

X3D::
~X3D ()
{
}

// EspduTransform
//

const EspduTransform::enabled_type EspduTransform::enabled_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const EspduTransform::siteID_type EspduTransform::siteID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::applicationID_type EspduTransform::applicationID_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const EspduTransform::entityID_type EspduTransform::entityID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::forceID_type EspduTransform::forceID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::entityKind_type EspduTransform::entityKind_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::entityDomain_type EspduTransform::entityDomain_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::entityCountry_type EspduTransform::entityCountry_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::entityCategory_type EspduTransform::entityCategory_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::entitySubCategory_type EspduTransform::entitySubCategory_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::entitySpecific_type EspduTransform::entitySpecific_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::entityExtra_type EspduTransform::entityExtra_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::readInterval_type EspduTransform::readInterval_default_value_ (
  ::std::string ("0.1"), 0, 0, 0);

const EspduTransform::writeInterval_type EspduTransform::writeInterval_default_value_ (
  ::std::string ("1.0"), 0, 0, 0);

const EspduTransform::networkMode_type EspduTransform::networkMode_default_value_ (
  ::std::string ("standAlone"), 0, 0, 0);

const EspduTransform::translation_type EspduTransform::translation_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const EspduTransform::rotation_type EspduTransform::rotation_default_value_ (
  ::std::string ("0 0 1 0"), 0, 0, 0);

const EspduTransform::scale_type EspduTransform::scale_default_value_ (
  ::std::string ("1 1 1"), 0, 0, 0);

const EspduTransform::scaleOrientation_type EspduTransform::scaleOrientation_default_value_ (
  ::std::string ("0 0 1 0"), 0, 0, 0);

const EspduTransform::center_type EspduTransform::center_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const EspduTransform::address_type EspduTransform::address_default_value_ (
  ::std::string ("localhost"), 0, 0, 0);

const EspduTransform::port_type EspduTransform::port_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::multicastRelayPort_type EspduTransform::multicastRelayPort_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::rtpHeaderExpected_type EspduTransform::rtpHeaderExpected_default_value_ (
  ::std::string ("false"), 0, 0, 0);

const EspduTransform::deadReckoning_type EspduTransform::deadReckoning_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::linearVelocity_type EspduTransform::linearVelocity_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const EspduTransform::linearAcceleration_type EspduTransform::linearAcceleration_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const EspduTransform::fired1_type EspduTransform::fired1_default_value_ (
  ::std::string ("false"), 0, 0, 0);

const EspduTransform::fired2_type EspduTransform::fired2_default_value_ (
  ::std::string ("false"), 0, 0, 0);

const EspduTransform::collisionType_type EspduTransform::collisionType_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::detonationLocation_type EspduTransform::detonationLocation_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const EspduTransform::detonationRelativeLocation_type EspduTransform::detonationRelativeLocation_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const EspduTransform::detonationResult_type EspduTransform::detonationResult_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::eventApplicationID_type EspduTransform::eventApplicationID_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const EspduTransform::eventEntityID_type EspduTransform::eventEntityID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::eventNumber_type EspduTransform::eventNumber_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::eventSiteID_type EspduTransform::eventSiteID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::munitionStartPoint_type EspduTransform::munitionStartPoint_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const EspduTransform::munitionEndPoint_type EspduTransform::munitionEndPoint_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const EspduTransform::munitionSiteID_type EspduTransform::munitionSiteID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::munitionApplicationID_type EspduTransform::munitionApplicationID_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const EspduTransform::munitionEntityID_type EspduTransform::munitionEntityID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::fireMissionIndex_type EspduTransform::fireMissionIndex_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::warhead_type EspduTransform::warhead_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::fuse_type EspduTransform::fuse_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::munitionQuantity_type EspduTransform::munitionQuantity_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::firingRate_type EspduTransform::firingRate_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::firingRange_type EspduTransform::firingRange_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const EspduTransform::articulationParameterCount_type EspduTransform::articulationParameterCount_default_value_ (
  ::std::string ("0"), 0, 0, 0);

EspduTransform::
EspduTransform ()
: ::X3DGroupingNode (),
  enabled_ (enabled_default_value (), ::xml_schema::flags (), this),
  marking_ (::xml_schema::flags (), this),
  siteID_ (siteID_default_value (), ::xml_schema::flags (), this),
  applicationID_ (applicationID_default_value (), ::xml_schema::flags (), this),
  entityID_ (entityID_default_value (), ::xml_schema::flags (), this),
  forceID_ (forceID_default_value (), ::xml_schema::flags (), this),
  entityKind_ (entityKind_default_value (), ::xml_schema::flags (), this),
  entityDomain_ (entityDomain_default_value (), ::xml_schema::flags (), this),
  entityCountry_ (entityCountry_default_value (), ::xml_schema::flags (), this),
  entityCategory_ (entityCategory_default_value (), ::xml_schema::flags (), this),
  entitySubCategory_ (entitySubCategory_default_value (), ::xml_schema::flags (), this),
  entitySpecific_ (entitySpecific_default_value (), ::xml_schema::flags (), this),
  entityExtra_ (entityExtra_default_value (), ::xml_schema::flags (), this),
  readInterval_ (readInterval_default_value (), ::xml_schema::flags (), this),
  writeInterval_ (writeInterval_default_value (), ::xml_schema::flags (), this),
  networkMode_ (networkMode_default_value (), ::xml_schema::flags (), this),
  translation_ (translation_default_value (), ::xml_schema::flags (), this),
  rotation_ (rotation_default_value (), ::xml_schema::flags (), this),
  scale_ (scale_default_value (), ::xml_schema::flags (), this),
  scaleOrientation_ (scaleOrientation_default_value (), ::xml_schema::flags (), this),
  center_ (center_default_value (), ::xml_schema::flags (), this),
  address_ (address_default_value (), ::xml_schema::flags (), this),
  port_ (port_default_value (), ::xml_schema::flags (), this),
  multicastRelayHost_ (::xml_schema::flags (), this),
  multicastRelayPort_ (multicastRelayPort_default_value (), ::xml_schema::flags (), this),
  rtpHeaderExpected_ (rtpHeaderExpected_default_value (), ::xml_schema::flags (), this),
  deadReckoning_ (deadReckoning_default_value (), ::xml_schema::flags (), this),
  linearVelocity_ (linearVelocity_default_value (), ::xml_schema::flags (), this),
  linearAcceleration_ (linearAcceleration_default_value (), ::xml_schema::flags (), this),
  fired1_ (fired1_default_value (), ::xml_schema::flags (), this),
  fired2_ (fired2_default_value (), ::xml_schema::flags (), this),
  collisionType_ (collisionType_default_value (), ::xml_schema::flags (), this),
  detonationLocation_ (detonationLocation_default_value (), ::xml_schema::flags (), this),
  detonationRelativeLocation_ (detonationRelativeLocation_default_value (), ::xml_schema::flags (), this),
  detonationResult_ (detonationResult_default_value (), ::xml_schema::flags (), this),
  eventApplicationID_ (eventApplicationID_default_value (), ::xml_schema::flags (), this),
  eventEntityID_ (eventEntityID_default_value (), ::xml_schema::flags (), this),
  eventNumber_ (eventNumber_default_value (), ::xml_schema::flags (), this),
  eventSiteID_ (eventSiteID_default_value (), ::xml_schema::flags (), this),
  munitionStartPoint_ (munitionStartPoint_default_value (), ::xml_schema::flags (), this),
  munitionEndPoint_ (munitionEndPoint_default_value (), ::xml_schema::flags (), this),
  munitionSiteID_ (munitionSiteID_default_value (), ::xml_schema::flags (), this),
  munitionApplicationID_ (munitionApplicationID_default_value (), ::xml_schema::flags (), this),
  munitionEntityID_ (munitionEntityID_default_value (), ::xml_schema::flags (), this),
  fireMissionIndex_ (fireMissionIndex_default_value (), ::xml_schema::flags (), this),
  warhead_ (warhead_default_value (), ::xml_schema::flags (), this),
  fuse_ (fuse_default_value (), ::xml_schema::flags (), this),
  munitionQuantity_ (munitionQuantity_default_value (), ::xml_schema::flags (), this),
  firingRate_ (firingRate_default_value (), ::xml_schema::flags (), this),
  firingRange_ (firingRange_default_value (), ::xml_schema::flags (), this),
  articulationParameterCount_ (articulationParameterCount_default_value (), ::xml_schema::flags (), this),
  articulationParameterDesignatorArray_ (::xml_schema::flags (), this),
  articulationParameterChangeIndicatorArray_ (::xml_schema::flags (), this),
  articulationParameterIdPartAttachedToArray_ (::xml_schema::flags (), this),
  articulationParameterTypeArray_ (::xml_schema::flags (), this),
  articulationParameterArray_ (::xml_schema::flags (), this)
{
}

EspduTransform::
EspduTransform (const EspduTransform& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c),
  enabled_ (x.enabled_, f, this),
  marking_ (x.marking_, f, this),
  siteID_ (x.siteID_, f, this),
  applicationID_ (x.applicationID_, f, this),
  entityID_ (x.entityID_, f, this),
  forceID_ (x.forceID_, f, this),
  entityKind_ (x.entityKind_, f, this),
  entityDomain_ (x.entityDomain_, f, this),
  entityCountry_ (x.entityCountry_, f, this),
  entityCategory_ (x.entityCategory_, f, this),
  entitySubCategory_ (x.entitySubCategory_, f, this),
  entitySpecific_ (x.entitySpecific_, f, this),
  entityExtra_ (x.entityExtra_, f, this),
  readInterval_ (x.readInterval_, f, this),
  writeInterval_ (x.writeInterval_, f, this),
  networkMode_ (x.networkMode_, f, this),
  translation_ (x.translation_, f, this),
  rotation_ (x.rotation_, f, this),
  scale_ (x.scale_, f, this),
  scaleOrientation_ (x.scaleOrientation_, f, this),
  center_ (x.center_, f, this),
  address_ (x.address_, f, this),
  port_ (x.port_, f, this),
  multicastRelayHost_ (x.multicastRelayHost_, f, this),
  multicastRelayPort_ (x.multicastRelayPort_, f, this),
  rtpHeaderExpected_ (x.rtpHeaderExpected_, f, this),
  deadReckoning_ (x.deadReckoning_, f, this),
  linearVelocity_ (x.linearVelocity_, f, this),
  linearAcceleration_ (x.linearAcceleration_, f, this),
  fired1_ (x.fired1_, f, this),
  fired2_ (x.fired2_, f, this),
  collisionType_ (x.collisionType_, f, this),
  detonationLocation_ (x.detonationLocation_, f, this),
  detonationRelativeLocation_ (x.detonationRelativeLocation_, f, this),
  detonationResult_ (x.detonationResult_, f, this),
  eventApplicationID_ (x.eventApplicationID_, f, this),
  eventEntityID_ (x.eventEntityID_, f, this),
  eventNumber_ (x.eventNumber_, f, this),
  eventSiteID_ (x.eventSiteID_, f, this),
  munitionStartPoint_ (x.munitionStartPoint_, f, this),
  munitionEndPoint_ (x.munitionEndPoint_, f, this),
  munitionSiteID_ (x.munitionSiteID_, f, this),
  munitionApplicationID_ (x.munitionApplicationID_, f, this),
  munitionEntityID_ (x.munitionEntityID_, f, this),
  fireMissionIndex_ (x.fireMissionIndex_, f, this),
  warhead_ (x.warhead_, f, this),
  fuse_ (x.fuse_, f, this),
  munitionQuantity_ (x.munitionQuantity_, f, this),
  firingRate_ (x.firingRate_, f, this),
  firingRange_ (x.firingRange_, f, this),
  articulationParameterCount_ (x.articulationParameterCount_, f, this),
  articulationParameterDesignatorArray_ (x.articulationParameterDesignatorArray_, f, this),
  articulationParameterChangeIndicatorArray_ (x.articulationParameterChangeIndicatorArray_, f, this),
  articulationParameterIdPartAttachedToArray_ (x.articulationParameterIdPartAttachedToArray_, f, this),
  articulationParameterTypeArray_ (x.articulationParameterTypeArray_, f, this),
  articulationParameterArray_ (x.articulationParameterArray_, f, this)
{
}

EspduTransform::
EspduTransform (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DGroupingNode (e, f | ::xml_schema::flags::base, c),
  enabled_ (f, this),
  marking_ (f, this),
  siteID_ (f, this),
  applicationID_ (f, this),
  entityID_ (f, this),
  forceID_ (f, this),
  entityKind_ (f, this),
  entityDomain_ (f, this),
  entityCountry_ (f, this),
  entityCategory_ (f, this),
  entitySubCategory_ (f, this),
  entitySpecific_ (f, this),
  entityExtra_ (f, this),
  readInterval_ (f, this),
  writeInterval_ (f, this),
  networkMode_ (f, this),
  translation_ (f, this),
  rotation_ (f, this),
  scale_ (f, this),
  scaleOrientation_ (f, this),
  center_ (f, this),
  address_ (f, this),
  port_ (f, this),
  multicastRelayHost_ (f, this),
  multicastRelayPort_ (f, this),
  rtpHeaderExpected_ (f, this),
  deadReckoning_ (f, this),
  linearVelocity_ (f, this),
  linearAcceleration_ (f, this),
  fired1_ (f, this),
  fired2_ (f, this),
  collisionType_ (f, this),
  detonationLocation_ (f, this),
  detonationRelativeLocation_ (f, this),
  detonationResult_ (f, this),
  eventApplicationID_ (f, this),
  eventEntityID_ (f, this),
  eventNumber_ (f, this),
  eventSiteID_ (f, this),
  munitionStartPoint_ (f, this),
  munitionEndPoint_ (f, this),
  munitionSiteID_ (f, this),
  munitionApplicationID_ (f, this),
  munitionEntityID_ (f, this),
  fireMissionIndex_ (f, this),
  warhead_ (f, this),
  fuse_ (f, this),
  munitionQuantity_ (f, this),
  firingRate_ (f, this),
  firingRange_ (f, this),
  articulationParameterCount_ (f, this),
  articulationParameterDesignatorArray_ (f, this),
  articulationParameterChangeIndicatorArray_ (f, this),
  articulationParameterIdPartAttachedToArray_ (f, this),
  articulationParameterTypeArray_ (f, this),
  articulationParameterArray_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void EspduTransform::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGroupingNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "enabled" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< enabled_type > r (
        enabled_traits::create (i, f, this));

      this->enabled (r);
      continue;
    }

    if (n.name () == "marking" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< marking_type > r (
        marking_traits::create (i, f, this));

      this->marking (r);
      continue;
    }

    if (n.name () == "siteID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< siteID_type > r (
        siteID_traits::create (i, f, this));

      this->siteID (r);
      continue;
    }

    if (n.name () == "applicationID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< applicationID_type > r (
        applicationID_traits::create (i, f, this));

      this->applicationID (r);
      continue;
    }

    if (n.name () == "entityID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< entityID_type > r (
        entityID_traits::create (i, f, this));

      this->entityID (r);
      continue;
    }

    if (n.name () == "forceID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< forceID_type > r (
        forceID_traits::create (i, f, this));

      this->forceID (r);
      continue;
    }

    if (n.name () == "entityKind" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< entityKind_type > r (
        entityKind_traits::create (i, f, this));

      this->entityKind (r);
      continue;
    }

    if (n.name () == "entityDomain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< entityDomain_type > r (
        entityDomain_traits::create (i, f, this));

      this->entityDomain (r);
      continue;
    }

    if (n.name () == "entityCountry" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< entityCountry_type > r (
        entityCountry_traits::create (i, f, this));

      this->entityCountry (r);
      continue;
    }

    if (n.name () == "entityCategory" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< entityCategory_type > r (
        entityCategory_traits::create (i, f, this));

      this->entityCategory (r);
      continue;
    }

    if (n.name () == "entitySubCategory" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< entitySubCategory_type > r (
        entitySubCategory_traits::create (i, f, this));

      this->entitySubCategory (r);
      continue;
    }

    if (n.name () == "entitySpecific" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< entitySpecific_type > r (
        entitySpecific_traits::create (i, f, this));

      this->entitySpecific (r);
      continue;
    }

    if (n.name () == "entityExtra" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< entityExtra_type > r (
        entityExtra_traits::create (i, f, this));

      this->entityExtra (r);
      continue;
    }

    if (n.name () == "readInterval" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< readInterval_type > r (
        readInterval_traits::create (i, f, this));

      this->readInterval (r);
      continue;
    }

    if (n.name () == "writeInterval" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< writeInterval_type > r (
        writeInterval_traits::create (i, f, this));

      this->writeInterval (r);
      continue;
    }

    if (n.name () == "networkMode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< networkMode_type > r (
        networkMode_traits::create (i, f, this));

      this->networkMode (r);
      continue;
    }

    if (n.name () == "translation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< translation_type > r (
        translation_traits::create (i, f, this));

      this->translation (r);
      continue;
    }

    if (n.name () == "rotation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rotation_type > r (
        rotation_traits::create (i, f, this));

      this->rotation (r);
      continue;
    }

    if (n.name () == "scale" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< scale_type > r (
        scale_traits::create (i, f, this));

      this->scale (r);
      continue;
    }

    if (n.name () == "scaleOrientation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< scaleOrientation_type > r (
        scaleOrientation_traits::create (i, f, this));

      this->scaleOrientation (r);
      continue;
    }

    if (n.name () == "center" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< center_type > r (
        center_traits::create (i, f, this));

      this->center (r);
      continue;
    }

    if (n.name () == "address" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< address_type > r (
        address_traits::create (i, f, this));

      this->address (r);
      continue;
    }

    if (n.name () == "port" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< port_type > r (
        port_traits::create (i, f, this));

      this->port (r);
      continue;
    }

    if (n.name () == "multicastRelayHost" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< multicastRelayHost_type > r (
        multicastRelayHost_traits::create (i, f, this));

      this->multicastRelayHost (r);
      continue;
    }

    if (n.name () == "multicastRelayPort" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< multicastRelayPort_type > r (
        multicastRelayPort_traits::create (i, f, this));

      this->multicastRelayPort (r);
      continue;
    }

    if (n.name () == "rtpHeaderExpected" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rtpHeaderExpected_type > r (
        rtpHeaderExpected_traits::create (i, f, this));

      this->rtpHeaderExpected (r);
      continue;
    }

    if (n.name () == "deadReckoning" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< deadReckoning_type > r (
        deadReckoning_traits::create (i, f, this));

      this->deadReckoning (r);
      continue;
    }

    if (n.name () == "linearVelocity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< linearVelocity_type > r (
        linearVelocity_traits::create (i, f, this));

      this->linearVelocity (r);
      continue;
    }

    if (n.name () == "linearAcceleration" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< linearAcceleration_type > r (
        linearAcceleration_traits::create (i, f, this));

      this->linearAcceleration (r);
      continue;
    }

    if (n.name () == "fired1" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< fired1_type > r (
        fired1_traits::create (i, f, this));

      this->fired1 (r);
      continue;
    }

    if (n.name () == "fired2" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< fired2_type > r (
        fired2_traits::create (i, f, this));

      this->fired2 (r);
      continue;
    }

    if (n.name () == "collisionType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< collisionType_type > r (
        collisionType_traits::create (i, f, this));

      this->collisionType (r);
      continue;
    }

    if (n.name () == "detonationLocation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< detonationLocation_type > r (
        detonationLocation_traits::create (i, f, this));

      this->detonationLocation (r);
      continue;
    }

    if (n.name () == "detonationRelativeLocation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< detonationRelativeLocation_type > r (
        detonationRelativeLocation_traits::create (i, f, this));

      this->detonationRelativeLocation (r);
      continue;
    }

    if (n.name () == "detonationResult" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< detonationResult_type > r (
        detonationResult_traits::create (i, f, this));

      this->detonationResult (r);
      continue;
    }

    if (n.name () == "eventApplicationID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< eventApplicationID_type > r (
        eventApplicationID_traits::create (i, f, this));

      this->eventApplicationID (r);
      continue;
    }

    if (n.name () == "eventEntityID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< eventEntityID_type > r (
        eventEntityID_traits::create (i, f, this));

      this->eventEntityID (r);
      continue;
    }

    if (n.name () == "eventNumber" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< eventNumber_type > r (
        eventNumber_traits::create (i, f, this));

      this->eventNumber (r);
      continue;
    }

    if (n.name () == "eventSiteID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< eventSiteID_type > r (
        eventSiteID_traits::create (i, f, this));

      this->eventSiteID (r);
      continue;
    }

    if (n.name () == "munitionStartPoint" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< munitionStartPoint_type > r (
        munitionStartPoint_traits::create (i, f, this));

      this->munitionStartPoint (r);
      continue;
    }

    if (n.name () == "munitionEndPoint" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< munitionEndPoint_type > r (
        munitionEndPoint_traits::create (i, f, this));

      this->munitionEndPoint (r);
      continue;
    }

    if (n.name () == "munitionSiteID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< munitionSiteID_type > r (
        munitionSiteID_traits::create (i, f, this));

      this->munitionSiteID (r);
      continue;
    }

    if (n.name () == "munitionApplicationID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< munitionApplicationID_type > r (
        munitionApplicationID_traits::create (i, f, this));

      this->munitionApplicationID (r);
      continue;
    }

    if (n.name () == "munitionEntityID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< munitionEntityID_type > r (
        munitionEntityID_traits::create (i, f, this));

      this->munitionEntityID (r);
      continue;
    }

    if (n.name () == "fireMissionIndex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< fireMissionIndex_type > r (
        fireMissionIndex_traits::create (i, f, this));

      this->fireMissionIndex (r);
      continue;
    }

    if (n.name () == "warhead" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< warhead_type > r (
        warhead_traits::create (i, f, this));

      this->warhead (r);
      continue;
    }

    if (n.name () == "fuse" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< fuse_type > r (
        fuse_traits::create (i, f, this));

      this->fuse (r);
      continue;
    }

    if (n.name () == "munitionQuantity" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< munitionQuantity_type > r (
        munitionQuantity_traits::create (i, f, this));

      this->munitionQuantity (r);
      continue;
    }

    if (n.name () == "firingRate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< firingRate_type > r (
        firingRate_traits::create (i, f, this));

      this->firingRate (r);
      continue;
    }

    if (n.name () == "firingRange" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< firingRange_type > r (
        firingRange_traits::create (i, f, this));

      this->firingRange (r);
      continue;
    }

    if (n.name () == "articulationParameterCount" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< articulationParameterCount_type > r (
        articulationParameterCount_traits::create (i, f, this));

      this->articulationParameterCount (r);
      continue;
    }

    if (n.name () == "articulationParameterDesignatorArray" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< articulationParameterDesignatorArray_type > r (
        articulationParameterDesignatorArray_traits::create (i, f, this));

      this->articulationParameterDesignatorArray (r);
      continue;
    }

    if (n.name () == "articulationParameterChangeIndicatorArray" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< articulationParameterChangeIndicatorArray_type > r (
        articulationParameterChangeIndicatorArray_traits::create (i, f, this));

      this->articulationParameterChangeIndicatorArray (r);
      continue;
    }

    if (n.name () == "articulationParameterIdPartAttachedToArray" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< articulationParameterIdPartAttachedToArray_type > r (
        articulationParameterIdPartAttachedToArray_traits::create (i, f, this));

      this->articulationParameterIdPartAttachedToArray (r);
      continue;
    }

    if (n.name () == "articulationParameterTypeArray" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< articulationParameterTypeArray_type > r (
        articulationParameterTypeArray_traits::create (i, f, this));

      this->articulationParameterTypeArray (r);
      continue;
    }

    if (n.name () == "articulationParameterArray" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< articulationParameterArray_type > r (
        articulationParameterArray_traits::create (i, f, this));

      this->articulationParameterArray (r);
      continue;
    }
  }

  if (!enabled_.present ())
  {
    ::std::auto_ptr< enabled_type > r (
      enabled_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->enabled (r);
  }

  if (!siteID_.present ())
  {
    ::std::auto_ptr< siteID_type > r (
      siteID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->siteID (r);
  }

  if (!applicationID_.present ())
  {
    ::std::auto_ptr< applicationID_type > r (
      applicationID_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->applicationID (r);
  }

  if (!entityID_.present ())
  {
    ::std::auto_ptr< entityID_type > r (
      entityID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->entityID (r);
  }

  if (!forceID_.present ())
  {
    ::std::auto_ptr< forceID_type > r (
      forceID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->forceID (r);
  }

  if (!entityKind_.present ())
  {
    ::std::auto_ptr< entityKind_type > r (
      entityKind_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->entityKind (r);
  }

  if (!entityDomain_.present ())
  {
    ::std::auto_ptr< entityDomain_type > r (
      entityDomain_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->entityDomain (r);
  }

  if (!entityCountry_.present ())
  {
    ::std::auto_ptr< entityCountry_type > r (
      entityCountry_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->entityCountry (r);
  }

  if (!entityCategory_.present ())
  {
    ::std::auto_ptr< entityCategory_type > r (
      entityCategory_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->entityCategory (r);
  }

  if (!entitySubCategory_.present ())
  {
    ::std::auto_ptr< entitySubCategory_type > r (
      entitySubCategory_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->entitySubCategory (r);
  }

  if (!entitySpecific_.present ())
  {
    ::std::auto_ptr< entitySpecific_type > r (
      entitySpecific_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->entitySpecific (r);
  }

  if (!entityExtra_.present ())
  {
    ::std::auto_ptr< entityExtra_type > r (
      entityExtra_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->entityExtra (r);
  }

  if (!readInterval_.present ())
  {
    ::std::auto_ptr< readInterval_type > r (
      readInterval_traits::create (
        ::std::string ("0.1"),
        &p.element (), f, this));

    this->readInterval (r);
  }

  if (!writeInterval_.present ())
  {
    ::std::auto_ptr< writeInterval_type > r (
      writeInterval_traits::create (
        ::std::string ("1.0"),
        &p.element (), f, this));

    this->writeInterval (r);
  }

  if (!networkMode_.present ())
  {
    ::std::auto_ptr< networkMode_type > r (
      networkMode_traits::create (
        ::std::string ("standAlone"),
        &p.element (), f, this));

    this->networkMode (r);
  }

  if (!translation_.present ())
  {
    ::std::auto_ptr< translation_type > r (
      translation_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->translation (r);
  }

  if (!rotation_.present ())
  {
    ::std::auto_ptr< rotation_type > r (
      rotation_traits::create (
        ::std::string ("0 0 1 0"),
        &p.element (), f, this));

    this->rotation (r);
  }

  if (!scale_.present ())
  {
    ::std::auto_ptr< scale_type > r (
      scale_traits::create (
        ::std::string ("1 1 1"),
        &p.element (), f, this));

    this->scale (r);
  }

  if (!scaleOrientation_.present ())
  {
    ::std::auto_ptr< scaleOrientation_type > r (
      scaleOrientation_traits::create (
        ::std::string ("0 0 1 0"),
        &p.element (), f, this));

    this->scaleOrientation (r);
  }

  if (!center_.present ())
  {
    ::std::auto_ptr< center_type > r (
      center_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->center (r);
  }

  if (!address_.present ())
  {
    ::std::auto_ptr< address_type > r (
      address_traits::create (
        ::std::string ("localhost"),
        &p.element (), f, this));

    this->address (r);
  }

  if (!port_.present ())
  {
    ::std::auto_ptr< port_type > r (
      port_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->port (r);
  }

  if (!multicastRelayPort_.present ())
  {
    ::std::auto_ptr< multicastRelayPort_type > r (
      multicastRelayPort_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->multicastRelayPort (r);
  }

  if (!rtpHeaderExpected_.present ())
  {
    ::std::auto_ptr< rtpHeaderExpected_type > r (
      rtpHeaderExpected_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->rtpHeaderExpected (r);
  }

  if (!deadReckoning_.present ())
  {
    ::std::auto_ptr< deadReckoning_type > r (
      deadReckoning_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->deadReckoning (r);
  }

  if (!linearVelocity_.present ())
  {
    ::std::auto_ptr< linearVelocity_type > r (
      linearVelocity_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->linearVelocity (r);
  }

  if (!linearAcceleration_.present ())
  {
    ::std::auto_ptr< linearAcceleration_type > r (
      linearAcceleration_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->linearAcceleration (r);
  }

  if (!fired1_.present ())
  {
    ::std::auto_ptr< fired1_type > r (
      fired1_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->fired1 (r);
  }

  if (!fired2_.present ())
  {
    ::std::auto_ptr< fired2_type > r (
      fired2_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->fired2 (r);
  }

  if (!collisionType_.present ())
  {
    ::std::auto_ptr< collisionType_type > r (
      collisionType_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->collisionType (r);
  }

  if (!detonationLocation_.present ())
  {
    ::std::auto_ptr< detonationLocation_type > r (
      detonationLocation_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->detonationLocation (r);
  }

  if (!detonationRelativeLocation_.present ())
  {
    ::std::auto_ptr< detonationRelativeLocation_type > r (
      detonationRelativeLocation_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->detonationRelativeLocation (r);
  }

  if (!detonationResult_.present ())
  {
    ::std::auto_ptr< detonationResult_type > r (
      detonationResult_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->detonationResult (r);
  }

  if (!eventApplicationID_.present ())
  {
    ::std::auto_ptr< eventApplicationID_type > r (
      eventApplicationID_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->eventApplicationID (r);
  }

  if (!eventEntityID_.present ())
  {
    ::std::auto_ptr< eventEntityID_type > r (
      eventEntityID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->eventEntityID (r);
  }

  if (!eventNumber_.present ())
  {
    ::std::auto_ptr< eventNumber_type > r (
      eventNumber_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->eventNumber (r);
  }

  if (!eventSiteID_.present ())
  {
    ::std::auto_ptr< eventSiteID_type > r (
      eventSiteID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->eventSiteID (r);
  }

  if (!munitionStartPoint_.present ())
  {
    ::std::auto_ptr< munitionStartPoint_type > r (
      munitionStartPoint_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->munitionStartPoint (r);
  }

  if (!munitionEndPoint_.present ())
  {
    ::std::auto_ptr< munitionEndPoint_type > r (
      munitionEndPoint_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->munitionEndPoint (r);
  }

  if (!munitionSiteID_.present ())
  {
    ::std::auto_ptr< munitionSiteID_type > r (
      munitionSiteID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->munitionSiteID (r);
  }

  if (!munitionApplicationID_.present ())
  {
    ::std::auto_ptr< munitionApplicationID_type > r (
      munitionApplicationID_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->munitionApplicationID (r);
  }

  if (!munitionEntityID_.present ())
  {
    ::std::auto_ptr< munitionEntityID_type > r (
      munitionEntityID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->munitionEntityID (r);
  }

  if (!fireMissionIndex_.present ())
  {
    ::std::auto_ptr< fireMissionIndex_type > r (
      fireMissionIndex_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->fireMissionIndex (r);
  }

  if (!warhead_.present ())
  {
    ::std::auto_ptr< warhead_type > r (
      warhead_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->warhead (r);
  }

  if (!fuse_.present ())
  {
    ::std::auto_ptr< fuse_type > r (
      fuse_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->fuse (r);
  }

  if (!munitionQuantity_.present ())
  {
    ::std::auto_ptr< munitionQuantity_type > r (
      munitionQuantity_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->munitionQuantity (r);
  }

  if (!firingRate_.present ())
  {
    ::std::auto_ptr< firingRate_type > r (
      firingRate_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->firingRate (r);
  }

  if (!firingRange_.present ())
  {
    ::std::auto_ptr< firingRange_type > r (
      firingRange_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->firingRange (r);
  }

  if (!articulationParameterCount_.present ())
  {
    ::std::auto_ptr< articulationParameterCount_type > r (
      articulationParameterCount_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->articulationParameterCount (r);
  }
}

EspduTransform* EspduTransform::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new EspduTransform (*this, f, c);
}

EspduTransform::
~EspduTransform ()
{
}

// ReceiverPdu
//

const ReceiverPdu::enabled_type ReceiverPdu::enabled_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const ReceiverPdu::whichGeometry_type ReceiverPdu::whichGeometry_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const ReceiverPdu::readInterval_type ReceiverPdu::readInterval_default_value_ (
  ::std::string ("0.1"), 0, 0, 0);

const ReceiverPdu::writeInterval_type ReceiverPdu::writeInterval_default_value_ (
  ::std::string ("1.0"), 0, 0, 0);

const ReceiverPdu::networkMode_type ReceiverPdu::networkMode_default_value_ (
  ::std::string ("standAlone"), 0, 0, 0);

const ReceiverPdu::siteID_type ReceiverPdu::siteID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const ReceiverPdu::applicationID_type ReceiverPdu::applicationID_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const ReceiverPdu::entityID_type ReceiverPdu::entityID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const ReceiverPdu::address_type ReceiverPdu::address_default_value_ (
  ::std::string ("localhost"), 0, 0, 0);

const ReceiverPdu::port_type ReceiverPdu::port_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const ReceiverPdu::multicastRelayPort_type ReceiverPdu::multicastRelayPort_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const ReceiverPdu::rtpHeaderExpected_type ReceiverPdu::rtpHeaderExpected_default_value_ (
  ::std::string ("false"), 0, 0, 0);

const ReceiverPdu::radioID_type ReceiverPdu::radioID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const ReceiverPdu::receivedPower_type ReceiverPdu::receivedPower_default_value_ (
  ::std::string ("0.0"), 0, 0, 0);

const ReceiverPdu::receiverState_type ReceiverPdu::receiverState_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const ReceiverPdu::transmitterSiteID_type ReceiverPdu::transmitterSiteID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const ReceiverPdu::transmitterApplicationID_type ReceiverPdu::transmitterApplicationID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const ReceiverPdu::transmitterEntityID_type ReceiverPdu::transmitterEntityID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const ReceiverPdu::transmitterRadioID_type ReceiverPdu::transmitterRadioID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

ReceiverPdu::
ReceiverPdu ()
: ::X3DGroupingNode (),
  enabled_ (enabled_default_value (), ::xml_schema::flags (), this),
  whichGeometry_ (whichGeometry_default_value (), ::xml_schema::flags (), this),
  readInterval_ (readInterval_default_value (), ::xml_schema::flags (), this),
  writeInterval_ (writeInterval_default_value (), ::xml_schema::flags (), this),
  networkMode_ (networkMode_default_value (), ::xml_schema::flags (), this),
  siteID_ (siteID_default_value (), ::xml_schema::flags (), this),
  applicationID_ (applicationID_default_value (), ::xml_schema::flags (), this),
  entityID_ (entityID_default_value (), ::xml_schema::flags (), this),
  address_ (address_default_value (), ::xml_schema::flags (), this),
  port_ (port_default_value (), ::xml_schema::flags (), this),
  multicastRelayHost_ (::xml_schema::flags (), this),
  multicastRelayPort_ (multicastRelayPort_default_value (), ::xml_schema::flags (), this),
  rtpHeaderExpected_ (rtpHeaderExpected_default_value (), ::xml_schema::flags (), this),
  radioID_ (radioID_default_value (), ::xml_schema::flags (), this),
  receivedPower_ (receivedPower_default_value (), ::xml_schema::flags (), this),
  receiverState_ (receiverState_default_value (), ::xml_schema::flags (), this),
  transmitterSiteID_ (transmitterSiteID_default_value (), ::xml_schema::flags (), this),
  transmitterApplicationID_ (transmitterApplicationID_default_value (), ::xml_schema::flags (), this),
  transmitterEntityID_ (transmitterEntityID_default_value (), ::xml_schema::flags (), this),
  transmitterRadioID_ (transmitterRadioID_default_value (), ::xml_schema::flags (), this)
{
}

ReceiverPdu::
ReceiverPdu (const ReceiverPdu& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c),
  enabled_ (x.enabled_, f, this),
  whichGeometry_ (x.whichGeometry_, f, this),
  readInterval_ (x.readInterval_, f, this),
  writeInterval_ (x.writeInterval_, f, this),
  networkMode_ (x.networkMode_, f, this),
  siteID_ (x.siteID_, f, this),
  applicationID_ (x.applicationID_, f, this),
  entityID_ (x.entityID_, f, this),
  address_ (x.address_, f, this),
  port_ (x.port_, f, this),
  multicastRelayHost_ (x.multicastRelayHost_, f, this),
  multicastRelayPort_ (x.multicastRelayPort_, f, this),
  rtpHeaderExpected_ (x.rtpHeaderExpected_, f, this),
  radioID_ (x.radioID_, f, this),
  receivedPower_ (x.receivedPower_, f, this),
  receiverState_ (x.receiverState_, f, this),
  transmitterSiteID_ (x.transmitterSiteID_, f, this),
  transmitterApplicationID_ (x.transmitterApplicationID_, f, this),
  transmitterEntityID_ (x.transmitterEntityID_, f, this),
  transmitterRadioID_ (x.transmitterRadioID_, f, this)
{
}

ReceiverPdu::
ReceiverPdu (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DGroupingNode (e, f | ::xml_schema::flags::base, c),
  enabled_ (f, this),
  whichGeometry_ (f, this),
  readInterval_ (f, this),
  writeInterval_ (f, this),
  networkMode_ (f, this),
  siteID_ (f, this),
  applicationID_ (f, this),
  entityID_ (f, this),
  address_ (f, this),
  port_ (f, this),
  multicastRelayHost_ (f, this),
  multicastRelayPort_ (f, this),
  rtpHeaderExpected_ (f, this),
  radioID_ (f, this),
  receivedPower_ (f, this),
  receiverState_ (f, this),
  transmitterSiteID_ (f, this),
  transmitterApplicationID_ (f, this),
  transmitterEntityID_ (f, this),
  transmitterRadioID_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ReceiverPdu::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGroupingNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "enabled" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< enabled_type > r (
        enabled_traits::create (i, f, this));

      this->enabled (r);
      continue;
    }

    if (n.name () == "whichGeometry" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< whichGeometry_type > r (
        whichGeometry_traits::create (i, f, this));

      this->whichGeometry (r);
      continue;
    }

    if (n.name () == "readInterval" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< readInterval_type > r (
        readInterval_traits::create (i, f, this));

      this->readInterval (r);
      continue;
    }

    if (n.name () == "writeInterval" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< writeInterval_type > r (
        writeInterval_traits::create (i, f, this));

      this->writeInterval (r);
      continue;
    }

    if (n.name () == "networkMode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< networkMode_type > r (
        networkMode_traits::create (i, f, this));

      this->networkMode (r);
      continue;
    }

    if (n.name () == "siteID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< siteID_type > r (
        siteID_traits::create (i, f, this));

      this->siteID (r);
      continue;
    }

    if (n.name () == "applicationID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< applicationID_type > r (
        applicationID_traits::create (i, f, this));

      this->applicationID (r);
      continue;
    }

    if (n.name () == "entityID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< entityID_type > r (
        entityID_traits::create (i, f, this));

      this->entityID (r);
      continue;
    }

    if (n.name () == "address" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< address_type > r (
        address_traits::create (i, f, this));

      this->address (r);
      continue;
    }

    if (n.name () == "port" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< port_type > r (
        port_traits::create (i, f, this));

      this->port (r);
      continue;
    }

    if (n.name () == "multicastRelayHost" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< multicastRelayHost_type > r (
        multicastRelayHost_traits::create (i, f, this));

      this->multicastRelayHost (r);
      continue;
    }

    if (n.name () == "multicastRelayPort" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< multicastRelayPort_type > r (
        multicastRelayPort_traits::create (i, f, this));

      this->multicastRelayPort (r);
      continue;
    }

    if (n.name () == "rtpHeaderExpected" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rtpHeaderExpected_type > r (
        rtpHeaderExpected_traits::create (i, f, this));

      this->rtpHeaderExpected (r);
      continue;
    }

    if (n.name () == "radioID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< radioID_type > r (
        radioID_traits::create (i, f, this));

      this->radioID (r);
      continue;
    }

    if (n.name () == "receivedPower" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< receivedPower_type > r (
        receivedPower_traits::create (i, f, this));

      this->receivedPower (r);
      continue;
    }

    if (n.name () == "receiverState" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< receiverState_type > r (
        receiverState_traits::create (i, f, this));

      this->receiverState (r);
      continue;
    }

    if (n.name () == "transmitterSiteID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< transmitterSiteID_type > r (
        transmitterSiteID_traits::create (i, f, this));

      this->transmitterSiteID (r);
      continue;
    }

    if (n.name () == "transmitterApplicationID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< transmitterApplicationID_type > r (
        transmitterApplicationID_traits::create (i, f, this));

      this->transmitterApplicationID (r);
      continue;
    }

    if (n.name () == "transmitterEntityID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< transmitterEntityID_type > r (
        transmitterEntityID_traits::create (i, f, this));

      this->transmitterEntityID (r);
      continue;
    }

    if (n.name () == "transmitterRadioID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< transmitterRadioID_type > r (
        transmitterRadioID_traits::create (i, f, this));

      this->transmitterRadioID (r);
      continue;
    }
  }

  if (!enabled_.present ())
  {
    ::std::auto_ptr< enabled_type > r (
      enabled_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->enabled (r);
  }

  if (!whichGeometry_.present ())
  {
    ::std::auto_ptr< whichGeometry_type > r (
      whichGeometry_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->whichGeometry (r);
  }

  if (!readInterval_.present ())
  {
    ::std::auto_ptr< readInterval_type > r (
      readInterval_traits::create (
        ::std::string ("0.1"),
        &p.element (), f, this));

    this->readInterval (r);
  }

  if (!writeInterval_.present ())
  {
    ::std::auto_ptr< writeInterval_type > r (
      writeInterval_traits::create (
        ::std::string ("1.0"),
        &p.element (), f, this));

    this->writeInterval (r);
  }

  if (!networkMode_.present ())
  {
    ::std::auto_ptr< networkMode_type > r (
      networkMode_traits::create (
        ::std::string ("standAlone"),
        &p.element (), f, this));

    this->networkMode (r);
  }

  if (!siteID_.present ())
  {
    ::std::auto_ptr< siteID_type > r (
      siteID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->siteID (r);
  }

  if (!applicationID_.present ())
  {
    ::std::auto_ptr< applicationID_type > r (
      applicationID_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->applicationID (r);
  }

  if (!entityID_.present ())
  {
    ::std::auto_ptr< entityID_type > r (
      entityID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->entityID (r);
  }

  if (!address_.present ())
  {
    ::std::auto_ptr< address_type > r (
      address_traits::create (
        ::std::string ("localhost"),
        &p.element (), f, this));

    this->address (r);
  }

  if (!port_.present ())
  {
    ::std::auto_ptr< port_type > r (
      port_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->port (r);
  }

  if (!multicastRelayPort_.present ())
  {
    ::std::auto_ptr< multicastRelayPort_type > r (
      multicastRelayPort_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->multicastRelayPort (r);
  }

  if (!rtpHeaderExpected_.present ())
  {
    ::std::auto_ptr< rtpHeaderExpected_type > r (
      rtpHeaderExpected_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->rtpHeaderExpected (r);
  }

  if (!radioID_.present ())
  {
    ::std::auto_ptr< radioID_type > r (
      radioID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->radioID (r);
  }

  if (!receivedPower_.present ())
  {
    ::std::auto_ptr< receivedPower_type > r (
      receivedPower_traits::create (
        ::std::string ("0.0"),
        &p.element (), f, this));

    this->receivedPower (r);
  }

  if (!receiverState_.present ())
  {
    ::std::auto_ptr< receiverState_type > r (
      receiverState_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->receiverState (r);
  }

  if (!transmitterSiteID_.present ())
  {
    ::std::auto_ptr< transmitterSiteID_type > r (
      transmitterSiteID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->transmitterSiteID (r);
  }

  if (!transmitterApplicationID_.present ())
  {
    ::std::auto_ptr< transmitterApplicationID_type > r (
      transmitterApplicationID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->transmitterApplicationID (r);
  }

  if (!transmitterEntityID_.present ())
  {
    ::std::auto_ptr< transmitterEntityID_type > r (
      transmitterEntityID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->transmitterEntityID (r);
  }

  if (!transmitterRadioID_.present ())
  {
    ::std::auto_ptr< transmitterRadioID_type > r (
      transmitterRadioID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->transmitterRadioID (r);
  }
}

ReceiverPdu* ReceiverPdu::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ReceiverPdu (*this, f, c);
}

ReceiverPdu::
~ReceiverPdu ()
{
}

// SignalPdu
//

const SignalPdu::enabled_type SignalPdu::enabled_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const SignalPdu::whichGeometry_type SignalPdu::whichGeometry_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const SignalPdu::readInterval_type SignalPdu::readInterval_default_value_ (
  ::std::string ("0.1"), 0, 0, 0);

const SignalPdu::writeInterval_type SignalPdu::writeInterval_default_value_ (
  ::std::string ("1.0"), 0, 0, 0);

const SignalPdu::networkMode_type SignalPdu::networkMode_default_value_ (
  ::std::string ("standAlone"), 0, 0, 0);

const SignalPdu::siteID_type SignalPdu::siteID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const SignalPdu::applicationID_type SignalPdu::applicationID_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const SignalPdu::entityID_type SignalPdu::entityID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const SignalPdu::address_type SignalPdu::address_default_value_ (
  ::std::string ("localhost"), 0, 0, 0);

const SignalPdu::port_type SignalPdu::port_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const SignalPdu::multicastRelayPort_type SignalPdu::multicastRelayPort_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const SignalPdu::rtpHeaderExpected_type SignalPdu::rtpHeaderExpected_default_value_ (
  ::std::string ("false"), 0, 0, 0);

const SignalPdu::radioID_type SignalPdu::radioID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const SignalPdu::encodingScheme_type SignalPdu::encodingScheme_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const SignalPdu::tdlType_type SignalPdu::tdlType_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const SignalPdu::sampleRate_type SignalPdu::sampleRate_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const SignalPdu::samples_type SignalPdu::samples_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const SignalPdu::dataLength_type SignalPdu::dataLength_default_value_ (
  ::std::string ("0"), 0, 0, 0);

SignalPdu::
SignalPdu ()
: ::X3DGroupingNode (),
  enabled_ (enabled_default_value (), ::xml_schema::flags (), this),
  whichGeometry_ (whichGeometry_default_value (), ::xml_schema::flags (), this),
  readInterval_ (readInterval_default_value (), ::xml_schema::flags (), this),
  writeInterval_ (writeInterval_default_value (), ::xml_schema::flags (), this),
  networkMode_ (networkMode_default_value (), ::xml_schema::flags (), this),
  siteID_ (siteID_default_value (), ::xml_schema::flags (), this),
  applicationID_ (applicationID_default_value (), ::xml_schema::flags (), this),
  entityID_ (entityID_default_value (), ::xml_schema::flags (), this),
  address_ (address_default_value (), ::xml_schema::flags (), this),
  port_ (port_default_value (), ::xml_schema::flags (), this),
  multicastRelayHost_ (::xml_schema::flags (), this),
  multicastRelayPort_ (multicastRelayPort_default_value (), ::xml_schema::flags (), this),
  rtpHeaderExpected_ (rtpHeaderExpected_default_value (), ::xml_schema::flags (), this),
  radioID_ (radioID_default_value (), ::xml_schema::flags (), this),
  encodingScheme_ (encodingScheme_default_value (), ::xml_schema::flags (), this),
  tdlType_ (tdlType_default_value (), ::xml_schema::flags (), this),
  sampleRate_ (sampleRate_default_value (), ::xml_schema::flags (), this),
  samples_ (samples_default_value (), ::xml_schema::flags (), this),
  dataLength_ (dataLength_default_value (), ::xml_schema::flags (), this),
  data_ (::xml_schema::flags (), this)
{
}

SignalPdu::
SignalPdu (const SignalPdu& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c),
  enabled_ (x.enabled_, f, this),
  whichGeometry_ (x.whichGeometry_, f, this),
  readInterval_ (x.readInterval_, f, this),
  writeInterval_ (x.writeInterval_, f, this),
  networkMode_ (x.networkMode_, f, this),
  siteID_ (x.siteID_, f, this),
  applicationID_ (x.applicationID_, f, this),
  entityID_ (x.entityID_, f, this),
  address_ (x.address_, f, this),
  port_ (x.port_, f, this),
  multicastRelayHost_ (x.multicastRelayHost_, f, this),
  multicastRelayPort_ (x.multicastRelayPort_, f, this),
  rtpHeaderExpected_ (x.rtpHeaderExpected_, f, this),
  radioID_ (x.radioID_, f, this),
  encodingScheme_ (x.encodingScheme_, f, this),
  tdlType_ (x.tdlType_, f, this),
  sampleRate_ (x.sampleRate_, f, this),
  samples_ (x.samples_, f, this),
  dataLength_ (x.dataLength_, f, this),
  data_ (x.data_, f, this)
{
}

SignalPdu::
SignalPdu (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DGroupingNode (e, f | ::xml_schema::flags::base, c),
  enabled_ (f, this),
  whichGeometry_ (f, this),
  readInterval_ (f, this),
  writeInterval_ (f, this),
  networkMode_ (f, this),
  siteID_ (f, this),
  applicationID_ (f, this),
  entityID_ (f, this),
  address_ (f, this),
  port_ (f, this),
  multicastRelayHost_ (f, this),
  multicastRelayPort_ (f, this),
  rtpHeaderExpected_ (f, this),
  radioID_ (f, this),
  encodingScheme_ (f, this),
  tdlType_ (f, this),
  sampleRate_ (f, this),
  samples_ (f, this),
  dataLength_ (f, this),
  data_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void SignalPdu::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGroupingNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "enabled" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< enabled_type > r (
        enabled_traits::create (i, f, this));

      this->enabled (r);
      continue;
    }

    if (n.name () == "whichGeometry" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< whichGeometry_type > r (
        whichGeometry_traits::create (i, f, this));

      this->whichGeometry (r);
      continue;
    }

    if (n.name () == "readInterval" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< readInterval_type > r (
        readInterval_traits::create (i, f, this));

      this->readInterval (r);
      continue;
    }

    if (n.name () == "writeInterval" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< writeInterval_type > r (
        writeInterval_traits::create (i, f, this));

      this->writeInterval (r);
      continue;
    }

    if (n.name () == "networkMode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< networkMode_type > r (
        networkMode_traits::create (i, f, this));

      this->networkMode (r);
      continue;
    }

    if (n.name () == "siteID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< siteID_type > r (
        siteID_traits::create (i, f, this));

      this->siteID (r);
      continue;
    }

    if (n.name () == "applicationID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< applicationID_type > r (
        applicationID_traits::create (i, f, this));

      this->applicationID (r);
      continue;
    }

    if (n.name () == "entityID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< entityID_type > r (
        entityID_traits::create (i, f, this));

      this->entityID (r);
      continue;
    }

    if (n.name () == "address" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< address_type > r (
        address_traits::create (i, f, this));

      this->address (r);
      continue;
    }

    if (n.name () == "port" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< port_type > r (
        port_traits::create (i, f, this));

      this->port (r);
      continue;
    }

    if (n.name () == "multicastRelayHost" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< multicastRelayHost_type > r (
        multicastRelayHost_traits::create (i, f, this));

      this->multicastRelayHost (r);
      continue;
    }

    if (n.name () == "multicastRelayPort" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< multicastRelayPort_type > r (
        multicastRelayPort_traits::create (i, f, this));

      this->multicastRelayPort (r);
      continue;
    }

    if (n.name () == "rtpHeaderExpected" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rtpHeaderExpected_type > r (
        rtpHeaderExpected_traits::create (i, f, this));

      this->rtpHeaderExpected (r);
      continue;
    }

    if (n.name () == "radioID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< radioID_type > r (
        radioID_traits::create (i, f, this));

      this->radioID (r);
      continue;
    }

    if (n.name () == "encodingScheme" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< encodingScheme_type > r (
        encodingScheme_traits::create (i, f, this));

      this->encodingScheme (r);
      continue;
    }

    if (n.name () == "tdlType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< tdlType_type > r (
        tdlType_traits::create (i, f, this));

      this->tdlType (r);
      continue;
    }

    if (n.name () == "sampleRate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< sampleRate_type > r (
        sampleRate_traits::create (i, f, this));

      this->sampleRate (r);
      continue;
    }

    if (n.name () == "samples" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< samples_type > r (
        samples_traits::create (i, f, this));

      this->samples (r);
      continue;
    }

    if (n.name () == "dataLength" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< dataLength_type > r (
        dataLength_traits::create (i, f, this));

      this->dataLength (r);
      continue;
    }

    if (n.name () == "data" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< data_type > r (
        data_traits::create (i, f, this));

      this->data (r);
      continue;
    }
  }

  if (!enabled_.present ())
  {
    ::std::auto_ptr< enabled_type > r (
      enabled_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->enabled (r);
  }

  if (!whichGeometry_.present ())
  {
    ::std::auto_ptr< whichGeometry_type > r (
      whichGeometry_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->whichGeometry (r);
  }

  if (!readInterval_.present ())
  {
    ::std::auto_ptr< readInterval_type > r (
      readInterval_traits::create (
        ::std::string ("0.1"),
        &p.element (), f, this));

    this->readInterval (r);
  }

  if (!writeInterval_.present ())
  {
    ::std::auto_ptr< writeInterval_type > r (
      writeInterval_traits::create (
        ::std::string ("1.0"),
        &p.element (), f, this));

    this->writeInterval (r);
  }

  if (!networkMode_.present ())
  {
    ::std::auto_ptr< networkMode_type > r (
      networkMode_traits::create (
        ::std::string ("standAlone"),
        &p.element (), f, this));

    this->networkMode (r);
  }

  if (!siteID_.present ())
  {
    ::std::auto_ptr< siteID_type > r (
      siteID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->siteID (r);
  }

  if (!applicationID_.present ())
  {
    ::std::auto_ptr< applicationID_type > r (
      applicationID_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->applicationID (r);
  }

  if (!entityID_.present ())
  {
    ::std::auto_ptr< entityID_type > r (
      entityID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->entityID (r);
  }

  if (!address_.present ())
  {
    ::std::auto_ptr< address_type > r (
      address_traits::create (
        ::std::string ("localhost"),
        &p.element (), f, this));

    this->address (r);
  }

  if (!port_.present ())
  {
    ::std::auto_ptr< port_type > r (
      port_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->port (r);
  }

  if (!multicastRelayPort_.present ())
  {
    ::std::auto_ptr< multicastRelayPort_type > r (
      multicastRelayPort_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->multicastRelayPort (r);
  }

  if (!rtpHeaderExpected_.present ())
  {
    ::std::auto_ptr< rtpHeaderExpected_type > r (
      rtpHeaderExpected_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->rtpHeaderExpected (r);
  }

  if (!radioID_.present ())
  {
    ::std::auto_ptr< radioID_type > r (
      radioID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->radioID (r);
  }

  if (!encodingScheme_.present ())
  {
    ::std::auto_ptr< encodingScheme_type > r (
      encodingScheme_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->encodingScheme (r);
  }

  if (!tdlType_.present ())
  {
    ::std::auto_ptr< tdlType_type > r (
      tdlType_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->tdlType (r);
  }

  if (!sampleRate_.present ())
  {
    ::std::auto_ptr< sampleRate_type > r (
      sampleRate_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->sampleRate (r);
  }

  if (!samples_.present ())
  {
    ::std::auto_ptr< samples_type > r (
      samples_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->samples (r);
  }

  if (!dataLength_.present ())
  {
    ::std::auto_ptr< dataLength_type > r (
      dataLength_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->dataLength (r);
  }
}

SignalPdu* SignalPdu::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new SignalPdu (*this, f, c);
}

SignalPdu::
~SignalPdu ()
{
}

// TransmitterPdu
//

const TransmitterPdu::enabled_type TransmitterPdu::enabled_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const TransmitterPdu::whichGeometry_type TransmitterPdu::whichGeometry_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const TransmitterPdu::readInterval_type TransmitterPdu::readInterval_default_value_ (
  ::std::string ("0.1"), 0, 0, 0);

const TransmitterPdu::writeInterval_type TransmitterPdu::writeInterval_default_value_ (
  ::std::string ("1.0"), 0, 0, 0);

const TransmitterPdu::networkMode_type TransmitterPdu::networkMode_default_value_ (
  ::std::string ("standAlone"), 0, 0, 0);

const TransmitterPdu::siteID_type TransmitterPdu::siteID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::applicationID_type TransmitterPdu::applicationID_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const TransmitterPdu::entityID_type TransmitterPdu::entityID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::address_type TransmitterPdu::address_default_value_ (
  ::std::string ("localhost"), 0, 0, 0);

const TransmitterPdu::port_type TransmitterPdu::port_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::multicastRelayPort_type TransmitterPdu::multicastRelayPort_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::rtpHeaderExpected_type TransmitterPdu::rtpHeaderExpected_default_value_ (
  ::std::string ("false"), 0, 0, 0);

const TransmitterPdu::radioID_type TransmitterPdu::radioID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::antennaLocation_type TransmitterPdu::antennaLocation_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const TransmitterPdu::antennaPatternLength_type TransmitterPdu::antennaPatternLength_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::antennaPatternType_type TransmitterPdu::antennaPatternType_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::cryptoKeyID_type TransmitterPdu::cryptoKeyID_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::cryptoSystem_type TransmitterPdu::cryptoSystem_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::frequency_type TransmitterPdu::frequency_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::inputSource_type TransmitterPdu::inputSource_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::lengthOfModulationParameters_type TransmitterPdu::lengthOfModulationParameters_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::modulationTypeDetail_type TransmitterPdu::modulationTypeDetail_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::modulationTypeMajor_type TransmitterPdu::modulationTypeMajor_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::modulationTypeSpreadSpectrum_type TransmitterPdu::modulationTypeSpreadSpectrum_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::modulationTypeSystem_type TransmitterPdu::modulationTypeSystem_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::power_type TransmitterPdu::power_default_value_ (
  ::std::string ("0.0"), 0, 0, 0);

const TransmitterPdu::radioEntityTypeCategory_type TransmitterPdu::radioEntityTypeCategory_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::radioEntityTypeCountry_type TransmitterPdu::radioEntityTypeCountry_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::radioEntityTypeDomain_type TransmitterPdu::radioEntityTypeDomain_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::radioEntityTypeKind_type TransmitterPdu::radioEntityTypeKind_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::radioEntityTypeNomenclature_type TransmitterPdu::radioEntityTypeNomenclature_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::radioEntityTypeNomenclatureVersion_type TransmitterPdu::radioEntityTypeNomenclatureVersion_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::relativeAntennaLocation_type TransmitterPdu::relativeAntennaLocation_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const TransmitterPdu::transmitFrequencyBandwidth_type TransmitterPdu::transmitFrequencyBandwidth_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const TransmitterPdu::transmitState_type TransmitterPdu::transmitState_default_value_ (
  ::std::string ("0"), 0, 0, 0);

TransmitterPdu::
TransmitterPdu ()
: ::X3DGroupingNode (),
  enabled_ (enabled_default_value (), ::xml_schema::flags (), this),
  whichGeometry_ (whichGeometry_default_value (), ::xml_schema::flags (), this),
  readInterval_ (readInterval_default_value (), ::xml_schema::flags (), this),
  writeInterval_ (writeInterval_default_value (), ::xml_schema::flags (), this),
  networkMode_ (networkMode_default_value (), ::xml_schema::flags (), this),
  siteID_ (siteID_default_value (), ::xml_schema::flags (), this),
  applicationID_ (applicationID_default_value (), ::xml_schema::flags (), this),
  entityID_ (entityID_default_value (), ::xml_schema::flags (), this),
  address_ (address_default_value (), ::xml_schema::flags (), this),
  port_ (port_default_value (), ::xml_schema::flags (), this),
  multicastRelayHost_ (::xml_schema::flags (), this),
  multicastRelayPort_ (multicastRelayPort_default_value (), ::xml_schema::flags (), this),
  rtpHeaderExpected_ (rtpHeaderExpected_default_value (), ::xml_schema::flags (), this),
  radioID_ (radioID_default_value (), ::xml_schema::flags (), this),
  antennaLocation_ (antennaLocation_default_value (), ::xml_schema::flags (), this),
  antennaPatternLength_ (antennaPatternLength_default_value (), ::xml_schema::flags (), this),
  antennaPatternType_ (antennaPatternType_default_value (), ::xml_schema::flags (), this),
  cryptoKeyID_ (cryptoKeyID_default_value (), ::xml_schema::flags (), this),
  cryptoSystem_ (cryptoSystem_default_value (), ::xml_schema::flags (), this),
  frequency_ (frequency_default_value (), ::xml_schema::flags (), this),
  inputSource_ (inputSource_default_value (), ::xml_schema::flags (), this),
  lengthOfModulationParameters_ (lengthOfModulationParameters_default_value (), ::xml_schema::flags (), this),
  modulationTypeDetail_ (modulationTypeDetail_default_value (), ::xml_schema::flags (), this),
  modulationTypeMajor_ (modulationTypeMajor_default_value (), ::xml_schema::flags (), this),
  modulationTypeSpreadSpectrum_ (modulationTypeSpreadSpectrum_default_value (), ::xml_schema::flags (), this),
  modulationTypeSystem_ (modulationTypeSystem_default_value (), ::xml_schema::flags (), this),
  power_ (power_default_value (), ::xml_schema::flags (), this),
  radioEntityTypeCategory_ (radioEntityTypeCategory_default_value (), ::xml_schema::flags (), this),
  radioEntityTypeCountry_ (radioEntityTypeCountry_default_value (), ::xml_schema::flags (), this),
  radioEntityTypeDomain_ (radioEntityTypeDomain_default_value (), ::xml_schema::flags (), this),
  radioEntityTypeKind_ (radioEntityTypeKind_default_value (), ::xml_schema::flags (), this),
  radioEntityTypeNomenclature_ (radioEntityTypeNomenclature_default_value (), ::xml_schema::flags (), this),
  radioEntityTypeNomenclatureVersion_ (radioEntityTypeNomenclatureVersion_default_value (), ::xml_schema::flags (), this),
  relativeAntennaLocation_ (relativeAntennaLocation_default_value (), ::xml_schema::flags (), this),
  transmitFrequencyBandwidth_ (transmitFrequencyBandwidth_default_value (), ::xml_schema::flags (), this),
  transmitState_ (transmitState_default_value (), ::xml_schema::flags (), this)
{
}

TransmitterPdu::
TransmitterPdu (const TransmitterPdu& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c),
  enabled_ (x.enabled_, f, this),
  whichGeometry_ (x.whichGeometry_, f, this),
  readInterval_ (x.readInterval_, f, this),
  writeInterval_ (x.writeInterval_, f, this),
  networkMode_ (x.networkMode_, f, this),
  siteID_ (x.siteID_, f, this),
  applicationID_ (x.applicationID_, f, this),
  entityID_ (x.entityID_, f, this),
  address_ (x.address_, f, this),
  port_ (x.port_, f, this),
  multicastRelayHost_ (x.multicastRelayHost_, f, this),
  multicastRelayPort_ (x.multicastRelayPort_, f, this),
  rtpHeaderExpected_ (x.rtpHeaderExpected_, f, this),
  radioID_ (x.radioID_, f, this),
  antennaLocation_ (x.antennaLocation_, f, this),
  antennaPatternLength_ (x.antennaPatternLength_, f, this),
  antennaPatternType_ (x.antennaPatternType_, f, this),
  cryptoKeyID_ (x.cryptoKeyID_, f, this),
  cryptoSystem_ (x.cryptoSystem_, f, this),
  frequency_ (x.frequency_, f, this),
  inputSource_ (x.inputSource_, f, this),
  lengthOfModulationParameters_ (x.lengthOfModulationParameters_, f, this),
  modulationTypeDetail_ (x.modulationTypeDetail_, f, this),
  modulationTypeMajor_ (x.modulationTypeMajor_, f, this),
  modulationTypeSpreadSpectrum_ (x.modulationTypeSpreadSpectrum_, f, this),
  modulationTypeSystem_ (x.modulationTypeSystem_, f, this),
  power_ (x.power_, f, this),
  radioEntityTypeCategory_ (x.radioEntityTypeCategory_, f, this),
  radioEntityTypeCountry_ (x.radioEntityTypeCountry_, f, this),
  radioEntityTypeDomain_ (x.radioEntityTypeDomain_, f, this),
  radioEntityTypeKind_ (x.radioEntityTypeKind_, f, this),
  radioEntityTypeNomenclature_ (x.radioEntityTypeNomenclature_, f, this),
  radioEntityTypeNomenclatureVersion_ (x.radioEntityTypeNomenclatureVersion_, f, this),
  relativeAntennaLocation_ (x.relativeAntennaLocation_, f, this),
  transmitFrequencyBandwidth_ (x.transmitFrequencyBandwidth_, f, this),
  transmitState_ (x.transmitState_, f, this)
{
}

TransmitterPdu::
TransmitterPdu (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DGroupingNode (e, f | ::xml_schema::flags::base, c),
  enabled_ (f, this),
  whichGeometry_ (f, this),
  readInterval_ (f, this),
  writeInterval_ (f, this),
  networkMode_ (f, this),
  siteID_ (f, this),
  applicationID_ (f, this),
  entityID_ (f, this),
  address_ (f, this),
  port_ (f, this),
  multicastRelayHost_ (f, this),
  multicastRelayPort_ (f, this),
  rtpHeaderExpected_ (f, this),
  radioID_ (f, this),
  antennaLocation_ (f, this),
  antennaPatternLength_ (f, this),
  antennaPatternType_ (f, this),
  cryptoKeyID_ (f, this),
  cryptoSystem_ (f, this),
  frequency_ (f, this),
  inputSource_ (f, this),
  lengthOfModulationParameters_ (f, this),
  modulationTypeDetail_ (f, this),
  modulationTypeMajor_ (f, this),
  modulationTypeSpreadSpectrum_ (f, this),
  modulationTypeSystem_ (f, this),
  power_ (f, this),
  radioEntityTypeCategory_ (f, this),
  radioEntityTypeCountry_ (f, this),
  radioEntityTypeDomain_ (f, this),
  radioEntityTypeKind_ (f, this),
  radioEntityTypeNomenclature_ (f, this),
  radioEntityTypeNomenclatureVersion_ (f, this),
  relativeAntennaLocation_ (f, this),
  transmitFrequencyBandwidth_ (f, this),
  transmitState_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void TransmitterPdu::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGroupingNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "enabled" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< enabled_type > r (
        enabled_traits::create (i, f, this));

      this->enabled (r);
      continue;
    }

    if (n.name () == "whichGeometry" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< whichGeometry_type > r (
        whichGeometry_traits::create (i, f, this));

      this->whichGeometry (r);
      continue;
    }

    if (n.name () == "readInterval" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< readInterval_type > r (
        readInterval_traits::create (i, f, this));

      this->readInterval (r);
      continue;
    }

    if (n.name () == "writeInterval" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< writeInterval_type > r (
        writeInterval_traits::create (i, f, this));

      this->writeInterval (r);
      continue;
    }

    if (n.name () == "networkMode" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< networkMode_type > r (
        networkMode_traits::create (i, f, this));

      this->networkMode (r);
      continue;
    }

    if (n.name () == "siteID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< siteID_type > r (
        siteID_traits::create (i, f, this));

      this->siteID (r);
      continue;
    }

    if (n.name () == "applicationID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< applicationID_type > r (
        applicationID_traits::create (i, f, this));

      this->applicationID (r);
      continue;
    }

    if (n.name () == "entityID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< entityID_type > r (
        entityID_traits::create (i, f, this));

      this->entityID (r);
      continue;
    }

    if (n.name () == "address" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< address_type > r (
        address_traits::create (i, f, this));

      this->address (r);
      continue;
    }

    if (n.name () == "port" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< port_type > r (
        port_traits::create (i, f, this));

      this->port (r);
      continue;
    }

    if (n.name () == "multicastRelayHost" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< multicastRelayHost_type > r (
        multicastRelayHost_traits::create (i, f, this));

      this->multicastRelayHost (r);
      continue;
    }

    if (n.name () == "multicastRelayPort" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< multicastRelayPort_type > r (
        multicastRelayPort_traits::create (i, f, this));

      this->multicastRelayPort (r);
      continue;
    }

    if (n.name () == "rtpHeaderExpected" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rtpHeaderExpected_type > r (
        rtpHeaderExpected_traits::create (i, f, this));

      this->rtpHeaderExpected (r);
      continue;
    }

    if (n.name () == "radioID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< radioID_type > r (
        radioID_traits::create (i, f, this));

      this->radioID (r);
      continue;
    }

    if (n.name () == "antennaLocation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< antennaLocation_type > r (
        antennaLocation_traits::create (i, f, this));

      this->antennaLocation (r);
      continue;
    }

    if (n.name () == "antennaPatternLength" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< antennaPatternLength_type > r (
        antennaPatternLength_traits::create (i, f, this));

      this->antennaPatternLength (r);
      continue;
    }

    if (n.name () == "antennaPatternType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< antennaPatternType_type > r (
        antennaPatternType_traits::create (i, f, this));

      this->antennaPatternType (r);
      continue;
    }

    if (n.name () == "cryptoKeyID" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cryptoKeyID_type > r (
        cryptoKeyID_traits::create (i, f, this));

      this->cryptoKeyID (r);
      continue;
    }

    if (n.name () == "cryptoSystem" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cryptoSystem_type > r (
        cryptoSystem_traits::create (i, f, this));

      this->cryptoSystem (r);
      continue;
    }

    if (n.name () == "frequency" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< frequency_type > r (
        frequency_traits::create (i, f, this));

      this->frequency (r);
      continue;
    }

    if (n.name () == "inputSource" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< inputSource_type > r (
        inputSource_traits::create (i, f, this));

      this->inputSource (r);
      continue;
    }

    if (n.name () == "lengthOfModulationParameters" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< lengthOfModulationParameters_type > r (
        lengthOfModulationParameters_traits::create (i, f, this));

      this->lengthOfModulationParameters (r);
      continue;
    }

    if (n.name () == "modulationTypeDetail" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< modulationTypeDetail_type > r (
        modulationTypeDetail_traits::create (i, f, this));

      this->modulationTypeDetail (r);
      continue;
    }

    if (n.name () == "modulationTypeMajor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< modulationTypeMajor_type > r (
        modulationTypeMajor_traits::create (i, f, this));

      this->modulationTypeMajor (r);
      continue;
    }

    if (n.name () == "modulationTypeSpreadSpectrum" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< modulationTypeSpreadSpectrum_type > r (
        modulationTypeSpreadSpectrum_traits::create (i, f, this));

      this->modulationTypeSpreadSpectrum (r);
      continue;
    }

    if (n.name () == "modulationTypeSystem" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< modulationTypeSystem_type > r (
        modulationTypeSystem_traits::create (i, f, this));

      this->modulationTypeSystem (r);
      continue;
    }

    if (n.name () == "power" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< power_type > r (
        power_traits::create (i, f, this));

      this->power (r);
      continue;
    }

    if (n.name () == "radioEntityTypeCategory" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< radioEntityTypeCategory_type > r (
        radioEntityTypeCategory_traits::create (i, f, this));

      this->radioEntityTypeCategory (r);
      continue;
    }

    if (n.name () == "radioEntityTypeCountry" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< radioEntityTypeCountry_type > r (
        radioEntityTypeCountry_traits::create (i, f, this));

      this->radioEntityTypeCountry (r);
      continue;
    }

    if (n.name () == "radioEntityTypeDomain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< radioEntityTypeDomain_type > r (
        radioEntityTypeDomain_traits::create (i, f, this));

      this->radioEntityTypeDomain (r);
      continue;
    }

    if (n.name () == "radioEntityTypeKind" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< radioEntityTypeKind_type > r (
        radioEntityTypeKind_traits::create (i, f, this));

      this->radioEntityTypeKind (r);
      continue;
    }

    if (n.name () == "radioEntityTypeNomenclature" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< radioEntityTypeNomenclature_type > r (
        radioEntityTypeNomenclature_traits::create (i, f, this));

      this->radioEntityTypeNomenclature (r);
      continue;
    }

    if (n.name () == "radioEntityTypeNomenclatureVersion" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< radioEntityTypeNomenclatureVersion_type > r (
        radioEntityTypeNomenclatureVersion_traits::create (i, f, this));

      this->radioEntityTypeNomenclatureVersion (r);
      continue;
    }

    if (n.name () == "relativeAntennaLocation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< relativeAntennaLocation_type > r (
        relativeAntennaLocation_traits::create (i, f, this));

      this->relativeAntennaLocation (r);
      continue;
    }

    if (n.name () == "transmitFrequencyBandwidth" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< transmitFrequencyBandwidth_type > r (
        transmitFrequencyBandwidth_traits::create (i, f, this));

      this->transmitFrequencyBandwidth (r);
      continue;
    }

    if (n.name () == "transmitState" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< transmitState_type > r (
        transmitState_traits::create (i, f, this));

      this->transmitState (r);
      continue;
    }
  }

  if (!enabled_.present ())
  {
    ::std::auto_ptr< enabled_type > r (
      enabled_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->enabled (r);
  }

  if (!whichGeometry_.present ())
  {
    ::std::auto_ptr< whichGeometry_type > r (
      whichGeometry_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->whichGeometry (r);
  }

  if (!readInterval_.present ())
  {
    ::std::auto_ptr< readInterval_type > r (
      readInterval_traits::create (
        ::std::string ("0.1"),
        &p.element (), f, this));

    this->readInterval (r);
  }

  if (!writeInterval_.present ())
  {
    ::std::auto_ptr< writeInterval_type > r (
      writeInterval_traits::create (
        ::std::string ("1.0"),
        &p.element (), f, this));

    this->writeInterval (r);
  }

  if (!networkMode_.present ())
  {
    ::std::auto_ptr< networkMode_type > r (
      networkMode_traits::create (
        ::std::string ("standAlone"),
        &p.element (), f, this));

    this->networkMode (r);
  }

  if (!siteID_.present ())
  {
    ::std::auto_ptr< siteID_type > r (
      siteID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->siteID (r);
  }

  if (!applicationID_.present ())
  {
    ::std::auto_ptr< applicationID_type > r (
      applicationID_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->applicationID (r);
  }

  if (!entityID_.present ())
  {
    ::std::auto_ptr< entityID_type > r (
      entityID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->entityID (r);
  }

  if (!address_.present ())
  {
    ::std::auto_ptr< address_type > r (
      address_traits::create (
        ::std::string ("localhost"),
        &p.element (), f, this));

    this->address (r);
  }

  if (!port_.present ())
  {
    ::std::auto_ptr< port_type > r (
      port_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->port (r);
  }

  if (!multicastRelayPort_.present ())
  {
    ::std::auto_ptr< multicastRelayPort_type > r (
      multicastRelayPort_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->multicastRelayPort (r);
  }

  if (!rtpHeaderExpected_.present ())
  {
    ::std::auto_ptr< rtpHeaderExpected_type > r (
      rtpHeaderExpected_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->rtpHeaderExpected (r);
  }

  if (!radioID_.present ())
  {
    ::std::auto_ptr< radioID_type > r (
      radioID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->radioID (r);
  }

  if (!antennaLocation_.present ())
  {
    ::std::auto_ptr< antennaLocation_type > r (
      antennaLocation_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->antennaLocation (r);
  }

  if (!antennaPatternLength_.present ())
  {
    ::std::auto_ptr< antennaPatternLength_type > r (
      antennaPatternLength_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->antennaPatternLength (r);
  }

  if (!antennaPatternType_.present ())
  {
    ::std::auto_ptr< antennaPatternType_type > r (
      antennaPatternType_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->antennaPatternType (r);
  }

  if (!cryptoKeyID_.present ())
  {
    ::std::auto_ptr< cryptoKeyID_type > r (
      cryptoKeyID_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->cryptoKeyID (r);
  }

  if (!cryptoSystem_.present ())
  {
    ::std::auto_ptr< cryptoSystem_type > r (
      cryptoSystem_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->cryptoSystem (r);
  }

  if (!frequency_.present ())
  {
    ::std::auto_ptr< frequency_type > r (
      frequency_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->frequency (r);
  }

  if (!inputSource_.present ())
  {
    ::std::auto_ptr< inputSource_type > r (
      inputSource_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->inputSource (r);
  }

  if (!lengthOfModulationParameters_.present ())
  {
    ::std::auto_ptr< lengthOfModulationParameters_type > r (
      lengthOfModulationParameters_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->lengthOfModulationParameters (r);
  }

  if (!modulationTypeDetail_.present ())
  {
    ::std::auto_ptr< modulationTypeDetail_type > r (
      modulationTypeDetail_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->modulationTypeDetail (r);
  }

  if (!modulationTypeMajor_.present ())
  {
    ::std::auto_ptr< modulationTypeMajor_type > r (
      modulationTypeMajor_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->modulationTypeMajor (r);
  }

  if (!modulationTypeSpreadSpectrum_.present ())
  {
    ::std::auto_ptr< modulationTypeSpreadSpectrum_type > r (
      modulationTypeSpreadSpectrum_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->modulationTypeSpreadSpectrum (r);
  }

  if (!modulationTypeSystem_.present ())
  {
    ::std::auto_ptr< modulationTypeSystem_type > r (
      modulationTypeSystem_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->modulationTypeSystem (r);
  }

  if (!power_.present ())
  {
    ::std::auto_ptr< power_type > r (
      power_traits::create (
        ::std::string ("0.0"),
        &p.element (), f, this));

    this->power (r);
  }

  if (!radioEntityTypeCategory_.present ())
  {
    ::std::auto_ptr< radioEntityTypeCategory_type > r (
      radioEntityTypeCategory_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->radioEntityTypeCategory (r);
  }

  if (!radioEntityTypeCountry_.present ())
  {
    ::std::auto_ptr< radioEntityTypeCountry_type > r (
      radioEntityTypeCountry_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->radioEntityTypeCountry (r);
  }

  if (!radioEntityTypeDomain_.present ())
  {
    ::std::auto_ptr< radioEntityTypeDomain_type > r (
      radioEntityTypeDomain_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->radioEntityTypeDomain (r);
  }

  if (!radioEntityTypeKind_.present ())
  {
    ::std::auto_ptr< radioEntityTypeKind_type > r (
      radioEntityTypeKind_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->radioEntityTypeKind (r);
  }

  if (!radioEntityTypeNomenclature_.present ())
  {
    ::std::auto_ptr< radioEntityTypeNomenclature_type > r (
      radioEntityTypeNomenclature_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->radioEntityTypeNomenclature (r);
  }

  if (!radioEntityTypeNomenclatureVersion_.present ())
  {
    ::std::auto_ptr< radioEntityTypeNomenclatureVersion_type > r (
      radioEntityTypeNomenclatureVersion_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->radioEntityTypeNomenclatureVersion (r);
  }

  if (!relativeAntennaLocation_.present ())
  {
    ::std::auto_ptr< relativeAntennaLocation_type > r (
      relativeAntennaLocation_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->relativeAntennaLocation (r);
  }

  if (!transmitFrequencyBandwidth_.present ())
  {
    ::std::auto_ptr< transmitFrequencyBandwidth_type > r (
      transmitFrequencyBandwidth_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->transmitFrequencyBandwidth (r);
  }

  if (!transmitState_.present ())
  {
    ::std::auto_ptr< transmitState_type > r (
      transmitState_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->transmitState (r);
  }
}

TransmitterPdu* TransmitterPdu::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new TransmitterPdu (*this, f, c);
}

TransmitterPdu::
~TransmitterPdu ()
{
}

// GeoCoordinate
//

const GeoCoordinate::geoSystem_type GeoCoordinate::geoSystem_default_value_ (
  ::std::string ("\"GD\" \"WE\""), 0, 0, 0);

const GeoCoordinate::containerField_type GeoCoordinate::containerField_default_value_ (
  ::std::string ("coord"), 0, 0, 0);

GeoCoordinate::
GeoCoordinate ()
: ::X3DCoordinateNode (),
  GeoOrigin_ (::xml_schema::flags (), this),
  geoSystem_ (geoSystem_default_value (), ::xml_schema::flags (), this),
  point_ (::xml_schema::flags (), this),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

GeoCoordinate::
GeoCoordinate (const GeoCoordinate& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DCoordinateNode (x, f, c),
  GeoOrigin_ (x.GeoOrigin_, f, this),
  geoSystem_ (x.geoSystem_, f, this),
  point_ (x.point_, f, this),
  containerField_ (x.containerField_, f, this)
{
}

GeoCoordinate::
GeoCoordinate (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DCoordinateNode (e, f | ::xml_schema::flags::base, c),
  GeoOrigin_ (f, this),
  geoSystem_ (f, this),
  point_ (f, this),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void GeoCoordinate::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DCoordinateNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // GeoOrigin
    //
    if (n.name () == "GeoOrigin" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoOrigin_type > r (
        GeoOrigin_traits::create (i, f, this));

      if (!this->GeoOrigin ())
      {
        this->GeoOrigin (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "geoSystem" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< geoSystem_type > r (
        geoSystem_traits::create (i, f, this));

      this->geoSystem (r);
      continue;
    }

    if (n.name () == "point" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< point_type > r (
        point_traits::create (i, f, this));

      this->point (r);
      continue;
    }

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!geoSystem_.present ())
  {
    ::std::auto_ptr< geoSystem_type > r (
      geoSystem_traits::create (
        ::std::string ("\"GD\" \"WE\""),
        &p.element (), f, this));

    this->geoSystem (r);
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("coord"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

GeoCoordinate* GeoCoordinate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new GeoCoordinate (*this, f, c);
}

GeoCoordinate::
~GeoCoordinate ()
{
}

// GeoElevationGrid
//

const GeoElevationGrid::geoSystem_type GeoElevationGrid::geoSystem_default_value_ (
  ::std::string ("\"GD\" \"WE\""), 0, 0, 0);

const GeoElevationGrid::geoGridOrigin_type GeoElevationGrid::geoGridOrigin_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const GeoElevationGrid::height_type GeoElevationGrid::height_default_value_ (
  ::std::string ("0 0"), 0, 0, 0);

const GeoElevationGrid::ccw_type GeoElevationGrid::ccw_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const GeoElevationGrid::colorPerVertex_type GeoElevationGrid::colorPerVertex_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const GeoElevationGrid::creaseAngle_type GeoElevationGrid::creaseAngle_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const GeoElevationGrid::normalPerVertex_type GeoElevationGrid::normalPerVertex_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const GeoElevationGrid::solid_type GeoElevationGrid::solid_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const GeoElevationGrid::xDimension_type GeoElevationGrid::xDimension_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const GeoElevationGrid::xSpacing_type GeoElevationGrid::xSpacing_default_value_ (
  ::std::string ("1.0"), 0, 0, 0);

const GeoElevationGrid::yScale_type GeoElevationGrid::yScale_default_value_ (
  ::std::string ("1"), 0, 0, 0);

const GeoElevationGrid::zDimension_type GeoElevationGrid::zDimension_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const GeoElevationGrid::zSpacing_type GeoElevationGrid::zSpacing_default_value_ (
  ::std::string ("1.0"), 0, 0, 0);

GeoElevationGrid::
GeoElevationGrid ()
: ::X3DGeometryNode (),
  GeoOrigin_ (::xml_schema::flags (), this),
  Color_ (::xml_schema::flags (), this),
  ColorRGBA_ (::xml_schema::flags (), this),
  Normal_ (::xml_schema::flags (), this),
  TextureCoordinate_ (::xml_schema::flags (), this),
  TextureCoordinateGenerator_ (::xml_schema::flags (), this),
  MultiTextureCoordinate_ (::xml_schema::flags (), this),
  NurbsTextureCoordinate_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  FogCoordinate_ (::xml_schema::flags (), this),
  geoSystem_ (geoSystem_default_value (), ::xml_schema::flags (), this),
  geoGridOrigin_ (geoGridOrigin_default_value (), ::xml_schema::flags (), this),
  height_ (height_default_value (), ::xml_schema::flags (), this),
  ccw_ (ccw_default_value (), ::xml_schema::flags (), this),
  colorPerVertex_ (colorPerVertex_default_value (), ::xml_schema::flags (), this),
  creaseAngle_ (creaseAngle_default_value (), ::xml_schema::flags (), this),
  normalPerVertex_ (normalPerVertex_default_value (), ::xml_schema::flags (), this),
  solid_ (solid_default_value (), ::xml_schema::flags (), this),
  xDimension_ (xDimension_default_value (), ::xml_schema::flags (), this),
  xSpacing_ (xSpacing_default_value (), ::xml_schema::flags (), this),
  yScale_ (yScale_default_value (), ::xml_schema::flags (), this),
  zDimension_ (zDimension_default_value (), ::xml_schema::flags (), this),
  zSpacing_ (zSpacing_default_value (), ::xml_schema::flags (), this)
{
}

GeoElevationGrid::
GeoElevationGrid (const GeoElevationGrid& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DGeometryNode (x, f, c),
  GeoOrigin_ (x.GeoOrigin_, f, this),
  Color_ (x.Color_, f, this),
  ColorRGBA_ (x.ColorRGBA_, f, this),
  Normal_ (x.Normal_, f, this),
  TextureCoordinate_ (x.TextureCoordinate_, f, this),
  TextureCoordinateGenerator_ (x.TextureCoordinateGenerator_, f, this),
  MultiTextureCoordinate_ (x.MultiTextureCoordinate_, f, this),
  NurbsTextureCoordinate_ (x.NurbsTextureCoordinate_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  FogCoordinate_ (x.FogCoordinate_, f, this),
  geoSystem_ (x.geoSystem_, f, this),
  geoGridOrigin_ (x.geoGridOrigin_, f, this),
  height_ (x.height_, f, this),
  ccw_ (x.ccw_, f, this),
  colorPerVertex_ (x.colorPerVertex_, f, this),
  creaseAngle_ (x.creaseAngle_, f, this),
  normalPerVertex_ (x.normalPerVertex_, f, this),
  solid_ (x.solid_, f, this),
  xDimension_ (x.xDimension_, f, this),
  xSpacing_ (x.xSpacing_, f, this),
  yScale_ (x.yScale_, f, this),
  zDimension_ (x.zDimension_, f, this),
  zSpacing_ (x.zSpacing_, f, this)
{
}

GeoElevationGrid::
GeoElevationGrid (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::X3DGeometryNode (e, f | ::xml_schema::flags::base, c),
  GeoOrigin_ (f, this),
  Color_ (f, this),
  ColorRGBA_ (f, this),
  Normal_ (f, this),
  TextureCoordinate_ (f, this),
  TextureCoordinateGenerator_ (f, this),
  MultiTextureCoordinate_ (f, this),
  NurbsTextureCoordinate_ (f, this),
  ProtoInstance_ (f, this),
  FogCoordinate_ (f, this),
  geoSystem_ (f, this),
  geoGridOrigin_ (f, this),
  height_ (f, this),
  ccw_ (f, this),
  colorPerVertex_ (f, this),
  creaseAngle_ (f, this),
  normalPerVertex_ (f, this),
  solid_ (f, this),
  xDimension_ (f, this),
  xSpacing_ (f, this),
  yScale_ (f, this),
  zDimension_ (f, this),
  zSpacing_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void GeoElevationGrid::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometryNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // GeoOrigin
    //
    if (n.name () == "GeoOrigin" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoOrigin_type > r (
        GeoOrigin_traits::create (i, f, this));

      if (!this->GeoOrigin ())
      {
        this->GeoOrigin (r);
        continue;
      }
    }

    // Color
    //
    if (n.name () == "Color" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Color_type > r (
        Color_traits::create (i, f, this));

      if (!this->Color ())
      {
        this->Color (r);
        continue;
      }
    }

    // ColorRGBA
    //
    if (n.name () == "ColorRGBA" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ColorRGBA_type > r (
        ColorRGBA_traits::create (i, f, this));

      if (!this->ColorRGBA ())
      {
        this->ColorRGBA (r);
        continue;
      }
    }

    // Normal
    //
    if (n.name () == "Normal" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Normal_type > r (
        Normal_traits::create (i, f, this));

      if (!this->Normal ())
      {
        this->Normal (r);
        continue;
      }
    }

    // TextureCoordinate
    //
    if (n.name () == "TextureCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureCoordinate_type > r (
        TextureCoordinate_traits::create (i, f, this));

      if (!this->TextureCoordinate ())
      {
        this->TextureCoordinate (r);
        continue;
      }
    }

    // TextureCoordinateGenerator
    //
    if (n.name () == "TextureCoordinateGenerator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureCoordinateGenerator_type > r (
        TextureCoordinateGenerator_traits::create (i, f, this));

      if (!this->TextureCoordinateGenerator ())
      {
        this->TextureCoordinateGenerator (r);
        continue;
      }
    }

    // MultiTextureCoordinate
    //
    if (n.name () == "MultiTextureCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MultiTextureCoordinate_type > r (
        MultiTextureCoordinate_traits::create (i, f, this));

      if (!this->MultiTextureCoordinate ())
      {
        this->MultiTextureCoordinate (r);
        continue;
      }
    }

    // NurbsTextureCoordinate
    //
    if (n.name () == "NurbsTextureCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsTextureCoordinate_type > r (
        NurbsTextureCoordinate_traits::create (i, f, this));

      if (!this->NurbsTextureCoordinate ())
      {
        this->NurbsTextureCoordinate (r);
        continue;
      }
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    // FogCoordinate
    //
    if (n.name () == "FogCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< FogCoordinate_type > r (
        FogCoordinate_traits::create (i, f, this));

      if (!this->FogCoordinate ())
      {
        this->FogCoordinate (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "geoSystem" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< geoSystem_type > r (
        geoSystem_traits::create (i, f, this));

      this->geoSystem (r);
      continue;
    }

    if (n.name () == "geoGridOrigin" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< geoGridOrigin_type > r (
        geoGridOrigin_traits::create (i, f, this));

      this->geoGridOrigin (r);
      continue;
    }

    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< height_type > r (
        height_traits::create (i, f, this));

      this->height (r);
      continue;
    }

    if (n.name () == "ccw" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ccw_type > r (
        ccw_traits::create (i, f, this));

      this->ccw (r);
      continue;
    }

    if (n.name () == "colorPerVertex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< colorPerVertex_type > r (
        colorPerVertex_traits::create (i, f, this));

      this->colorPerVertex (r);
      continue;
    }

    if (n.name () == "creaseAngle" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< creaseAngle_type > r (
        creaseAngle_traits::create (i, f, this));

      this->creaseAngle (r);
      continue;
    }

    if (n.name () == "normalPerVertex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< normalPerVertex_type > r (
        normalPerVertex_traits::create (i, f, this));

      this->normalPerVertex (r);
      continue;
    }

    if (n.name () == "solid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< solid_type > r (
        solid_traits::create (i, f, this));

      this->solid (r);
      continue;
    }

    if (n.name () == "xDimension" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xDimension_type > r (
        xDimension_traits::create (i, f, this));

      this->xDimension (r);
      continue;
    }

    if (n.name () == "xSpacing" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< xSpacing_type > r (
        xSpacing_traits::create (i, f, this));

      this->xSpacing (r);
      continue;
    }

    if (n.name () == "yScale" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< yScale_type > r (
        yScale_traits::create (i, f, this));

      this->yScale (r);
      continue;
    }

    if (n.name () == "zDimension" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< zDimension_type > r (
        zDimension_traits::create (i, f, this));

      this->zDimension (r);
      continue;
    }

    if (n.name () == "zSpacing" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< zSpacing_type > r (
        zSpacing_traits::create (i, f, this));

      this->zSpacing (r);
      continue;
    }
  }

  if (!geoSystem_.present ())
  {
    ::std::auto_ptr< geoSystem_type > r (
      geoSystem_traits::create (
        ::std::string ("\"GD\" \"WE\""),
        &p.element (), f, this));

    this->geoSystem (r);
  }

  if (!geoGridOrigin_.present ())
  {
    ::std::auto_ptr< geoGridOrigin_type > r (
      geoGridOrigin_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->geoGridOrigin (r);
  }

  if (!height_.present ())
  {
    ::std::auto_ptr< height_type > r (
      height_traits::create (
        ::std::string ("0 0"),
        &p.element (), f, this));

    this->height (r);
  }

  if (!ccw_.present ())
  {
    ::std::auto_ptr< ccw_type > r (
      ccw_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->ccw (r);
  }

  if (!colorPerVertex_.present ())
  {
    ::std::auto_ptr< colorPerVertex_type > r (
      colorPerVertex_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->colorPerVertex (r);
  }

  if (!creaseAngle_.present ())
  {
    ::std::auto_ptr< creaseAngle_type > r (
      creaseAngle_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->creaseAngle (r);
  }

  if (!normalPerVertex_.present ())
  {
    ::std::auto_ptr< normalPerVertex_type > r (
      normalPerVertex_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->normalPerVertex (r);
  }

  if (!solid_.present ())
  {
    ::std::auto_ptr< solid_type > r (
      solid_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->solid (r);
  }

  if (!xDimension_.present ())
  {
    ::std::auto_ptr< xDimension_type > r (
      xDimension_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->xDimension (r);
  }

  if (!xSpacing_.present ())
  {
    ::std::auto_ptr< xSpacing_type > r (
      xSpacing_traits::create (
        ::std::string ("1.0"),
        &p.element (), f, this));

    this->xSpacing (r);
  }

  if (!yScale_.present ())
  {
    ::std::auto_ptr< yScale_type > r (
      yScale_traits::create (
        ::std::string ("1"),
        &p.element (), f, this));

    this->yScale (r);
  }

  if (!zDimension_.present ())
  {
    ::std::auto_ptr< zDimension_type > r (
      zDimension_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->zDimension (r);
  }

  if (!zSpacing_.present ())
  {
    ::std::auto_ptr< zSpacing_type > r (
      zSpacing_traits::create (
        ::std::string ("1.0"),
        &p.element (), f, this));

    this->zSpacing (r);
  }
}

GeoElevationGrid* GeoElevationGrid::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new GeoElevationGrid (*this, f, c);
}

GeoElevationGrid::
~GeoElevationGrid ()
{
}

// GeoLocation
//

const GeoLocation::geoSystem_type GeoLocation::geoSystem_default_value_ (
  ::std::string ("\"GD\" \"WE\""), 0, 0, 0);

const GeoLocation::geoCoords_type GeoLocation::geoCoords_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

GeoLocation::
GeoLocation ()
: ::X3DGroupingNode (),
  geoSystem_ (geoSystem_default_value (), ::xml_schema::flags (), this),
  geoCoords_ (geoCoords_default_value (), ::xml_schema::flags (), this)
{
}

GeoLocation::
GeoLocation (const GeoLocation& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c),
  geoSystem_ (x.geoSystem_, f, this),
  geoCoords_ (x.geoCoords_, f, this)
{
}

GeoLocation::
GeoLocation (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DGroupingNode (e, f | ::xml_schema::flags::base, c),
  geoSystem_ (f, this),
  geoCoords_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void GeoLocation::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGroupingNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "geoSystem" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< geoSystem_type > r (
        geoSystem_traits::create (i, f, this));

      this->geoSystem (r);
      continue;
    }

    if (n.name () == "geoCoords" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< geoCoords_type > r (
        geoCoords_traits::create (i, f, this));

      this->geoCoords (r);
      continue;
    }
  }

  if (!geoSystem_.present ())
  {
    ::std::auto_ptr< geoSystem_type > r (
      geoSystem_traits::create (
        ::std::string ("\"GD\" \"WE\""),
        &p.element (), f, this));

    this->geoSystem (r);
  }

  if (!geoCoords_.present ())
  {
    ::std::auto_ptr< geoCoords_type > r (
      geoCoords_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->geoCoords (r);
  }
}

GeoLocation* GeoLocation::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new GeoLocation (*this, f, c);
}

GeoLocation::
~GeoLocation ()
{
}

// GeoLOD
//

const GeoLOD::geoSystem_type GeoLOD::geoSystem_default_value_ (
  ::std::string ("\"GD\" \"WE\""), 0, 0, 0);

const GeoLOD::center_type GeoLOD::center_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const GeoLOD::range_type GeoLOD::range_default_value_ (
  ::std::string ("10"), 0, 0, 0);

GeoLOD::
GeoLOD ()
: ::X3DGroupingNode (),
  geoSystem_ (geoSystem_default_value (), ::xml_schema::flags (), this),
  rootUrl_ (::xml_schema::flags (), this),
  child1Url_ (::xml_schema::flags (), this),
  child2Url_ (::xml_schema::flags (), this),
  child3Url_ (::xml_schema::flags (), this),
  child4Url_ (::xml_schema::flags (), this),
  center_ (center_default_value (), ::xml_schema::flags (), this),
  range_ (range_default_value (), ::xml_schema::flags (), this)
{
}

GeoLOD::
GeoLOD (const GeoLOD& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c),
  geoSystem_ (x.geoSystem_, f, this),
  rootUrl_ (x.rootUrl_, f, this),
  child1Url_ (x.child1Url_, f, this),
  child2Url_ (x.child2Url_, f, this),
  child3Url_ (x.child3Url_, f, this),
  child4Url_ (x.child4Url_, f, this),
  center_ (x.center_, f, this),
  range_ (x.range_, f, this)
{
}

GeoLOD::
GeoLOD (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::X3DGroupingNode (e, f | ::xml_schema::flags::base, c),
  geoSystem_ (f, this),
  rootUrl_ (f, this),
  child1Url_ (f, this),
  child2Url_ (f, this),
  child3Url_ (f, this),
  child4Url_ (f, this),
  center_ (f, this),
  range_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void GeoLOD::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGroupingNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "geoSystem" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< geoSystem_type > r (
        geoSystem_traits::create (i, f, this));

      this->geoSystem (r);
      continue;
    }

    if (n.name () == "rootUrl" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rootUrl_type > r (
        rootUrl_traits::create (i, f, this));

      this->rootUrl (r);
      continue;
    }

    if (n.name () == "child1Url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< child1Url_type > r (
        child1Url_traits::create (i, f, this));

      this->child1Url (r);
      continue;
    }

    if (n.name () == "child2Url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< child2Url_type > r (
        child2Url_traits::create (i, f, this));

      this->child2Url (r);
      continue;
    }

    if (n.name () == "child3Url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< child3Url_type > r (
        child3Url_traits::create (i, f, this));

      this->child3Url (r);
      continue;
    }

    if (n.name () == "child4Url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< child4Url_type > r (
        child4Url_traits::create (i, f, this));

      this->child4Url (r);
      continue;
    }

    if (n.name () == "center" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< center_type > r (
        center_traits::create (i, f, this));

      this->center (r);
      continue;
    }

    if (n.name () == "range" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< range_type > r (
        range_traits::create (i, f, this));

      this->range (r);
      continue;
    }
  }

  if (!geoSystem_.present ())
  {
    ::std::auto_ptr< geoSystem_type > r (
      geoSystem_traits::create (
        ::std::string ("\"GD\" \"WE\""),
        &p.element (), f, this));

    this->geoSystem (r);
  }

  if (!center_.present ())
  {
    ::std::auto_ptr< center_type > r (
      center_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->center (r);
  }

  if (!range_.present ())
  {
    ::std::auto_ptr< range_type > r (
      range_traits::create (
        ::std::string ("10"),
        &p.element (), f, this));

    this->range (r);
  }
}

GeoLOD* GeoLOD::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new GeoLOD (*this, f, c);
}

GeoLOD::
~GeoLOD ()
{
}

// GeoMetadata
//

GeoMetadata::
GeoMetadata ()
: ::X3DInfoNode (),
  GeoCoordinate_ (::xml_schema::flags (), this),
  GeoElevationGrid_ (::xml_schema::flags (), this),
  GeoLocation_ (::xml_schema::flags (), this),
  GeoOrigin_ (::xml_schema::flags (), this),
  GeoLOD_ (::xml_schema::flags (), this),
  GeoPositionInterpolator_ (::xml_schema::flags (), this),
  GeoTouchSensor_ (::xml_schema::flags (), this),
  GeoViewpoint_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  url_ (::xml_schema::flags (), this),
  data_ (::xml_schema::flags (), this),
  summary_ (::xml_schema::flags (), this)
{
}

GeoMetadata::
GeoMetadata (const GeoMetadata& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DInfoNode (x, f, c),
  GeoCoordinate_ (x.GeoCoordinate_, f, this),
  GeoElevationGrid_ (x.GeoElevationGrid_, f, this),
  GeoLocation_ (x.GeoLocation_, f, this),
  GeoOrigin_ (x.GeoOrigin_, f, this),
  GeoLOD_ (x.GeoLOD_, f, this),
  GeoPositionInterpolator_ (x.GeoPositionInterpolator_, f, this),
  GeoTouchSensor_ (x.GeoTouchSensor_, f, this),
  GeoViewpoint_ (x.GeoViewpoint_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  url_ (x.url_, f, this),
  data_ (x.data_, f, this),
  summary_ (x.summary_, f, this)
{
}

GeoMetadata::
GeoMetadata (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DInfoNode (e, f | ::xml_schema::flags::base, c),
  GeoCoordinate_ (f, this),
  GeoElevationGrid_ (f, this),
  GeoLocation_ (f, this),
  GeoOrigin_ (f, this),
  GeoLOD_ (f, this),
  GeoPositionInterpolator_ (f, this),
  GeoTouchSensor_ (f, this),
  GeoViewpoint_ (f, this),
  ProtoInstance_ (f, this),
  url_ (f, this),
  data_ (f, this),
  summary_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void GeoMetadata::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DInfoNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // GeoCoordinate
    //
    if (n.name () == "GeoCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoCoordinate_type > r (
        GeoCoordinate_traits::create (i, f, this));

      if (!this->GeoCoordinate ())
      {
        this->GeoCoordinate (r);
        continue;
      }
    }

    // GeoElevationGrid
    //
    if (n.name () == "GeoElevationGrid" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoElevationGrid_type > r (
        GeoElevationGrid_traits::create (i, f, this));

      if (!this->GeoElevationGrid ())
      {
        this->GeoElevationGrid (r);
        continue;
      }
    }

    // GeoLocation
    //
    if (n.name () == "GeoLocation" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoLocation_type > r (
        GeoLocation_traits::create (i, f, this));

      if (!this->GeoLocation ())
      {
        this->GeoLocation (r);
        continue;
      }
    }

    // GeoOrigin
    //
    if (n.name () == "GeoOrigin" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoOrigin_type > r (
        GeoOrigin_traits::create (i, f, this));

      if (!this->GeoOrigin ())
      {
        this->GeoOrigin (r);
        continue;
      }
    }

    // GeoLOD
    //
    if (n.name () == "GeoLOD" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoLOD_type > r (
        GeoLOD_traits::create (i, f, this));

      if (!this->GeoLOD ())
      {
        this->GeoLOD (r);
        continue;
      }
    }

    // GeoPositionInterpolator
    //
    if (n.name () == "GeoPositionInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoPositionInterpolator_type > r (
        GeoPositionInterpolator_traits::create (i, f, this));

      if (!this->GeoPositionInterpolator ())
      {
        this->GeoPositionInterpolator (r);
        continue;
      }
    }

    // GeoTouchSensor
    //
    if (n.name () == "GeoTouchSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoTouchSensor_type > r (
        GeoTouchSensor_traits::create (i, f, this));

      if (!this->GeoTouchSensor ())
      {
        this->GeoTouchSensor (r);
        continue;
      }
    }

    // GeoViewpoint
    //
    if (n.name () == "GeoViewpoint" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoViewpoint_type > r (
        GeoViewpoint_traits::create (i, f, this));

      if (!this->GeoViewpoint ())
      {
        this->GeoViewpoint (r);
        continue;
      }
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      if (!this->ProtoInstance ())
      {
        this->ProtoInstance (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< url_type > r (
        url_traits::create (i, f, this));

      this->url (r);
      continue;
    }

    if (n.name () == "data" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< data_type > r (
        data_traits::create (i, f, this));

      this->data (r);
      continue;
    }

    if (n.name () == "summary" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< summary_type > r (
        summary_traits::create (i, f, this));

      this->summary (r);
      continue;
    }
  }
}

GeoMetadata* GeoMetadata::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new GeoMetadata (*this, f, c);
}

GeoMetadata::
~GeoMetadata ()
{
}

// GeoOrigin
//

const GeoOrigin::geoSystem_type GeoOrigin::geoSystem_default_value_ (
  ::std::string ("\"GD\" \"WE\""), 0, 0, 0);

const GeoOrigin::geoCoords_type GeoOrigin::geoCoords_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const GeoOrigin::rotateYUp_type GeoOrigin::rotateYUp_default_value_ (
  ::std::string ("false"), 0, 0, 0);

const GeoOrigin::containerField_type GeoOrigin::containerField_default_value_ (
  ::std::string ("geoOrigin"), 0, 0, 0);

GeoOrigin::
GeoOrigin ()
: ::X3DNode (),
  geoSystem_ (geoSystem_default_value (), ::xml_schema::flags (), this),
  geoCoords_ (geoCoords_default_value (), ::xml_schema::flags (), this),
  rotateYUp_ (rotateYUp_default_value (), ::xml_schema::flags (), this),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

GeoOrigin::
GeoOrigin (const GeoOrigin& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DNode (x, f, c),
  geoSystem_ (x.geoSystem_, f, this),
  geoCoords_ (x.geoCoords_, f, this),
  rotateYUp_ (x.rotateYUp_, f, this),
  containerField_ (x.containerField_, f, this)
{
}

GeoOrigin::
GeoOrigin (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DNode (e, f | ::xml_schema::flags::base, c),
  geoSystem_ (f, this),
  geoCoords_ (f, this),
  rotateYUp_ (f, this),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void GeoOrigin::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "geoSystem" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< geoSystem_type > r (
        geoSystem_traits::create (i, f, this));

      this->geoSystem (r);
      continue;
    }

    if (n.name () == "geoCoords" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< geoCoords_type > r (
        geoCoords_traits::create (i, f, this));

      this->geoCoords (r);
      continue;
    }

    if (n.name () == "rotateYUp" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rotateYUp_type > r (
        rotateYUp_traits::create (i, f, this));

      this->rotateYUp (r);
      continue;
    }

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!geoSystem_.present ())
  {
    ::std::auto_ptr< geoSystem_type > r (
      geoSystem_traits::create (
        ::std::string ("\"GD\" \"WE\""),
        &p.element (), f, this));

    this->geoSystem (r);
  }

  if (!geoCoords_.present ())
  {
    ::std::auto_ptr< geoCoords_type > r (
      geoCoords_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->geoCoords (r);
  }

  if (!rotateYUp_.present ())
  {
    ::std::auto_ptr< rotateYUp_type > r (
      rotateYUp_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->rotateYUp (r);
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("geoOrigin"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

GeoOrigin* GeoOrigin::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new GeoOrigin (*this, f, c);
}

GeoOrigin::
~GeoOrigin ()
{
}

// GeoPositionInterpolator
//

const GeoPositionInterpolator::geoSystem_type GeoPositionInterpolator::geoSystem_default_value_ (
  ::std::string ("\"GD\" \"WE\""), 0, 0, 0);

GeoPositionInterpolator::
GeoPositionInterpolator ()
: ::X3DInterpolatorNode (),
  GeoOrigin_ (::xml_schema::flags (), this),
  geoSystem_ (geoSystem_default_value (), ::xml_schema::flags (), this),
  keyValue_ (::xml_schema::flags (), this)
{
}

GeoPositionInterpolator::
GeoPositionInterpolator (const GeoPositionInterpolator& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::X3DInterpolatorNode (x, f, c),
  GeoOrigin_ (x.GeoOrigin_, f, this),
  geoSystem_ (x.geoSystem_, f, this),
  keyValue_ (x.keyValue_, f, this)
{
}

GeoPositionInterpolator::
GeoPositionInterpolator (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::X3DInterpolatorNode (e, f | ::xml_schema::flags::base, c),
  GeoOrigin_ (f, this),
  geoSystem_ (f, this),
  keyValue_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void GeoPositionInterpolator::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DInterpolatorNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // GeoOrigin
    //
    if (n.name () == "GeoOrigin" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoOrigin_type > r (
        GeoOrigin_traits::create (i, f, this));

      if (!this->GeoOrigin ())
      {
        this->GeoOrigin (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "geoSystem" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< geoSystem_type > r (
        geoSystem_traits::create (i, f, this));

      this->geoSystem (r);
      continue;
    }

    if (n.name () == "keyValue" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< keyValue_type > r (
        keyValue_traits::create (i, f, this));

      this->keyValue (r);
      continue;
    }
  }

  if (!geoSystem_.present ())
  {
    ::std::auto_ptr< geoSystem_type > r (
      geoSystem_traits::create (
        ::std::string ("\"GD\" \"WE\""),
        &p.element (), f, this));

    this->geoSystem (r);
  }
}

GeoPositionInterpolator* GeoPositionInterpolator::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new GeoPositionInterpolator (*this, f, c);
}

GeoPositionInterpolator::
~GeoPositionInterpolator ()
{
}

// GeoTouchSensor
//

const GeoTouchSensor::geoSystem_type GeoTouchSensor::geoSystem_default_value_ (
  ::std::string ("\"GD\" \"WE\""), 0, 0, 0);

GeoTouchSensor::
GeoTouchSensor ()
: ::X3DTouchSensorNode (),
  GeoOrigin_ (::xml_schema::flags (), this),
  geoSystem_ (geoSystem_default_value (), ::xml_schema::flags (), this)
{
}

GeoTouchSensor::
GeoTouchSensor (const GeoTouchSensor& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DTouchSensorNode (x, f, c),
  GeoOrigin_ (x.GeoOrigin_, f, this),
  geoSystem_ (x.geoSystem_, f, this)
{
}

GeoTouchSensor::
GeoTouchSensor (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DTouchSensorNode (e, f | ::xml_schema::flags::base, c),
  GeoOrigin_ (f, this),
  geoSystem_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void GeoTouchSensor::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTouchSensorNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // GeoOrigin
    //
    if (n.name () == "GeoOrigin" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoOrigin_type > r (
        GeoOrigin_traits::create (i, f, this));

      if (!this->GeoOrigin ())
      {
        this->GeoOrigin (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "geoSystem" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< geoSystem_type > r (
        geoSystem_traits::create (i, f, this));

      this->geoSystem (r);
      continue;
    }
  }

  if (!geoSystem_.present ())
  {
    ::std::auto_ptr< geoSystem_type > r (
      geoSystem_traits::create (
        ::std::string ("\"GD\" \"WE\""),
        &p.element (), f, this));

    this->geoSystem (r);
  }
}

GeoTouchSensor* GeoTouchSensor::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new GeoTouchSensor (*this, f, c);
}

GeoTouchSensor::
~GeoTouchSensor ()
{
}

// GeoViewpoint
//

const GeoViewpoint::geoSystem_type GeoViewpoint::geoSystem_default_value_ (
  ::std::string ("\"GD\" \"WE\""), 0, 0, 0);

const GeoViewpoint::fieldOfView_type GeoViewpoint::fieldOfView_default_value_ (
  ::std::string ("0.785398"), 0, 0, 0);

const GeoViewpoint::jump_type GeoViewpoint::jump_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const GeoViewpoint::orientation_type GeoViewpoint::orientation_default_value_ (
  ::std::string ("0 0 1 0"), 0, 0, 0);

const GeoViewpoint::position_type GeoViewpoint::position_default_value_ (
  ::std::string ("0 0 100000"), 0, 0, 0);

const GeoViewpoint::headlight_type GeoViewpoint::headlight_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const GeoViewpoint::navType_type GeoViewpoint::navType_default_value_ (
  ::std::string ("\"EXAMINE\" \"ANY\""), 0, 0, 0);

const GeoViewpoint::speedFactor_type GeoViewpoint::speedFactor_default_value_ (
  ::std::string ("1.0"), 0, 0, 0);

GeoViewpoint::
GeoViewpoint ()
: ::X3DBindableNode (),
  GeoOrigin_ (::xml_schema::flags (), this),
  geoSystem_ (geoSystem_default_value (), ::xml_schema::flags (), this),
  fieldOfView_ (fieldOfView_default_value (), ::xml_schema::flags (), this),
  jump_ (jump_default_value (), ::xml_schema::flags (), this),
  orientation_ (orientation_default_value (), ::xml_schema::flags (), this),
  position_ (position_default_value (), ::xml_schema::flags (), this),
  description_ (::xml_schema::flags (), this),
  headlight_ (headlight_default_value (), ::xml_schema::flags (), this),
  navType_ (navType_default_value (), ::xml_schema::flags (), this),
  speedFactor_ (speedFactor_default_value (), ::xml_schema::flags (), this)
{
}

GeoViewpoint::
GeoViewpoint (const GeoViewpoint& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DBindableNode (x, f, c),
  GeoOrigin_ (x.GeoOrigin_, f, this),
  geoSystem_ (x.geoSystem_, f, this),
  fieldOfView_ (x.fieldOfView_, f, this),
  jump_ (x.jump_, f, this),
  orientation_ (x.orientation_, f, this),
  position_ (x.position_, f, this),
  description_ (x.description_, f, this),
  headlight_ (x.headlight_, f, this),
  navType_ (x.navType_, f, this),
  speedFactor_ (x.speedFactor_, f, this)
{
}

GeoViewpoint::
GeoViewpoint (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DBindableNode (e, f | ::xml_schema::flags::base, c),
  GeoOrigin_ (f, this),
  geoSystem_ (f, this),
  fieldOfView_ (f, this),
  jump_ (f, this),
  orientation_ (f, this),
  position_ (f, this),
  description_ (f, this),
  headlight_ (f, this),
  navType_ (f, this),
  speedFactor_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void GeoViewpoint::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DBindableNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // GeoOrigin
    //
    if (n.name () == "GeoOrigin" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoOrigin_type > r (
        GeoOrigin_traits::create (i, f, this));

      if (!this->GeoOrigin ())
      {
        this->GeoOrigin (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "geoSystem" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< geoSystem_type > r (
        geoSystem_traits::create (i, f, this));

      this->geoSystem (r);
      continue;
    }

    if (n.name () == "fieldOfView" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< fieldOfView_type > r (
        fieldOfView_traits::create (i, f, this));

      this->fieldOfView (r);
      continue;
    }

    if (n.name () == "jump" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< jump_type > r (
        jump_traits::create (i, f, this));

      this->jump (r);
      continue;
    }

    if (n.name () == "orientation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< orientation_type > r (
        orientation_traits::create (i, f, this));

      this->orientation (r);
      continue;
    }

    if (n.name () == "position" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< position_type > r (
        position_traits::create (i, f, this));

      this->position (r);
      continue;
    }

    if (n.name () == "description" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< description_type > r (
        description_traits::create (i, f, this));

      this->description (r);
      continue;
    }

    if (n.name () == "headlight" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< headlight_type > r (
        headlight_traits::create (i, f, this));

      this->headlight (r);
      continue;
    }

    if (n.name () == "navType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< navType_type > r (
        navType_traits::create (i, f, this));

      this->navType (r);
      continue;
    }

    if (n.name () == "speedFactor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< speedFactor_type > r (
        speedFactor_traits::create (i, f, this));

      this->speedFactor (r);
      continue;
    }
  }

  if (!geoSystem_.present ())
  {
    ::std::auto_ptr< geoSystem_type > r (
      geoSystem_traits::create (
        ::std::string ("\"GD\" \"WE\""),
        &p.element (), f, this));

    this->geoSystem (r);
  }

  if (!fieldOfView_.present ())
  {
    ::std::auto_ptr< fieldOfView_type > r (
      fieldOfView_traits::create (
        ::std::string ("0.785398"),
        &p.element (), f, this));

    this->fieldOfView (r);
  }

  if (!jump_.present ())
  {
    ::std::auto_ptr< jump_type > r (
      jump_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->jump (r);
  }

  if (!orientation_.present ())
  {
    ::std::auto_ptr< orientation_type > r (
      orientation_traits::create (
        ::std::string ("0 0 1 0"),
        &p.element (), f, this));

    this->orientation (r);
  }

  if (!position_.present ())
  {
    ::std::auto_ptr< position_type > r (
      position_traits::create (
        ::std::string ("0 0 100000"),
        &p.element (), f, this));

    this->position (r);
  }

  if (!headlight_.present ())
  {
    ::std::auto_ptr< headlight_type > r (
      headlight_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->headlight (r);
  }

  if (!navType_.present ())
  {
    ::std::auto_ptr< navType_type > r (
      navType_traits::create (
        ::std::string ("\"EXAMINE\" \"ANY\""),
        &p.element (), f, this));

    this->navType (r);
  }

  if (!speedFactor_.present ())
  {
    ::std::auto_ptr< speedFactor_type > r (
      speedFactor_traits::create (
        ::std::string ("1.0"),
        &p.element (), f, this));

    this->speedFactor (r);
  }
}

GeoViewpoint* GeoViewpoint::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new GeoViewpoint (*this, f, c);
}

GeoViewpoint::
~GeoViewpoint ()
{
}

// HAnimDisplacer
//

const HAnimDisplacer::weight_type HAnimDisplacer::weight_default_value_ (
  ::std::string ("0.0"), 0, 0, 0);

const HAnimDisplacer::containerField_type HAnimDisplacer::containerField_default_value_ (
  ::std::string ("displacers"), 0, 0, 0);

HAnimDisplacer::
HAnimDisplacer ()
: ::X3DGeometricPropertyNode (),
  name_ (::xml_schema::flags (), this),
  coordIndex_ (::xml_schema::flags (), this),
  displacements_ (::xml_schema::flags (), this),
  weight_ (weight_default_value (), ::xml_schema::flags (), this),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

HAnimDisplacer::
HAnimDisplacer (const HAnimDisplacer& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DGeometricPropertyNode (x, f, c),
  name_ (x.name_, f, this),
  coordIndex_ (x.coordIndex_, f, this),
  displacements_ (x.displacements_, f, this),
  weight_ (x.weight_, f, this),
  containerField_ (x.containerField_, f, this)
{
}

HAnimDisplacer::
HAnimDisplacer (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DGeometricPropertyNode (e, f | ::xml_schema::flags::base, c),
  name_ (f, this),
  coordIndex_ (f, this),
  displacements_ (f, this),
  weight_ (f, this),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void HAnimDisplacer::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGeometricPropertyNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name (r);
      continue;
    }

    if (n.name () == "coordIndex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< coordIndex_type > r (
        coordIndex_traits::create (i, f, this));

      this->coordIndex (r);
      continue;
    }

    if (n.name () == "displacements" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< displacements_type > r (
        displacements_traits::create (i, f, this));

      this->displacements (r);
      continue;
    }

    if (n.name () == "weight" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< weight_type > r (
        weight_traits::create (i, f, this));

      this->weight (r);
      continue;
    }

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!weight_.present ())
  {
    ::std::auto_ptr< weight_type > r (
      weight_traits::create (
        ::std::string ("0.0"),
        &p.element (), f, this));

    this->weight (r);
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("displacers"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

HAnimDisplacer* HAnimDisplacer::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new HAnimDisplacer (*this, f, c);
}

HAnimDisplacer::
~HAnimDisplacer ()
{
}

// HAnimHumanoid
//

const HAnimHumanoid::center_type HAnimHumanoid::center_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const HAnimHumanoid::rotation_type HAnimHumanoid::rotation_default_value_ (
  ::std::string ("0 0 1 0"), 0, 0, 0);

const HAnimHumanoid::scale_type HAnimHumanoid::scale_default_value_ (
  ::std::string ("1 1 1"), 0, 0, 0);

const HAnimHumanoid::scaleOrientation_type HAnimHumanoid::scaleOrientation_default_value_ (
  ::std::string ("0 0 1 0"), 0, 0, 0);

const HAnimHumanoid::translation_type HAnimHumanoid::translation_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

HAnimHumanoid::
HAnimHumanoid ()
: ::X3DHumanoidNode (),
  Appearance_ (::xml_schema::flags (), this),
  Background_ (::xml_schema::flags (), this),
  ColorInterpolator_ (::xml_schema::flags (), this),
  CoordinateInterpolator_ (::xml_schema::flags (), this),
  DirectionalLight_ (::xml_schema::flags (), this),
  Group_ (::xml_schema::flags (), this),
  NavigationInfo_ (::xml_schema::flags (), this),
  NormalInterpolator_ (::xml_schema::flags (), this),
  OrientationInterpolator_ (::xml_schema::flags (), this),
  PositionInterpolator_ (::xml_schema::flags (), this),
  ScalarInterpolator_ (::xml_schema::flags (), this),
  Shape_ (::xml_schema::flags (), this),
  TimeSensor_ (::xml_schema::flags (), this),
  Transform_ (::xml_schema::flags (), this),
  Viewpoint_ (::xml_schema::flags (), this),
  WorldInfo_ (::xml_schema::flags (), this),
  Anchor_ (::xml_schema::flags (), this),
  BooleanFilter_ (::xml_schema::flags (), this),
  BooleanSequencer_ (::xml_schema::flags (), this),
  BooleanToggle_ (::xml_schema::flags (), this),
  BooleanTrigger_ (::xml_schema::flags (), this),
  CylinderSensor_ (::xml_schema::flags (), this),
  Inline_ (::xml_schema::flags (), this),
  IntegerSequencer_ (::xml_schema::flags (), this),
  IntegerTrigger_ (::xml_schema::flags (), this),
  KeySensor_ (::xml_schema::flags (), this),
  PlaneSensor_ (::xml_schema::flags (), this),
  PointLight_ (::xml_schema::flags (), this),
  ProximitySensor_ (::xml_schema::flags (), this),
  SphereSensor_ (::xml_schema::flags (), this),
  SpotLight_ (::xml_schema::flags (), this),
  StringSensor_ (::xml_schema::flags (), this),
  Switch_ (::xml_schema::flags (), this),
  TimeTrigger_ (::xml_schema::flags (), this),
  TouchSensor_ (::xml_schema::flags (), this),
  AudioClip_ (::xml_schema::flags (), this),
  Billboard_ (::xml_schema::flags (), this),
  Collision_ (::xml_schema::flags (), this),
  Fog_ (::xml_schema::flags (), this),
  LoadSensor_ (::xml_schema::flags (), this),
  LocalFog_ (::xml_schema::flags (), this),
  LOD_ (::xml_schema::flags (), this),
  Script_ (::xml_schema::flags (), this),
  Sound_ (::xml_schema::flags (), this),
  VisibilitySensor_ (::xml_schema::flags (), this),
  CoordinateInterpolator2D_ (::xml_schema::flags (), this),
  PositionInterpolator2D_ (::xml_schema::flags (), this),
  StaticGroup_ (::xml_schema::flags (), this),
  CADAssembly_ (::xml_schema::flags (), this),
  CADLayer_ (::xml_schema::flags (), this),
  EspduTransform_ (::xml_schema::flags (), this),
  ReceiverPdu_ (::xml_schema::flags (), this),
  SignalPdu_ (::xml_schema::flags (), this),
  TransmitterPdu_ (::xml_schema::flags (), this),
  GeoLocation_ (::xml_schema::flags (), this),
  GeoLOD_ (::xml_schema::flags (), this),
  GeoMetadata_ (::xml_schema::flags (), this),
  GeoOrigin_ (::xml_schema::flags (), this),
  GeoPositionInterpolator_ (::xml_schema::flags (), this),
  GeoTouchSensor_ (::xml_schema::flags (), this),
  GeoViewpoint_ (::xml_schema::flags (), this),
  HAnimHumanoid1_ (::xml_schema::flags (), this),
  HAnimJoint_ (::xml_schema::flags (), this),
  HAnimSegment_ (::xml_schema::flags (), this),
  HAnimSite_ (::xml_schema::flags (), this),
  NurbsOrientationInterpolator_ (::xml_schema::flags (), this),
  NurbsPositionInterpolator_ (::xml_schema::flags (), this),
  NurbsSurfaceInterpolator_ (::xml_schema::flags (), this),
  NurbsSet_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  Coordinate_ (::xml_schema::flags (), this),
  CoordinateDouble_ (::xml_schema::flags (), this),
  Normal_ (::xml_schema::flags (), this),
  name_ (::xml_schema::flags (), this),
  center_ (center_default_value (), ::xml_schema::flags (), this),
  rotation_ (rotation_default_value (), ::xml_schema::flags (), this),
  scale_ (scale_default_value (), ::xml_schema::flags (), this),
  scaleOrientation_ (scaleOrientation_default_value (), ::xml_schema::flags (), this),
  translation_ (translation_default_value (), ::xml_schema::flags (), this),
  info_ (::xml_schema::flags (), this),
  version_ (::xml_schema::flags (), this)
{
}

HAnimHumanoid::
HAnimHumanoid (const HAnimHumanoid& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DHumanoidNode (x, f, c),
  Appearance_ (x.Appearance_, f, this),
  Background_ (x.Background_, f, this),
  ColorInterpolator_ (x.ColorInterpolator_, f, this),
  CoordinateInterpolator_ (x.CoordinateInterpolator_, f, this),
  DirectionalLight_ (x.DirectionalLight_, f, this),
  Group_ (x.Group_, f, this),
  NavigationInfo_ (x.NavigationInfo_, f, this),
  NormalInterpolator_ (x.NormalInterpolator_, f, this),
  OrientationInterpolator_ (x.OrientationInterpolator_, f, this),
  PositionInterpolator_ (x.PositionInterpolator_, f, this),
  ScalarInterpolator_ (x.ScalarInterpolator_, f, this),
  Shape_ (x.Shape_, f, this),
  TimeSensor_ (x.TimeSensor_, f, this),
  Transform_ (x.Transform_, f, this),
  Viewpoint_ (x.Viewpoint_, f, this),
  WorldInfo_ (x.WorldInfo_, f, this),
  Anchor_ (x.Anchor_, f, this),
  BooleanFilter_ (x.BooleanFilter_, f, this),
  BooleanSequencer_ (x.BooleanSequencer_, f, this),
  BooleanToggle_ (x.BooleanToggle_, f, this),
  BooleanTrigger_ (x.BooleanTrigger_, f, this),
  CylinderSensor_ (x.CylinderSensor_, f, this),
  Inline_ (x.Inline_, f, this),
  IntegerSequencer_ (x.IntegerSequencer_, f, this),
  IntegerTrigger_ (x.IntegerTrigger_, f, this),
  KeySensor_ (x.KeySensor_, f, this),
  PlaneSensor_ (x.PlaneSensor_, f, this),
  PointLight_ (x.PointLight_, f, this),
  ProximitySensor_ (x.ProximitySensor_, f, this),
  SphereSensor_ (x.SphereSensor_, f, this),
  SpotLight_ (x.SpotLight_, f, this),
  StringSensor_ (x.StringSensor_, f, this),
  Switch_ (x.Switch_, f, this),
  TimeTrigger_ (x.TimeTrigger_, f, this),
  TouchSensor_ (x.TouchSensor_, f, this),
  AudioClip_ (x.AudioClip_, f, this),
  Billboard_ (x.Billboard_, f, this),
  Collision_ (x.Collision_, f, this),
  Fog_ (x.Fog_, f, this),
  LoadSensor_ (x.LoadSensor_, f, this),
  LocalFog_ (x.LocalFog_, f, this),
  LOD_ (x.LOD_, f, this),
  Script_ (x.Script_, f, this),
  Sound_ (x.Sound_, f, this),
  VisibilitySensor_ (x.VisibilitySensor_, f, this),
  CoordinateInterpolator2D_ (x.CoordinateInterpolator2D_, f, this),
  PositionInterpolator2D_ (x.PositionInterpolator2D_, f, this),
  StaticGroup_ (x.StaticGroup_, f, this),
  CADAssembly_ (x.CADAssembly_, f, this),
  CADLayer_ (x.CADLayer_, f, this),
  EspduTransform_ (x.EspduTransform_, f, this),
  ReceiverPdu_ (x.ReceiverPdu_, f, this),
  SignalPdu_ (x.SignalPdu_, f, this),
  TransmitterPdu_ (x.TransmitterPdu_, f, this),
  GeoLocation_ (x.GeoLocation_, f, this),
  GeoLOD_ (x.GeoLOD_, f, this),
  GeoMetadata_ (x.GeoMetadata_, f, this),
  GeoOrigin_ (x.GeoOrigin_, f, this),
  GeoPositionInterpolator_ (x.GeoPositionInterpolator_, f, this),
  GeoTouchSensor_ (x.GeoTouchSensor_, f, this),
  GeoViewpoint_ (x.GeoViewpoint_, f, this),
  HAnimHumanoid1_ (x.HAnimHumanoid1_, f, this),
  HAnimJoint_ (x.HAnimJoint_, f, this),
  HAnimSegment_ (x.HAnimSegment_, f, this),
  HAnimSite_ (x.HAnimSite_, f, this),
  NurbsOrientationInterpolator_ (x.NurbsOrientationInterpolator_, f, this),
  NurbsPositionInterpolator_ (x.NurbsPositionInterpolator_, f, this),
  NurbsSurfaceInterpolator_ (x.NurbsSurfaceInterpolator_, f, this),
  NurbsSet_ (x.NurbsSet_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  Coordinate_ (x.Coordinate_, f, this),
  CoordinateDouble_ (x.CoordinateDouble_, f, this),
  Normal_ (x.Normal_, f, this),
  name_ (x.name_, f, this),
  center_ (x.center_, f, this),
  rotation_ (x.rotation_, f, this),
  scale_ (x.scale_, f, this),
  scaleOrientation_ (x.scaleOrientation_, f, this),
  translation_ (x.translation_, f, this),
  info_ (x.info_, f, this),
  version_ (x.version_, f, this)
{
}

HAnimHumanoid::
HAnimHumanoid (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DHumanoidNode (e, f | ::xml_schema::flags::base, c),
  Appearance_ (f, this),
  Background_ (f, this),
  ColorInterpolator_ (f, this),
  CoordinateInterpolator_ (f, this),
  DirectionalLight_ (f, this),
  Group_ (f, this),
  NavigationInfo_ (f, this),
  NormalInterpolator_ (f, this),
  OrientationInterpolator_ (f, this),
  PositionInterpolator_ (f, this),
  ScalarInterpolator_ (f, this),
  Shape_ (f, this),
  TimeSensor_ (f, this),
  Transform_ (f, this),
  Viewpoint_ (f, this),
  WorldInfo_ (f, this),
  Anchor_ (f, this),
  BooleanFilter_ (f, this),
  BooleanSequencer_ (f, this),
  BooleanToggle_ (f, this),
  BooleanTrigger_ (f, this),
  CylinderSensor_ (f, this),
  Inline_ (f, this),
  IntegerSequencer_ (f, this),
  IntegerTrigger_ (f, this),
  KeySensor_ (f, this),
  PlaneSensor_ (f, this),
  PointLight_ (f, this),
  ProximitySensor_ (f, this),
  SphereSensor_ (f, this),
  SpotLight_ (f, this),
  StringSensor_ (f, this),
  Switch_ (f, this),
  TimeTrigger_ (f, this),
  TouchSensor_ (f, this),
  AudioClip_ (f, this),
  Billboard_ (f, this),
  Collision_ (f, this),
  Fog_ (f, this),
  LoadSensor_ (f, this),
  LocalFog_ (f, this),
  LOD_ (f, this),
  Script_ (f, this),
  Sound_ (f, this),
  VisibilitySensor_ (f, this),
  CoordinateInterpolator2D_ (f, this),
  PositionInterpolator2D_ (f, this),
  StaticGroup_ (f, this),
  CADAssembly_ (f, this),
  CADLayer_ (f, this),
  EspduTransform_ (f, this),
  ReceiverPdu_ (f, this),
  SignalPdu_ (f, this),
  TransmitterPdu_ (f, this),
  GeoLocation_ (f, this),
  GeoLOD_ (f, this),
  GeoMetadata_ (f, this),
  GeoOrigin_ (f, this),
  GeoPositionInterpolator_ (f, this),
  GeoTouchSensor_ (f, this),
  GeoViewpoint_ (f, this),
  HAnimHumanoid1_ (f, this),
  HAnimJoint_ (f, this),
  HAnimSegment_ (f, this),
  HAnimSite_ (f, this),
  NurbsOrientationInterpolator_ (f, this),
  NurbsPositionInterpolator_ (f, this),
  NurbsSurfaceInterpolator_ (f, this),
  NurbsSet_ (f, this),
  ProtoInstance_ (f, this),
  Coordinate_ (f, this),
  CoordinateDouble_ (f, this),
  Normal_ (f, this),
  name_ (f, this),
  center_ (f, this),
  rotation_ (f, this),
  scale_ (f, this),
  scaleOrientation_ (f, this),
  translation_ (f, this),
  info_ (f, this),
  version_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void HAnimHumanoid::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DHumanoidNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Appearance
    //
    if (n.name () == "Appearance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Appearance_type > r (
        Appearance_traits::create (i, f, this));

      this->Appearance ().push_back (r);
      continue;
    }

    // Background
    //
    if (n.name () == "Background" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Background_type > r (
        Background_traits::create (i, f, this));

      this->Background ().push_back (r);
      continue;
    }

    // ColorInterpolator
    //
    if (n.name () == "ColorInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ColorInterpolator_type > r (
        ColorInterpolator_traits::create (i, f, this));

      this->ColorInterpolator ().push_back (r);
      continue;
    }

    // CoordinateInterpolator
    //
    if (n.name () == "CoordinateInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateInterpolator_type > r (
        CoordinateInterpolator_traits::create (i, f, this));

      this->CoordinateInterpolator ().push_back (r);
      continue;
    }

    // DirectionalLight
    //
    if (n.name () == "DirectionalLight" && n.namespace_ () == "")
    {
      ::std::auto_ptr< DirectionalLight_type > r (
        DirectionalLight_traits::create (i, f, this));

      this->DirectionalLight ().push_back (r);
      continue;
    }

    // Group
    //
    if (n.name () == "Group" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Group_type > r (
        Group_traits::create (i, f, this));

      this->Group ().push_back (r);
      continue;
    }

    // NavigationInfo
    //
    if (n.name () == "NavigationInfo" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NavigationInfo_type > r (
        NavigationInfo_traits::create (i, f, this));

      this->NavigationInfo ().push_back (r);
      continue;
    }

    // NormalInterpolator
    //
    if (n.name () == "NormalInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NormalInterpolator_type > r (
        NormalInterpolator_traits::create (i, f, this));

      this->NormalInterpolator ().push_back (r);
      continue;
    }

    // OrientationInterpolator
    //
    if (n.name () == "OrientationInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< OrientationInterpolator_type > r (
        OrientationInterpolator_traits::create (i, f, this));

      this->OrientationInterpolator ().push_back (r);
      continue;
    }

    // PositionInterpolator
    //
    if (n.name () == "PositionInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PositionInterpolator_type > r (
        PositionInterpolator_traits::create (i, f, this));

      this->PositionInterpolator ().push_back (r);
      continue;
    }

    // ScalarInterpolator
    //
    if (n.name () == "ScalarInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ScalarInterpolator_type > r (
        ScalarInterpolator_traits::create (i, f, this));

      this->ScalarInterpolator ().push_back (r);
      continue;
    }

    // Shape
    //
    if (n.name () == "Shape" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Shape_type > r (
        Shape_traits::create (i, f, this));

      this->Shape ().push_back (r);
      continue;
    }

    // TimeSensor
    //
    if (n.name () == "TimeSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TimeSensor_type > r (
        TimeSensor_traits::create (i, f, this));

      this->TimeSensor ().push_back (r);
      continue;
    }

    // Transform
    //
    if (n.name () == "Transform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Transform_type > r (
        Transform_traits::create (i, f, this));

      this->Transform ().push_back (r);
      continue;
    }

    // Viewpoint
    //
    if (n.name () == "Viewpoint" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Viewpoint_type > r (
        Viewpoint_traits::create (i, f, this));

      this->Viewpoint ().push_back (r);
      continue;
    }

    // WorldInfo
    //
    if (n.name () == "WorldInfo" && n.namespace_ () == "")
    {
      ::std::auto_ptr< WorldInfo_type > r (
        WorldInfo_traits::create (i, f, this));

      this->WorldInfo ().push_back (r);
      continue;
    }

    // Anchor
    //
    if (n.name () == "Anchor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Anchor_type > r (
        Anchor_traits::create (i, f, this));

      this->Anchor ().push_back (r);
      continue;
    }

    // BooleanFilter
    //
    if (n.name () == "BooleanFilter" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanFilter_type > r (
        BooleanFilter_traits::create (i, f, this));

      this->BooleanFilter ().push_back (r);
      continue;
    }

    // BooleanSequencer
    //
    if (n.name () == "BooleanSequencer" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanSequencer_type > r (
        BooleanSequencer_traits::create (i, f, this));

      this->BooleanSequencer ().push_back (r);
      continue;
    }

    // BooleanToggle
    //
    if (n.name () == "BooleanToggle" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanToggle_type > r (
        BooleanToggle_traits::create (i, f, this));

      this->BooleanToggle ().push_back (r);
      continue;
    }

    // BooleanTrigger
    //
    if (n.name () == "BooleanTrigger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< BooleanTrigger_type > r (
        BooleanTrigger_traits::create (i, f, this));

      this->BooleanTrigger ().push_back (r);
      continue;
    }

    // CylinderSensor
    //
    if (n.name () == "CylinderSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CylinderSensor_type > r (
        CylinderSensor_traits::create (i, f, this));

      this->CylinderSensor ().push_back (r);
      continue;
    }

    // Inline
    //
    if (n.name () == "Inline" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Inline_type > r (
        Inline_traits::create (i, f, this));

      this->Inline ().push_back (r);
      continue;
    }

    // IntegerSequencer
    //
    if (n.name () == "IntegerSequencer" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IntegerSequencer_type > r (
        IntegerSequencer_traits::create (i, f, this));

      this->IntegerSequencer ().push_back (r);
      continue;
    }

    // IntegerTrigger
    //
    if (n.name () == "IntegerTrigger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< IntegerTrigger_type > r (
        IntegerTrigger_traits::create (i, f, this));

      this->IntegerTrigger ().push_back (r);
      continue;
    }

    // KeySensor
    //
    if (n.name () == "KeySensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< KeySensor_type > r (
        KeySensor_traits::create (i, f, this));

      this->KeySensor ().push_back (r);
      continue;
    }

    // PlaneSensor
    //
    if (n.name () == "PlaneSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PlaneSensor_type > r (
        PlaneSensor_traits::create (i, f, this));

      this->PlaneSensor ().push_back (r);
      continue;
    }

    // PointLight
    //
    if (n.name () == "PointLight" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PointLight_type > r (
        PointLight_traits::create (i, f, this));

      this->PointLight ().push_back (r);
      continue;
    }

    // ProximitySensor
    //
    if (n.name () == "ProximitySensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProximitySensor_type > r (
        ProximitySensor_traits::create (i, f, this));

      this->ProximitySensor ().push_back (r);
      continue;
    }

    // SphereSensor
    //
    if (n.name () == "SphereSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< SphereSensor_type > r (
        SphereSensor_traits::create (i, f, this));

      this->SphereSensor ().push_back (r);
      continue;
    }

    // SpotLight
    //
    if (n.name () == "SpotLight" && n.namespace_ () == "")
    {
      ::std::auto_ptr< SpotLight_type > r (
        SpotLight_traits::create (i, f, this));

      this->SpotLight ().push_back (r);
      continue;
    }

    // StringSensor
    //
    if (n.name () == "StringSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< StringSensor_type > r (
        StringSensor_traits::create (i, f, this));

      this->StringSensor ().push_back (r);
      continue;
    }

    // Switch
    //
    if (n.name () == "Switch" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Switch_type > r (
        Switch_traits::create (i, f, this));

      this->Switch ().push_back (r);
      continue;
    }

    // TimeTrigger
    //
    if (n.name () == "TimeTrigger" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TimeTrigger_type > r (
        TimeTrigger_traits::create (i, f, this));

      this->TimeTrigger ().push_back (r);
      continue;
    }

    // TouchSensor
    //
    if (n.name () == "TouchSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TouchSensor_type > r (
        TouchSensor_traits::create (i, f, this));

      this->TouchSensor ().push_back (r);
      continue;
    }

    // AudioClip
    //
    if (n.name () == "AudioClip" && n.namespace_ () == "")
    {
      ::std::auto_ptr< AudioClip_type > r (
        AudioClip_traits::create (i, f, this));

      this->AudioClip ().push_back (r);
      continue;
    }

    // Billboard
    //
    if (n.name () == "Billboard" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Billboard_type > r (
        Billboard_traits::create (i, f, this));

      this->Billboard ().push_back (r);
      continue;
    }

    // Collision
    //
    if (n.name () == "Collision" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Collision_type > r (
        Collision_traits::create (i, f, this));

      this->Collision ().push_back (r);
      continue;
    }

    // Fog
    //
    if (n.name () == "Fog" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Fog_type > r (
        Fog_traits::create (i, f, this));

      this->Fog ().push_back (r);
      continue;
    }

    // LoadSensor
    //
    if (n.name () == "LoadSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LoadSensor_type > r (
        LoadSensor_traits::create (i, f, this));

      this->LoadSensor ().push_back (r);
      continue;
    }

    // LocalFog
    //
    if (n.name () == "LocalFog" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LocalFog_type > r (
        LocalFog_traits::create (i, f, this));

      this->LocalFog ().push_back (r);
      continue;
    }

    // LOD
    //
    if (n.name () == "LOD" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LOD_type > r (
        LOD_traits::create (i, f, this));

      this->LOD ().push_back (r);
      continue;
    }

    // Script
    //
    if (n.name () == "Script" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Script_type > r (
        Script_traits::create (i, f, this));

      this->Script ().push_back (r);
      continue;
    }

    // Sound
    //
    if (n.name () == "Sound" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Sound_type > r (
        Sound_traits::create (i, f, this));

      this->Sound ().push_back (r);
      continue;
    }

    // VisibilitySensor
    //
    if (n.name () == "VisibilitySensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< VisibilitySensor_type > r (
        VisibilitySensor_traits::create (i, f, this));

      this->VisibilitySensor ().push_back (r);
      continue;
    }

    // CoordinateInterpolator2D
    //
    if (n.name () == "CoordinateInterpolator2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateInterpolator2D_type > r (
        CoordinateInterpolator2D_traits::create (i, f, this));

      this->CoordinateInterpolator2D ().push_back (r);
      continue;
    }

    // PositionInterpolator2D
    //
    if (n.name () == "PositionInterpolator2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PositionInterpolator2D_type > r (
        PositionInterpolator2D_traits::create (i, f, this));

      this->PositionInterpolator2D ().push_back (r);
      continue;
    }

    // StaticGroup
    //
    if (n.name () == "StaticGroup" && n.namespace_ () == "")
    {
      ::std::auto_ptr< StaticGroup_type > r (
        StaticGroup_traits::create (i, f, this));

      this->StaticGroup ().push_back (r);
      continue;
    }

    // CADAssembly
    //
    if (n.name () == "CADAssembly" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CADAssembly_type > r (
        CADAssembly_traits::create (i, f, this));

      this->CADAssembly ().push_back (r);
      continue;
    }

    // CADLayer
    //
    if (n.name () == "CADLayer" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CADLayer_type > r (
        CADLayer_traits::create (i, f, this));

      this->CADLayer ().push_back (r);
      continue;
    }

    // EspduTransform
    //
    if (n.name () == "EspduTransform" && n.namespace_ () == "")
    {
      ::std::auto_ptr< EspduTransform_type > r (
        EspduTransform_traits::create (i, f, this));

      this->EspduTransform ().push_back (r);
      continue;
    }

    // ReceiverPdu
    //
    if (n.name () == "ReceiverPdu" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ReceiverPdu_type > r (
        ReceiverPdu_traits::create (i, f, this));

      this->ReceiverPdu ().push_back (r);
      continue;
    }

    // SignalPdu
    //
    if (n.name () == "SignalPdu" && n.namespace_ () == "")
    {
      ::std::auto_ptr< SignalPdu_type > r (
        SignalPdu_traits::create (i, f, this));

      this->SignalPdu ().push_back (r);
      continue;
    }

    // TransmitterPdu
    //
    if (n.name () == "TransmitterPdu" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TransmitterPdu_type > r (
        TransmitterPdu_traits::create (i, f, this));

      this->TransmitterPdu ().push_back (r);
      continue;
    }

    // GeoLocation
    //
    if (n.name () == "GeoLocation" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoLocation_type > r (
        GeoLocation_traits::create (i, f, this));

      this->GeoLocation ().push_back (r);
      continue;
    }

    // GeoLOD
    //
    if (n.name () == "GeoLOD" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoLOD_type > r (
        GeoLOD_traits::create (i, f, this));

      this->GeoLOD ().push_back (r);
      continue;
    }

    // GeoMetadata
    //
    if (n.name () == "GeoMetadata" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoMetadata_type > r (
        GeoMetadata_traits::create (i, f, this));

      this->GeoMetadata ().push_back (r);
      continue;
    }

    // GeoOrigin
    //
    if (n.name () == "GeoOrigin" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoOrigin_type > r (
        GeoOrigin_traits::create (i, f, this));

      this->GeoOrigin ().push_back (r);
      continue;
    }

    // GeoPositionInterpolator
    //
    if (n.name () == "GeoPositionInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoPositionInterpolator_type > r (
        GeoPositionInterpolator_traits::create (i, f, this));

      this->GeoPositionInterpolator ().push_back (r);
      continue;
    }

    // GeoTouchSensor
    //
    if (n.name () == "GeoTouchSensor" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoTouchSensor_type > r (
        GeoTouchSensor_traits::create (i, f, this));

      this->GeoTouchSensor ().push_back (r);
      continue;
    }

    // GeoViewpoint
    //
    if (n.name () == "GeoViewpoint" && n.namespace_ () == "")
    {
      ::std::auto_ptr< GeoViewpoint_type > r (
        GeoViewpoint_traits::create (i, f, this));

      this->GeoViewpoint ().push_back (r);
      continue;
    }

    // HAnimHumanoid
    //
    if (n.name () == "HAnimHumanoid" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimHumanoid1_type > r (
        HAnimHumanoid1_traits::create (i, f, this));

      this->HAnimHumanoid1 ().push_back (r);
      continue;
    }

    // HAnimJoint
    //
    if (n.name () == "HAnimJoint" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimJoint_type > r (
        HAnimJoint_traits::create (i, f, this));

      this->HAnimJoint ().push_back (r);
      continue;
    }

    // HAnimSegment
    //
    if (n.name () == "HAnimSegment" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimSegment_type > r (
        HAnimSegment_traits::create (i, f, this));

      this->HAnimSegment ().push_back (r);
      continue;
    }

    // HAnimSite
    //
    if (n.name () == "HAnimSite" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimSite_type > r (
        HAnimSite_traits::create (i, f, this));

      this->HAnimSite ().push_back (r);
      continue;
    }

    // NurbsOrientationInterpolator
    //
    if (n.name () == "NurbsOrientationInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsOrientationInterpolator_type > r (
        NurbsOrientationInterpolator_traits::create (i, f, this));

      this->NurbsOrientationInterpolator ().push_back (r);
      continue;
    }

    // NurbsPositionInterpolator
    //
    if (n.name () == "NurbsPositionInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsPositionInterpolator_type > r (
        NurbsPositionInterpolator_traits::create (i, f, this));

      this->NurbsPositionInterpolator ().push_back (r);
      continue;
    }

    // NurbsSurfaceInterpolator
    //
    if (n.name () == "NurbsSurfaceInterpolator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSurfaceInterpolator_type > r (
        NurbsSurfaceInterpolator_traits::create (i, f, this));

      this->NurbsSurfaceInterpolator ().push_back (r);
      continue;
    }

    // NurbsSet
    //
    if (n.name () == "NurbsSet" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSet_type > r (
        NurbsSet_traits::create (i, f, this));

      this->NurbsSet ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    // Coordinate
    //
    if (n.name () == "Coordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Coordinate_type > r (
        Coordinate_traits::create (i, f, this));

      this->Coordinate ().push_back (r);
      continue;
    }

    // CoordinateDouble
    //
    if (n.name () == "CoordinateDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateDouble_type > r (
        CoordinateDouble_traits::create (i, f, this));

      this->CoordinateDouble ().push_back (r);
      continue;
    }

    // Normal
    //
    if (n.name () == "Normal" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Normal_type > r (
        Normal_traits::create (i, f, this));

      this->Normal ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name (r);
      continue;
    }

    if (n.name () == "center" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< center_type > r (
        center_traits::create (i, f, this));

      this->center (r);
      continue;
    }

    if (n.name () == "rotation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rotation_type > r (
        rotation_traits::create (i, f, this));

      this->rotation (r);
      continue;
    }

    if (n.name () == "scale" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< scale_type > r (
        scale_traits::create (i, f, this));

      this->scale (r);
      continue;
    }

    if (n.name () == "scaleOrientation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< scaleOrientation_type > r (
        scaleOrientation_traits::create (i, f, this));

      this->scaleOrientation (r);
      continue;
    }

    if (n.name () == "translation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< translation_type > r (
        translation_traits::create (i, f, this));

      this->translation (r);
      continue;
    }

    if (n.name () == "info" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< info_type > r (
        info_traits::create (i, f, this));

      this->info (r);
      continue;
    }

    if (n.name () == "version" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< version_type > r (
        version_traits::create (i, f, this));

      this->version (r);
      continue;
    }
  }

  if (!center_.present ())
  {
    ::std::auto_ptr< center_type > r (
      center_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->center (r);
  }

  if (!rotation_.present ())
  {
    ::std::auto_ptr< rotation_type > r (
      rotation_traits::create (
        ::std::string ("0 0 1 0"),
        &p.element (), f, this));

    this->rotation (r);
  }

  if (!scale_.present ())
  {
    ::std::auto_ptr< scale_type > r (
      scale_traits::create (
        ::std::string ("1 1 1"),
        &p.element (), f, this));

    this->scale (r);
  }

  if (!scaleOrientation_.present ())
  {
    ::std::auto_ptr< scaleOrientation_type > r (
      scaleOrientation_traits::create (
        ::std::string ("0 0 1 0"),
        &p.element (), f, this));

    this->scaleOrientation (r);
  }

  if (!translation_.present ())
  {
    ::std::auto_ptr< translation_type > r (
      translation_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->translation (r);
  }
}

HAnimHumanoid* HAnimHumanoid::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new HAnimHumanoid (*this, f, c);
}

HAnimHumanoid::
~HAnimHumanoid ()
{
}

// HAnimJoint
//

const HAnimJoint::center_type HAnimJoint::center_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const HAnimJoint::rotation_type HAnimJoint::rotation_default_value_ (
  ::std::string ("0 0 1 0"), 0, 0, 0);

const HAnimJoint::scale_type HAnimJoint::scale_default_value_ (
  ::std::string ("1 1 1"), 0, 0, 0);

const HAnimJoint::scaleOrientation_type HAnimJoint::scaleOrientation_default_value_ (
  ::std::string ("0 0 1 0"), 0, 0, 0);

const HAnimJoint::translation_type HAnimJoint::translation_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const HAnimJoint::limitOrientation_type HAnimJoint::limitOrientation_default_value_ (
  ::std::string ("0 0 1 0"), 0, 0, 0);

const HAnimJoint::stiffness_type HAnimJoint::stiffness_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

HAnimJoint::
HAnimJoint ()
: ::X3DGroupingNode (),
  name_ (::xml_schema::flags (), this),
  center_ (center_default_value (), ::xml_schema::flags (), this),
  rotation_ (rotation_default_value (), ::xml_schema::flags (), this),
  scale_ (scale_default_value (), ::xml_schema::flags (), this),
  scaleOrientation_ (scaleOrientation_default_value (), ::xml_schema::flags (), this),
  translation_ (translation_default_value (), ::xml_schema::flags (), this),
  skinCoordIndex_ (::xml_schema::flags (), this),
  skinCoordWeight_ (::xml_schema::flags (), this),
  llimit_ (::xml_schema::flags (), this),
  ulimit_ (::xml_schema::flags (), this),
  limitOrientation_ (limitOrientation_default_value (), ::xml_schema::flags (), this),
  stiffness_ (stiffness_default_value (), ::xml_schema::flags (), this)
{
}

HAnimJoint::
HAnimJoint (const HAnimJoint& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c),
  name_ (x.name_, f, this),
  center_ (x.center_, f, this),
  rotation_ (x.rotation_, f, this),
  scale_ (x.scale_, f, this),
  scaleOrientation_ (x.scaleOrientation_, f, this),
  translation_ (x.translation_, f, this),
  skinCoordIndex_ (x.skinCoordIndex_, f, this),
  skinCoordWeight_ (x.skinCoordWeight_, f, this),
  llimit_ (x.llimit_, f, this),
  ulimit_ (x.ulimit_, f, this),
  limitOrientation_ (x.limitOrientation_, f, this),
  stiffness_ (x.stiffness_, f, this)
{
}

HAnimJoint::
HAnimJoint (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DGroupingNode (e, f | ::xml_schema::flags::base, c),
  name_ (f, this),
  center_ (f, this),
  rotation_ (f, this),
  scale_ (f, this),
  scaleOrientation_ (f, this),
  translation_ (f, this),
  skinCoordIndex_ (f, this),
  skinCoordWeight_ (f, this),
  llimit_ (f, this),
  ulimit_ (f, this),
  limitOrientation_ (f, this),
  stiffness_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void HAnimJoint::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGroupingNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name (r);
      continue;
    }

    if (n.name () == "center" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< center_type > r (
        center_traits::create (i, f, this));

      this->center (r);
      continue;
    }

    if (n.name () == "rotation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rotation_type > r (
        rotation_traits::create (i, f, this));

      this->rotation (r);
      continue;
    }

    if (n.name () == "scale" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< scale_type > r (
        scale_traits::create (i, f, this));

      this->scale (r);
      continue;
    }

    if (n.name () == "scaleOrientation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< scaleOrientation_type > r (
        scaleOrientation_traits::create (i, f, this));

      this->scaleOrientation (r);
      continue;
    }

    if (n.name () == "translation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< translation_type > r (
        translation_traits::create (i, f, this));

      this->translation (r);
      continue;
    }

    if (n.name () == "skinCoordIndex" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< skinCoordIndex_type > r (
        skinCoordIndex_traits::create (i, f, this));

      this->skinCoordIndex (r);
      continue;
    }

    if (n.name () == "skinCoordWeight" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< skinCoordWeight_type > r (
        skinCoordWeight_traits::create (i, f, this));

      this->skinCoordWeight (r);
      continue;
    }

    if (n.name () == "llimit" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< llimit_type > r (
        llimit_traits::create (i, f, this));

      this->llimit (r);
      continue;
    }

    if (n.name () == "ulimit" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ulimit_type > r (
        ulimit_traits::create (i, f, this));

      this->ulimit (r);
      continue;
    }

    if (n.name () == "limitOrientation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< limitOrientation_type > r (
        limitOrientation_traits::create (i, f, this));

      this->limitOrientation (r);
      continue;
    }

    if (n.name () == "stiffness" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< stiffness_type > r (
        stiffness_traits::create (i, f, this));

      this->stiffness (r);
      continue;
    }
  }

  if (!center_.present ())
  {
    ::std::auto_ptr< center_type > r (
      center_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->center (r);
  }

  if (!rotation_.present ())
  {
    ::std::auto_ptr< rotation_type > r (
      rotation_traits::create (
        ::std::string ("0 0 1 0"),
        &p.element (), f, this));

    this->rotation (r);
  }

  if (!scale_.present ())
  {
    ::std::auto_ptr< scale_type > r (
      scale_traits::create (
        ::std::string ("1 1 1"),
        &p.element (), f, this));

    this->scale (r);
  }

  if (!scaleOrientation_.present ())
  {
    ::std::auto_ptr< scaleOrientation_type > r (
      scaleOrientation_traits::create (
        ::std::string ("0 0 1 0"),
        &p.element (), f, this));

    this->scaleOrientation (r);
  }

  if (!translation_.present ())
  {
    ::std::auto_ptr< translation_type > r (
      translation_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->translation (r);
  }

  if (!limitOrientation_.present ())
  {
    ::std::auto_ptr< limitOrientation_type > r (
      limitOrientation_traits::create (
        ::std::string ("0 0 1 0"),
        &p.element (), f, this));

    this->limitOrientation (r);
  }

  if (!stiffness_.present ())
  {
    ::std::auto_ptr< stiffness_type > r (
      stiffness_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->stiffness (r);
  }
}

HAnimJoint* HAnimJoint::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new HAnimJoint (*this, f, c);
}

HAnimJoint::
~HAnimJoint ()
{
}

// HAnimSegment
//

const HAnimSegment::mass_type HAnimSegment::mass_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const HAnimSegment::centerOfMass_type HAnimSegment::centerOfMass_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const HAnimSegment::momentsOfInertia_type HAnimSegment::momentsOfInertia_default_value_ (
  ::std::string ("0 0 0 0 0 0 0 0 0"), 0, 0, 0);

HAnimSegment::
HAnimSegment ()
: ::X3DGroupingNode (),
  HAnimDisplacer_ (::xml_schema::flags (), this),
  name_ (::xml_schema::flags (), this),
  mass_ (mass_default_value (), ::xml_schema::flags (), this),
  centerOfMass_ (centerOfMass_default_value (), ::xml_schema::flags (), this),
  momentsOfInertia_ (momentsOfInertia_default_value (), ::xml_schema::flags (), this)
{
}

HAnimSegment::
HAnimSegment (const HAnimSegment& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c),
  HAnimDisplacer_ (x.HAnimDisplacer_, f, this),
  name_ (x.name_, f, this),
  mass_ (x.mass_, f, this),
  centerOfMass_ (x.centerOfMass_, f, this),
  momentsOfInertia_ (x.momentsOfInertia_, f, this)
{
}

HAnimSegment::
HAnimSegment (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DGroupingNode (e, f | ::xml_schema::flags::base, c),
  HAnimDisplacer_ (f, this),
  name_ (f, this),
  mass_ (f, this),
  centerOfMass_ (f, this),
  momentsOfInertia_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void HAnimSegment::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGroupingNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // HAnimDisplacer
    //
    if (n.name () == "HAnimDisplacer" && n.namespace_ () == "")
    {
      ::std::auto_ptr< HAnimDisplacer_type > r (
        HAnimDisplacer_traits::create (i, f, this));

      this->HAnimDisplacer ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name (r);
      continue;
    }

    if (n.name () == "mass" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< mass_type > r (
        mass_traits::create (i, f, this));

      this->mass (r);
      continue;
    }

    if (n.name () == "centerOfMass" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< centerOfMass_type > r (
        centerOfMass_traits::create (i, f, this));

      this->centerOfMass (r);
      continue;
    }

    if (n.name () == "momentsOfInertia" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< momentsOfInertia_type > r (
        momentsOfInertia_traits::create (i, f, this));

      this->momentsOfInertia (r);
      continue;
    }
  }

  if (!mass_.present ())
  {
    ::std::auto_ptr< mass_type > r (
      mass_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->mass (r);
  }

  if (!centerOfMass_.present ())
  {
    ::std::auto_ptr< centerOfMass_type > r (
      centerOfMass_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->centerOfMass (r);
  }

  if (!momentsOfInertia_.present ())
  {
    ::std::auto_ptr< momentsOfInertia_type > r (
      momentsOfInertia_traits::create (
        ::std::string ("0 0 0 0 0 0 0 0 0"),
        &p.element (), f, this));

    this->momentsOfInertia (r);
  }
}

HAnimSegment* HAnimSegment::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new HAnimSegment (*this, f, c);
}

HAnimSegment::
~HAnimSegment ()
{
}

// HAnimSite
//

const HAnimSite::center_type HAnimSite::center_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const HAnimSite::rotation_type HAnimSite::rotation_default_value_ (
  ::std::string ("0 0 1 0"), 0, 0, 0);

const HAnimSite::scale_type HAnimSite::scale_default_value_ (
  ::std::string ("1 1 1"), 0, 0, 0);

const HAnimSite::scaleOrientation_type HAnimSite::scaleOrientation_default_value_ (
  ::std::string ("0 0 1 0"), 0, 0, 0);

const HAnimSite::translation_type HAnimSite::translation_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

HAnimSite::
HAnimSite ()
: ::X3DGroupingNode (),
  name_ (::xml_schema::flags (), this),
  center_ (center_default_value (), ::xml_schema::flags (), this),
  rotation_ (rotation_default_value (), ::xml_schema::flags (), this),
  scale_ (scale_default_value (), ::xml_schema::flags (), this),
  scaleOrientation_ (scaleOrientation_default_value (), ::xml_schema::flags (), this),
  translation_ (translation_default_value (), ::xml_schema::flags (), this)
{
}

HAnimSite::
HAnimSite (const HAnimSite& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c),
  name_ (x.name_, f, this),
  center_ (x.center_, f, this),
  rotation_ (x.rotation_, f, this),
  scale_ (x.scale_, f, this),
  scaleOrientation_ (x.scaleOrientation_, f, this),
  translation_ (x.translation_, f, this)
{
}

HAnimSite::
HAnimSite (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DGroupingNode (e, f | ::xml_schema::flags::base, c),
  name_ (f, this),
  center_ (f, this),
  rotation_ (f, this),
  scale_ (f, this),
  scaleOrientation_ (f, this),
  translation_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void HAnimSite::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGroupingNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name (r);
      continue;
    }

    if (n.name () == "center" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< center_type > r (
        center_traits::create (i, f, this));

      this->center (r);
      continue;
    }

    if (n.name () == "rotation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rotation_type > r (
        rotation_traits::create (i, f, this));

      this->rotation (r);
      continue;
    }

    if (n.name () == "scale" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< scale_type > r (
        scale_traits::create (i, f, this));

      this->scale (r);
      continue;
    }

    if (n.name () == "scaleOrientation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< scaleOrientation_type > r (
        scaleOrientation_traits::create (i, f, this));

      this->scaleOrientation (r);
      continue;
    }

    if (n.name () == "translation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< translation_type > r (
        translation_traits::create (i, f, this));

      this->translation (r);
      continue;
    }
  }

  if (!center_.present ())
  {
    ::std::auto_ptr< center_type > r (
      center_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->center (r);
  }

  if (!rotation_.present ())
  {
    ::std::auto_ptr< rotation_type > r (
      rotation_traits::create (
        ::std::string ("0 0 1 0"),
        &p.element (), f, this));

    this->rotation (r);
  }

  if (!scale_.present ())
  {
    ::std::auto_ptr< scale_type > r (
      scale_traits::create (
        ::std::string ("1 1 1"),
        &p.element (), f, this));

    this->scale (r);
  }

  if (!scaleOrientation_.present ())
  {
    ::std::auto_ptr< scaleOrientation_type > r (
      scaleOrientation_traits::create (
        ::std::string ("0 0 1 0"),
        &p.element (), f, this));

    this->scaleOrientation (r);
  }

  if (!translation_.present ())
  {
    ::std::auto_ptr< translation_type > r (
      translation_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->translation (r);
  }
}

HAnimSite* HAnimSite::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new HAnimSite (*this, f, c);
}

HAnimSite::
~HAnimSite ()
{
}

// Contour2D
//

const Contour2D::containerField_type Contour2D::containerField_default_value_ (
  ::std::string ("trimmingContour"), 0, 0, 0);

Contour2D::
Contour2D ()
: ::X3DNode (),
  NurbsCurve2D_ (::xml_schema::flags (), this),
  ContourPolyline2D_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this)
{
}

Contour2D::
Contour2D (const Contour2D& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DNode (x, f, c),
  NurbsCurve2D_ (x.NurbsCurve2D_, f, this),
  ContourPolyline2D_ (x.ContourPolyline2D_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  containerField_ (x.containerField_, f, this)
{
}

Contour2D::
Contour2D (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::X3DNode (e, f | ::xml_schema::flags::base, c),
  NurbsCurve2D_ (f, this),
  ContourPolyline2D_ (f, this),
  ProtoInstance_ (f, this),
  containerField_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Contour2D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NurbsCurve2D
    //
    if (n.name () == "NurbsCurve2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsCurve2D_type > r (
        NurbsCurve2D_traits::create (i, f, this));

      this->NurbsCurve2D ().push_back (r);
      continue;
    }

    // ContourPolyline2D
    //
    if (n.name () == "ContourPolyline2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ContourPolyline2D_type > r (
        ContourPolyline2D_traits::create (i, f, this));

      this->ContourPolyline2D ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("trimmingContour"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

Contour2D* Contour2D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Contour2D (*this, f, c);
}

Contour2D::
~Contour2D ()
{
}

// ContourPolyline2D
//

ContourPolyline2D::
ContourPolyline2D ()
: ::X3DNurbsControlCurveNode ()
{
}

ContourPolyline2D::
ContourPolyline2D (const ContourPolyline2D& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DNurbsControlCurveNode (x, f, c)
{
}

ContourPolyline2D::
ContourPolyline2D (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DNurbsControlCurveNode (e, f, c)
{
}

ContourPolyline2D* ContourPolyline2D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ContourPolyline2D (*this, f, c);
}

ContourPolyline2D::
~ContourPolyline2D ()
{
}

// NurbsCurve
//

const NurbsCurve::closed_type NurbsCurve::closed_default_value_ (
  ::std::string ("false"), 0, 0, 0);

const NurbsCurve::order_type NurbsCurve::order_default_value_ (
  ::std::string ("3"), 0, 0, 0);

const NurbsCurve::tessellation_type NurbsCurve::tessellation_default_value_ (
  ::std::string ("0"), 0, 0, 0);

NurbsCurve::
NurbsCurve ()
: ::X3DParametricGeometryNode (),
  Coordinate_ (::xml_schema::flags (), this),
  CoordinateDouble_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  closed_ (closed_default_value (), ::xml_schema::flags (), this),
  knot_ (::xml_schema::flags (), this),
  order_ (order_default_value (), ::xml_schema::flags (), this),
  tessellation_ (tessellation_default_value (), ::xml_schema::flags (), this),
  weight_ (::xml_schema::flags (), this)
{
}

NurbsCurve::
NurbsCurve (const NurbsCurve& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DParametricGeometryNode (x, f, c),
  Coordinate_ (x.Coordinate_, f, this),
  CoordinateDouble_ (x.CoordinateDouble_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  closed_ (x.closed_, f, this),
  knot_ (x.knot_, f, this),
  order_ (x.order_, f, this),
  tessellation_ (x.tessellation_, f, this),
  weight_ (x.weight_, f, this)
{
}

NurbsCurve::
NurbsCurve (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DParametricGeometryNode (e, f | ::xml_schema::flags::base, c),
  Coordinate_ (f, this),
  CoordinateDouble_ (f, this),
  ProtoInstance_ (f, this),
  closed_ (f, this),
  knot_ (f, this),
  order_ (f, this),
  tessellation_ (f, this),
  weight_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void NurbsCurve::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DParametricGeometryNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Coordinate
    //
    if (n.name () == "Coordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Coordinate_type > r (
        Coordinate_traits::create (i, f, this));

      if (!this->Coordinate ())
      {
        this->Coordinate (r);
        continue;
      }
    }

    // CoordinateDouble
    //
    if (n.name () == "CoordinateDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateDouble_type > r (
        CoordinateDouble_traits::create (i, f, this));

      if (!this->CoordinateDouble ())
      {
        this->CoordinateDouble (r);
        continue;
      }
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      if (!this->ProtoInstance ())
      {
        this->ProtoInstance (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "closed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< closed_type > r (
        closed_traits::create (i, f, this));

      this->closed (r);
      continue;
    }

    if (n.name () == "knot" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< knot_type > r (
        knot_traits::create (i, f, this));

      this->knot (r);
      continue;
    }

    if (n.name () == "order" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< order_type > r (
        order_traits::create (i, f, this));

      this->order (r);
      continue;
    }

    if (n.name () == "tessellation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< tessellation_type > r (
        tessellation_traits::create (i, f, this));

      this->tessellation (r);
      continue;
    }

    if (n.name () == "weight" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< weight_type > r (
        weight_traits::create (i, f, this));

      this->weight (r);
      continue;
    }
  }

  if (!closed_.present ())
  {
    ::std::auto_ptr< closed_type > r (
      closed_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->closed (r);
  }

  if (!order_.present ())
  {
    ::std::auto_ptr< order_type > r (
      order_traits::create (
        ::std::string ("3"),
        &p.element (), f, this));

    this->order (r);
  }

  if (!tessellation_.present ())
  {
    ::std::auto_ptr< tessellation_type > r (
      tessellation_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->tessellation (r);
  }
}

NurbsCurve* NurbsCurve::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new NurbsCurve (*this, f, c);
}

NurbsCurve::
~NurbsCurve ()
{
}

// NurbsCurve2D
//

const NurbsCurve2D::closed_type NurbsCurve2D::closed_default_value_ (
  ::std::string ("false"), 0, 0, 0);

const NurbsCurve2D::order_type NurbsCurve2D::order_default_value_ (
  ::std::string ("3"), 0, 0, 0);

const NurbsCurve2D::tessellation_type NurbsCurve2D::tessellation_default_value_ (
  ::std::string ("0"), 0, 0, 0);

NurbsCurve2D::
NurbsCurve2D ()
: ::X3DNurbsControlCurveNode (),
  closed_ (closed_default_value (), ::xml_schema::flags (), this),
  knot_ (::xml_schema::flags (), this),
  order_ (order_default_value (), ::xml_schema::flags (), this),
  tessellation_ (tessellation_default_value (), ::xml_schema::flags (), this),
  weight_ (::xml_schema::flags (), this)
{
}

NurbsCurve2D::
NurbsCurve2D (const NurbsCurve2D& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DNurbsControlCurveNode (x, f, c),
  closed_ (x.closed_, f, this),
  knot_ (x.knot_, f, this),
  order_ (x.order_, f, this),
  tessellation_ (x.tessellation_, f, this),
  weight_ (x.weight_, f, this)
{
}

NurbsCurve2D::
NurbsCurve2D (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::X3DNurbsControlCurveNode (e, f | ::xml_schema::flags::base, c),
  closed_ (f, this),
  knot_ (f, this),
  order_ (f, this),
  tessellation_ (f, this),
  weight_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void NurbsCurve2D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DNurbsControlCurveNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "closed" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< closed_type > r (
        closed_traits::create (i, f, this));

      this->closed (r);
      continue;
    }

    if (n.name () == "knot" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< knot_type > r (
        knot_traits::create (i, f, this));

      this->knot (r);
      continue;
    }

    if (n.name () == "order" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< order_type > r (
        order_traits::create (i, f, this));

      this->order (r);
      continue;
    }

    if (n.name () == "tessellation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< tessellation_type > r (
        tessellation_traits::create (i, f, this));

      this->tessellation (r);
      continue;
    }

    if (n.name () == "weight" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< weight_type > r (
        weight_traits::create (i, f, this));

      this->weight (r);
      continue;
    }
  }

  if (!closed_.present ())
  {
    ::std::auto_ptr< closed_type > r (
      closed_traits::create (
        ::std::string ("false"),
        &p.element (), f, this));

    this->closed (r);
  }

  if (!order_.present ())
  {
    ::std::auto_ptr< order_type > r (
      order_traits::create (
        ::std::string ("3"),
        &p.element (), f, this));

    this->order (r);
  }

  if (!tessellation_.present ())
  {
    ::std::auto_ptr< tessellation_type > r (
      tessellation_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->tessellation (r);
  }
}

NurbsCurve2D* NurbsCurve2D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new NurbsCurve2D (*this, f, c);
}

NurbsCurve2D::
~NurbsCurve2D ()
{
}

// NurbsOrientationInterpolator
//

const NurbsOrientationInterpolator::order_type NurbsOrientationInterpolator::order_default_value_ (
  ::std::string ("3"), 0, 0, 0);

NurbsOrientationInterpolator::
NurbsOrientationInterpolator ()
: ::X3DChildNode (),
  Coordinate_ (::xml_schema::flags (), this),
  CoordinateDouble_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  knot_ (::xml_schema::flags (), this),
  order_ (order_default_value (), ::xml_schema::flags (), this),
  weight_ (::xml_schema::flags (), this)
{
}

NurbsOrientationInterpolator::
NurbsOrientationInterpolator (const NurbsOrientationInterpolator& x,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::X3DChildNode (x, f, c),
  Coordinate_ (x.Coordinate_, f, this),
  CoordinateDouble_ (x.CoordinateDouble_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  knot_ (x.knot_, f, this),
  order_ (x.order_, f, this),
  weight_ (x.weight_, f, this)
{
}

NurbsOrientationInterpolator::
NurbsOrientationInterpolator (const ::xercesc::DOMElement& e,
                              ::xml_schema::flags f,
                              ::xml_schema::container* c)
: ::X3DChildNode (e, f | ::xml_schema::flags::base, c),
  Coordinate_ (f, this),
  CoordinateDouble_ (f, this),
  ProtoInstance_ (f, this),
  knot_ (f, this),
  order_ (f, this),
  weight_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void NurbsOrientationInterpolator::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DChildNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Coordinate
    //
    if (n.name () == "Coordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Coordinate_type > r (
        Coordinate_traits::create (i, f, this));

      if (!this->Coordinate ())
      {
        this->Coordinate (r);
        continue;
      }
    }

    // CoordinateDouble
    //
    if (n.name () == "CoordinateDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateDouble_type > r (
        CoordinateDouble_traits::create (i, f, this));

      if (!this->CoordinateDouble ())
      {
        this->CoordinateDouble (r);
        continue;
      }
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      if (!this->ProtoInstance ())
      {
        this->ProtoInstance (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "knot" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< knot_type > r (
        knot_traits::create (i, f, this));

      this->knot (r);
      continue;
    }

    if (n.name () == "order" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< order_type > r (
        order_traits::create (i, f, this));

      this->order (r);
      continue;
    }

    if (n.name () == "weight" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< weight_type > r (
        weight_traits::create (i, f, this));

      this->weight (r);
      continue;
    }
  }

  if (!order_.present ())
  {
    ::std::auto_ptr< order_type > r (
      order_traits::create (
        ::std::string ("3"),
        &p.element (), f, this));

    this->order (r);
  }
}

NurbsOrientationInterpolator* NurbsOrientationInterpolator::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new NurbsOrientationInterpolator (*this, f, c);
}

NurbsOrientationInterpolator::
~NurbsOrientationInterpolator ()
{
}

// NurbsPatchSurface
//

NurbsPatchSurface::
NurbsPatchSurface ()
: ::X3DNurbsSurfaceGeometryNode (),
  Coordinate_ (::xml_schema::flags (), this),
  CoordinateDouble_ (::xml_schema::flags (), this),
  TextureCoordinate_ (::xml_schema::flags (), this),
  TextureCoordinateGenerator_ (::xml_schema::flags (), this),
  NurbsTextureCoordinate_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this)
{
}

NurbsPatchSurface::
NurbsPatchSurface (const NurbsPatchSurface& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DNurbsSurfaceGeometryNode (x, f, c),
  Coordinate_ (x.Coordinate_, f, this),
  CoordinateDouble_ (x.CoordinateDouble_, f, this),
  TextureCoordinate_ (x.TextureCoordinate_, f, this),
  TextureCoordinateGenerator_ (x.TextureCoordinateGenerator_, f, this),
  NurbsTextureCoordinate_ (x.NurbsTextureCoordinate_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this)
{
}

NurbsPatchSurface::
NurbsPatchSurface (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DNurbsSurfaceGeometryNode (e, f | ::xml_schema::flags::base, c),
  Coordinate_ (f, this),
  CoordinateDouble_ (f, this),
  TextureCoordinate_ (f, this),
  TextureCoordinateGenerator_ (f, this),
  NurbsTextureCoordinate_ (f, this),
  ProtoInstance_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void NurbsPatchSurface::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DNurbsSurfaceGeometryNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Coordinate
    //
    if (n.name () == "Coordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Coordinate_type > r (
        Coordinate_traits::create (i, f, this));

      this->Coordinate ().push_back (r);
      continue;
    }

    // CoordinateDouble
    //
    if (n.name () == "CoordinateDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateDouble_type > r (
        CoordinateDouble_traits::create (i, f, this));

      this->CoordinateDouble ().push_back (r);
      continue;
    }

    // TextureCoordinate
    //
    if (n.name () == "TextureCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureCoordinate_type > r (
        TextureCoordinate_traits::create (i, f, this));

      this->TextureCoordinate ().push_back (r);
      continue;
    }

    // TextureCoordinateGenerator
    //
    if (n.name () == "TextureCoordinateGenerator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureCoordinateGenerator_type > r (
        TextureCoordinateGenerator_traits::create (i, f, this));

      this->TextureCoordinateGenerator ().push_back (r);
      continue;
    }

    // NurbsTextureCoordinate
    //
    if (n.name () == "NurbsTextureCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsTextureCoordinate_type > r (
        NurbsTextureCoordinate_traits::create (i, f, this));

      this->NurbsTextureCoordinate ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    break;
  }
}

NurbsPatchSurface* NurbsPatchSurface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new NurbsPatchSurface (*this, f, c);
}

NurbsPatchSurface::
~NurbsPatchSurface ()
{
}

// NurbsPositionInterpolator
//

const NurbsPositionInterpolator::order_type NurbsPositionInterpolator::order_default_value_ (
  ::std::string ("3"), 0, 0, 0);

NurbsPositionInterpolator::
NurbsPositionInterpolator ()
: ::X3DChildNode (),
  Coordinate_ (::xml_schema::flags (), this),
  CoordinateDouble_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  knot_ (::xml_schema::flags (), this),
  order_ (order_default_value (), ::xml_schema::flags (), this),
  weight_ (::xml_schema::flags (), this)
{
}

NurbsPositionInterpolator::
NurbsPositionInterpolator (const NurbsPositionInterpolator& x,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::X3DChildNode (x, f, c),
  Coordinate_ (x.Coordinate_, f, this),
  CoordinateDouble_ (x.CoordinateDouble_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  knot_ (x.knot_, f, this),
  order_ (x.order_, f, this),
  weight_ (x.weight_, f, this)
{
}

NurbsPositionInterpolator::
NurbsPositionInterpolator (const ::xercesc::DOMElement& e,
                           ::xml_schema::flags f,
                           ::xml_schema::container* c)
: ::X3DChildNode (e, f | ::xml_schema::flags::base, c),
  Coordinate_ (f, this),
  CoordinateDouble_ (f, this),
  ProtoInstance_ (f, this),
  knot_ (f, this),
  order_ (f, this),
  weight_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void NurbsPositionInterpolator::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DChildNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Coordinate
    //
    if (n.name () == "Coordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Coordinate_type > r (
        Coordinate_traits::create (i, f, this));

      if (!this->Coordinate ())
      {
        this->Coordinate (r);
        continue;
      }
    }

    // CoordinateDouble
    //
    if (n.name () == "CoordinateDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateDouble_type > r (
        CoordinateDouble_traits::create (i, f, this));

      if (!this->CoordinateDouble ())
      {
        this->CoordinateDouble (r);
        continue;
      }
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      if (!this->ProtoInstance ())
      {
        this->ProtoInstance (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "knot" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< knot_type > r (
        knot_traits::create (i, f, this));

      this->knot (r);
      continue;
    }

    if (n.name () == "order" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< order_type > r (
        order_traits::create (i, f, this));

      this->order (r);
      continue;
    }

    if (n.name () == "weight" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< weight_type > r (
        weight_traits::create (i, f, this));

      this->weight (r);
      continue;
    }
  }

  if (!order_.present ())
  {
    ::std::auto_ptr< order_type > r (
      order_traits::create (
        ::std::string ("3"),
        &p.element (), f, this));

    this->order (r);
  }
}

NurbsPositionInterpolator* NurbsPositionInterpolator::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new NurbsPositionInterpolator (*this, f, c);
}

NurbsPositionInterpolator::
~NurbsPositionInterpolator ()
{
}

// NurbsSet
//

const NurbsSet::tessellationScale_type NurbsSet::tessellationScale_default_value_ (
  ::std::string ("1.0"), 0, 0, 0);

const NurbsSet::bboxCenter_type NurbsSet::bboxCenter_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const NurbsSet::bboxSize_type NurbsSet::bboxSize_default_value_ (
  ::std::string ("-1 -1 -1"), 0, 0, 0);

NurbsSet::
NurbsSet ()
: ::X3DChildNode (),
  NurbsPatchSurface_ (::xml_schema::flags (), this),
  NurbsSweptSurface_ (::xml_schema::flags (), this),
  NurbsSwungSurface_ (::xml_schema::flags (), this),
  NurbsTrimmedSurface_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  tessellationScale_ (tessellationScale_default_value (), ::xml_schema::flags (), this),
  bboxCenter_ (bboxCenter_default_value (), ::xml_schema::flags (), this),
  bboxSize_ (bboxSize_default_value (), ::xml_schema::flags (), this)
{
}

NurbsSet::
NurbsSet (const NurbsSet& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::X3DChildNode (x, f, c),
  NurbsPatchSurface_ (x.NurbsPatchSurface_, f, this),
  NurbsSweptSurface_ (x.NurbsSweptSurface_, f, this),
  NurbsSwungSurface_ (x.NurbsSwungSurface_, f, this),
  NurbsTrimmedSurface_ (x.NurbsTrimmedSurface_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  tessellationScale_ (x.tessellationScale_, f, this),
  bboxCenter_ (x.bboxCenter_, f, this),
  bboxSize_ (x.bboxSize_, f, this)
{
}

NurbsSet::
NurbsSet (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::X3DChildNode (e, f | ::xml_schema::flags::base, c),
  NurbsPatchSurface_ (f, this),
  NurbsSweptSurface_ (f, this),
  NurbsSwungSurface_ (f, this),
  NurbsTrimmedSurface_ (f, this),
  ProtoInstance_ (f, this),
  tessellationScale_ (f, this),
  bboxCenter_ (f, this),
  bboxSize_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void NurbsSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DChildNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // NurbsPatchSurface
    //
    if (n.name () == "NurbsPatchSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsPatchSurface_type > r (
        NurbsPatchSurface_traits::create (i, f, this));

      this->NurbsPatchSurface ().push_back (r);
      continue;
    }

    // NurbsSweptSurface
    //
    if (n.name () == "NurbsSweptSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSweptSurface_type > r (
        NurbsSweptSurface_traits::create (i, f, this));

      this->NurbsSweptSurface ().push_back (r);
      continue;
    }

    // NurbsSwungSurface
    //
    if (n.name () == "NurbsSwungSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsSwungSurface_type > r (
        NurbsSwungSurface_traits::create (i, f, this));

      this->NurbsSwungSurface ().push_back (r);
      continue;
    }

    // NurbsTrimmedSurface
    //
    if (n.name () == "NurbsTrimmedSurface" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsTrimmedSurface_type > r (
        NurbsTrimmedSurface_traits::create (i, f, this));

      this->NurbsTrimmedSurface ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "tessellationScale" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< tessellationScale_type > r (
        tessellationScale_traits::create (i, f, this));

      this->tessellationScale (r);
      continue;
    }

    if (n.name () == "bboxCenter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bboxCenter_type > r (
        bboxCenter_traits::create (i, f, this));

      this->bboxCenter (r);
      continue;
    }

    if (n.name () == "bboxSize" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bboxSize_type > r (
        bboxSize_traits::create (i, f, this));

      this->bboxSize (r);
      continue;
    }
  }

  if (!tessellationScale_.present ())
  {
    ::std::auto_ptr< tessellationScale_type > r (
      tessellationScale_traits::create (
        ::std::string ("1.0"),
        &p.element (), f, this));

    this->tessellationScale (r);
  }

  if (!bboxCenter_.present ())
  {
    ::std::auto_ptr< bboxCenter_type > r (
      bboxCenter_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->bboxCenter (r);
  }

  if (!bboxSize_.present ())
  {
    ::std::auto_ptr< bboxSize_type > r (
      bboxSize_traits::create (
        ::std::string ("-1 -1 -1"),
        &p.element (), f, this));

    this->bboxSize (r);
  }
}

NurbsSet* NurbsSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new NurbsSet (*this, f, c);
}

NurbsSet::
~NurbsSet ()
{
}

// NurbsSurfaceInterpolator
//

const NurbsSurfaceInterpolator::uDimension_type NurbsSurfaceInterpolator::uDimension_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const NurbsSurfaceInterpolator::vDimension_type NurbsSurfaceInterpolator::vDimension_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const NurbsSurfaceInterpolator::uOrder_type NurbsSurfaceInterpolator::uOrder_default_value_ (
  ::std::string ("3"), 0, 0, 0);

const NurbsSurfaceInterpolator::vOrder_type NurbsSurfaceInterpolator::vOrder_default_value_ (
  ::std::string ("3"), 0, 0, 0);

NurbsSurfaceInterpolator::
NurbsSurfaceInterpolator ()
: ::X3DChildNode (),
  Coordinate_ (::xml_schema::flags (), this),
  CoordinateDouble_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  uDimension_ (uDimension_default_value (), ::xml_schema::flags (), this),
  vDimension_ (vDimension_default_value (), ::xml_schema::flags (), this),
  uKnot_ (::xml_schema::flags (), this),
  vKnot_ (::xml_schema::flags (), this),
  uOrder_ (uOrder_default_value (), ::xml_schema::flags (), this),
  vOrder_ (vOrder_default_value (), ::xml_schema::flags (), this),
  weight_ (::xml_schema::flags (), this)
{
}

NurbsSurfaceInterpolator::
NurbsSurfaceInterpolator (const NurbsSurfaceInterpolator& x,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::X3DChildNode (x, f, c),
  Coordinate_ (x.Coordinate_, f, this),
  CoordinateDouble_ (x.CoordinateDouble_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  uDimension_ (x.uDimension_, f, this),
  vDimension_ (x.vDimension_, f, this),
  uKnot_ (x.uKnot_, f, this),
  vKnot_ (x.vKnot_, f, this),
  uOrder_ (x.uOrder_, f, this),
  vOrder_ (x.vOrder_, f, this),
  weight_ (x.weight_, f, this)
{
}

NurbsSurfaceInterpolator::
NurbsSurfaceInterpolator (const ::xercesc::DOMElement& e,
                          ::xml_schema::flags f,
                          ::xml_schema::container* c)
: ::X3DChildNode (e, f | ::xml_schema::flags::base, c),
  Coordinate_ (f, this),
  CoordinateDouble_ (f, this),
  ProtoInstance_ (f, this),
  uDimension_ (f, this),
  vDimension_ (f, this),
  uKnot_ (f, this),
  vKnot_ (f, this),
  uOrder_ (f, this),
  vOrder_ (f, this),
  weight_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void NurbsSurfaceInterpolator::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DChildNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Coordinate
    //
    if (n.name () == "Coordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Coordinate_type > r (
        Coordinate_traits::create (i, f, this));

      if (!this->Coordinate ())
      {
        this->Coordinate (r);
        continue;
      }
    }

    // CoordinateDouble
    //
    if (n.name () == "CoordinateDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateDouble_type > r (
        CoordinateDouble_traits::create (i, f, this));

      if (!this->CoordinateDouble ())
      {
        this->CoordinateDouble (r);
        continue;
      }
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      if (!this->ProtoInstance ())
      {
        this->ProtoInstance (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "uDimension" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< uDimension_type > r (
        uDimension_traits::create (i, f, this));

      this->uDimension (r);
      continue;
    }

    if (n.name () == "vDimension" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vDimension_type > r (
        vDimension_traits::create (i, f, this));

      this->vDimension (r);
      continue;
    }

    if (n.name () == "uKnot" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< uKnot_type > r (
        uKnot_traits::create (i, f, this));

      this->uKnot (r);
      continue;
    }

    if (n.name () == "vKnot" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vKnot_type > r (
        vKnot_traits::create (i, f, this));

      this->vKnot (r);
      continue;
    }

    if (n.name () == "uOrder" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< uOrder_type > r (
        uOrder_traits::create (i, f, this));

      this->uOrder (r);
      continue;
    }

    if (n.name () == "vOrder" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vOrder_type > r (
        vOrder_traits::create (i, f, this));

      this->vOrder (r);
      continue;
    }

    if (n.name () == "weight" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< weight_type > r (
        weight_traits::create (i, f, this));

      this->weight (r);
      continue;
    }
  }

  if (!uDimension_.present ())
  {
    ::std::auto_ptr< uDimension_type > r (
      uDimension_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->uDimension (r);
  }

  if (!vDimension_.present ())
  {
    ::std::auto_ptr< vDimension_type > r (
      vDimension_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->vDimension (r);
  }

  if (!uOrder_.present ())
  {
    ::std::auto_ptr< uOrder_type > r (
      uOrder_traits::create (
        ::std::string ("3"),
        &p.element (), f, this));

    this->uOrder (r);
  }

  if (!vOrder_.present ())
  {
    ::std::auto_ptr< vOrder_type > r (
      vOrder_traits::create (
        ::std::string ("3"),
        &p.element (), f, this));

    this->vOrder (r);
  }
}

NurbsSurfaceInterpolator* NurbsSurfaceInterpolator::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new NurbsSurfaceInterpolator (*this, f, c);
}

NurbsSurfaceInterpolator::
~NurbsSurfaceInterpolator ()
{
}

// NurbsSweptSurface
//

const NurbsSweptSurface::ccw_type NurbsSweptSurface::ccw_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const NurbsSweptSurface::solid_type NurbsSweptSurface::solid_default_value_ (
  ::std::string ("true"), 0, 0, 0);

NurbsSweptSurface::
NurbsSweptSurface ()
: ::X3DParametricGeometryNode (),
  ContourPolyline2D_ (::xml_schema::flags (), this),
  NurbsCurve2D_ (::xml_schema::flags (), this),
  NurbsCurve_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  ccw_ (ccw_default_value (), ::xml_schema::flags (), this),
  solid_ (solid_default_value (), ::xml_schema::flags (), this)
{
}

NurbsSweptSurface::
NurbsSweptSurface (const NurbsSweptSurface& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DParametricGeometryNode (x, f, c),
  ContourPolyline2D_ (x.ContourPolyline2D_, f, this),
  NurbsCurve2D_ (x.NurbsCurve2D_, f, this),
  NurbsCurve_ (x.NurbsCurve_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  ccw_ (x.ccw_, f, this),
  solid_ (x.solid_, f, this)
{
}

NurbsSweptSurface::
NurbsSweptSurface (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DParametricGeometryNode (e, f | ::xml_schema::flags::base, c),
  ContourPolyline2D_ (f, this),
  NurbsCurve2D_ (f, this),
  NurbsCurve_ (f, this),
  ProtoInstance_ (f, this),
  ccw_ (f, this),
  solid_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void NurbsSweptSurface::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DParametricGeometryNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ContourPolyline2D
    //
    if (n.name () == "ContourPolyline2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ContourPolyline2D_type > r (
        ContourPolyline2D_traits::create (i, f, this));

      this->ContourPolyline2D ().push_back (r);
      continue;
    }

    // NurbsCurve2D
    //
    if (n.name () == "NurbsCurve2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsCurve2D_type > r (
        NurbsCurve2D_traits::create (i, f, this));

      this->NurbsCurve2D ().push_back (r);
      continue;
    }

    // NurbsCurve
    //
    if (n.name () == "NurbsCurve" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsCurve_type > r (
        NurbsCurve_traits::create (i, f, this));

      this->NurbsCurve ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "ccw" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ccw_type > r (
        ccw_traits::create (i, f, this));

      this->ccw (r);
      continue;
    }

    if (n.name () == "solid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< solid_type > r (
        solid_traits::create (i, f, this));

      this->solid (r);
      continue;
    }
  }

  if (!ccw_.present ())
  {
    ::std::auto_ptr< ccw_type > r (
      ccw_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->ccw (r);
  }

  if (!solid_.present ())
  {
    ::std::auto_ptr< solid_type > r (
      solid_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->solid (r);
  }
}

NurbsSweptSurface* NurbsSweptSurface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new NurbsSweptSurface (*this, f, c);
}

NurbsSweptSurface::
~NurbsSweptSurface ()
{
}

// NurbsSwungSurface
//

const NurbsSwungSurface::ccw_type NurbsSwungSurface::ccw_default_value_ (
  ::std::string ("true"), 0, 0, 0);

const NurbsSwungSurface::solid_type NurbsSwungSurface::solid_default_value_ (
  ::std::string ("true"), 0, 0, 0);

NurbsSwungSurface::
NurbsSwungSurface ()
: ::X3DParametricGeometryNode (),
  ContourPolyline2D_ (::xml_schema::flags (), this),
  NurbsCurve2D_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  ccw_ (ccw_default_value (), ::xml_schema::flags (), this),
  solid_ (solid_default_value (), ::xml_schema::flags (), this)
{
}

NurbsSwungSurface::
NurbsSwungSurface (const NurbsSwungSurface& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DParametricGeometryNode (x, f, c),
  ContourPolyline2D_ (x.ContourPolyline2D_, f, this),
  NurbsCurve2D_ (x.NurbsCurve2D_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  ccw_ (x.ccw_, f, this),
  solid_ (x.solid_, f, this)
{
}

NurbsSwungSurface::
NurbsSwungSurface (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DParametricGeometryNode (e, f | ::xml_schema::flags::base, c),
  ContourPolyline2D_ (f, this),
  NurbsCurve2D_ (f, this),
  ProtoInstance_ (f, this),
  ccw_ (f, this),
  solid_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void NurbsSwungSurface::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DParametricGeometryNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ContourPolyline2D
    //
    if (n.name () == "ContourPolyline2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ContourPolyline2D_type > r (
        ContourPolyline2D_traits::create (i, f, this));

      this->ContourPolyline2D ().push_back (r);
      continue;
    }

    // NurbsCurve2D
    //
    if (n.name () == "NurbsCurve2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsCurve2D_type > r (
        NurbsCurve2D_traits::create (i, f, this));

      this->NurbsCurve2D ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "ccw" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ccw_type > r (
        ccw_traits::create (i, f, this));

      this->ccw (r);
      continue;
    }

    if (n.name () == "solid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< solid_type > r (
        solid_traits::create (i, f, this));

      this->solid (r);
      continue;
    }
  }

  if (!ccw_.present ())
  {
    ::std::auto_ptr< ccw_type > r (
      ccw_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->ccw (r);
  }

  if (!solid_.present ())
  {
    ::std::auto_ptr< solid_type > r (
      solid_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));

    this->solid (r);
  }
}

NurbsSwungSurface* NurbsSwungSurface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new NurbsSwungSurface (*this, f, c);
}

NurbsSwungSurface::
~NurbsSwungSurface ()
{
}

// NurbsTextureCoordinate
//

const NurbsTextureCoordinate::uDimension_type NurbsTextureCoordinate::uDimension_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const NurbsTextureCoordinate::vDimension_type NurbsTextureCoordinate::vDimension_default_value_ (
  ::std::string ("0"), 0, 0, 0);

const NurbsTextureCoordinate::uOrder_type NurbsTextureCoordinate::uOrder_default_value_ (
  ::std::string ("3"), 0, 0, 0);

const NurbsTextureCoordinate::vOrder_type NurbsTextureCoordinate::vOrder_default_value_ (
  ::std::string ("3"), 0, 0, 0);

NurbsTextureCoordinate::
NurbsTextureCoordinate ()
: ::X3DTextureCoordinateNode (),
  controlPoint_ (::xml_schema::flags (), this),
  uDimension_ (uDimension_default_value (), ::xml_schema::flags (), this),
  vDimension_ (vDimension_default_value (), ::xml_schema::flags (), this),
  uKnot_ (::xml_schema::flags (), this),
  vKnot_ (::xml_schema::flags (), this),
  uOrder_ (uOrder_default_value (), ::xml_schema::flags (), this),
  vOrder_ (vOrder_default_value (), ::xml_schema::flags (), this),
  weight_ (::xml_schema::flags (), this)
{
}

NurbsTextureCoordinate::
NurbsTextureCoordinate (const NurbsTextureCoordinate& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DTextureCoordinateNode (x, f, c),
  controlPoint_ (x.controlPoint_, f, this),
  uDimension_ (x.uDimension_, f, this),
  vDimension_ (x.vDimension_, f, this),
  uKnot_ (x.uKnot_, f, this),
  vKnot_ (x.vKnot_, f, this),
  uOrder_ (x.uOrder_, f, this),
  vOrder_ (x.vOrder_, f, this),
  weight_ (x.weight_, f, this)
{
}

NurbsTextureCoordinate::
NurbsTextureCoordinate (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DTextureCoordinateNode (e, f | ::xml_schema::flags::base, c),
  controlPoint_ (f, this),
  uDimension_ (f, this),
  vDimension_ (f, this),
  uKnot_ (f, this),
  vKnot_ (f, this),
  uOrder_ (f, this),
  vOrder_ (f, this),
  weight_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void NurbsTextureCoordinate::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTextureCoordinateNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "controlPoint" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< controlPoint_type > r (
        controlPoint_traits::create (i, f, this));

      this->controlPoint (r);
      continue;
    }

    if (n.name () == "uDimension" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< uDimension_type > r (
        uDimension_traits::create (i, f, this));

      this->uDimension (r);
      continue;
    }

    if (n.name () == "vDimension" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vDimension_type > r (
        vDimension_traits::create (i, f, this));

      this->vDimension (r);
      continue;
    }

    if (n.name () == "uKnot" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< uKnot_type > r (
        uKnot_traits::create (i, f, this));

      this->uKnot (r);
      continue;
    }

    if (n.name () == "vKnot" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vKnot_type > r (
        vKnot_traits::create (i, f, this));

      this->vKnot (r);
      continue;
    }

    if (n.name () == "uOrder" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< uOrder_type > r (
        uOrder_traits::create (i, f, this));

      this->uOrder (r);
      continue;
    }

    if (n.name () == "vOrder" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< vOrder_type > r (
        vOrder_traits::create (i, f, this));

      this->vOrder (r);
      continue;
    }

    if (n.name () == "weight" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< weight_type > r (
        weight_traits::create (i, f, this));

      this->weight (r);
      continue;
    }
  }

  if (!uDimension_.present ())
  {
    ::std::auto_ptr< uDimension_type > r (
      uDimension_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->uDimension (r);
  }

  if (!vDimension_.present ())
  {
    ::std::auto_ptr< vDimension_type > r (
      vDimension_traits::create (
        ::std::string ("0"),
        &p.element (), f, this));

    this->vDimension (r);
  }

  if (!uOrder_.present ())
  {
    ::std::auto_ptr< uOrder_type > r (
      uOrder_traits::create (
        ::std::string ("3"),
        &p.element (), f, this));

    this->uOrder (r);
  }

  if (!vOrder_.present ())
  {
    ::std::auto_ptr< vOrder_type > r (
      vOrder_traits::create (
        ::std::string ("3"),
        &p.element (), f, this));

    this->vOrder (r);
  }
}

NurbsTextureCoordinate* NurbsTextureCoordinate::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new NurbsTextureCoordinate (*this, f, c);
}

NurbsTextureCoordinate::
~NurbsTextureCoordinate ()
{
}

// NurbsTrimmedSurface
//

NurbsTrimmedSurface::
NurbsTrimmedSurface ()
: ::X3DNurbsSurfaceGeometryNode (),
  Contour2D_ (::xml_schema::flags (), this),
  Coordinate_ (::xml_schema::flags (), this),
  CoordinateDouble_ (::xml_schema::flags (), this),
  TextureCoordinate_ (::xml_schema::flags (), this),
  TextureCoordinateGenerator_ (::xml_schema::flags (), this),
  NurbsTextureCoordinate_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this)
{
}

NurbsTrimmedSurface::
NurbsTrimmedSurface (const NurbsTrimmedSurface& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::X3DNurbsSurfaceGeometryNode (x, f, c),
  Contour2D_ (x.Contour2D_, f, this),
  Coordinate_ (x.Coordinate_, f, this),
  CoordinateDouble_ (x.CoordinateDouble_, f, this),
  TextureCoordinate_ (x.TextureCoordinate_, f, this),
  TextureCoordinateGenerator_ (x.TextureCoordinateGenerator_, f, this),
  NurbsTextureCoordinate_ (x.NurbsTextureCoordinate_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this)
{
}

NurbsTrimmedSurface::
NurbsTrimmedSurface (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::X3DNurbsSurfaceGeometryNode (e, f | ::xml_schema::flags::base, c),
  Contour2D_ (f, this),
  Coordinate_ (f, this),
  CoordinateDouble_ (f, this),
  TextureCoordinate_ (f, this),
  TextureCoordinateGenerator_ (f, this),
  NurbsTextureCoordinate_ (f, this),
  ProtoInstance_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void NurbsTrimmedSurface::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DNurbsSurfaceGeometryNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Contour2D
    //
    if (n.name () == "Contour2D" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Contour2D_type > r (
        Contour2D_traits::create (i, f, this));

      this->Contour2D ().push_back (r);
      continue;
    }

    // Coordinate
    //
    if (n.name () == "Coordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Coordinate_type > r (
        Coordinate_traits::create (i, f, this));

      this->Coordinate ().push_back (r);
      continue;
    }

    // CoordinateDouble
    //
    if (n.name () == "CoordinateDouble" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CoordinateDouble_type > r (
        CoordinateDouble_traits::create (i, f, this));

      this->CoordinateDouble ().push_back (r);
      continue;
    }

    // TextureCoordinate
    //
    if (n.name () == "TextureCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureCoordinate_type > r (
        TextureCoordinate_traits::create (i, f, this));

      this->TextureCoordinate ().push_back (r);
      continue;
    }

    // TextureCoordinateGenerator
    //
    if (n.name () == "TextureCoordinateGenerator" && n.namespace_ () == "")
    {
      ::std::auto_ptr< TextureCoordinateGenerator_type > r (
        TextureCoordinateGenerator_traits::create (i, f, this));

      this->TextureCoordinateGenerator ().push_back (r);
      continue;
    }

    // NurbsTextureCoordinate
    //
    if (n.name () == "NurbsTextureCoordinate" && n.namespace_ () == "")
    {
      ::std::auto_ptr< NurbsTextureCoordinate_type > r (
        NurbsTextureCoordinate_traits::create (i, f, this));

      this->NurbsTextureCoordinate ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    break;
  }
}

NurbsTrimmedSurface* NurbsTrimmedSurface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new NurbsTrimmedSurface (*this, f, c);
}

NurbsTrimmedSurface::
~NurbsTrimmedSurface ()
{
}

// CADAssembly
//

CADAssembly::
CADAssembly ()
: ::X3DGroupingNode (),
  CADPart_ (::xml_schema::flags (), this),
  name_ (::xml_schema::flags (), this)
{
}

CADAssembly::
CADAssembly (const CADAssembly& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c),
  CADPart_ (x.CADPart_, f, this),
  name_ (x.name_, f, this)
{
}

CADAssembly::
CADAssembly (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::X3DGroupingNode (e, f | ::xml_schema::flags::base, c),
  CADPart_ (f, this),
  name_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void CADAssembly::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGroupingNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // CADPart
    //
    if (n.name () == "CADPart" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CADPart_type > r (
        CADPart_traits::create (i, f, this));

      this->CADPart ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name (r);
      continue;
    }
  }
}

CADAssembly* CADAssembly::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new CADAssembly (*this, f, c);
}

CADAssembly::
~CADAssembly ()
{
}

// CADFace
//

const CADFace::bboxCenter_type CADFace::bboxCenter_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const CADFace::bboxSize_type CADFace::bboxSize_default_value_ (
  ::std::string ("-1 -1 -1"), 0, 0, 0);

CADFace::
CADFace ()
: ::X3DProductStructureChildNode (),
  Shape_ (::xml_schema::flags (), this),
  LOD_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this),
  bboxCenter_ (bboxCenter_default_value (), ::xml_schema::flags (), this),
  bboxSize_ (bboxSize_default_value (), ::xml_schema::flags (), this),
  name_ (::xml_schema::flags (), this)
{
}

CADFace::
CADFace (const CADFace& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::X3DProductStructureChildNode (x, f, c),
  Shape_ (x.Shape_, f, this),
  LOD_ (x.LOD_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this),
  bboxCenter_ (x.bboxCenter_, f, this),
  bboxSize_ (x.bboxSize_, f, this),
  name_ (x.name_, f, this)
{
}

CADFace::
CADFace (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::X3DProductStructureChildNode (e, f | ::xml_schema::flags::base, c),
  Shape_ (f, this),
  LOD_ (f, this),
  ProtoInstance_ (f, this),
  bboxCenter_ (f, this),
  bboxSize_ (f, this),
  name_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void CADFace::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DProductStructureChildNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Shape
    //
    if (n.name () == "Shape" && n.namespace_ () == "")
    {
      ::std::auto_ptr< Shape_type > r (
        Shape_traits::create (i, f, this));

      if (!this->Shape ())
      {
        this->Shape (r);
        continue;
      }
    }

    // LOD
    //
    if (n.name () == "LOD" && n.namespace_ () == "")
    {
      ::std::auto_ptr< LOD_type > r (
        LOD_traits::create (i, f, this));

      if (!this->LOD ())
      {
        this->LOD (r);
        continue;
      }
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      if (!this->ProtoInstance ())
      {
        this->ProtoInstance (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "bboxCenter" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bboxCenter_type > r (
        bboxCenter_traits::create (i, f, this));

      this->bboxCenter (r);
      continue;
    }

    if (n.name () == "bboxSize" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< bboxSize_type > r (
        bboxSize_traits::create (i, f, this));

      this->bboxSize (r);
      continue;
    }

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name (r);
      continue;
    }
  }

  if (!bboxCenter_.present ())
  {
    ::std::auto_ptr< bboxCenter_type > r (
      bboxCenter_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->bboxCenter (r);
  }

  if (!bboxSize_.present ())
  {
    ::std::auto_ptr< bboxSize_type > r (
      bboxSize_traits::create (
        ::std::string ("-1 -1 -1"),
        &p.element (), f, this));

    this->bboxSize (r);
  }
}

CADFace* CADFace::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new CADFace (*this, f, c);
}

CADFace::
~CADFace ()
{
}

// CADLayer
//

CADLayer::
CADLayer ()
: ::X3DGroupingNode (),
  name_ (::xml_schema::flags (), this),
  visible_ (::xml_schema::flags (), this)
{
}

CADLayer::
CADLayer (const CADLayer& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c),
  name_ (x.name_, f, this),
  visible_ (x.visible_, f, this)
{
}

CADLayer::
CADLayer (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::X3DGroupingNode (e, f | ::xml_schema::flags::base, c),
  name_ (f, this),
  visible_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void CADLayer::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGroupingNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name (r);
      continue;
    }

    if (n.name () == "visible" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< visible_type > r (
        visible_traits::create (i, f, this));

      this->visible (r);
      continue;
    }
  }
}

CADLayer* CADLayer::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new CADLayer (*this, f, c);
}

CADLayer::
~CADLayer ()
{
}

// CADPart
//

CADPart::
CADPart ()
: ::X3DGroupingNode (),
  CADFace_ (::xml_schema::flags (), this),
  name_ (::xml_schema::flags (), this)
{
}

CADPart::
CADPart (const CADPart& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::X3DGroupingNode (x, f, c),
  CADFace_ (x.CADFace_, f, this),
  name_ (x.name_, f, this)
{
}

CADPart::
CADPart (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::X3DGroupingNode (e, f | ::xml_schema::flags::base, c),
  CADFace_ (f, this),
  name_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void CADPart::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DGroupingNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // CADFace
    //
    if (n.name () == "CADFace" && n.namespace_ () == "")
    {
      ::std::auto_ptr< CADFace_type > r (
        CADFace_traits::create (i, f, this));

      this->CADFace ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      this->name (r);
      continue;
    }
  }
}

CADPart* CADPart::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new CADPart (*this, f, c);
}

CADPart::
~CADPart ()
{
}

// IndexedQuadSet
//

IndexedQuadSet::
IndexedQuadSet ()
: ::X3DComposedGeometryNode (),
  index_ (::xml_schema::flags (), this)
{
}

IndexedQuadSet::
IndexedQuadSet (const IndexedQuadSet& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DComposedGeometryNode (x, f, c),
  index_ (x.index_, f, this)
{
}

IndexedQuadSet::
IndexedQuadSet (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DComposedGeometryNode (e, f | ::xml_schema::flags::base, c),
  index_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void IndexedQuadSet::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DComposedGeometryNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "index" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< index_type > r (
        index_traits::create (i, f, this));

      this->index (r);
      continue;
    }
  }
}

IndexedQuadSet* IndexedQuadSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new IndexedQuadSet (*this, f, c);
}

IndexedQuadSet::
~IndexedQuadSet ()
{
}

// QuadSet
//

QuadSet::
QuadSet ()
: ::X3DComposedGeometryNode ()
{
}

QuadSet::
QuadSet (const QuadSet& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::X3DComposedGeometryNode (x, f, c)
{
}

QuadSet::
QuadSet (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::X3DComposedGeometryNode (e, f, c)
{
}

QuadSet* QuadSet::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new QuadSet (*this, f, c);
}

QuadSet::
~QuadSet ()
{
}

// ComposedShader
//

ComposedShader::
ComposedShader ()
: ::X3DShaderNode (),
  field_ (::xml_schema::flags (), this),
  ShaderPart_ (::xml_schema::flags (), this)
{
}

ComposedShader::
ComposedShader (const ComposedShader& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DShaderNode (x, f, c),
  field_ (x.field_, f, this),
  ShaderPart_ (x.ShaderPart_, f, this)
{
}

ComposedShader::
ComposedShader (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DShaderNode (e, f | ::xml_schema::flags::base, c),
  field_ (f, this),
  ShaderPart_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ComposedShader::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DShaderNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // field
    //
    if (n.name () == "field" && n.namespace_ () == "")
    {
      ::std::auto_ptr< field_type > r (
        field_traits::create (i, f, this));

      this->field ().push_back (r);
      continue;
    }

    // ShaderPart
    //
    if (n.name () == "ShaderPart" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ShaderPart_type > r (
        ShaderPart_traits::create (i, f, this));

      this->ShaderPart ().push_back (r);
      continue;
    }

    break;
  }
}

ComposedShader* ComposedShader::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ComposedShader (*this, f, c);
}

ComposedShader::
~ComposedShader ()
{
}

// FloatVertexAttribute
//

const FloatVertexAttribute::numComponents_type FloatVertexAttribute::numComponents_default_value_ (
  ::std::string ("4"), 0, 0, 0);

FloatVertexAttribute::
FloatVertexAttribute ()
: ::X3DVertexAttributeNode (),
  value_ (::xml_schema::flags (), this),
  numComponents_ (numComponents_default_value (), ::xml_schema::flags (), this)
{
}

FloatVertexAttribute::
FloatVertexAttribute (const FloatVertexAttribute& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::X3DVertexAttributeNode (x, f, c),
  value_ (x.value_, f, this),
  numComponents_ (x.numComponents_, f, this)
{
}

FloatVertexAttribute::
FloatVertexAttribute (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::X3DVertexAttributeNode (e, f | ::xml_schema::flags::base, c),
  value_ (f, this),
  numComponents_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void FloatVertexAttribute::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DVertexAttributeNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< value_type > r (
        value_traits::create (i, f, this));

      this->value (r);
      continue;
    }

    if (n.name () == "numComponents" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< numComponents_type > r (
        numComponents_traits::create (i, f, this));

      this->numComponents (r);
      continue;
    }
  }

  if (!numComponents_.present ())
  {
    ::std::auto_ptr< numComponents_type > r (
      numComponents_traits::create (
        ::std::string ("4"),
        &p.element (), f, this));

    this->numComponents (r);
  }
}

FloatVertexAttribute* FloatVertexAttribute::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new FloatVertexAttribute (*this, f, c);
}

FloatVertexAttribute::
~FloatVertexAttribute ()
{
}

// Matrix3VertexAttribute
//

Matrix3VertexAttribute::
Matrix3VertexAttribute ()
: ::X3DVertexAttributeNode (),
  value_ (::xml_schema::flags (), this)
{
}

Matrix3VertexAttribute::
Matrix3VertexAttribute (const Matrix3VertexAttribute& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DVertexAttributeNode (x, f, c),
  value_ (x.value_, f, this)
{
}

Matrix3VertexAttribute::
Matrix3VertexAttribute (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DVertexAttributeNode (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Matrix3VertexAttribute::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DVertexAttributeNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< value_type > r (
        value_traits::create (i, f, this));

      this->value (r);
      continue;
    }
  }
}

Matrix3VertexAttribute* Matrix3VertexAttribute::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Matrix3VertexAttribute (*this, f, c);
}

Matrix3VertexAttribute::
~Matrix3VertexAttribute ()
{
}

// Matrix4VertexAttribute
//

Matrix4VertexAttribute::
Matrix4VertexAttribute ()
: ::X3DVertexAttributeNode (),
  value_ (::xml_schema::flags (), this)
{
}

Matrix4VertexAttribute::
Matrix4VertexAttribute (const Matrix4VertexAttribute& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DVertexAttributeNode (x, f, c),
  value_ (x.value_, f, this)
{
}

Matrix4VertexAttribute::
Matrix4VertexAttribute (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DVertexAttributeNode (e, f | ::xml_schema::flags::base, c),
  value_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void Matrix4VertexAttribute::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DVertexAttributeNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< value_type > r (
        value_traits::create (i, f, this));

      this->value (r);
      continue;
    }
  }
}

Matrix4VertexAttribute* Matrix4VertexAttribute::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new Matrix4VertexAttribute (*this, f, c);
}

Matrix4VertexAttribute::
~Matrix4VertexAttribute ()
{
}

// PackagedShader
//

PackagedShader::
PackagedShader ()
: ::X3DShaderNode (),
  field_ (::xml_schema::flags (), this),
  url_ (::xml_schema::flags (), this)
{
}

PackagedShader::
PackagedShader (const PackagedShader& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DShaderNode (x, f, c),
  field_ (x.field_, f, this),
  url_ (x.url_, f, this)
{
}

PackagedShader::
PackagedShader (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DShaderNode (e, f | ::xml_schema::flags::base, c),
  field_ (f, this),
  url_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void PackagedShader::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DShaderNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // field
    //
    if (n.name () == "field" && n.namespace_ () == "")
    {
      ::std::auto_ptr< field_type > r (
        field_traits::create (i, f, this));

      this->field ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< url_type > r (
        url_traits::create (i, f, this));

      this->url (r);
      continue;
    }
  }
}

PackagedShader* PackagedShader::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new PackagedShader (*this, f, c);
}

PackagedShader::
~PackagedShader ()
{
}

// ProgramShader
//

ProgramShader::
ProgramShader ()
: ::X3DShaderNode (),
  ShaderProgram_ (::xml_schema::flags (), this)
{
}

ProgramShader::
ProgramShader (const ProgramShader& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DShaderNode (x, f, c),
  ShaderProgram_ (x.ShaderProgram_, f, this)
{
}

ProgramShader::
ProgramShader (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DShaderNode (e, f | ::xml_schema::flags::base, c),
  ShaderProgram_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ProgramShader::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DShaderNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ShaderProgram
    //
    if (n.name () == "ShaderProgram" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ShaderProgram_type > r (
        ShaderProgram_traits::create (i, f, this));

      this->ShaderProgram ().push_back (r);
      continue;
    }

    break;
  }
}

ProgramShader* ProgramShader::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ProgramShader (*this, f, c);
}

ProgramShader::
~ProgramShader ()
{
}

// ShaderPart
//

const ShaderPart::containerField_type ShaderPart::containerField_default_value_ (
  ::std::string ("parts"), 0, 0, 0);

ShaderPart::
ShaderPart ()
: ::X3DNode (),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this),
  url_ (::xml_schema::flags (), this),
  type_ (::xml_schema::flags (), this)
{
}

ShaderPart::
ShaderPart (const ShaderPart& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DNode (x, f, c),
  containerField_ (x.containerField_, f, this),
  url_ (x.url_, f, this),
  type_ (x.type_, f, this)
{
}

ShaderPart::
ShaderPart (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::X3DNode (e, f | ::xml_schema::flags::base, c),
  containerField_ (f, this),
  url_ (f, this),
  type_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ShaderPart::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }

    if (n.name () == "url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< url_type > r (
        url_traits::create (i, f, this));

      this->url (r);
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      this->type (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("parts"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

ShaderPart* ShaderPart::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ShaderPart (*this, f, c);
}

ShaderPart::
~ShaderPart ()
{
}

// ShaderProgram
//

const ShaderProgram::containerField_type ShaderProgram::containerField_default_value_ (
  ::std::string ("programs"), 0, 0, 0);

ShaderProgram::
ShaderProgram ()
: ::X3DNode (),
  field_ (::xml_schema::flags (), this),
  containerField_ (containerField_default_value (), ::xml_schema::flags (), this),
  url_ (::xml_schema::flags (), this),
  type_ (::xml_schema::flags (), this)
{
}

ShaderProgram::
ShaderProgram (const ShaderProgram& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DNode (x, f, c),
  field_ (x.field_, f, this),
  containerField_ (x.containerField_, f, this),
  url_ (x.url_, f, this),
  type_ (x.type_, f, this)
{
}

ShaderProgram::
ShaderProgram (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::X3DNode (e, f | ::xml_schema::flags::base, c),
  field_ (f, this),
  containerField_ (f, this),
  url_ (f, this),
  type_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ShaderProgram::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // field
    //
    if (n.name () == "field" && n.namespace_ () == "")
    {
      ::std::auto_ptr< field_type > r (
        field_traits::create (i, f, this));

      this->field ().push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "containerField" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< containerField_type > r (
        containerField_traits::create (i, f, this));

      this->containerField (r);
      continue;
    }

    if (n.name () == "url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< url_type > r (
        url_traits::create (i, f, this));

      this->url (r);
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      this->type (r);
      continue;
    }
  }

  if (!containerField_.present ())
  {
    ::std::auto_ptr< containerField_type > r (
      containerField_traits::create (
        ::std::string ("programs"),
        &p.element (), f, this));

    this->containerField (r);
  }
}

ShaderProgram* ShaderProgram::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ShaderProgram (*this, f, c);
}

ShaderProgram::
~ShaderProgram ()
{
}

// ComposedCubeMapTexture
//

ComposedCubeMapTexture::
ComposedCubeMapTexture ()
: ::X3DEnvironmentTextureNode (),
  ImageTexture_ (::xml_schema::flags (), this),
  PixelTexture_ (::xml_schema::flags (), this),
  MovieTexture_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this)
{
}

ComposedCubeMapTexture::
ComposedCubeMapTexture (const ComposedCubeMapTexture& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DEnvironmentTextureNode (x, f, c),
  ImageTexture_ (x.ImageTexture_, f, this),
  PixelTexture_ (x.PixelTexture_, f, this),
  MovieTexture_ (x.MovieTexture_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this)
{
}

ComposedCubeMapTexture::
ComposedCubeMapTexture (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DEnvironmentTextureNode (e, f | ::xml_schema::flags::base, c),
  ImageTexture_ (f, this),
  PixelTexture_ (f, this),
  MovieTexture_ (f, this),
  ProtoInstance_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ComposedCubeMapTexture::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DEnvironmentTextureNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ImageTexture
    //
    if (n.name () == "ImageTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ImageTexture_type > r (
        ImageTexture_traits::create (i, f, this));

      this->ImageTexture ().push_back (r);
      continue;
    }

    // PixelTexture
    //
    if (n.name () == "PixelTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PixelTexture_type > r (
        PixelTexture_traits::create (i, f, this));

      this->PixelTexture ().push_back (r);
      continue;
    }

    // MovieTexture
    //
    if (n.name () == "MovieTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MovieTexture_type > r (
        MovieTexture_traits::create (i, f, this));

      this->MovieTexture ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    break;
  }
}

ComposedCubeMapTexture* ComposedCubeMapTexture::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ComposedCubeMapTexture (*this, f, c);
}

ComposedCubeMapTexture::
~ComposedCubeMapTexture ()
{
}

// GeneratedCubeMapTexture
//

const GeneratedCubeMapTexture::update_type GeneratedCubeMapTexture::update_default_value_ (
  ::std::string ("NONE"), 0, 0, 0);

const GeneratedCubeMapTexture::size_type GeneratedCubeMapTexture::size_default_value_ (
  ::std::string ("128"), 0, 0, 0);

GeneratedCubeMapTexture::
GeneratedCubeMapTexture ()
: ::X3DEnvironmentTextureNode (),
  update_ (update_default_value (), ::xml_schema::flags (), this),
  size_ (size_default_value (), ::xml_schema::flags (), this)
{
}

GeneratedCubeMapTexture::
GeneratedCubeMapTexture (const GeneratedCubeMapTexture& x,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::X3DEnvironmentTextureNode (x, f, c),
  update_ (x.update_, f, this),
  size_ (x.size_, f, this)
{
}

GeneratedCubeMapTexture::
GeneratedCubeMapTexture (const ::xercesc::DOMElement& e,
                         ::xml_schema::flags f,
                         ::xml_schema::container* c)
: ::X3DEnvironmentTextureNode (e, f | ::xml_schema::flags::base, c),
  update_ (f, this),
  size_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void GeneratedCubeMapTexture::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DEnvironmentTextureNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "update" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< update_type > r (
        update_traits::create (i, f, this));

      this->update (r);
      continue;
    }

    if (n.name () == "size" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< size_type > r (
        size_traits::create (i, f, this));

      this->size (r);
      continue;
    }
  }

  if (!update_.present ())
  {
    ::std::auto_ptr< update_type > r (
      update_traits::create (
        ::std::string ("NONE"),
        &p.element (), f, this));

    this->update (r);
  }

  if (!size_.present ())
  {
    ::std::auto_ptr< size_type > r (
      size_traits::create (
        ::std::string ("128"),
        &p.element (), f, this));

    this->size (r);
  }
}

GeneratedCubeMapTexture* GeneratedCubeMapTexture::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new GeneratedCubeMapTexture (*this, f, c);
}

GeneratedCubeMapTexture::
~GeneratedCubeMapTexture ()
{
}

// ImageCubeMapTexture
//

ImageCubeMapTexture::
ImageCubeMapTexture ()
: ::X3DEnvironmentTextureNode (),
  url_ (::xml_schema::flags (), this)
{
}

ImageCubeMapTexture::
ImageCubeMapTexture (const ImageCubeMapTexture& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::X3DEnvironmentTextureNode (x, f, c),
  url_ (x.url_, f, this)
{
}

ImageCubeMapTexture::
ImageCubeMapTexture (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::X3DEnvironmentTextureNode (e, f | ::xml_schema::flags::base, c),
  url_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ImageCubeMapTexture::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DEnvironmentTextureNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< url_type > r (
        url_traits::create (i, f, this));

      this->url (r);
      continue;
    }
  }
}

ImageCubeMapTexture* ImageCubeMapTexture::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ImageCubeMapTexture (*this, f, c);
}

ImageCubeMapTexture::
~ImageCubeMapTexture ()
{
}

// ComposedTexture3D
//

ComposedTexture3D::
ComposedTexture3D ()
: ::X3DTexture3DNode (),
  ImageTexture_ (::xml_schema::flags (), this),
  PixelTexture_ (::xml_schema::flags (), this),
  MovieTexture_ (::xml_schema::flags (), this),
  ProtoInstance_ (::xml_schema::flags (), this)
{
}

ComposedTexture3D::
ComposedTexture3D (const ComposedTexture3D& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DTexture3DNode (x, f, c),
  ImageTexture_ (x.ImageTexture_, f, this),
  PixelTexture_ (x.PixelTexture_, f, this),
  MovieTexture_ (x.MovieTexture_, f, this),
  ProtoInstance_ (x.ProtoInstance_, f, this)
{
}

ComposedTexture3D::
ComposedTexture3D (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::X3DTexture3DNode (e, f | ::xml_schema::flags::base, c),
  ImageTexture_ (f, this),
  PixelTexture_ (f, this),
  MovieTexture_ (f, this),
  ProtoInstance_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ComposedTexture3D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTexture3DNode::parse (p, f);

  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ImageTexture
    //
    if (n.name () == "ImageTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ImageTexture_type > r (
        ImageTexture_traits::create (i, f, this));

      this->ImageTexture ().push_back (r);
      continue;
    }

    // PixelTexture
    //
    if (n.name () == "PixelTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< PixelTexture_type > r (
        PixelTexture_traits::create (i, f, this));

      this->PixelTexture ().push_back (r);
      continue;
    }

    // MovieTexture
    //
    if (n.name () == "MovieTexture" && n.namespace_ () == "")
    {
      ::std::auto_ptr< MovieTexture_type > r (
        MovieTexture_traits::create (i, f, this));

      this->MovieTexture ().push_back (r);
      continue;
    }

    // ProtoInstance
    //
    if (n.name () == "ProtoInstance" && n.namespace_ () == "")
    {
      ::std::auto_ptr< ProtoInstance_type > r (
        ProtoInstance_traits::create (i, f, this));

      this->ProtoInstance ().push_back (r);
      continue;
    }

    break;
  }
}

ComposedTexture3D* ComposedTexture3D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ComposedTexture3D (*this, f, c);
}

ComposedTexture3D::
~ComposedTexture3D ()
{
}

// ImageTexture3D
//

ImageTexture3D::
ImageTexture3D ()
: ::X3DTexture3DNode (),
  url_ (::xml_schema::flags (), this)
{
}

ImageTexture3D::
ImageTexture3D (const ImageTexture3D& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DTexture3DNode (x, f, c),
  url_ (x.url_, f, this)
{
}

ImageTexture3D::
ImageTexture3D (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DTexture3DNode (e, f | ::xml_schema::flags::base, c),
  url_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void ImageTexture3D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTexture3DNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< url_type > r (
        url_traits::create (i, f, this));

      this->url (r);
      continue;
    }
  }
}

ImageTexture3D* ImageTexture3D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ImageTexture3D (*this, f, c);
}

ImageTexture3D::
~ImageTexture3D ()
{
}

// PixelTexture3D
//

const PixelTexture3D::image_type PixelTexture3D::image_default_value_ (
  ::std::string ("0 0 0 0"), 0, 0, 0);

PixelTexture3D::
PixelTexture3D ()
: ::X3DTexture3DNode (),
  image_ (image_default_value (), ::xml_schema::flags (), this)
{
}

PixelTexture3D::
PixelTexture3D (const PixelTexture3D& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DTexture3DNode (x, f, c),
  image_ (x.image_, f, this)
{
}

PixelTexture3D::
PixelTexture3D (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::X3DTexture3DNode (e, f | ::xml_schema::flags::base, c),
  image_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void PixelTexture3D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTexture3DNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "image" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< image_type > r (
        image_traits::create (i, f, this));

      this->image (r);
      continue;
    }
  }

  if (!image_.present ())
  {
    ::std::auto_ptr< image_type > r (
      image_traits::create (
        ::std::string ("0 0 0 0"),
        &p.element (), f, this));

    this->image (r);
  }
}

PixelTexture3D* PixelTexture3D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new PixelTexture3D (*this, f, c);
}

PixelTexture3D::
~PixelTexture3D ()
{
}

// TextureCoordinate3D
//

TextureCoordinate3D::
TextureCoordinate3D ()
: ::X3DTextureCoordinateNode (),
  point_ (::xml_schema::flags (), this)
{
}

TextureCoordinate3D::
TextureCoordinate3D (const TextureCoordinate3D& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::X3DTextureCoordinateNode (x, f, c),
  point_ (x.point_, f, this)
{
}

TextureCoordinate3D::
TextureCoordinate3D (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::X3DTextureCoordinateNode (e, f | ::xml_schema::flags::base, c),
  point_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void TextureCoordinate3D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTextureCoordinateNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "point" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< point_type > r (
        point_traits::create (i, f, this));

      this->point (r);
      continue;
    }
  }
}

TextureCoordinate3D* TextureCoordinate3D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new TextureCoordinate3D (*this, f, c);
}

TextureCoordinate3D::
~TextureCoordinate3D ()
{
}

// TextureCoordinate4D
//

TextureCoordinate4D::
TextureCoordinate4D ()
: ::X3DTextureCoordinateNode (),
  point_ (::xml_schema::flags (), this)
{
}

TextureCoordinate4D::
TextureCoordinate4D (const TextureCoordinate4D& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::X3DTextureCoordinateNode (x, f, c),
  point_ (x.point_, f, this)
{
}

TextureCoordinate4D::
TextureCoordinate4D (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::X3DTextureCoordinateNode (e, f | ::xml_schema::flags::base, c),
  point_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void TextureCoordinate4D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTextureCoordinateNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "point" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< point_type > r (
        point_traits::create (i, f, this));

      this->point (r);
      continue;
    }
  }
}

TextureCoordinate4D* TextureCoordinate4D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new TextureCoordinate4D (*this, f, c);
}

TextureCoordinate4D::
~TextureCoordinate4D ()
{
}

// TextureMatrixTransform
//

const TextureMatrixTransform::matrix_type TextureMatrixTransform::matrix_default_value_ (
  ::std::string ("1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1"), 0, 0, 0);

TextureMatrixTransform::
TextureMatrixTransform ()
: ::X3DTextureTransformNode (),
  matrix_ (matrix_default_value (), ::xml_schema::flags (), this)
{
}

TextureMatrixTransform::
TextureMatrixTransform (const TextureMatrixTransform& x,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DTextureTransformNode (x, f, c),
  matrix_ (x.matrix_, f, this)
{
}

TextureMatrixTransform::
TextureMatrixTransform (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f,
                        ::xml_schema::container* c)
: ::X3DTextureTransformNode (e, f | ::xml_schema::flags::base, c),
  matrix_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void TextureMatrixTransform::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTextureTransformNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "matrix" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< matrix_type > r (
        matrix_traits::create (i, f, this));

      this->matrix (r);
      continue;
    }
  }

  if (!matrix_.present ())
  {
    ::std::auto_ptr< matrix_type > r (
      matrix_traits::create (
        ::std::string ("1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1"),
        &p.element (), f, this));

    this->matrix (r);
  }
}

TextureMatrixTransform* TextureMatrixTransform::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new TextureMatrixTransform (*this, f, c);
}

TextureMatrixTransform::
~TextureMatrixTransform ()
{
}

// TextureTransform3D
//

const TextureTransform3D::center_type TextureTransform3D::center_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

const TextureTransform3D::rotation_type TextureTransform3D::rotation_default_value_ (
  ::std::string ("0 0 1 0"), 0, 0, 0);

const TextureTransform3D::scale_type TextureTransform3D::scale_default_value_ (
  ::std::string ("1 1 1"), 0, 0, 0);

const TextureTransform3D::translation_type TextureTransform3D::translation_default_value_ (
  ::std::string ("0 0 0"), 0, 0, 0);

TextureTransform3D::
TextureTransform3D ()
: ::X3DTextureTransformNode (),
  center_ (center_default_value (), ::xml_schema::flags (), this),
  rotation_ (rotation_default_value (), ::xml_schema::flags (), this),
  scale_ (scale_default_value (), ::xml_schema::flags (), this),
  translation_ (translation_default_value (), ::xml_schema::flags (), this)
{
}

TextureTransform3D::
TextureTransform3D (const TextureTransform3D& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::X3DTextureTransformNode (x, f, c),
  center_ (x.center_, f, this),
  rotation_ (x.rotation_, f, this),
  scale_ (x.scale_, f, this),
  translation_ (x.translation_, f, this)
{
}

TextureTransform3D::
TextureTransform3D (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::X3DTextureTransformNode (e, f | ::xml_schema::flags::base, c),
  center_ (f, this),
  rotation_ (f, this),
  scale_ (f, this),
  translation_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void TextureTransform3D::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::X3DTextureTransformNode::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "center" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< center_type > r (
        center_traits::create (i, f, this));

      this->center (r);
      continue;
    }

    if (n.name () == "rotation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< rotation_type > r (
        rotation_traits::create (i, f, this));

      this->rotation (r);
      continue;
    }

    if (n.name () == "scale" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< scale_type > r (
        scale_traits::create (i, f, this));

      this->scale (r);
      continue;
    }

    if (n.name () == "translation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< translation_type > r (
        translation_traits::create (i, f, this));

      this->translation (r);
      continue;
    }
  }

  if (!center_.present ())
  {
    ::std::auto_ptr< center_type > r (
      center_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->center (r);
  }

  if (!rotation_.present ())
  {
    ::std::auto_ptr< rotation_type > r (
      rotation_traits::create (
        ::std::string ("0 0 1 0"),
        &p.element (), f, this));

    this->rotation (r);
  }

  if (!scale_.present ())
  {
    ::std::auto_ptr< scale_type > r (
      scale_traits::create (
        ::std::string ("1 1 1"),
        &p.element (), f, this));

    this->scale (r);
  }

  if (!translation_.present ())
  {
    ::std::auto_ptr< translation_type > r (
      translation_traits::create (
        ::std::string ("0 0 0"),
        &p.element (), f, this));

    this->translation (r);
  }
}

TextureTransform3D* TextureTransform3D::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new TextureTransform3D (*this, f, c);
}

TextureTransform3D::
~TextureTransform3D ()
{
}

// radius
//

radius::
radius (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

radius::
radius (const radius& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

radius::
radius (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

radius::
radius (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

radius::
radius (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

radius* radius::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new radius (*this, f, c);
}

radius::
~radius ()
{
}

// radius1
//

radius1::
radius1 (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

radius1::
radius1 (const radius1& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

radius1::
radius1 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

radius1::
radius1 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

radius1::
radius1 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

radius1* radius1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new radius1 (*this, f, c);
}

radius1::
~radius1 ()
{
}

// radius2
//

radius2::
radius2 (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

radius2::
radius2 (const radius2& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

radius2::
radius2 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

radius2::
radius2 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

radius2::
radius2 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

radius2* radius2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new radius2 (*this, f, c);
}

radius2::
~radius2 ()
{
}

// bottomRadius
//

bottomRadius::
bottomRadius (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

bottomRadius::
bottomRadius (const bottomRadius& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

bottomRadius::
bottomRadius (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

bottomRadius::
bottomRadius (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

bottomRadius::
bottomRadius (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

bottomRadius* bottomRadius::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new bottomRadius (*this, f, c);
}

bottomRadius::
~bottomRadius ()
{
}

// height
//

height::
height (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

height::
height (const height& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

height::
height (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

height::
height (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

height::
height (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

height* height::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new height (*this, f, c);
}

height::
~height ()
{
}

// height1
//

height1::
height1 (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

height1::
height1 (const height1& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

height1::
height1 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

height1::
height1 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

height1::
height1 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

height1* height1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new height1 (*this, f, c);
}

height1::
~height1 ()
{
}

// radius3
//

radius3::
radius3 (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

radius3::
radius3 (const radius3& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

radius3::
radius3 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

radius3::
radius3 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

radius3::
radius3 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

radius3* radius3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new radius3 (*this, f, c);
}

radius3::
~radius3 ()
{
}

// innerRadius
//

innerRadius::
innerRadius (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

innerRadius::
innerRadius (const innerRadius& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

innerRadius::
innerRadius (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

innerRadius::
innerRadius (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

innerRadius::
innerRadius (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

innerRadius* innerRadius::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new innerRadius (*this, f, c);
}

innerRadius::
~innerRadius ()
{
}

// outerRadius
//

outerRadius::
outerRadius (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

outerRadius::
outerRadius (const outerRadius& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

outerRadius::
outerRadius (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

outerRadius::
outerRadius (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

outerRadius::
outerRadius (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

outerRadius* outerRadius::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new outerRadius (*this, f, c);
}

outerRadius::
~outerRadius ()
{
}

// creaseAngle
//

creaseAngle::
creaseAngle (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

creaseAngle::
creaseAngle (const creaseAngle& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

creaseAngle::
creaseAngle (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

creaseAngle::
creaseAngle (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

creaseAngle::
creaseAngle (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

creaseAngle* creaseAngle::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new creaseAngle (*this, f, c);
}

creaseAngle::
~creaseAngle ()
{
}

// xSpacing
//

xSpacing::
xSpacing (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

xSpacing::
xSpacing (const xSpacing& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

xSpacing::
xSpacing (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

xSpacing::
xSpacing (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

xSpacing::
xSpacing (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

xSpacing* xSpacing::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new xSpacing (*this, f, c);
}

xSpacing::
~xSpacing ()
{
}

// zSpacing
//

zSpacing::
zSpacing (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

zSpacing::
zSpacing (const zSpacing& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

zSpacing::
zSpacing (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

zSpacing::
zSpacing (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

zSpacing::
zSpacing (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

zSpacing* zSpacing::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new zSpacing (*this, f, c);
}

zSpacing::
~zSpacing ()
{
}

// creaseAngle1
//

creaseAngle1::
creaseAngle1 (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

creaseAngle1::
creaseAngle1 (const creaseAngle1& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

creaseAngle1::
creaseAngle1 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

creaseAngle1::
creaseAngle1 (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

creaseAngle1::
creaseAngle1 (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

creaseAngle1* creaseAngle1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new creaseAngle1 (*this, f, c);
}

creaseAngle1::
~creaseAngle1 ()
{
}

// creaseAngle2
//

creaseAngle2::
creaseAngle2 (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

creaseAngle2::
creaseAngle2 (const creaseAngle2& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

creaseAngle2::
creaseAngle2 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

creaseAngle2::
creaseAngle2 (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

creaseAngle2::
creaseAngle2 (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

creaseAngle2* creaseAngle2::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new creaseAngle2 (*this, f, c);
}

creaseAngle2::
~creaseAngle2 ()
{
}

// ambientIntensity1
//

ambientIntensity1::
ambientIntensity1 (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

ambientIntensity1::
ambientIntensity1 (const ambientIntensity1& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

ambientIntensity1::
ambientIntensity1 (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

ambientIntensity1::
ambientIntensity1 (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

ambientIntensity1::
ambientIntensity1 (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

ambientIntensity1* ambientIntensity1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new ambientIntensity1 (*this, f, c);
}

ambientIntensity1::
~ambientIntensity1 ()
{
}

// shininess
//

shininess::
shininess (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

shininess::
shininess (const shininess& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

shininess::
shininess (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

shininess::
shininess (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

shininess::
shininess (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

shininess* shininess::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new shininess (*this, f, c);
}

shininess::
~shininess ()
{
}

// transparency
//

transparency::
transparency (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

transparency::
transparency (const transparency& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

transparency::
transparency (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

transparency::
transparency (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

transparency::
transparency (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

transparency* transparency::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new transparency (*this, f, c);
}

transparency::
~transparency ()
{
}

// radius4
//

radius4::
radius4 (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

radius4::
radius4 (const radius4& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

radius4::
radius4 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

radius4::
radius4 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

radius4::
radius4 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

radius4* radius4::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new radius4 (*this, f, c);
}

radius4::
~radius4 ()
{
}

// radius5
//

radius5::
radius5 (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

radius5::
radius5 (const radius5& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

radius5::
radius5 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

radius5::
radius5 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

radius5::
radius5 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

radius5* radius5::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new radius5 (*this, f, c);
}

radius5::
~radius5 ()
{
}

// beamWidth
//

beamWidth::
beamWidth (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

beamWidth::
beamWidth (const beamWidth& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

beamWidth::
beamWidth (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

beamWidth::
beamWidth (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

beamWidth::
beamWidth (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

beamWidth* beamWidth::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new beamWidth (*this, f, c);
}

beamWidth::
~beamWidth ()
{
}

// radius6
//

radius6::
radius6 (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

radius6::
radius6 (const radius6& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

radius6::
radius6 (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

radius6::
radius6 (const ::xercesc::DOMAttr& a,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

radius6::
radius6 (const ::std::string& s,
         const ::xercesc::DOMElement* e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

radius6* radius6::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new radius6 (*this, f, c);
}

radius6::
~radius6 ()
{
}

// maxExtent
//

maxExtent::
maxExtent (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

maxExtent::
maxExtent (const maxExtent& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

maxExtent::
maxExtent (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

maxExtent::
maxExtent (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

maxExtent::
maxExtent (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

maxExtent* maxExtent::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new maxExtent (*this, f, c);
}

maxExtent::
~maxExtent ()
{
}

// creaseAngle3
//

creaseAngle3::
creaseAngle3 (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

creaseAngle3::
creaseAngle3 (const creaseAngle3& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

creaseAngle3::
creaseAngle3 (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

creaseAngle3::
creaseAngle3 (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

creaseAngle3::
creaseAngle3 (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

creaseAngle3* creaseAngle3::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new creaseAngle3 (*this, f, c);
}

creaseAngle3::
~creaseAngle3 ()
{
}

// xSpacing1
//

xSpacing1::
xSpacing1 (const ::xml_schema::double_& double_)
: ::SFDouble (double_)
{
}

xSpacing1::
xSpacing1 (const xSpacing1& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFDouble (x, f, c)
{
}

xSpacing1::
xSpacing1 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFDouble (e, f, c)
{
}

xSpacing1::
xSpacing1 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFDouble (a, f, c)
{
}

xSpacing1::
xSpacing1 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFDouble (s, e, f, c)
{
}

xSpacing1* xSpacing1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new xSpacing1 (*this, f, c);
}

xSpacing1::
~xSpacing1 ()
{
}

// yScale
//

yScale::
yScale (const ::xml_schema::float_& float_)
: ::SFFloat (float_)
{
}

yScale::
yScale (const yScale& x,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SFFloat (x, f, c)
{
}

yScale::
yScale (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SFFloat (e, f, c)
{
}

yScale::
yScale (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SFFloat (a, f, c)
{
}

yScale::
yScale (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SFFloat (s, e, f, c)
{
}

yScale* yScale::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new yScale (*this, f, c);
}

yScale::
~yScale ()
{
}

// zSpacing1
//

zSpacing1::
zSpacing1 (const ::xml_schema::double_& double_)
: ::SFDouble (double_)
{
}

zSpacing1::
zSpacing1 (const zSpacing1& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFDouble (x, f, c)
{
}

zSpacing1::
zSpacing1 (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFDouble (e, f, c)
{
}

zSpacing1::
zSpacing1 (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFDouble (a, f, c)
{
}

zSpacing1::
zSpacing1 (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::SFDouble (s, e, f, c)
{
}

zSpacing1* zSpacing1::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new zSpacing1 (*this, f, c);
}

zSpacing1::
~zSpacing1 ()
{
}

// numComponents
//

numComponents::
numComponents (const ::xml_schema::integer& integer)
: ::SFInt32 (integer)
{
}

numComponents::
numComponents (const numComponents& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::SFInt32 (x, f, c)
{
}

numComponents::
numComponents (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::SFInt32 (e, f, c)
{
}

numComponents::
numComponents (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::SFInt32 (a, f, c)
{
}

numComponents::
numComponents (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::SFInt32 (s, e, f, c)
{
}

numComponents* numComponents::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new numComponents (*this, f, c);
}

numComponents::
~numComponents ()
{
}

// update
//

update::
update (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SFString (e, f, c)
{
  _xsd_update_convert ();
}

update::
update (const ::xercesc::DOMAttr& a,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SFString (a, f, c)
{
  _xsd_update_convert ();
}

update::
update (const ::std::string& s,
        const ::xercesc::DOMElement* e,
        ::xml_schema::flags f,
        ::xml_schema::container* c)
: ::SFString (s, e, f, c)
{
  _xsd_update_convert ();
}

update* update::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new update (*this, f, c);
}

update::value update::
_xsd_update_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_update_literals_);
  const value* i (::std::lower_bound (
                    _xsd_update_indexes_,
                    _xsd_update_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_update_indexes_ + 3 || _xsd_update_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const update::
_xsd_update_literals_[3] =
{
  "NONE",
  "NEXT_FRAME_ONLY",
  "ALWAYS"
};

const update::value update::
_xsd_update_indexes_[3] =
{
  ::update::ALWAYS,
  ::update::NEXT_FRAME_ONLY,
  ::update::NONE
};

// size
//

size::
size (const ::xml_schema::integer& integer)
: ::SFInt32 (integer)
{
}

size::
size (const size& x,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::SFInt32 (x, f, c)
{
}

size::
size (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::SFInt32 (e, f, c)
{
}

size::
size (const ::xercesc::DOMAttr& a,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::SFInt32 (a, f, c)
{
}

size::
size (const ::std::string& s,
      const ::xercesc::DOMElement* e,
      ::xml_schema::flags f,
      ::xml_schema::container* c)
: ::SFInt32 (s, e, f, c)
{
}

size* size::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new size (*this, f, c);
}

size::
~size ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::X3D >
X3D_ (const ::std::string& u,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::X3D > r (
    ::X3D_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::X3D >
X3D_ (const ::std::string& u,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::X3D > r (
    ::X3D_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::X3D >
X3D_ (const ::std::string& u,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::X3D > r (
    ::X3D_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::X3D >
X3D_ (::std::istream& is,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::X3D_ (isrc, f, p);
}

::std::auto_ptr< ::X3D >
X3D_ (::std::istream& is,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::X3D_ (isrc, h, f, p);
}

::std::auto_ptr< ::X3D >
X3D_ (::std::istream& is,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::X3D_ (isrc, h, f, p);
}

::std::auto_ptr< ::X3D >
X3D_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::X3D_ (isrc, f, p);
}

::std::auto_ptr< ::X3D >
X3D_ (::std::istream& is,
      const ::std::string& sid,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::X3D_ (isrc, h, f, p);
}

::std::auto_ptr< ::X3D >
X3D_ (::std::istream& is,
      const ::std::string& sid,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::X3D_ (isrc, h, f, p);
}

::std::auto_ptr< ::X3D >
X3D_ (::xercesc::InputSource& i,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::X3D > r (
    ::X3D_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::X3D >
X3D_ (::xercesc::InputSource& i,
      ::xml_schema::error_handler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::X3D > r (
    ::X3D_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::X3D >
X3D_ (::xercesc::InputSource& i,
      ::xercesc::DOMErrorHandler& h,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::X3D > r (
    ::X3D_ (
      d, f | ::xml_schema::flags::own_dom, p));

  return r;
}

::std::auto_ptr< ::X3D >
X3D_ (const ::xercesc::DOMDocument& d,
      ::xml_schema::flags f,
      const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::X3D > r (
      ::X3D_ (
        c, f | ::xml_schema::flags::own_dom, p));

    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "X3D" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::X3D > r (
      ::xsd::cxx::tree::traits< ::X3D, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "X3D",
    "");
}

::std::auto_ptr< ::X3D >
X3D_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >& d,
      ::xml_schema::flags f,
      const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "X3D" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::X3D > r (
      ::xsd::cxx::tree::traits< ::X3D, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "X3D",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

